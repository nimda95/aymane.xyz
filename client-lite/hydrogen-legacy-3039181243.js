// @license magnet:?xt=urn:btih:8e4f440f4c65981c5bf93c76d35135ba5064d8b7&dn=apache-2.0.txt Apache-2.0
var hydrogen = (function (exports) {
    'use strict';

    function createCommonjsModule(fn, basedir, module) {
      return module = {
        path: basedir,
        exports: {},
        require: function require(path, base) {
          return commonjsRequire(path, base === undefined || base === null ? module.path : base);
        }
      }, fn(module, module.exports), module.exports;
    }

    function commonjsRequire() {
      throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var aesJs = createCommonjsModule(function (module, exports) {
      /*! MIT License. Copyright 2015-2018 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
      (function (root) {
        function checkInt(value) {
          return parseInt(value) === value;
        }

        function checkInts(arrayish) {
          if (!checkInt(arrayish.length)) {
            return false;
          }

          for (var i = 0; i < arrayish.length; i++) {
            if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
              return false;
            }
          }

          return true;
        }

        function coerceArray(arg, copy) {
          // ArrayBuffer view
          if (arg.buffer && arg.name === 'Uint8Array') {
            if (copy) {
              if (arg.slice) {
                arg = arg.slice();
              } else {
                arg = Array.prototype.slice.call(arg);
              }
            }

            return arg;
          } // It's an array; check it is a valid representation of a byte


          if (Array.isArray(arg)) {
            if (!checkInts(arg)) {
              throw new Error('Array contains invalid value: ' + arg);
            }

            return new Uint8Array(arg);
          } // Something else, but behaves like an array (maybe a Buffer? Arguments?)


          if (checkInt(arg.length) && checkInts(arg)) {
            return new Uint8Array(arg);
          }

          throw new Error('unsupported array-like object');
        }

        function createArray(length) {
          return new Uint8Array(length);
        }

        function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
          if (sourceStart != null || sourceEnd != null) {
            if (sourceArray.slice) {
              sourceArray = sourceArray.slice(sourceStart, sourceEnd);
            } else {
              sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
            }
          }

          targetArray.set(sourceArray, targetStart);
        }

        var convertUtf8 = function () {
          function toBytes(text) {
            var result = [],
                i = 0;
            text = encodeURI(text);

            while (i < text.length) {
              var c = text.charCodeAt(i++); // if it is a % sign, encode the following 2 bytes as a hex value

              if (c === 37) {
                result.push(parseInt(text.substr(i, 2), 16));
                i += 2; // otherwise, just the actual byte
              } else {
                result.push(c);
              }
            }

            return coerceArray(result);
          }

          function fromBytes(bytes) {
            var result = [],
                i = 0;

            while (i < bytes.length) {
              var c = bytes[i];

              if (c < 128) {
                result.push(String.fromCharCode(c));
                i++;
              } else if (c > 191 && c < 224) {
                result.push(String.fromCharCode((c & 0x1f) << 6 | bytes[i + 1] & 0x3f));
                i += 2;
              } else {
                result.push(String.fromCharCode((c & 0x0f) << 12 | (bytes[i + 1] & 0x3f) << 6 | bytes[i + 2] & 0x3f));
                i += 3;
              }
            }

            return result.join('');
          }

          return {
            toBytes: toBytes,
            fromBytes: fromBytes
          };
        }();

        var convertHex = function () {
          function toBytes(text) {
            var result = [];

            for (var i = 0; i < text.length; i += 2) {
              result.push(parseInt(text.substr(i, 2), 16));
            }

            return result;
          } // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html


          var Hex = '0123456789abcdef';

          function fromBytes(bytes) {
            var result = [];

            for (var i = 0; i < bytes.length; i++) {
              var v = bytes[i];
              result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);
            }

            return result.join('');
          }

          return {
            toBytes: toBytes,
            fromBytes: fromBytes
          };
        }(); // Number of rounds by keysize


        var numberOfRounds = {
          16: 10,
          24: 12,
          32: 14
        }; // Round constant words

        var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91]; // S-box and Inverse S-box (S is for Substitution)

        var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
        var Si = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]; // Transformations for encryption

        var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
        var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
        var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
        var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c]; // Transformations for decryption

        var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
        var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
        var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
        var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0]; // Transformations for decryption key expansion

        var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
        var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
        var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
        var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];

        function convertToInt32(bytes) {
          var result = [];

          for (var i = 0; i < bytes.length; i += 4) {
            result.push(bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]);
          }

          return result;
        }

        var AES = function AES(key) {
          if (!(this instanceof AES)) {
            throw Error('AES must be instanitated with `new`');
          }

          Object.defineProperty(this, 'key', {
            value: coerceArray(key, true)
          });

          this._prepare();
        };

        AES.prototype._prepare = function () {
          var rounds = numberOfRounds[this.key.length];

          if (rounds == null) {
            throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
          } // encryption round keys


          this._Ke = []; // decryption round keys

          this._Kd = [];

          for (var i = 0; i <= rounds; i++) {
            this._Ke.push([0, 0, 0, 0]);

            this._Kd.push([0, 0, 0, 0]);
          }

          var roundKeyCount = (rounds + 1) * 4;
          var KC = this.key.length / 4; // convert the key into ints

          var tk = convertToInt32(this.key); // copy values into round key arrays

          var index;

          for (var i = 0; i < KC; i++) {
            index = i >> 2;
            this._Ke[index][i % 4] = tk[i];
            this._Kd[rounds - index][i % 4] = tk[i];
          } // key expansion (fips-197 section 5.2)


          var rconpointer = 0;
          var t = KC,
              tt;

          while (t < roundKeyCount) {
            tt = tk[KC - 1];
            tk[0] ^= S[tt >> 16 & 0xFF] << 24 ^ S[tt >> 8 & 0xFF] << 16 ^ S[tt & 0xFF] << 8 ^ S[tt >> 24 & 0xFF] ^ rcon[rconpointer] << 24;
            rconpointer += 1; // key expansion (for non-256 bit)

            if (KC != 8) {
              for (var i = 1; i < KC; i++) {
                tk[i] ^= tk[i - 1];
              } // key expansion for 256-bit keys is "slightly different" (fips-197)

            } else {
              for (var i = 1; i < KC / 2; i++) {
                tk[i] ^= tk[i - 1];
              }

              tt = tk[KC / 2 - 1];
              tk[KC / 2] ^= S[tt & 0xFF] ^ S[tt >> 8 & 0xFF] << 8 ^ S[tt >> 16 & 0xFF] << 16 ^ S[tt >> 24 & 0xFF] << 24;

              for (var i = KC / 2 + 1; i < KC; i++) {
                tk[i] ^= tk[i - 1];
              }
            } // copy values into round key arrays


            var i = 0,
                r,
                c;

            while (i < KC && t < roundKeyCount) {
              r = t >> 2;
              c = t % 4;
              this._Ke[r][c] = tk[i];
              this._Kd[rounds - r][c] = tk[i++];
              t++;
            }
          } // inverse-cipher-ify the decryption round key (fips-197 section 5.3)


          for (var r = 1; r < rounds; r++) {
            for (var c = 0; c < 4; c++) {
              tt = this._Kd[r][c];
              this._Kd[r][c] = U1[tt >> 24 & 0xFF] ^ U2[tt >> 16 & 0xFF] ^ U3[tt >> 8 & 0xFF] ^ U4[tt & 0xFF];
            }
          }
        };

        AES.prototype.encrypt = function (plaintext) {
          if (plaintext.length != 16) {
            throw new Error('invalid plaintext size (must be 16 bytes)');
          }

          var rounds = this._Ke.length - 1;
          var a = [0, 0, 0, 0]; // convert plaintext to (ints ^ key)

          var t = convertToInt32(plaintext);

          for (var i = 0; i < 4; i++) {
            t[i] ^= this._Ke[0][i];
          } // apply round transforms


          for (var r = 1; r < rounds; r++) {
            for (var i = 0; i < 4; i++) {
              a[i] = T1[t[i] >> 24 & 0xff] ^ T2[t[(i + 1) % 4] >> 16 & 0xff] ^ T3[t[(i + 2) % 4] >> 8 & 0xff] ^ T4[t[(i + 3) % 4] & 0xff] ^ this._Ke[r][i];
            }

            t = a.slice();
          } // the last round is special


          var result = createArray(16),
              tt;

          for (var i = 0; i < 4; i++) {
            tt = this._Ke[rounds][i];
            result[4 * i] = (S[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;
            result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
            result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
            result[4 * i + 3] = (S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;
          }

          return result;
        };

        AES.prototype.decrypt = function (ciphertext) {
          if (ciphertext.length != 16) {
            throw new Error('invalid ciphertext size (must be 16 bytes)');
          }

          var rounds = this._Kd.length - 1;
          var a = [0, 0, 0, 0]; // convert plaintext to (ints ^ key)

          var t = convertToInt32(ciphertext);

          for (var i = 0; i < 4; i++) {
            t[i] ^= this._Kd[0][i];
          } // apply round transforms


          for (var r = 1; r < rounds; r++) {
            for (var i = 0; i < 4; i++) {
              a[i] = T5[t[i] >> 24 & 0xff] ^ T6[t[(i + 3) % 4] >> 16 & 0xff] ^ T7[t[(i + 2) % 4] >> 8 & 0xff] ^ T8[t[(i + 1) % 4] & 0xff] ^ this._Kd[r][i];
            }

            t = a.slice();
          } // the last round is special


          var result = createArray(16),
              tt;

          for (var i = 0; i < 4; i++) {
            tt = this._Kd[rounds][i];
            result[4 * i] = (Si[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;
            result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
            result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
            result[4 * i + 3] = (Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;
          }

          return result;
        };
        /**
         *  Mode Of Operation - Electonic Codebook (ECB)
         */


        var ModeOfOperationECB = function ModeOfOperationECB(key) {
          if (!(this instanceof ModeOfOperationECB)) {
            throw Error('AES must be instanitated with `new`');
          }

          this.description = "Electronic Code Block";
          this.name = "ecb";
          this._aes = new AES(key);
        };

        ModeOfOperationECB.prototype.encrypt = function (plaintext) {
          plaintext = coerceArray(plaintext);

          if (plaintext.length % 16 !== 0) {
            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
          }

          var ciphertext = createArray(plaintext.length);
          var block = createArray(16);

          for (var i = 0; i < plaintext.length; i += 16) {
            copyArray(plaintext, block, 0, i, i + 16);
            block = this._aes.encrypt(block);
            copyArray(block, ciphertext, i);
          }

          return ciphertext;
        };

        ModeOfOperationECB.prototype.decrypt = function (ciphertext) {
          ciphertext = coerceArray(ciphertext);

          if (ciphertext.length % 16 !== 0) {
            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
          }

          var plaintext = createArray(ciphertext.length);
          var block = createArray(16);

          for (var i = 0; i < ciphertext.length; i += 16) {
            copyArray(ciphertext, block, 0, i, i + 16);
            block = this._aes.decrypt(block);
            copyArray(block, plaintext, i);
          }

          return plaintext;
        };
        /**
         *  Mode Of Operation - Cipher Block Chaining (CBC)
         */


        var ModeOfOperationCBC = function ModeOfOperationCBC(key, iv) {
          if (!(this instanceof ModeOfOperationCBC)) {
            throw Error('AES must be instanitated with `new`');
          }

          this.description = "Cipher Block Chaining";
          this.name = "cbc";

          if (!iv) {
            iv = createArray(16);
          } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 bytes)');
          }

          this._lastCipherblock = coerceArray(iv, true);
          this._aes = new AES(key);
        };

        ModeOfOperationCBC.prototype.encrypt = function (plaintext) {
          plaintext = coerceArray(plaintext);

          if (plaintext.length % 16 !== 0) {
            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
          }

          var ciphertext = createArray(plaintext.length);
          var block = createArray(16);

          for (var i = 0; i < plaintext.length; i += 16) {
            copyArray(plaintext, block, 0, i, i + 16);

            for (var j = 0; j < 16; j++) {
              block[j] ^= this._lastCipherblock[j];
            }

            this._lastCipherblock = this._aes.encrypt(block);
            copyArray(this._lastCipherblock, ciphertext, i);
          }

          return ciphertext;
        };

        ModeOfOperationCBC.prototype.decrypt = function (ciphertext) {
          ciphertext = coerceArray(ciphertext);

          if (ciphertext.length % 16 !== 0) {
            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
          }

          var plaintext = createArray(ciphertext.length);
          var block = createArray(16);

          for (var i = 0; i < ciphertext.length; i += 16) {
            copyArray(ciphertext, block, 0, i, i + 16);
            block = this._aes.decrypt(block);

            for (var j = 0; j < 16; j++) {
              plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
            }

            copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
          }

          return plaintext;
        };
        /**
         *  Mode Of Operation - Cipher Feedback (CFB)
         */


        var ModeOfOperationCFB = function ModeOfOperationCFB(key, iv, segmentSize) {
          if (!(this instanceof ModeOfOperationCFB)) {
            throw Error('AES must be instanitated with `new`');
          }

          this.description = "Cipher Feedback";
          this.name = "cfb";

          if (!iv) {
            iv = createArray(16);
          } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 size)');
          }

          if (!segmentSize) {
            segmentSize = 1;
          }

          this.segmentSize = segmentSize;
          this._shiftRegister = coerceArray(iv, true);
          this._aes = new AES(key);
        };

        ModeOfOperationCFB.prototype.encrypt = function (plaintext) {
          if (plaintext.length % this.segmentSize != 0) {
            throw new Error('invalid plaintext size (must be segmentSize bytes)');
          }

          var encrypted = coerceArray(plaintext, true);
          var xorSegment;

          for (var i = 0; i < encrypted.length; i += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);

            for (var j = 0; j < this.segmentSize; j++) {
              encrypted[i + j] ^= xorSegment[j];
            } // Shift the register


            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
          }

          return encrypted;
        };

        ModeOfOperationCFB.prototype.decrypt = function (ciphertext) {
          if (ciphertext.length % this.segmentSize != 0) {
            throw new Error('invalid ciphertext size (must be segmentSize bytes)');
          }

          var plaintext = coerceArray(ciphertext, true);
          var xorSegment;

          for (var i = 0; i < plaintext.length; i += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);

            for (var j = 0; j < this.segmentSize; j++) {
              plaintext[i + j] ^= xorSegment[j];
            } // Shift the register


            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
          }

          return plaintext;
        };
        /**
         *  Mode Of Operation - Output Feedback (OFB)
         */


        var ModeOfOperationOFB = function ModeOfOperationOFB(key, iv) {
          if (!(this instanceof ModeOfOperationOFB)) {
            throw Error('AES must be instanitated with `new`');
          }

          this.description = "Output Feedback";
          this.name = "ofb";

          if (!iv) {
            iv = createArray(16);
          } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 bytes)');
          }

          this._lastPrecipher = coerceArray(iv, true);
          this._lastPrecipherIndex = 16;
          this._aes = new AES(key);
        };

        ModeOfOperationOFB.prototype.encrypt = function (plaintext) {
          var encrypted = coerceArray(plaintext, true);

          for (var i = 0; i < encrypted.length; i++) {
            if (this._lastPrecipherIndex === 16) {
              this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
              this._lastPrecipherIndex = 0;
            }

            encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
          }

          return encrypted;
        }; // Decryption is symetric


        ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
        /**
         *  Counter object for CTR common mode of operation
         */

        var Counter = function Counter(initialValue) {
          if (!(this instanceof Counter)) {
            throw Error('Counter must be instanitated with `new`');
          } // We allow 0, but anything false-ish uses the default 1


          if (initialValue !== 0 && !initialValue) {
            initialValue = 1;
          }

          if (typeof initialValue === 'number') {
            this._counter = createArray(16);
            this.setValue(initialValue);
          } else {
            this.setBytes(initialValue);
          }
        };

        Counter.prototype.setValue = function (value) {
          if (typeof value !== 'number' || parseInt(value) != value) {
            throw new Error('invalid counter value (must be an integer)');
          } // We cannot safely handle numbers beyond the safe range for integers


          if (value > Number.MAX_SAFE_INTEGER) {
            throw new Error('integer value out of safe range');
          }

          for (var index = 15; index >= 0; --index) {
            this._counter[index] = value % 256;
            value = parseInt(value / 256);
          }
        };

        Counter.prototype.setBytes = function (bytes) {
          bytes = coerceArray(bytes, true);

          if (bytes.length != 16) {
            throw new Error('invalid counter bytes size (must be 16 bytes)');
          }

          this._counter = bytes;
        };

        Counter.prototype.increment = function () {
          for (var i = 15; i >= 0; i--) {
            if (this._counter[i] === 255) {
              this._counter[i] = 0;
            } else {
              this._counter[i]++;
              break;
            }
          }
        };
        /**
         *  Mode Of Operation - Counter (CTR)
         */


        var ModeOfOperationCTR = function ModeOfOperationCTR(key, counter) {
          if (!(this instanceof ModeOfOperationCTR)) {
            throw Error('AES must be instanitated with `new`');
          }

          this.description = "Counter";
          this.name = "ctr";

          if (!(counter instanceof Counter)) {
            counter = new Counter(counter);
          }

          this._counter = counter;
          this._remainingCounter = null;
          this._remainingCounterIndex = 16;
          this._aes = new AES(key);
        };

        ModeOfOperationCTR.prototype.encrypt = function (plaintext) {
          var encrypted = coerceArray(plaintext, true);

          for (var i = 0; i < encrypted.length; i++) {
            if (this._remainingCounterIndex === 16) {
              this._remainingCounter = this._aes.encrypt(this._counter._counter);
              this._remainingCounterIndex = 0;

              this._counter.increment();
            }

            encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
          }

          return encrypted;
        }; // Decryption is symetric


        ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt; ///////////////////////
        // Padding
        // See:https://tools.ietf.org/html/rfc2315

        function pkcs7pad(data) {
          data = coerceArray(data, true);
          var padder = 16 - data.length % 16;
          var result = createArray(data.length + padder);
          copyArray(data, result);

          for (var i = data.length; i < result.length; i++) {
            result[i] = padder;
          }

          return result;
        }

        function pkcs7strip(data) {
          data = coerceArray(data, true);

          if (data.length < 16) {
            throw new Error('PKCS#7 invalid length');
          }

          var padder = data[data.length - 1];

          if (padder > 16) {
            throw new Error('PKCS#7 padding byte out of range');
          }

          var length = data.length - padder;

          for (var i = 0; i < padder; i++) {
            if (data[length + i] !== padder) {
              throw new Error('PKCS#7 invalid padding byte');
            }
          }

          var result = createArray(length);
          copyArray(data, result, 0, 0, length);
          return result;
        } ///////////////////////
        // Exporting
        // The block cipher


        var aesjs = {
          AES: AES,
          Counter: Counter,
          ModeOfOperation: {
            ecb: ModeOfOperationECB,
            cbc: ModeOfOperationCBC,
            cfb: ModeOfOperationCFB,
            ofb: ModeOfOperationOFB,
            ctr: ModeOfOperationCTR
          },
          utils: {
            hex: convertHex,
            utf8: convertUtf8
          },
          padding: {
            pkcs7: {
              pad: pkcs7pad,
              strip: pkcs7strip
            }
          },
          _arrayTest: {
            coerceArray: coerceArray,
            createArray: createArray,
            copyArray: copyArray
          }
        }; // node.js

        {
          module.exports = aesjs; // RequireJS/AMD
          // http://www.requirejs.org/docs/api.html
          // https://github.com/amdjs/amdjs-api/wiki/AMD
        }
      })();
    });

    function _typeof(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function (obj) {
          return typeof obj;
        };
      } else {
        _typeof = function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }

      return _typeof(obj);
    }

    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }

      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }

    function _asyncToGenerator(fn) {
      return function () {
        var self = this,
            args = arguments;
        return new Promise(function (resolve, reject) {
          var gen = fn.apply(self, args);

          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }

          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }

          _next(undefined);
        });
      };
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);

      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
      }

      return keys;
    }

    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};

        if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }

      return target;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class) _setPrototypeOf(instance, Class.prototype);
          return instance;
        };
      }

      return _construct.apply(null, arguments);
    }

    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }

    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : undefined;

      _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;

        if (typeof Class !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }

        if (typeof _cache !== "undefined") {
          if (_cache.has(Class)) return _cache.get(Class);

          _cache.set(Class, Wrapper);
        }

        function Wrapper() {
          return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }

        Wrapper.prototype = Object.create(Class.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class);
      };

      return _wrapNativeSuper(Class);
    }

    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;

      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }

      return target;
    }

    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};

      var target = _objectWithoutPropertiesLoose(source, excluded);

      var key, i;

      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }

      return target;
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized(self);
    }

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;

          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return _possibleConstructorReturn(this, result);
      };
    }

    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null) break;
      }

      return object;
    }

    function _get(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get(target, property, receiver) {
          var base = _superPropBase(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get(target, property, receiver || target);
    }

    function _taggedTemplateLiteral(strings, raw) {
      if (!raw) {
        raw = strings.slice(0);
      }

      return Object.freeze(Object.defineProperties(strings, {
        raw: {
          value: Object.freeze(raw)
        }
      }));
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
    }

    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;

      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

      return arr2;
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it;

      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;

          var F = function () {};

          return {
            s: F,
            n: function () {
              if (i >= o.length) return {
                done: true
              };
              return {
                done: false,
                value: o[i++]
              };
            },
            e: function (e) {
              throw e;
            },
            f: F
          };
        }

        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      var normalCompletion = true,
          didErr = false,
          err;
      return {
        s: function () {
          it = o[Symbol.iterator]();
        },
        n: function () {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function (e) {
          didErr = true;
          err = e;
        },
        f: function () {
          try {
            if (!normalCompletion && it.return != null) it.return();
          } finally {
            if (didErr) throw err;
          }
        }
      };
    }

    /**
     * Copyright (c) 2018 Jun Kurihara
     * Copyright 2020 The Matrix.org Foundation C.I.C.
     * 
     * MIT LICENSE, See https://github.com/junkurihara/jscu/blob/develop/packages/js-crypto-hkdf/LICENSE
     * Based on https://github.com/junkurihara/jscu/blob/develop/packages/js-crypto-hkdf/src/hkdf.ts
     */
    // forked this code to make it use the cryptoDriver for HMAC that is more backwards-compatible
    function hkdf(_x, _x2, _x3, _x4, _x5, _x6) {
      return _hkdf.apply(this, arguments);
    }

    function _hkdf() {
      _hkdf = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(cryptoDriver, key, salt, info, hash, length) {
        var len, prk, t, okm, i, concat;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                length = length / 8;
                len = cryptoDriver.digestSize(hash); // RFC5869 Step 1 (Extract)

                _context.next = 4;
                return cryptoDriver.hmac.compute(salt, key, hash);

              case 4:
                prk = _context.sent;
                // RFC5869 Step 2 (Expand)
                t = new Uint8Array([]);
                okm = new Uint8Array(Math.ceil(length / len) * len);
                i = 0;

              case 8:
                if (!(i < Math.ceil(length / len))) {
                  _context.next = 20;
                  break;
                }

                concat = new Uint8Array(t.length + info.length + 1);
                concat.set(t);
                concat.set(info, t.length);
                concat.set(new Uint8Array([i + 1]), t.length + info.length);
                _context.next = 15;
                return cryptoDriver.hmac.compute(prk, concat, hash);

              case 15:
                t = _context.sent;
                okm.set(t, len * i);

              case 17:
                i++;
                _context.next = 8;
                break;

              case 20:
                return _context.abrupt("return", okm.slice(0, length));

              case 21:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return _hkdf.apply(this, arguments);
    }

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var AbortError = /*#__PURE__*/function (_Error) {
      _inherits(AbortError, _Error);

      var _super = _createSuper(AbortError);

      function AbortError() {
        _classCallCheck(this, AbortError);

        return _super.apply(this, arguments);
      }

      _createClass(AbortError, [{
        key: "name",
        get: function get() {
          return "AbortError";
        }
      }]);

      return AbortError;
    }( /*#__PURE__*/_wrapNativeSuper(Error));

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var WrappedError = /*#__PURE__*/function (_Error) {
      _inherits(WrappedError, _Error);

      var _super = _createSuper(WrappedError);

      function WrappedError(message, cause) {
        var _this;

        _classCallCheck(this, WrappedError);

        _this = _super.call(this, "".concat(message, ": ").concat(cause.message));
        _this.cause = cause;
        return _this;
      }

      _createClass(WrappedError, [{
        key: "name",
        get: function get() {
          return "WrappedError";
        }
      }]);

      return WrappedError;
    }( /*#__PURE__*/_wrapNativeSuper(Error));
    var HomeServerError = /*#__PURE__*/function (_Error2) {
      _inherits(HomeServerError, _Error2);

      var _super2 = _createSuper(HomeServerError);

      function HomeServerError(method, url, body, status) {
        var _this2;

        _classCallCheck(this, HomeServerError);

        _this2 = _super2.call(this, "".concat(body ? body.error : status, " on ").concat(method, " ").concat(url));
        _this2.errcode = body ? body.errcode : null;
        _this2.retry_after_ms = body ? body.retry_after_ms : 0;
        _this2.statusCode = status;
        return _this2;
      }

      _createClass(HomeServerError, [{
        key: "name",
        get: function get() {
          return "HomeServerError";
        }
      }]);

      return HomeServerError;
    }( /*#__PURE__*/_wrapNativeSuper(Error));
    var ConnectionError = /*#__PURE__*/function (_Error3) {
      _inherits(ConnectionError, _Error3);

      var _super3 = _createSuper(ConnectionError);

      function ConnectionError(message, isTimeout) {
        var _this3;

        _classCallCheck(this, ConnectionError);

        _this3 = _super3.call(this, message || "ConnectionError");
        _this3.isTimeout = isTimeout;
        return _this3;
      }

      _createClass(ConnectionError, [{
        key: "name",
        get: function get() {
          return "ConnectionError";
        }
      }]);

      return ConnectionError;
    }( /*#__PURE__*/_wrapNativeSuper(Error));

    var BaseObservable = /*#__PURE__*/function () {
      function BaseObservable() {
        _classCallCheck(this, BaseObservable);

        this._handlers = new Set();
      }

      _createClass(BaseObservable, [{
        key: "onSubscribeFirst",
        value: function onSubscribeFirst() {}
      }, {
        key: "onUnsubscribeLast",
        value: function onUnsubscribeLast() {}
      }, {
        key: "subscribe",
        value: function subscribe(handler) {
          var _this = this;

          this._handlers.add(handler);

          if (this._handlers.size === 1) {
            this.onSubscribeFirst();
          }

          return function () {
            return _this.unsubscribe(handler);
          };
        }
      }, {
        key: "unsubscribe",
        value: function unsubscribe(handler) {
          if (handler) {
            this._handlers.delete(handler);

            if (this._handlers.size === 0) {
              this.onUnsubscribeLast();
            }
          }

          return void 0;
        }
      }, {
        key: "unsubscribeAll",
        value: function unsubscribeAll() {
          if (this._handlers.size !== 0) {
            this._handlers.clear();

            this.onUnsubscribeLast();
          }
        }
      }, {
        key: "hasSubscriptions",
        get: function get() {
          return this._handlers.size !== 0;
        }
      }]);

      return BaseObservable;
    }();

    var BaseObservableValue = /*#__PURE__*/function (_BaseObservable) {
      _inherits(BaseObservableValue, _BaseObservable);

      var _super = _createSuper(BaseObservableValue);

      function BaseObservableValue() {
        _classCallCheck(this, BaseObservableValue);

        return _super.apply(this, arguments);
      }

      _createClass(BaseObservableValue, [{
        key: "emit",
        value: function emit(argument) {
          var _iterator = _createForOfIteratorHelper(this._handlers),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var h = _step.value;
              h(argument);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }, {
        key: "waitFor",
        value: function waitFor(predicate) {
          if (predicate(this.get())) {
            return new ResolvedWaitForHandle(Promise.resolve(this.get()));
          } else {
            return new WaitForHandle(this, predicate);
          }
        }
      }]);

      return BaseObservableValue;
    }(BaseObservable);

    var WaitForHandle = /*#__PURE__*/function () {
      function WaitForHandle(observable, predicate) {
        var _this = this;

        _classCallCheck(this, WaitForHandle);

        this._promise = new Promise(function (resolve, reject) {
          _this._reject = reject;
          _this._subscription = observable.subscribe(function (v) {
            if (predicate(v)) {
              _this._reject = null;
              resolve(v);

              _this.dispose();
            }
          });
        });
      }

      _createClass(WaitForHandle, [{
        key: "dispose",
        value: function dispose() {
          if (this._subscription) {
            this._subscription();

            this._subscription = null;
          }

          if (this._reject) {
            this._reject(new AbortError());

            this._reject = null;
          }
        }
      }, {
        key: "promise",
        get: function get() {
          return this._promise;
        }
      }]);

      return WaitForHandle;
    }();

    var ResolvedWaitForHandle = /*#__PURE__*/function () {
      function ResolvedWaitForHandle(promise) {
        _classCallCheck(this, ResolvedWaitForHandle);

        this.promise = promise;
      }

      _createClass(ResolvedWaitForHandle, [{
        key: "dispose",
        value: function dispose() {}
      }]);

      return ResolvedWaitForHandle;
    }();

    var ObservableValue = /*#__PURE__*/function (_BaseObservableValue) {
      _inherits(ObservableValue, _BaseObservableValue);

      var _super2 = _createSuper(ObservableValue);

      function ObservableValue(initialValue) {
        var _this2;

        _classCallCheck(this, ObservableValue);

        _this2 = _super2.call(this);
        _this2._value = initialValue;
        return _this2;
      }

      _createClass(ObservableValue, [{
        key: "get",
        value: function get() {
          return this._value;
        }
      }, {
        key: "set",
        value: function set(value) {
          if (value !== this._value) {
            this._value = value;
            this.emit(this._value);
          }
        }
      }]);

      return ObservableValue;
    }(BaseObservableValue);
    var RetainedObservableValue = /*#__PURE__*/function (_ObservableValue) {
      _inherits(RetainedObservableValue, _ObservableValue);

      var _super3 = _createSuper(RetainedObservableValue);

      function RetainedObservableValue(initialValue, freeCallback) {
        var _this3;

        _classCallCheck(this, RetainedObservableValue);

        _this3 = _super3.call(this, initialValue);
        _this3._freeCallback = freeCallback;
        return _this3;
      }

      _createClass(RetainedObservableValue, [{
        key: "onUnsubscribeLast",
        value: function onUnsubscribeLast() {
          _get(_getPrototypeOf(RetainedObservableValue.prototype), "onUnsubscribeLast", this).call(this);

          this._freeCallback();
        }
      }]);

      return RetainedObservableValue;
    }(ObservableValue);

    function abortOnTimeout(createTimeout, timeoutAmount, requestResult, responsePromise) {
      var timeout = createTimeout(timeoutAmount); // abort request if timeout finishes first

      var timedOut = false;
      timeout.elapsed().then(function () {
        timedOut = true;
        requestResult.abort();
      }, function () {} // ignore AbortError when timeout is aborted
      ); // abort timeout if request finishes first

      return responsePromise.then(function (response) {
        timeout.abort();
        return response;
      }, function (err) {
        timeout.abort(); // map error to TimeoutError

        if (err.name === "AbortError" && timedOut) {
          throw new ConnectionError("Request timed out after ".concat(timeoutAmount, "ms"), true);
        } else {
          throw err;
        }
      });
    } // because impunity only takes one entrypoint currently,

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function _addCacheBuster(urlStr) {
      var random = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Math.random;

      // XHR doesn't have a good way to disable cache,
      // so add a random query param
      // see https://davidtranscend.com/blog/prevent-ie11-cache-ajax-requests/
      if (urlStr.includes("?")) {
        urlStr = urlStr + "&";
      } else {
        urlStr = urlStr + "?";
      }

      return urlStr + "_cacheBuster=".concat(Math.ceil(random() * Number.MAX_SAFE_INTEGER));
    }

    var RequestResult = /*#__PURE__*/function () {
      function RequestResult(promise, xhr) {
        _classCallCheck(this, RequestResult);

        this._promise = promise;
        this._xhr = xhr;
      }

      _createClass(RequestResult, [{
        key: "abort",
        value: function abort() {
          this._xhr.abort();
        }
      }, {
        key: "response",
        value: function response() {
          return this._promise;
        }
      }]);

      return RequestResult;
    }();

    function createXhr(url, _ref) {
      var method = _ref.method,
          headers = _ref.headers,
          timeout = _ref.timeout,
          format = _ref.format,
          uploadProgress = _ref.uploadProgress;
      var xhr = new XMLHttpRequest();

      if (uploadProgress) {
        xhr.upload.addEventListener("progress", function (evt) {
          return uploadProgress(evt.loaded);
        });
      }

      xhr.open(method, url);

      if (format === "buffer") {
        // important to call this after calling open
        xhr.responseType = "arraybuffer";
      }

      if (headers) {
        var _iterator = _createForOfIteratorHelper(headers.entries()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
                name = _step$value[0],
                value = _step$value[1];

            try {
              xhr.setRequestHeader(name, value);
            } catch (err) {
              console.info("Could not set ".concat(name, " header: ").concat(err.message));
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      if (timeout) {
        xhr.timeout = timeout;
      }

      return xhr;
    }

    function xhrAsPromise(xhr, method, url) {
      return new Promise(function (resolve, reject) {
        xhr.addEventListener("load", function () {
          return resolve(xhr);
        });
        xhr.addEventListener("abort", function () {
          return reject(new AbortError());
        });
        xhr.addEventListener("error", function () {
          return reject(new ConnectionError("Error ".concat(method, " ").concat(url)));
        });
        xhr.addEventListener("timeout", function () {
          return reject(new ConnectionError("Timeout ".concat(method, " ").concat(url), true));
        });
      });
    }

    function xhrRequest(url, options) {
      var _body;

      var cache = options.cache,
          format = options.format,
          body = options.body,
          method = options.method;

      if (!cache) {
        url = _addCacheBuster(url);
      }

      var xhr = createXhr(url, options);
      var promise = xhrAsPromise(xhr, method, url).then(function (xhr) {
        var status = xhr.status;
        var body = null;

        if (format === "buffer") {
          body = xhr.response;
        } else if (xhr.getResponseHeader("Content-Type") === "application/json") {
          body = JSON.parse(xhr.responseText);
        }

        return {
          status: status,
          body: body
        };
      }); // if a BlobHandle, take native blob

      if ((_body = body) === null || _body === void 0 ? void 0 : _body.nativeBlob) {
        body = body.nativeBlob;
      }

      xhr.send(body || null);
      return new RequestResult(promise, xhr);
    }

    var RequestResult$1 = /*#__PURE__*/function () {
      function RequestResult(promise, controller) {
        var _this = this;

        _classCallCheck(this, RequestResult);

        if (!controller) {
          var abortPromise = new Promise(function (_, reject) {
            _this._controller = {
              abort: function abort() {
                var err = new Error("fetch request aborted");
                err.name = "AbortError";
                reject(err);
              }
            };
          });
          this.promise = Promise.race([promise, abortPromise]);
        } else {
          this.promise = promise;
          this._controller = controller;
        }
      }

      _createClass(RequestResult, [{
        key: "abort",
        value: function abort() {
          this._controller.abort();
        }
      }, {
        key: "response",
        value: function response() {
          return this.promise;
        }
      }]);

      return RequestResult;
    }();

    function createFetchRequest(createTimeout, serviceWorkerHandler) {
      return function fetchRequest(url, requestOptions) {
        var _body;

        if (serviceWorkerHandler === null || serviceWorkerHandler === void 0 ? void 0 : serviceWorkerHandler.haltRequests) {
          // prevent any requests while waiting
          // for the new service worker to get activated.
          // Once this happens, the page will be reloaded
          // by the serviceWorkerHandler so this is fine.
          return new RequestResult$1(new Promise(function () {}), {});
        } // fetch doesn't do upload progress yet, delegate to xhr


        if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.uploadProgress) {
          return xhrRequest(url, requestOptions);
        }

        var method = requestOptions.method,
            headers = requestOptions.headers,
            body = requestOptions.body,
            timeout = requestOptions.timeout,
            format = requestOptions.format,
            _requestOptions$cache = requestOptions.cache,
            cache = _requestOptions$cache === void 0 ? false : _requestOptions$cache;
        var controller = typeof AbortController === "function" ? new AbortController() : null; // if a BlobHandle, take native blob

        if ((_body = body) === null || _body === void 0 ? void 0 : _body.nativeBlob) {
          body = body.nativeBlob;
        }

        var options = {
          method: method,
          body: body
        };

        if (controller) {
          options = Object.assign(options, {
            signal: controller.signal
          });
        }

        if (!cache) {
          url = _addCacheBuster(url);
        }

        options = Object.assign(options, {
          mode: "cors",
          credentials: "omit",
          referrer: "no-referrer",
          // ideally we'd turn off cache here, but Safari interprets
          // `Access-Control-Allow-Headers` strictly (only when fetch is
          // intercepted by a service worker strangely enough), in that
          // it gives a CORS error if Cache-Control is not present
          // in the list of allowed headers (which it isn't commonly, at least not on matrix.org).
          // With no-store or no-cache here, it does set `Cache-Control`
          // so we don't do that, and prevent caching with `addCacheBuster`.
          // We also hope the server responds with `Cache-Control: no-store` so
          // we don't fill the http cache with api responses.
          // 
          // cache: "no-store",
          cache: "default"
        });

        if (headers) {
          var fetchHeaders = new Headers();

          var _iterator = _createForOfIteratorHelper(headers.entries()),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _slicedToArray(_step.value, 2),
                  name = _step$value[0],
                  value = _step$value[1];

              fetchHeaders.append(name, value);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          options.headers = fetchHeaders;
        }

        var promise = fetch(url, options).then( /*#__PURE__*/function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(response) {
            var status, body;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    status = response.status;
                    _context.prev = 1;

                    if (!(format === "json")) {
                      _context.next = 8;
                      break;
                    }

                    _context.next = 5;
                    return response.json();

                  case 5:
                    body = _context.sent;
                    _context.next = 12;
                    break;

                  case 8:
                    if (!(format === "buffer")) {
                      _context.next = 12;
                      break;
                    }

                    _context.next = 11;
                    return response.arrayBuffer();

                  case 11:
                    body = _context.sent;

                  case 12:
                    _context.next = 18;
                    break;

                  case 14:
                    _context.prev = 14;
                    _context.t0 = _context["catch"](1);

                    if (_context.t0.name === "SyntaxError" && status >= 400) {
                      _context.next = 18;
                      break;
                    }

                    throw _context.t0;

                  case 18:
                    return _context.abrupt("return", {
                      status: status,
                      body: body
                    });

                  case 19:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, null, [[1, 14]]);
          }));

          return function (_x) {
            return _ref.apply(this, arguments);
          };
        }(), function (err) {
          if (err.name === "AbortError") {
            // map DOMException with name AbortError to our own AbortError type
            // as we don't want DOMExceptions in the protocol layer.
            throw new AbortError();
          } else if (err instanceof TypeError) {
            // Network errors are reported as TypeErrors, see
            // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Checking_that_the_fetch_was_successful
            // this can either mean user is offline, server is offline, or a CORS error (server misconfiguration).
            // 
            // One could check navigator.onLine to rule out the first
            // but the 2 latter ones are indistinguishable from javascript.
            throw new ConnectionError("".concat(method, " ").concat(url, ": ").concat(err.message));
          }

          throw err;
        });
        var result = new RequestResult$1(promise, controller);

        if (timeout) {
          result.promise = abortOnTimeout(createTimeout, timeout, result, result.promise);
        }

        return result;
      };
    }

    var StoreNames;

    (function (StoreNames2) {
      StoreNames2["session"] = "session";
      StoreNames2["roomState"] = "roomState";
      StoreNames2["roomSummary"] = "roomSummary";
      StoreNames2["archivedRoomSummary"] = "archivedRoomSummary";
      StoreNames2["invites"] = "invites";
      StoreNames2["roomMembers"] = "roomMembers";
      StoreNames2["timelineEvents"] = "timelineEvents";
      StoreNames2["timelineRelations"] = "timelineRelations";
      StoreNames2["timelineFragments"] = "timelineFragments";
      StoreNames2["pendingEvents"] = "pendingEvents";
      StoreNames2["userIdentities"] = "userIdentities";
      StoreNames2["deviceIdentities"] = "deviceIdentities";
      StoreNames2["olmSessions"] = "olmSessions";
      StoreNames2["inboundGroupSessions"] = "inboundGroupSessions";
      StoreNames2["outboundGroupSessions"] = "outboundGroupSessions";
      StoreNames2["groupSessionDecryptions"] = "groupSessionDecryptions";
      StoreNames2["operations"] = "operations";
      StoreNames2["accountData"] = "accountData";
    })(StoreNames || (StoreNames = {}));

    var STORE_NAMES = Object.values(StoreNames);
    var StorageError = /*#__PURE__*/function (_Error) {
      _inherits(StorageError, _Error);

      var _super = _createSuper(StorageError);

      function StorageError(message) {
        var _this;

        var cause = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        _classCallCheck(this, StorageError);

        _this = _super.call(this, message);

        if (cause) {
          _this.errcode = cause.name;
        }

        _this.cause = cause;
        return _this;
      }

      _createClass(StorageError, [{
        key: "name",
        get: function get() {
          return "StorageError";
        }
      }]);

      return StorageError;
    }( /*#__PURE__*/_wrapNativeSuper(Error));
    var KeyLimits = {
      get minStorageKey() {
        return 0;
      },

      get middleStorageKey() {
        return 2147483647;
      },

      get maxStorageKey() {
        return 4294967295;
      }

    };

    function _sourceName(source) {
      return "objectStore" in source ? "".concat(source.objectStore.name, ".").concat(source.name) : source.name;
    }

    function _sourceDatabase(source) {
      var _source$objectStore, _source$objectStore$t, _source$objectStore$t2, _source$transaction, _source$transaction$d;

      return "objectStore" in source ? (_source$objectStore = source.objectStore) === null || _source$objectStore === void 0 ? void 0 : (_source$objectStore$t = _source$objectStore.transaction) === null || _source$objectStore$t === void 0 ? void 0 : (_source$objectStore$t2 = _source$objectStore$t.db) === null || _source$objectStore$t2 === void 0 ? void 0 : _source$objectStore$t2.name : (_source$transaction = source.transaction) === null || _source$transaction === void 0 ? void 0 : (_source$transaction$d = _source$transaction.db) === null || _source$transaction$d === void 0 ? void 0 : _source$transaction$d.name;
    }

    var IDBError = /*#__PURE__*/function (_StorageError) {
      _inherits(IDBError, _StorageError);

      var _super = _createSuper(IDBError);

      function IDBError(message, sourceOrCursor) {
        var _this;

        var cause = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        _classCallCheck(this, IDBError);

        var source = sourceOrCursor && "source" in sourceOrCursor ? sourceOrCursor.source : sourceOrCursor;
        var storeName = source ? _sourceName(source) : "";
        var databaseName = source ? _sourceDatabase(source) : "";
        var fullMessage = "".concat(message, " on ").concat(databaseName, ".").concat(storeName);

        if (cause) {
          fullMessage += ": ";

          if (typeof cause.name === "string") {
            fullMessage += "(name: ".concat(cause.name, ") ");
          }

          if (typeof cause.code === "number") {
            fullMessage += "(code: ".concat(cause.code, ") ");
          }
        }

        if (cause) {
          fullMessage += cause.message;
        }

        _this = _super.call(this, fullMessage, cause);
        _this.storeName = storeName;
        _this.databaseName = databaseName;
        return _this;
      }

      return IDBError;
    }(StorageError);
    var IDBRequestError = /*#__PURE__*/function (_IDBError) {
      _inherits(IDBRequestError, _IDBError);

      var _super2 = _createSuper(IDBRequestError);

      function IDBRequestError(errorEvent) {
        var _this2;

        _classCallCheck(this, IDBRequestError);

        var request = errorEvent.target;
        var source = request.source;
        var cause = request.error;
        _this2 = _super2.call(this, "IDBRequest failed", source, cause);
        _this2.errorEvent = errorEvent;
        return _this2;
      }

      _createClass(IDBRequestError, [{
        key: "preventTransactionAbort",
        value: function preventTransactionAbort() {
          this.errorEvent.preventDefault();
        }
      }]);

      return IDBRequestError;
    }(IDBError);
    var IDBRequestAttemptError = /*#__PURE__*/function (_IDBError2) {
      _inherits(IDBRequestAttemptError, _IDBError2);

      var _super3 = _createSuper(IDBRequestAttemptError);

      function IDBRequestAttemptError(method, source, cause, params) {
        _classCallCheck(this, IDBRequestAttemptError);

        return _super3.call(this, "".concat(method, "(").concat(params.map(function (p) {
          return JSON.stringify(p);
        }).join(", "), ") failed"), source, cause);
      }

      return IDBRequestAttemptError;
    }(IDBError);

    var DONE = {
      done: true
    };
    var NOT_DONE = {
      done: false
    };

    function encodeUint32(n) {
      var hex = n.toString(16);
      return "0".repeat(8 - hex.length) + hex;
    }
    function decodeUint32(str) {
      return parseInt(str, 16);
    }
    function openDatabase(name, createObjectStore, version) {
      var idbFactory = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : window.indexedDB;
      var req = idbFactory.open(name, version);

      req.onupgradeneeded = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(ev) {
          var req2, db, txn, oldVersion;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  req2 = ev.target;
                  db = req2.result;
                  txn = req2.transaction;
                  oldVersion = ev.oldVersion;
                  _context.prev = 4;
                  _context.next = 7;
                  return createObjectStore(db, txn, oldVersion, version);

                case 7:
                  _context.next = 12;
                  break;

                case 9:
                  _context.prev = 9;
                  _context.t0 = _context["catch"](4);

                  try {
                    txn.abort();
                  } catch (err2) {}

                case 12:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[4, 9]]);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }();

      return reqAsPromise(req);
    }
    function reqAsPromise(req) {
      return new Promise(function (resolve, reject) {
        req.addEventListener("success", function (event) {
          resolve(event.target.result);
        });
        req.addEventListener("error", function (event) {
          var error = new IDBRequestError(event);
          reject(error);
        });
      });
    }
    function txnAsPromise(txn) {
      return new Promise(function (resolve, reject) {
        txn.addEventListener("complete", function () {
          resolve();
        });
        txn.addEventListener("abort", function (event) {
          reject(new AbortError());
        });
      });
    }
    function iterateCursor(cursorRequest, processValue) {
      return new Promise(function (resolve, reject) {
        cursorRequest.onerror = function (event) {
          reject(new IDBRequestError(event));
        };

        cursorRequest.onsuccess = function (event) {
          var cursor = event.target.result;

          if (!cursor) {
            resolve(false);
            return;
          }

          var result = processValue(cursor["value"], cursor.key, cursor);
          var done = result === null || result === void 0 ? void 0 : result.done;
          var jumpTo = result === null || result === void 0 ? void 0 : result.jumpTo;

          if (done) {
            resolve(true);
          } else if (jumpTo) {
            cursor.continue(jumpTo);
          } else {
            cursor.continue();
          }
        };
      }).catch(function (err) {
        throw new StorageError("iterateCursor failed", err);
      });
    }
    function fetchResults(_x2, _x3) {
      return _fetchResults.apply(this, arguments);
    }

    function _fetchResults() {
      _fetchResults = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(cursor, isDone) {
        var results;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                results = [];
                _context3.next = 3;
                return iterateCursor(cursor, function (value) {
                  results.push(value);
                  return {
                    done: isDone(results)
                  };
                });

              case 3:
                return _context3.abrupt("return", results);

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      return _fetchResults.apply(this, arguments);
    }

    var LogLevel;

    (function (LogLevel2) {
      LogLevel2[LogLevel2["All"] = 1] = "All";
      LogLevel2[LogLevel2["Debug"] = 2] = "Debug";
      LogLevel2[LogLevel2["Detail"] = 3] = "Detail";
      LogLevel2[LogLevel2["Info"] = 4] = "Info";
      LogLevel2[LogLevel2["Warn"] = 5] = "Warn";
      LogLevel2[LogLevel2["Error"] = 6] = "Error";
      LogLevel2[LogLevel2["Fatal"] = 7] = "Fatal";
      LogLevel2[LogLevel2["Off"] = 8] = "Off";
    })(LogLevel || (LogLevel = {}));

    var LogFilter = /*#__PURE__*/function () {
      function LogFilter(parentFilter) {
        _classCallCheck(this, LogFilter);

        this._parentFilter = parentFilter;
      }

      _createClass(LogFilter, [{
        key: "filter",
        value: function filter(item, children) {
          if (this._parentFilter) {
            if (!this._parentFilter.filter(item, children)) {
              return false;
            }
          }

          if (this._min !== void 0 && !Array.isArray(children) && item.logLevel < this._min) {
            return false;
          } else {
            return true;
          }
        }
      }, {
        key: "minLevel",
        value: function minLevel(logLevel) {
          this._min = logLevel;
          return this;
        }
      }]);

      return LogFilter;
    }();

    function noop() {}

    var NullLogger = /*#__PURE__*/function () {
      function NullLogger() {
        _classCallCheck(this, NullLogger);

        this.item = new NullLogItem(this);
      }

      _createClass(NullLogger, [{
        key: "log",
        value: function log() {}
      }, {
        key: "run",
        value: function run(_, callback) {
          return callback(this.item);
        }
      }, {
        key: "wrapOrRun",
        value: function wrapOrRun(item, _, callback) {
          if (item) {
            return item.wrap(_, callback);
          } else {
            return this.run(_, callback);
          }
        }
      }, {
        key: "runDetached",
        value: function runDetached(_, callback) {
          var _this = this;

          new Promise(function (r) {
            return r(callback(_this.item));
          }).then(noop, noop);
          return this.item;
        }
      }, {
        key: "export",
        value: function () {
          var _export2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    return _context.abrupt("return", void 0);

                  case 1:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function _export() {
            return _export2.apply(this, arguments);
          }

          return _export;
        }()
      }, {
        key: "level",
        get: function get() {
          return LogLevel;
        }
      }]);

      return NullLogger;
    }();
    var NullLogItem = /*#__PURE__*/function () {
      function NullLogItem(logger) {
        _classCallCheck(this, NullLogItem);

        this.logger = logger;
      }

      _createClass(NullLogItem, [{
        key: "wrap",
        value: function wrap(_, callback) {
          return callback(this);
        }
      }, {
        key: "log",
        value: function log() {}
      }, {
        key: "set",
        value: function set() {}
      }, {
        key: "runDetached",
        value: function runDetached(_, callback) {
          var _this2 = this;

          new Promise(function (r) {
            return r(callback(_this2));
          }).then(noop, noop);
          return this;
        }
      }, {
        key: "wrapDetached",
        value: function wrapDetached(_, _callback) {
          return this.refDetached();
        }
      }, {
        key: "refDetached",
        value: function refDetached() {}
      }, {
        key: "ensureRefId",
        value: function ensureRefId() {}
      }, {
        key: "catch",
        value: function _catch(err) {
          return err;
        }
      }, {
        key: "child",
        value: function child() {
          return this;
        }
      }, {
        key: "finish",
        value: function finish() {}
      }, {
        key: "serialize",
        value: function serialize() {
          return void 0;
        }
      }, {
        key: "level",
        get: function get() {
          return LogLevel;
        }
      }, {
        key: "duration",
        get: function get() {
          return 0;
        }
      }]);

      return NullLogItem;
    }();
    var Instance = new NullLogger();

    var QueryTarget = /*#__PURE__*/function () {
      function QueryTarget(target, transaction) {
        _classCallCheck(this, QueryTarget);

        this._target = target;
        this._transaction = transaction;
      }

      _createClass(QueryTarget, [{
        key: "_openCursor",
        value: function _openCursor(range, direction) {
          if (range && direction) {
            return this._target.openCursor(range, direction);
          } else if (range) {
            return this._target.openCursor(range);
          } else if (direction) {
            return this._target.openCursor(null, direction);
          } else {
            return this._target.openCursor();
          }
        }
      }, {
        key: "supports",
        value: function supports(methodName) {
          return this._target.supports(methodName);
        }
      }, {
        key: "get",
        value: function get(key) {
          return reqAsPromise(this._target.get(key));
        }
      }, {
        key: "getKey",
        value: function getKey(key) {
          var _this = this;

          if (this._target.supports("getKey")) {
            return reqAsPromise(this._target.getKey(key));
          } else {
            return reqAsPromise(this._target.get(key)).then(function (value) {
              if (value) {
                var keyPath = _this._target.keyPath;

                if (typeof keyPath === "string") {
                  keyPath = [keyPath];
                }

                return keyPath.reduce(function (obj, key2) {
                  return obj[key2];
                }, value);
              }
            });
          }
        }
      }, {
        key: "reduce",
        value: function reduce(range, reducer, initialValue) {
          return this._reduce(range, reducer, initialValue, "next");
        }
      }, {
        key: "reduceReverse",
        value: function reduceReverse(range, reducer, initialValue) {
          return this._reduce(range, reducer, initialValue, "prev");
        }
      }, {
        key: "selectLimit",
        value: function selectLimit(range, amount) {
          return this._selectLimit(range, amount, "next");
        }
      }, {
        key: "selectLimitReverse",
        value: function selectLimitReverse(range, amount) {
          return this._selectLimit(range, amount, "prev");
        }
      }, {
        key: "selectWhile",
        value: function selectWhile(range, predicate) {
          return this._selectWhile(range, predicate, "next");
        }
      }, {
        key: "selectWhileReverse",
        value: function selectWhileReverse(range, predicate) {
          return this._selectWhile(range, predicate, "prev");
        }
      }, {
        key: "selectAll",
        value: function () {
          var _selectAll = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(range, direction) {
            var cursor, results;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    cursor = this._openCursor(range, direction);
                    results = [];
                    _context.next = 4;
                    return iterateCursor(cursor, function (value) {
                      results.push(value);
                      return NOT_DONE;
                    });

                  case 4:
                    return _context.abrupt("return", results);

                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function selectAll(_x, _x2) {
            return _selectAll.apply(this, arguments);
          }

          return selectAll;
        }()
      }, {
        key: "selectFirst",
        value: function selectFirst(range) {
          return this._find(range, function () {
            return true;
          }, "next");
        }
      }, {
        key: "selectLast",
        value: function selectLast(range) {
          return this._find(range, function () {
            return true;
          }, "prev");
        }
      }, {
        key: "find",
        value: function find(range, predicate) {
          return this._find(range, predicate, "next");
        }
      }, {
        key: "findReverse",
        value: function findReverse(range, predicate) {
          return this._find(range, predicate, "prev");
        }
      }, {
        key: "findMaxKey",
        value: function () {
          var _findMaxKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(range) {
            var cursor, maxKey;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    cursor = this._target.openKeyCursor(range, "prev");
                    _context2.next = 3;
                    return iterateCursor(cursor, function (_, key) {
                      maxKey = key;
                      return DONE;
                    });

                  case 3:
                    return _context2.abrupt("return", maxKey);

                  case 4:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function findMaxKey(_x3) {
            return _findMaxKey.apply(this, arguments);
          }

          return findMaxKey;
        }()
      }, {
        key: "iterateValues",
        value: function () {
          var _iterateValues = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(range, callback) {
            var cursor;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    cursor = this._target.openCursor(range, "next");
                    _context3.next = 3;
                    return iterateCursor(cursor, function (value, key, cur) {
                      return {
                        done: callback(value, key, cur)
                      };
                    });

                  case 3:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function iterateValues(_x4, _x5) {
            return _iterateValues.apply(this, arguments);
          }

          return iterateValues;
        }()
      }, {
        key: "iterateKeys",
        value: function () {
          var _iterateKeys = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(range, callback) {
            var cursor;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    cursor = this._target.openKeyCursor(range, "next");
                    _context4.next = 3;
                    return iterateCursor(cursor, function (_, key, cur) {
                      return {
                        done: callback(key, cur)
                      };
                    });

                  case 3:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function iterateKeys(_x6, _x7) {
            return _iterateKeys.apply(this, arguments);
          }

          return iterateKeys;
        }()
      }, {
        key: "findExistingKeys",
        value: function () {
          var _findExistingKeys = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(keys, backwards, callback) {
            var _this2 = this;

            var compareKeys, sortedKeys, firstKey, lastKey, direction, cursor, index;
            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    compareKeys = function compareKeys(a, b) {
                      return backwards ? -_this2.idbFactory.cmp(a, b) : _this2.idbFactory.cmp(a, b);
                    };

                    sortedKeys = keys.slice().sort(compareKeys);
                    firstKey = sortedKeys[0];
                    lastKey = sortedKeys[sortedKeys.length - 1];
                    direction = backwards ? "prev" : "next";
                    cursor = this._target.openKeyCursor(this.IDBKeyRange.bound(firstKey, lastKey), direction);
                    index = 0;
                    _context5.next = 9;
                    return iterateCursor(cursor, function (value, key, cursor2) {
                      while (index < sortedKeys.length && compareKeys(sortedKeys[index], key) < 0) {
                        index += 1;
                      }

                      var done = false;

                      if (sortedKeys[index] === key) {
                        var pk = cursor2.primaryKey;
                        done = callback(key, pk);
                        index += 1;
                      }

                      if (done || index >= sortedKeys.length) {
                        return DONE;
                      } else {
                        return {
                          done: false,
                          jumpTo: sortedKeys[index]
                        };
                      }
                    });

                  case 9:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));

          function findExistingKeys(_x8, _x9, _x10) {
            return _findExistingKeys.apply(this, arguments);
          }

          return findExistingKeys;
        }()
      }, {
        key: "_reduce",
        value: function _reduce(range, reducer, initialValue, direction) {
          var reducedValue = initialValue;

          var cursor = this._openCursor(range, direction);

          return iterateCursor(cursor, function (value) {
            reducedValue = reducer(reducedValue, value);
            return NOT_DONE;
          });
        }
      }, {
        key: "_selectLimit",
        value: function _selectLimit(range, amount, direction) {
          return this._selectUntil(range, function (results) {
            return results.length === amount;
          }, direction);
        }
      }, {
        key: "_selectUntil",
        value: function () {
          var _selectUntil2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(range, predicate, direction) {
            var cursor, results;
            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    cursor = this._openCursor(range, direction);
                    results = [];
                    _context6.next = 4;
                    return iterateCursor(cursor, function (value) {
                      results.push(value);
                      return {
                        done: predicate(results, value)
                      };
                    });

                  case 4:
                    return _context6.abrupt("return", results);

                  case 5:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));

          function _selectUntil(_x11, _x12, _x13) {
            return _selectUntil2.apply(this, arguments);
          }

          return _selectUntil;
        }()
      }, {
        key: "_selectWhile",
        value: function () {
          var _selectWhile2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(range, predicate, direction) {
            var cursor, results;
            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    cursor = this._openCursor(range, direction);
                    results = [];
                    _context7.next = 4;
                    return iterateCursor(cursor, function (value) {
                      var passesPredicate = predicate(value);

                      if (passesPredicate) {
                        results.push(value);
                      }

                      return {
                        done: !passesPredicate
                      };
                    });

                  case 4:
                    return _context7.abrupt("return", results);

                  case 5:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));

          function _selectWhile(_x14, _x15, _x16) {
            return _selectWhile2.apply(this, arguments);
          }

          return _selectWhile;
        }()
      }, {
        key: "iterateWhile",
        value: function () {
          var _iterateWhile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(range, predicate) {
            var cursor;
            return regeneratorRuntime.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    cursor = this._openCursor(range, "next");
                    _context8.next = 3;
                    return iterateCursor(cursor, function (value) {
                      var passesPredicate = predicate(value);
                      return {
                        done: !passesPredicate
                      };
                    });

                  case 3:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));

          function iterateWhile(_x17, _x18) {
            return _iterateWhile.apply(this, arguments);
          }

          return iterateWhile;
        }()
      }, {
        key: "_find",
        value: function () {
          var _find2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(range, predicate, direction) {
            var cursor, result, found;
            return regeneratorRuntime.wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    cursor = this._openCursor(range, direction);
                    _context9.next = 3;
                    return iterateCursor(cursor, function (value) {
                      var found2 = predicate(value);

                      if (found2) {
                        result = value;
                      }

                      return {
                        done: found2
                      };
                    });

                  case 3:
                    found = _context9.sent;

                    if (!found) {
                      _context9.next = 6;
                      break;
                    }

                    return _context9.abrupt("return", result);

                  case 6:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this);
          }));

          function _find(_x19, _x20, _x21) {
            return _find2.apply(this, arguments);
          }

          return _find;
        }()
      }, {
        key: "idbFactory",
        get: function get() {
          return this._transaction.idbFactory;
        }
      }, {
        key: "IDBKeyRange",
        get: function get() {
          return this._transaction.IDBKeyRange;
        }
      }, {
        key: "databaseName",
        get: function get() {
          return this._transaction.databaseName;
        }
      }]);

      return QueryTarget;
    }();

    var LOG_REQUESTS = false;

    function logRequest(method, params, source) {
      var _source$transaction, _source$transaction$d;

      var storeName = source === null || source === void 0 ? void 0 : source.name;
      var databaseName = source === null || source === void 0 ? void 0 : (_source$transaction = source.transaction) === null || _source$transaction === void 0 ? void 0 : (_source$transaction$d = _source$transaction.db) === null || _source$transaction$d === void 0 ? void 0 : _source$transaction$d.name;
      console.info("".concat(databaseName, ".").concat(storeName, ".").concat(method, "(").concat(params.map(function (p) {
        return JSON.stringify(p);
      }).join(", "), ")"));
    }

    var QueryTargetWrapper = /*#__PURE__*/function () {
      function QueryTargetWrapper(qt) {
        _classCallCheck(this, QueryTargetWrapper);

        this._qt = qt;
      }

      _createClass(QueryTargetWrapper, [{
        key: "supports",
        value: function supports(methodName) {
          return !!this._qt[methodName];
        }
      }, {
        key: "openKeyCursor",
        value: function openKeyCursor(range, direction) {
          try {
            if (!this._qt.openKeyCursor) {
              LOG_REQUESTS && logRequest("openCursor", [range, direction], this._qt);
              return this.openCursor(range, direction);
            }

            LOG_REQUESTS && logRequest("openKeyCursor", [range, direction], this._qt);
            return this._qt.openKeyCursor(range, direction);
          } catch (err) {
            throw new IDBRequestAttemptError("openKeyCursor", this._qt, err, [range, direction]);
          }
        }
      }, {
        key: "openCursor",
        value: function openCursor(range, direction) {
          try {
            LOG_REQUESTS && logRequest("openCursor", [], this._qt);
            return this._qt.openCursor(range, direction);
          } catch (err) {
            throw new IDBRequestAttemptError("openCursor", this._qt, err, [range, direction]);
          }
        }
      }, {
        key: "put",
        value: function put(item, key) {
          try {
            LOG_REQUESTS && logRequest("put", [item, key], this._qt);
            return this._qtStore.put(item, key);
          } catch (err) {
            throw new IDBRequestAttemptError("put", this._qt, err, [item, key]);
          }
        }
      }, {
        key: "add",
        value: function add(item, key) {
          try {
            LOG_REQUESTS && logRequest("add", [item, key], this._qt);
            return this._qtStore.add(item, key);
          } catch (err) {
            throw new IDBRequestAttemptError("add", this._qt, err, [item, key]);
          }
        }
      }, {
        key: "get",
        value: function get(key) {
          try {
            LOG_REQUESTS && logRequest("get", [key], this._qt);
            return this._qt.get(key);
          } catch (err) {
            throw new IDBRequestAttemptError("get", this._qt, err, [key]);
          }
        }
      }, {
        key: "getKey",
        value: function getKey(key) {
          try {
            LOG_REQUESTS && logRequest("getKey", [key], this._qt);
            return this._qt.getKey(key);
          } catch (err) {
            throw new IDBRequestAttemptError("getKey", this._qt, err, [key]);
          }
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          try {
            LOG_REQUESTS && logRequest("delete", [key], this._qt);
            return this._qtStore.delete(key);
          } catch (err) {
            throw new IDBRequestAttemptError("delete", this._qt, err, [key]);
          }
        }
      }, {
        key: "index",
        value: function index(name) {
          try {
            return this._qtStore.index(name);
          } catch (err) {
            throw new IDBRequestAttemptError("index", this._qt, err, [name]);
          }
        }
      }, {
        key: "keyPath",
        get: function get() {
          return this._qtStore.keyPath;
        }
      }, {
        key: "_qtStore",
        get: function get() {
          if ("objectStore" in this._qt) {
            return this._qt.objectStore;
          }

          return this._qt;
        }
      }, {
        key: "indexNames",
        get: function get() {
          return Array.from(this._qtStore.indexNames);
        }
      }]);

      return QueryTargetWrapper;
    }();
    var Store = /*#__PURE__*/function (_QueryTarget) {
      _inherits(Store, _QueryTarget);

      var _super = _createSuper(Store);

      function Store(idbStore, transaction) {
        _classCallCheck(this, Store);

        return _super.call(this, new QueryTargetWrapper(idbStore), transaction);
      }

      _createClass(Store, [{
        key: "index",
        value: function index(indexName) {
          return new QueryTarget(new QueryTargetWrapper(this._idbStore.index(indexName)), this._transaction);
        }
      }, {
        key: "put",
        value: function put(value, log) {
          var request = this._idbStore.put(value);

          this._prepareErrorLog(request, log, "put", void 0, value);
        }
      }, {
        key: "add",
        value: function add(value, log) {
          var request = this._idbStore.add(value);

          this._prepareErrorLog(request, log, "add", void 0, value);
        }
      }, {
        key: "tryAdd",
        value: function () {
          var _tryAdd = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(value, log) {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.prev = 0;
                    _context.next = 3;
                    return reqAsPromise(this._idbStore.add(value));

                  case 3:
                    return _context.abrupt("return", true);

                  case 6:
                    _context.prev = 6;
                    _context.t0 = _context["catch"](0);

                    if (!(_context.t0 instanceof IDBRequestError)) {
                      _context.next = 14;
                      break;
                    }

                    log.log({
                      l: "could not write",
                      id: this._getKeys(value),
                      e: _context.t0
                    }, log.level.Warn);

                    _context.t0.preventTransactionAbort();

                    return _context.abrupt("return", false);

                  case 14:
                    throw _context.t0;

                  case 15:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[0, 6]]);
          }));

          function tryAdd(_x, _x2) {
            return _tryAdd.apply(this, arguments);
          }

          return tryAdd;
        }()
      }, {
        key: "delete",
        value: function _delete(keyOrKeyRange, log) {
          var request = this._idbStore.delete(keyOrKeyRange);

          this._prepareErrorLog(request, log, "delete", keyOrKeyRange, void 0);
        }
      }, {
        key: "_prepareErrorLog",
        value: function _prepareErrorLog(request, log, operationName, key, value) {
          var _this = this;

          if (log) {
            log.ensureRefId();
          }

          reqAsPromise(request).catch(function (err) {
            var keys = void 0;

            if (value) {
              keys = _this._getKeys(value);
            } else if (key) {
              keys = [key];
            }

            _this._transaction.addWriteError(err, log, operationName, keys);
          });
        }
      }, {
        key: "_getKeys",
        value: function _getKeys(value) {
          var keys = [];
          var keyPath = this._idbStore.keyPath;

          try {
            keys.push(this._readKeyPath(value, keyPath));
          } catch (err) {
            console.warn("could not read keyPath", keyPath);
          }

          var _iterator = _createForOfIteratorHelper(this._idbStore.indexNames),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var indexName = _step.value;

              try {
                var index = this._idbStore.index(indexName);

                keys.push(this._readKeyPath(value, index.keyPath));
              } catch (err) {
                console.warn("could not read index", indexName);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          return keys;
        }
      }, {
        key: "_readKeyPath",
        value: function _readKeyPath(value, keyPath) {
          if (Array.isArray(keyPath)) {
            var field = value;

            var _iterator2 = _createForOfIteratorHelper(keyPath),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var part = _step2.value;

                if (_typeof(field) === "object") {
                  field = field[part];
                } else {
                  break;
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }

            return field;
          } else {
            return value[keyPath];
          }
        }
      }, {
        key: "_idbStore",
        get: function get() {
          return this._target;
        }
      }]);

      return Store;
    }(QueryTarget);

    /* Copyright 2015 Mark Haines
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     *  You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var escaped = /[\\\"\x00-\x1F]/g;
    var escapes = {};

    for (var i = 0; i < 0x20; ++i) {
      escapes[String.fromCharCode(i)] = "\\U" + ('0000' + i.toString(16)).slice(-4).toUpperCase();
    }

    escapes['\b'] = '\\b';
    escapes['\t'] = '\\t';
    escapes['\n'] = '\\n';
    escapes['\f'] = '\\f';
    escapes['\r'] = '\\r';
    escapes['\"'] = '\\\"';
    escapes['\\'] = '\\\\';

    function escapeString(value) {
      escaped.lastIndex = 0;
      return value.replace(escaped, function (c) {
        return escapes[c];
      });
    }

    function stringify(value) {
      switch (_typeof(value)) {
        case 'string':
          return '"' + escapeString(value) + '"';

        case 'number':
          return isFinite(value) ? value : 'null';

        case 'boolean':
          return value;

        case 'object':
          if (value === null) {
            return 'null';
          }

          if (Array.isArray(value)) {
            return stringifyArray(value);
          }

          return stringifyObject(value);

        default:
          throw new Error('Cannot stringify: ' + _typeof(value));
      }
    }

    function stringifyArray(array) {
      var sep = '[';
      var result = '';

      for (var i = 0; i < array.length; ++i) {
        result += sep;
        sep = ',';
        result += stringify(array[i]);
      }

      if (sep != ',') {
        return '[]';
      } else {
        return result + ']';
      }
    }

    function stringifyObject(object) {
      var sep = '{';
      var result = '';
      var keys = Object.keys(object);
      keys.sort();

      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        result += sep + '"' + escapeString(key) + '":';
        sep = ',';
        result += stringify(object[key]);
      }

      if (sep != ',') {
        return '{}';
      } else {
        return result + '}';
      }
    }
    /** */


    var anotherJson = {
      stringify: stringify
    };

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function createEnum() {
      var obj = {};

      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }

      for (var _i = 0, _values = values; _i < _values.length; _i++) {
        var value = _values[_i];

        if (typeof value !== "string") {
          throw new Error("Invalid enum value name" + (value === null || value === void 0 ? void 0 : value.toString()));
        }

        obj[value] = value;
      }

      return Object.freeze(obj);
    }

    var DecryptionSource = createEnum("Sync", "Timeline", "Retry"); // use common prefix so it's easy to clear properties that are not e2ee related during session clear

    var SESSION_E2EE_KEY_PREFIX = "e2ee:";
    var OLM_ALGORITHM = "m.olm.v1.curve25519-aes-sha2";
    var MEGOLM_ALGORITHM = "m.megolm.v1.aes-sha2";
    var DecryptionError = /*#__PURE__*/function (_Error) {
      _inherits(DecryptionError, _Error);

      var _super = _createSuper(DecryptionError);

      function DecryptionError(code, event) {
        var _this;

        var detailsObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        _classCallCheck(this, DecryptionError);

        _this = _super.call(this, "Decryption error ".concat(code).concat(detailsObj ? ": " + JSON.stringify(detailsObj) : ""));
        _this.code = code;
        _this.event = event;
        _this.details = detailsObj;
        return _this;
      }

      return DecryptionError;
    }( /*#__PURE__*/_wrapNativeSuper(Error));
    var SIGNATURE_ALGORITHM = "ed25519";
    function verifyEd25519Signature(olmUtil, userId, deviceOrKeyId, ed25519Key, value) {
      var _value$signatures, _value$signatures$use;

      var clone = Object.assign({}, value);
      delete clone.unsigned;
      delete clone.signatures;
      var canonicalJson = anotherJson.stringify(clone);
      var signature = value === null || value === void 0 ? void 0 : (_value$signatures = value.signatures) === null || _value$signatures === void 0 ? void 0 : (_value$signatures$use = _value$signatures[userId]) === null || _value$signatures$use === void 0 ? void 0 : _value$signatures$use["".concat(SIGNATURE_ALGORITHM, ":").concat(deviceOrKeyId)];

      try {
        if (!signature) {
          throw new Error("no signature");
        } // throws when signature is invalid


        olmUtil.ed25519_verify(ed25519Key, canonicalJson, signature);
        return true;
      } catch (err) {
        console.warn("Invalid signature, ignoring.", ed25519Key, canonicalJson, signature, err);
        return false;
      }
    }

    function stringify$1(value) {
      return JSON.stringify(encodeValue(value));
    }
    function parse(value) {
      return decodeValue(JSON.parse(value));
    }

    function encodeValue(value) {
      if (_typeof(value) === "object" && value !== null && !Array.isArray(value)) {
        if (value.byteLength) {
          return {
            _type: value.constructor.name,
            value: Array.from(value)
          };
        }

        var newObj = {};

        for (var prop in value) {
          if (value.hasOwnProperty(prop)) {
            newObj[prop] = encodeValue(value[prop]);
          }
        }

        return newObj;
      } else {
        return value;
      }
    }

    function decodeValue(value) {
      if (_typeof(value) === "object" && value !== null && !Array.isArray(value)) {
        if (typeof value._type === "string") {
          switch (value._type) {
            case "Int8Array":
              return Int8Array.from(value.value);

            case "Uint8Array":
              return Uint8Array.from(value.value);

            case "Uint8ClampedArray":
              return Uint8ClampedArray.from(value.value);

            case "Int16Array":
              return Int16Array.from(value.value);

            case "Uint16Array":
              return Uint16Array.from(value.value);

            case "Int32Array":
              return Int32Array.from(value.value);

            case "Uint32Array":
              return Uint32Array.from(value.value);

            case "Float32Array":
              return Float32Array.from(value.value);

            case "Float64Array":
              return Float64Array.from(value.value);

            case "BigInt64Array":
              return BigInt64Array.from(value.value);

            case "BigUint64Array":
              return BigUint64Array.from(value.value);

            default:
              return value.value;
          }
        }

        var newObj = {};

        for (var prop in value) {
          if (value.hasOwnProperty(prop)) {
            newObj[prop] = decodeValue(value[prop]);
          }
        }

        return newObj;
      } else {
        return value;
      }
    }

    var SessionStore = /*#__PURE__*/function () {
      function SessionStore(sessionStore, localStorage) {
        _classCallCheck(this, SessionStore);

        this._sessionStore = sessionStore;
        this._localStorage = localStorage;
      }

      _createClass(SessionStore, [{
        key: "get",
        value: function () {
          var _get = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(key) {
            var entry;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this._sessionStore.get(key);

                  case 2:
                    entry = _context.sent;

                    if (!entry) {
                      _context.next = 5;
                      break;
                    }

                    return _context.abrupt("return", entry.value);

                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function get(_x) {
            return _get.apply(this, arguments);
          }

          return get;
        }()
      }, {
        key: "_writeKeyToLocalStorage",
        value: function _writeKeyToLocalStorage(key, value) {
          try {
            var lsKey = this._localStorageKeyPrefix + key;
            var lsValue = stringify$1(value);

            this._localStorage.setItem(lsKey, lsValue);
          } catch (err) {
            console.error("could not write to localStorage", err);
          }
        }
      }, {
        key: "writeE2EEIdentityToLocalStorage",
        value: function writeE2EEIdentityToLocalStorage() {
          var _this = this;

          this._sessionStore.iterateValues(void 0, function (entry, key) {
            if (key.startsWith(SESSION_E2EE_KEY_PREFIX)) {
              _this._writeKeyToLocalStorage(key, entry.value);
            }

            return false;
          });
        }
      }, {
        key: "tryRestoreE2EEIdentityFromLocalStorage",
        value: function () {
          var _tryRestoreE2EEIdentityFromLocalStorage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(log) {
            var success, lsPrefix, prefix, i, lsKey, value, key, hasKey;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    success = false;
                    lsPrefix = this._localStorageKeyPrefix;
                    prefix = lsPrefix + SESSION_E2EE_KEY_PREFIX;
                    i = 0;

                  case 4:
                    if (!(i < this._localStorage.length)) {
                      _context2.next = 19;
                      break;
                    }

                    lsKey = this._localStorage.key(i);

                    if (!lsKey.startsWith(prefix)) {
                      _context2.next = 16;
                      break;
                    }

                    value = parse(this._localStorage.getItem(lsKey));
                    key = lsKey.substr(lsPrefix.length);
                    _context2.next = 11;
                    return this._sessionStore.getKey(key);

                  case 11:
                    _context2.t0 = _context2.sent;
                    _context2.t1 = key;
                    hasKey = _context2.t0 === _context2.t1;
                    log.set(key, !hasKey);

                    if (!hasKey) {
                      this._sessionStore.put({
                        key: key,
                        value: value
                      });

                      success = true;
                    }

                  case 16:
                    i += 1;
                    _context2.next = 4;
                    break;

                  case 19:
                    return _context2.abrupt("return", success);

                  case 20:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function tryRestoreE2EEIdentityFromLocalStorage(_x2) {
            return _tryRestoreE2EEIdentityFromLocalStorage.apply(this, arguments);
          }

          return tryRestoreE2EEIdentityFromLocalStorage;
        }()
      }, {
        key: "set",
        value: function set(key, value) {
          if (key.startsWith(SESSION_E2EE_KEY_PREFIX)) {
            this._writeKeyToLocalStorage(key, value);
          }

          this._sessionStore.put({
            key: key,
            value: value
          });
        }
      }, {
        key: "add",
        value: function add(key, value) {
          if (key.startsWith(SESSION_E2EE_KEY_PREFIX)) {
            this._writeKeyToLocalStorage(key, value);
          }

          this._sessionStore.add({
            key: key,
            value: value
          });
        }
      }, {
        key: "remove",
        value: function remove(key) {
          if (key.startsWith(SESSION_E2EE_KEY_PREFIX)) {
            this._localStorage.removeItem(this._localStorageKeyPrefix + key);
          }

          this._sessionStore.delete(key);
        }
      }, {
        key: "_localStorageKeyPrefix",
        get: function get() {
          return "".concat(this._sessionStore.databaseName, ".session.");
        }
      }]);

      return SessionStore;
    }();

    var RoomSummaryStore = /*#__PURE__*/function () {
      function RoomSummaryStore(summaryStore) {
        _classCallCheck(this, RoomSummaryStore);

        this._summaryStore = summaryStore;
      }

      _createClass(RoomSummaryStore, [{
        key: "getAll",
        value: function getAll() {
          return this._summaryStore.selectAll();
        }
      }, {
        key: "set",
        value: function set(summary) {
          this._summaryStore.put(summary);
        }
      }, {
        key: "get",
        value: function get(roomId) {
          return this._summaryStore.get(roomId);
        }
      }, {
        key: "has",
        value: function () {
          var _has = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(roomId) {
            var fetchedKey;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this._summaryStore.getKey(roomId);

                  case 2:
                    fetchedKey = _context.sent;
                    return _context.abrupt("return", roomId === fetchedKey);

                  case 4:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function has(_x) {
            return _has.apply(this, arguments);
          }

          return has;
        }()
      }, {
        key: "remove",
        value: function remove(roomId) {
          this._summaryStore.delete(roomId);
        }
      }]);

      return RoomSummaryStore;
    }();

    var InviteStore = /*#__PURE__*/function () {
      function InviteStore(inviteStore) {
        _classCallCheck(this, InviteStore);

        this._inviteStore = inviteStore;
      }

      _createClass(InviteStore, [{
        key: "getAll",
        value: function getAll() {
          return this._inviteStore.selectAll();
        }
      }, {
        key: "set",
        value: function set(invite) {
          this._inviteStore.put(invite);
        }
      }, {
        key: "remove",
        value: function remove(roomId) {
          this._inviteStore.delete(roomId);
        }
      }]);

      return InviteStore;
    }();

    var EventKey = /*#__PURE__*/function () {
      function EventKey(fragmentId, eventIndex) {
        _classCallCheck(this, EventKey);

        this.fragmentId = fragmentId;
        this.eventIndex = eventIndex;
      }

      _createClass(EventKey, [{
        key: "nextFragmentKey",
        value: function nextFragmentKey() {
          return new EventKey(this.fragmentId + 1, KeyLimits.middleStorageKey);
        }
      }, {
        key: "nextKeyForDirection",
        value: function nextKeyForDirection(direction) {
          if (direction.isForward) {
            return this.nextKey();
          } else {
            return this.previousKey();
          }
        }
      }, {
        key: "previousKey",
        value: function previousKey() {
          return new EventKey(this.fragmentId, this.eventIndex - 1);
        }
      }, {
        key: "nextKey",
        value: function nextKey() {
          return new EventKey(this.fragmentId, this.eventIndex + 1);
        }
      }, {
        key: "toString",
        value: function toString() {
          return "[".concat(this.fragmentId, "/").concat(this.eventIndex, "]");
        }
      }, {
        key: "equals",
        value: function equals(other) {
          return this.fragmentId === (other === null || other === void 0 ? void 0 : other.fragmentId) && this.eventIndex === (other === null || other === void 0 ? void 0 : other.eventIndex);
        }
      }], [{
        key: "defaultFragmentKey",
        value: function defaultFragmentKey(fragmentId) {
          return new EventKey(fragmentId, KeyLimits.middleStorageKey);
        }
      }, {
        key: "maxKey",
        get: function get() {
          return new EventKey(KeyLimits.maxStorageKey, KeyLimits.maxStorageKey);
        }
      }, {
        key: "minKey",
        get: function get() {
          return new EventKey(KeyLimits.minStorageKey, KeyLimits.minStorageKey);
        }
      }, {
        key: "defaultLiveKey",
        get: function get() {
          return EventKey.defaultFragmentKey(KeyLimits.minStorageKey);
        }
      }]);

      return EventKey;
    }();

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function createEventEntry(key, roomId, event) {
      return {
        fragmentId: key.fragmentId,
        eventIndex: key.eventIndex,
        roomId: roomId,
        event: event
      };
    }
    function directionalAppend(array, value, direction) {
      if (direction.isForward) {
        array.push(value);
      } else {
        array.unshift(value);
      }
    }
    function directionalConcat(array, otherArray, direction) {
      if (direction.isForward) {
        return array.concat(otherArray);
      } else {
        return otherArray.concat(array);
      }
    }

    function encodeKey(roomId, fragmentId, eventIndex) {
      return "".concat(roomId, "|").concat(encodeUint32(fragmentId), "|").concat(encodeUint32(eventIndex));
    }

    function decodeKey(key) {
      var _key$split = key.split("|"),
          _key$split2 = _slicedToArray(_key$split, 3),
          roomId = _key$split2[0],
          fragmentId = _key$split2[1],
          eventIndex = _key$split2[2];

      return {
        roomId: roomId,
        eventKey: new EventKey(decodeUint32(fragmentId), decodeUint32(eventIndex))
      };
    }

    function encodeEventIdKey(roomId, eventId) {
      return "".concat(roomId, "|").concat(eventId);
    }

    function decodeEventIdKey(eventIdKey) {
      var _eventIdKey$split = eventIdKey.split("|"),
          _eventIdKey$split2 = _slicedToArray(_eventIdKey$split, 2),
          roomId = _eventIdKey$split2[0],
          eventId = _eventIdKey$split2[1];

      return {
        roomId: roomId,
        eventId: eventId
      };
    }

    var Range = /*#__PURE__*/function () {
      function Range(_IDBKeyRange, only, lower, upper) {
        var lowerOpen = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        var upperOpen = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

        _classCallCheck(this, Range);

        this._IDBKeyRange = _IDBKeyRange;
        this._only = only;
        this._lower = lower;
        this._upper = upper;
        this._lowerOpen = lowerOpen;
        this._upperOpen = upperOpen;
      }

      _createClass(Range, [{
        key: "asIDBKeyRange",
        value: function asIDBKeyRange(roomId) {
          try {
            if (this._only) {
              return this._IDBKeyRange.only(encodeKey(roomId, this._only.fragmentId, this._only.eventIndex));
            }

            if (this._lower && !this._upper) {
              return this._IDBKeyRange.bound(encodeKey(roomId, this._lower.fragmentId, this._lower.eventIndex), encodeKey(roomId, this._lower.fragmentId, KeyLimits.maxStorageKey), this._lowerOpen, false);
            }

            if (!this._lower && this._upper) {
              return this._IDBKeyRange.bound(encodeKey(roomId, this._upper.fragmentId, KeyLimits.minStorageKey), encodeKey(roomId, this._upper.fragmentId, this._upper.eventIndex), false, this._upperOpen);
            }

            if (this._lower && this._upper) {
              return this._IDBKeyRange.bound(encodeKey(roomId, this._lower.fragmentId, this._lower.eventIndex), encodeKey(roomId, this._upper.fragmentId, this._upper.eventIndex), this._lowerOpen, this._upperOpen);
            }
          } catch (err) {
            throw new StorageError("IDBKeyRange failed with data: " + JSON.stringify(this), err);
          }
        }
      }]);

      return Range;
    }();

    var TimelineEventStore = /*#__PURE__*/function () {
      function TimelineEventStore(timelineStore) {
        _classCallCheck(this, TimelineEventStore);

        this._timelineStore = timelineStore;
      }

      _createClass(TimelineEventStore, [{
        key: "onlyRange",
        value: function onlyRange(eventKey) {
          return new Range(this._timelineStore.IDBKeyRange, eventKey);
        }
      }, {
        key: "upperBoundRange",
        value: function upperBoundRange(eventKey) {
          var open = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          return new Range(this._timelineStore.IDBKeyRange, void 0, void 0, eventKey, void 0, open);
        }
      }, {
        key: "lowerBoundRange",
        value: function lowerBoundRange(eventKey) {
          var open = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          return new Range(this._timelineStore.IDBKeyRange, void 0, eventKey, void 0, open);
        }
      }, {
        key: "boundRange",
        value: function boundRange(lower, upper) {
          var lowerOpen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var upperOpen = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          return new Range(this._timelineStore.IDBKeyRange, void 0, lower, upper, lowerOpen, upperOpen);
        }
      }, {
        key: "lastEvents",
        value: function () {
          var _lastEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(roomId, fragmentId, amount) {
            var eventKey;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    eventKey = EventKey.maxKey;
                    eventKey.fragmentId = fragmentId;
                    return _context.abrupt("return", this.eventsBefore(roomId, eventKey, amount));

                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function lastEvents(_x, _x2, _x3) {
            return _lastEvents.apply(this, arguments);
          }

          return lastEvents;
        }()
      }, {
        key: "firstEvents",
        value: function () {
          var _firstEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(roomId, fragmentId, amount) {
            var eventKey;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    eventKey = EventKey.minKey;
                    eventKey.fragmentId = fragmentId;
                    return _context2.abrupt("return", this.eventsAfter(roomId, eventKey, amount));

                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function firstEvents(_x4, _x5, _x6) {
            return _firstEvents.apply(this, arguments);
          }

          return firstEvents;
        }()
      }, {
        key: "eventsAfter",
        value: function eventsAfter(roomId, eventKey, amount) {
          var idbRange = this.lowerBoundRange(eventKey, true).asIDBKeyRange(roomId);
          return this._timelineStore.selectLimit(idbRange, amount);
        }
      }, {
        key: "eventsBefore",
        value: function () {
          var _eventsBefore = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(roomId, eventKey, amount) {
            var range, events;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    range = this.upperBoundRange(eventKey, true).asIDBKeyRange(roomId);
                    _context3.next = 3;
                    return this._timelineStore.selectLimitReverse(range, amount);

                  case 3:
                    events = _context3.sent;
                    events.reverse();
                    return _context3.abrupt("return", events);

                  case 6:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function eventsBefore(_x7, _x8, _x9) {
            return _eventsBefore.apply(this, arguments);
          }

          return eventsBefore;
        }()
      }, {
        key: "getEventKeysForIds",
        value: function () {
          var _getEventKeysForIds = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(roomId, eventIds) {
            var byEventId, keys, results;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    byEventId = this._timelineStore.index("byEventId");
                    keys = eventIds.map(function (eventId) {
                      return encodeEventIdKey(roomId, eventId);
                    });
                    results = new Map();
                    _context4.next = 5;
                    return byEventId.findExistingKeys(keys, false, function (indexKey, pk) {
                      var _decodeEventIdKey = decodeEventIdKey(indexKey),
                          eventId = _decodeEventIdKey.eventId;

                      var _decodeKey = decodeKey(pk),
                          eventKey = _decodeKey.eventKey;

                      results.set(eventId, eventKey);
                      return false;
                    });

                  case 5:
                    return _context4.abrupt("return", results);

                  case 6:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function getEventKeysForIds(_x10, _x11) {
            return _getEventKeysForIds.apply(this, arguments);
          }

          return getEventKeysForIds;
        }()
      }, {
        key: "findFirstOccurringEventId",
        value: function () {
          var _findFirstOccurringEventId = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(roomId, eventIds) {
            var byEventId, keys, results, firstFoundKey, firstFoundAndPrecedingResolved;
            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    firstFoundAndPrecedingResolved = function _firstFoundAndPrecedi() {
                      for (var i = 0; i < results.length; ++i) {
                        if (results[i] === void 0) {
                          return;
                        } else if (results[i] === true) {
                          return keys[i];
                        }
                      }
                    };

                    byEventId = this._timelineStore.index("byEventId");
                    keys = eventIds.map(function (eventId) {
                      return encodeEventIdKey(roomId, eventId);
                    });
                    results = new Array(keys.length);
                    _context5.next = 6;
                    return byEventId.findExistingKeys(keys, false, function (key, found) {
                      var index = keys.indexOf(key);
                      results[index] = found;
                      firstFoundKey = firstFoundAndPrecedingResolved();
                      return !!firstFoundKey;
                    });

                  case 6:
                    return _context5.abrupt("return", firstFoundKey && decodeEventIdKey(firstFoundKey).eventId);

                  case 7:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));

          function findFirstOccurringEventId(_x12, _x13) {
            return _findFirstOccurringEventId.apply(this, arguments);
          }

          return findFirstOccurringEventId;
        }()
      }, {
        key: "tryInsert",
        value: function tryInsert(entry, log) {
          entry.key = encodeKey(entry.roomId, entry.fragmentId, entry.eventIndex);
          entry.eventIdKey = encodeEventIdKey(entry.roomId, entry.event.event_id);
          return this._timelineStore.tryAdd(entry, log);
        }
      }, {
        key: "update",
        value: function update(entry) {
          this._timelineStore.put(entry);
        }
      }, {
        key: "get",
        value: function get(roomId, eventKey) {
          return this._timelineStore.get(encodeKey(roomId, eventKey.fragmentId, eventKey.eventIndex));
        }
      }, {
        key: "getByEventId",
        value: function getByEventId(roomId, eventId) {
          return this._timelineStore.index("byEventId").get(encodeEventIdKey(roomId, eventId));
        }
      }, {
        key: "removeAllForRoom",
        value: function removeAllForRoom(roomId) {
          var minKey = encodeKey(roomId, KeyLimits.minStorageKey, KeyLimits.minStorageKey);
          var maxKey = encodeKey(roomId, KeyLimits.maxStorageKey, KeyLimits.maxStorageKey);

          var range = this._timelineStore.IDBKeyRange.bound(minKey, maxKey);

          this._timelineStore.delete(range);
        }
      }]);

      return TimelineEventStore;
    }();

    var MIN_UNICODE = "\0";
    var MAX_UNICODE = "􏿿";

    function encodeKey$1(roomId, targetEventId, relType, sourceEventId) {
      return "".concat(roomId, "|").concat(targetEventId, "|").concat(relType, "|").concat(sourceEventId);
    }

    function decodeKey$1(key) {
      var _key$split = key.split("|"),
          _key$split2 = _slicedToArray(_key$split, 4),
          roomId = _key$split2[0],
          targetEventId = _key$split2[1],
          relType = _key$split2[2],
          sourceEventId = _key$split2[3];

      return {
        roomId: roomId,
        targetEventId: targetEventId,
        relType: relType,
        sourceEventId: sourceEventId
      };
    }

    var TimelineRelationStore = /*#__PURE__*/function () {
      function TimelineRelationStore(store) {
        _classCallCheck(this, TimelineRelationStore);

        this._store = store;
      }

      _createClass(TimelineRelationStore, [{
        key: "add",
        value: function add(roomId, targetEventId, relType, sourceEventId) {
          this._store.add({
            key: encodeKey$1(roomId, targetEventId, relType, sourceEventId)
          });
        }
      }, {
        key: "remove",
        value: function remove(roomId, targetEventId, relType, sourceEventId) {
          this._store.delete(encodeKey$1(roomId, targetEventId, relType, sourceEventId));
        }
      }, {
        key: "removeAllForTarget",
        value: function removeAllForTarget(roomId, targetId) {
          var range = this._store.IDBKeyRange.bound(encodeKey$1(roomId, targetId, MIN_UNICODE, MIN_UNICODE), encodeKey$1(roomId, targetId, MAX_UNICODE, MAX_UNICODE), true, true);

          this._store.delete(range);
        }
      }, {
        key: "removeAllForRoom",
        value: function removeAllForRoom(roomId) {
          var range = this._store.IDBKeyRange.bound(encodeKey$1(roomId, MIN_UNICODE, MIN_UNICODE, MIN_UNICODE), encodeKey$1(roomId, MAX_UNICODE, MAX_UNICODE, MAX_UNICODE), true, true);

          this._store.delete(range);
        }
      }, {
        key: "getForTargetAndType",
        value: function () {
          var _getForTargetAndType = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(roomId, targetId, relType) {
            var range, items;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    range = this._store.IDBKeyRange.bound(encodeKey$1(roomId, targetId, relType, MIN_UNICODE), encodeKey$1(roomId, targetId, relType, MAX_UNICODE), true, true);
                    _context.next = 3;
                    return this._store.selectAll(range);

                  case 3:
                    items = _context.sent;
                    return _context.abrupt("return", items.map(function (i) {
                      return decodeKey$1(i.key);
                    }));

                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function getForTargetAndType(_x, _x2, _x3) {
            return _getForTargetAndType.apply(this, arguments);
          }

          return getForTargetAndType;
        }()
      }, {
        key: "getAllForTarget",
        value: function () {
          var _getAllForTarget = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(roomId, targetId) {
            var range, items;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    range = this._store.IDBKeyRange.bound(encodeKey$1(roomId, targetId, MIN_UNICODE, MIN_UNICODE), encodeKey$1(roomId, targetId, MAX_UNICODE, MAX_UNICODE), true, true);
                    _context2.next = 3;
                    return this._store.selectAll(range);

                  case 3:
                    items = _context2.sent;
                    return _context2.abrupt("return", items.map(function (i) {
                      return decodeKey$1(i.key);
                    }));

                  case 5:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function getAllForTarget(_x4, _x5) {
            return _getAllForTarget.apply(this, arguments);
          }

          return getAllForTarget;
        }()
      }]);

      return TimelineRelationStore;
    }();

    function encodeKey$2(roomId, eventType, stateKey) {
      return "".concat(roomId, "|").concat(eventType, "|").concat(stateKey);
    }

    var RoomStateStore = /*#__PURE__*/function () {
      function RoomStateStore(idbStore) {
        _classCallCheck(this, RoomStateStore);

        this._roomStateStore = idbStore;
      }

      _createClass(RoomStateStore, [{
        key: "get",
        value: function get(roomId, type, stateKey) {
          var key = encodeKey$2(roomId, type, stateKey);
          return this._roomStateStore.get(key);
        }
      }, {
        key: "set",
        value: function set(roomId, event) {
          var key = encodeKey$2(roomId, event.type, event.state_key);
          var entry = {
            roomId: roomId,
            event: event,
            key: key
          };

          this._roomStateStore.put(entry);
        }
      }, {
        key: "removeAllForRoom",
        value: function removeAllForRoom(roomId) {
          var range = this._roomStateStore.IDBKeyRange.bound(roomId, "".concat(roomId, "|").concat(MAX_UNICODE), true, true);

          this._roomStateStore.delete(range);
        }
      }]);

      return RoomStateStore;
    }();

    function encodeKey$3(roomId, userId) {
      return "".concat(roomId, "|").concat(userId);
    }

    function decodeKey$2(key) {
      var _key$split = key.split("|"),
          _key$split2 = _slicedToArray(_key$split, 2),
          roomId = _key$split2[0],
          userId = _key$split2[1];

      return {
        roomId: roomId,
        userId: userId
      };
    }

    var RoomMemberStore = /*#__PURE__*/function () {
      function RoomMemberStore(roomMembersStore) {
        _classCallCheck(this, RoomMemberStore);

        this._roomMembersStore = roomMembersStore;
      }

      _createClass(RoomMemberStore, [{
        key: "get",
        value: function get(roomId, userId) {
          return this._roomMembersStore.get(encodeKey$3(roomId, userId));
        }
      }, {
        key: "set",
        value: function set(member) {
          member.key = encodeKey$3(member.roomId, member.userId);

          this._roomMembersStore.put(member);
        }
      }, {
        key: "getAll",
        value: function getAll(roomId) {
          var range = this._roomMembersStore.IDBKeyRange.lowerBound(encodeKey$3(roomId, ""));

          return this._roomMembersStore.selectWhile(range, function (member) {
            return member.roomId === roomId;
          });
        }
      }, {
        key: "getAllUserIds",
        value: function () {
          var _getAllUserIds = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(roomId) {
            var userIds, range;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    userIds = [];
                    range = this._roomMembersStore.IDBKeyRange.lowerBound(encodeKey$3(roomId, ""));
                    _context.next = 4;
                    return this._roomMembersStore.iterateKeys(range, function (key) {
                      var decodedKey = decodeKey$2(key);

                      if (decodedKey.roomId === roomId) {
                        userIds.push(decodedKey.userId);
                        return false;
                      }

                      return true;
                    });

                  case 4:
                    return _context.abrupt("return", userIds);

                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function getAllUserIds(_x) {
            return _getAllUserIds.apply(this, arguments);
          }

          return getAllUserIds;
        }()
      }, {
        key: "removeAllForRoom",
        value: function removeAllForRoom(roomId) {
          var range = this._roomMembersStore.IDBKeyRange.bound(roomId, "".concat(roomId, "|").concat(MAX_UNICODE), true, true);

          this._roomMembersStore.delete(range);
        }
      }]);

      return RoomMemberStore;
    }();

    function encodeKey$4(roomId, fragmentId) {
      return "".concat(roomId, "|").concat(encodeUint32(fragmentId));
    }

    var TimelineFragmentStore = /*#__PURE__*/function () {
      function TimelineFragmentStore(store) {
        _classCallCheck(this, TimelineFragmentStore);

        this._store = store;
      }

      _createClass(TimelineFragmentStore, [{
        key: "_allRange",
        value: function _allRange(roomId) {
          try {
            return this._store.IDBKeyRange.bound(encodeKey$4(roomId, KeyLimits.minStorageKey), encodeKey$4(roomId, KeyLimits.maxStorageKey));
          } catch (err) {
            throw new StorageError("error from IDBKeyRange with roomId ".concat(roomId), err);
          }
        }
      }, {
        key: "all",
        value: function all(roomId) {
          return this._store.selectAll(this._allRange(roomId));
        }
      }, {
        key: "liveFragment",
        value: function liveFragment(roomId) {
          return this._store.findReverse(this._allRange(roomId), function (fragment) {
            return typeof fragment.nextId !== "number" && typeof fragment.nextToken !== "string";
          });
        }
      }, {
        key: "add",
        value: function add(fragment) {
          fragment.key = encodeKey$4(fragment.roomId, fragment.id);

          this._store.add(fragment);
        }
      }, {
        key: "update",
        value: function update(fragment) {
          this._store.put(fragment);
        }
      }, {
        key: "get",
        value: function get(roomId, fragmentId) {
          return this._store.get(encodeKey$4(roomId, fragmentId));
        }
      }, {
        key: "removeAllForRoom",
        value: function removeAllForRoom(roomId) {
          this._store.delete(this._allRange(roomId));
        }
      }]);

      return TimelineFragmentStore;
    }();

    function encodeKey$5(roomId, queueIndex) {
      return "".concat(roomId, "|").concat(encodeUint32(queueIndex));
    }

    function decodeKey$3(key) {
      var _key$split = key.split("|"),
          _key$split2 = _slicedToArray(_key$split, 2),
          roomId = _key$split2[0],
          encodedQueueIndex = _key$split2[1];

      var queueIndex = decodeUint32(encodedQueueIndex);
      return {
        roomId: roomId,
        queueIndex: queueIndex
      };
    }

    var PendingEventStore = /*#__PURE__*/function () {
      function PendingEventStore(eventStore) {
        _classCallCheck(this, PendingEventStore);

        this._eventStore = eventStore;
      }

      _createClass(PendingEventStore, [{
        key: "getMaxQueueIndex",
        value: function () {
          var _getMaxQueueIndex = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(roomId) {
            var range, maxKey;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    range = this._eventStore.IDBKeyRange.bound(encodeKey$5(roomId, KeyLimits.minStorageKey), encodeKey$5(roomId, KeyLimits.maxStorageKey), false, false);
                    _context.next = 3;
                    return this._eventStore.findMaxKey(range);

                  case 3:
                    maxKey = _context.sent;

                    if (!maxKey) {
                      _context.next = 6;
                      break;
                    }

                    return _context.abrupt("return", decodeKey$3(maxKey).queueIndex);

                  case 6:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function getMaxQueueIndex(_x) {
            return _getMaxQueueIndex.apply(this, arguments);
          }

          return getMaxQueueIndex;
        }()
      }, {
        key: "remove",
        value: function remove(roomId, queueIndex) {
          var keyRange = this._eventStore.IDBKeyRange.only(encodeKey$5(roomId, queueIndex));

          this._eventStore.delete(keyRange);
        }
      }, {
        key: "exists",
        value: function () {
          var _exists = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(roomId, queueIndex) {
            var keyRange, key;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    keyRange = this._eventStore.IDBKeyRange.only(encodeKey$5(roomId, queueIndex));
                    _context2.next = 3;
                    return this._eventStore.getKey(keyRange);

                  case 3:
                    key = _context2.sent;
                    return _context2.abrupt("return", !!key);

                  case 5:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function exists(_x2, _x3) {
            return _exists.apply(this, arguments);
          }

          return exists;
        }()
      }, {
        key: "add",
        value: function add(pendingEvent) {
          pendingEvent.key = encodeKey$5(pendingEvent.roomId, pendingEvent.queueIndex);

          this._eventStore.add(pendingEvent);
        }
      }, {
        key: "update",
        value: function update(pendingEvent) {
          this._eventStore.put(pendingEvent);
        }
      }, {
        key: "getAll",
        value: function getAll() {
          return this._eventStore.selectAll();
        }
      }, {
        key: "removeAllForRoom",
        value: function removeAllForRoom(roomId) {
          var minKey = encodeKey$5(roomId, KeyLimits.minStorageKey);
          var maxKey = encodeKey$5(roomId, KeyLimits.maxStorageKey);

          var range = this._eventStore.IDBKeyRange.bound(minKey, maxKey);

          this._eventStore.delete(range);
        }
      }]);

      return PendingEventStore;
    }();

    var UserIdentityStore = /*#__PURE__*/function () {
      function UserIdentityStore(store) {
        _classCallCheck(this, UserIdentityStore);

        this._store = store;
      }

      _createClass(UserIdentityStore, [{
        key: "get",
        value: function get(userId) {
          return this._store.get(userId);
        }
      }, {
        key: "set",
        value: function set(userIdentity) {
          this._store.put(userIdentity);
        }
      }, {
        key: "remove",
        value: function remove(userId) {
          this._store.delete(userId);
        }
      }]);

      return UserIdentityStore;
    }();

    function encodeKey$6(userId, deviceId) {
      return "".concat(userId, "|").concat(deviceId);
    }

    function decodeKey$4(key) {
      var _key$split = key.split("|"),
          _key$split2 = _slicedToArray(_key$split, 2),
          userId = _key$split2[0],
          deviceId = _key$split2[1];

      return {
        userId: userId,
        deviceId: deviceId
      };
    }

    var DeviceIdentityStore = /*#__PURE__*/function () {
      function DeviceIdentityStore(store) {
        _classCallCheck(this, DeviceIdentityStore);

        this._store = store;
      }

      _createClass(DeviceIdentityStore, [{
        key: "getAllForUserId",
        value: function getAllForUserId(userId) {
          var range = this._store.IDBKeyRange.lowerBound(encodeKey$6(userId, ""));

          return this._store.selectWhile(range, function (device) {
            return device.userId === userId;
          });
        }
      }, {
        key: "getAllDeviceIds",
        value: function () {
          var _getAllDeviceIds = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(userId) {
            var deviceIds, range;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    deviceIds = [];
                    range = this._store.IDBKeyRange.lowerBound(encodeKey$6(userId, ""));
                    _context.next = 4;
                    return this._store.iterateKeys(range, function (key) {
                      var decodedKey = decodeKey$4(key);

                      if (decodedKey.userId === userId) {
                        deviceIds.push(decodedKey.deviceId);
                        return false;
                      }

                      return true;
                    });

                  case 4:
                    return _context.abrupt("return", deviceIds);

                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function getAllDeviceIds(_x) {
            return _getAllDeviceIds.apply(this, arguments);
          }

          return getAllDeviceIds;
        }()
      }, {
        key: "get",
        value: function get(userId, deviceId) {
          return this._store.get(encodeKey$6(userId, deviceId));
        }
      }, {
        key: "set",
        value: function set(deviceIdentity) {
          deviceIdentity.key = encodeKey$6(deviceIdentity.userId, deviceIdentity.deviceId);

          this._store.put(deviceIdentity);
        }
      }, {
        key: "getByCurve25519Key",
        value: function getByCurve25519Key(curve25519Key) {
          return this._store.index("byCurve25519Key").get(curve25519Key);
        }
      }, {
        key: "remove",
        value: function remove(userId, deviceId) {
          this._store.delete(encodeKey$6(userId, deviceId));
        }
      }, {
        key: "removeAllForUser",
        value: function removeAllForUser(userId) {
          var range = this._store.IDBKeyRange.bound(encodeKey$6(userId, MIN_UNICODE), encodeKey$6(userId, MAX_UNICODE), true, true);

          this._store.delete(range);
        }
      }]);

      return DeviceIdentityStore;
    }();

    function encodeKey$7(senderKey, sessionId) {
      return "".concat(senderKey, "|").concat(sessionId);
    }

    function decodeKey$5(key) {
      var _key$split = key.split("|"),
          _key$split2 = _slicedToArray(_key$split, 2),
          senderKey = _key$split2[0],
          sessionId = _key$split2[1];

      return {
        senderKey: senderKey,
        sessionId: sessionId
      };
    }

    var OlmSessionStore = /*#__PURE__*/function () {
      function OlmSessionStore(store) {
        _classCallCheck(this, OlmSessionStore);

        this._store = store;
      }

      _createClass(OlmSessionStore, [{
        key: "getSessionIds",
        value: function () {
          var _getSessionIds = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(senderKey) {
            var sessionIds, range;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    sessionIds = [];
                    range = this._store.IDBKeyRange.lowerBound(encodeKey$7(senderKey, ""));
                    _context.next = 4;
                    return this._store.iterateKeys(range, function (key) {
                      var decodedKey = decodeKey$5(key);

                      if (decodedKey.senderKey === senderKey) {
                        sessionIds.push(decodedKey.sessionId);
                        return false;
                      }

                      return true;
                    });

                  case 4:
                    return _context.abrupt("return", sessionIds);

                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function getSessionIds(_x) {
            return _getSessionIds.apply(this, arguments);
          }

          return getSessionIds;
        }()
      }, {
        key: "getAll",
        value: function getAll(senderKey) {
          var range = this._store.IDBKeyRange.lowerBound(encodeKey$7(senderKey, ""));

          return this._store.selectWhile(range, function (session) {
            return session.senderKey === senderKey;
          });
        }
      }, {
        key: "get",
        value: function get(senderKey, sessionId) {
          return this._store.get(encodeKey$7(senderKey, sessionId));
        }
      }, {
        key: "set",
        value: function set(session) {
          session.key = encodeKey$7(session.senderKey, session.sessionId);

          this._store.put(session);
        }
      }, {
        key: "remove",
        value: function remove(senderKey, sessionId) {
          this._store.delete(encodeKey$7(senderKey, sessionId));
        }
      }]);

      return OlmSessionStore;
    }();

    function encodeKey$8(roomId, senderKey, sessionId) {
      return "".concat(roomId, "|").concat(senderKey, "|").concat(sessionId);
    }

    var InboundGroupSessionStore = /*#__PURE__*/function () {
      function InboundGroupSessionStore(store) {
        _classCallCheck(this, InboundGroupSessionStore);

        this._store = store;
      }

      _createClass(InboundGroupSessionStore, [{
        key: "has",
        value: function () {
          var _has = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(roomId, senderKey, sessionId) {
            var key, fetchedKey;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    key = encodeKey$8(roomId, senderKey, sessionId);
                    _context.next = 3;
                    return this._store.getKey(key);

                  case 3:
                    fetchedKey = _context.sent;
                    return _context.abrupt("return", key === fetchedKey);

                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function has(_x, _x2, _x3) {
            return _has.apply(this, arguments);
          }

          return has;
        }()
      }, {
        key: "get",
        value: function get(roomId, senderKey, sessionId) {
          return this._store.get(encodeKey$8(roomId, senderKey, sessionId));
        }
      }, {
        key: "set",
        value: function set(session) {
          var storageEntry = session;
          storageEntry.key = encodeKey$8(session.roomId, session.senderKey, session.sessionId);

          this._store.put(storageEntry);
        }
      }, {
        key: "removeAllForRoom",
        value: function removeAllForRoom(roomId) {
          var range = this._store.IDBKeyRange.bound(encodeKey$8(roomId, MIN_UNICODE, MIN_UNICODE), encodeKey$8(roomId, MAX_UNICODE, MAX_UNICODE));

          this._store.delete(range);
        }
      }]);

      return InboundGroupSessionStore;
    }();

    var OutboundGroupSessionStore = /*#__PURE__*/function () {
      function OutboundGroupSessionStore(store) {
        _classCallCheck(this, OutboundGroupSessionStore);

        this._store = store;
      }

      _createClass(OutboundGroupSessionStore, [{
        key: "remove",
        value: function remove(roomId) {
          this._store.delete(roomId);
        }
      }, {
        key: "get",
        value: function get(roomId) {
          return this._store.get(roomId);
        }
      }, {
        key: "set",
        value: function set(session) {
          this._store.put(session);
        }
      }]);

      return OutboundGroupSessionStore;
    }();

    function encodeKey$9(roomId, sessionId, messageIndex) {
      return "".concat(roomId, "|").concat(sessionId, "|").concat(messageIndex);
    }

    var GroupSessionDecryptionStore = /*#__PURE__*/function () {
      function GroupSessionDecryptionStore(store) {
        _classCallCheck(this, GroupSessionDecryptionStore);

        this._store = store;
      }

      _createClass(GroupSessionDecryptionStore, [{
        key: "get",
        value: function get(roomId, sessionId, messageIndex) {
          return this._store.get(encodeKey$9(roomId, sessionId, messageIndex));
        }
      }, {
        key: "set",
        value: function set(roomId, sessionId, messageIndex, decryption) {
          decryption.key = encodeKey$9(roomId, sessionId, messageIndex);

          this._store.put(decryption);
        }
      }, {
        key: "removeAllForRoom",
        value: function removeAllForRoom(roomId) {
          var range = this._store.IDBKeyRange.bound(encodeKey$9(roomId, MIN_UNICODE, MIN_UNICODE), encodeKey$9(roomId, MAX_UNICODE, MAX_UNICODE));

          this._store.delete(range);
        }
      }]);

      return GroupSessionDecryptionStore;
    }();

    function encodeScopeTypeKey(scope, type) {
      return "".concat(scope, "|").concat(type);
    }
    var OperationStore = /*#__PURE__*/function () {
      function OperationStore(store) {
        _classCallCheck(this, OperationStore);

        this._store = store;
      }

      _createClass(OperationStore, [{
        key: "getAll",
        value: function getAll() {
          return this._store.selectAll();
        }
      }, {
        key: "getAllByTypeAndScope",
        value: function () {
          var _getAllByTypeAndScope = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(type, scope) {
            var key, results;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    key = encodeScopeTypeKey(scope, type);
                    results = [];
                    _context.next = 4;
                    return this._store.index("byScopeAndType").iterateWhile(key, function (value) {
                      if (value.scopeTypeKey !== key) {
                        return false;
                      }

                      results.push(value);
                      return true;
                    });

                  case 4:
                    return _context.abrupt("return", results);

                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function getAllByTypeAndScope(_x, _x2) {
            return _getAllByTypeAndScope.apply(this, arguments);
          }

          return getAllByTypeAndScope;
        }()
      }, {
        key: "add",
        value: function add(operation) {
          operation.scopeTypeKey = encodeScopeTypeKey(operation.scope, operation.type);

          this._store.add(operation);
        }
      }, {
        key: "update",
        value: function update(operation) {
          this._store.put(operation);
        }
      }, {
        key: "remove",
        value: function remove(id) {
          this._store.delete(id);
        }
      }, {
        key: "removeAllForScope",
        value: function () {
          var _removeAllForScope = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(scope) {
            var range, index;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    range = this._store.IDBKeyRange.bound(encodeScopeTypeKey(scope, MIN_UNICODE), encodeScopeTypeKey(scope, MAX_UNICODE));
                    index = this._store.index("byScopeAndType");
                    _context2.next = 4;
                    return index.iterateValues(range, function (_, __, cur) {
                      cur.delete();
                      return true;
                    });

                  case 4:
                    return _context2.abrupt("return");

                  case 5:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function removeAllForScope(_x3) {
            return _removeAllForScope.apply(this, arguments);
          }

          return removeAllForScope;
        }()
      }]);

      return OperationStore;
    }();

    var AccountDataStore = /*#__PURE__*/function () {
      function AccountDataStore(store) {
        _classCallCheck(this, AccountDataStore);

        this._store = store;
      }

      _createClass(AccountDataStore, [{
        key: "get",
        value: function () {
          var _get = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(type) {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this._store.get(type);

                  case 2:
                    return _context.abrupt("return", _context.sent);

                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function get(_x) {
            return _get.apply(this, arguments);
          }

          return get;
        }()
      }, {
        key: "set",
        value: function set(event) {
          this._store.put(event);
        }
      }]);

      return AccountDataStore;
    }();

    var WriteErrorInfo = function WriteErrorInfo(error, refItem, operationName, keys) {
      _classCallCheck(this, WriteErrorInfo);

      this.error = error;
      this.refItem = refItem;
      this.operationName = operationName;
      this.keys = keys;
    };

    var Transaction = /*#__PURE__*/function () {
      function Transaction(txn, allowedStoreNames, storage) {
        _classCallCheck(this, Transaction);

        this._txn = txn;
        this._allowedStoreNames = allowedStoreNames;
        this._stores = {};
        this._storage = storage;
        this._writeErrors = [];
      }

      _createClass(Transaction, [{
        key: "_idbStore",
        value: function _idbStore(name) {
          if (!this._allowedStoreNames.includes(name)) {
            throw new StorageError("Invalid store for transaction: ".concat(name, ", only ").concat(this._allowedStoreNames.join(", "), " are allowed."));
          }

          return new Store(this._txn.objectStore(name), this);
        }
      }, {
        key: "_store",
        value: function _store(name, mapStore) {
          if (!this._stores[name]) {
            var idbStore = this._idbStore(name);

            this._stores[name] = mapStore(idbStore);
          }

          return this._stores[name];
        }
      }, {
        key: "complete",
        value: function () {
          var _complete = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(log) {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.prev = 0;
                    _context.next = 3;
                    return txnAsPromise(this._txn);

                  case 3:
                    _context.next = 11;
                    break;

                  case 5:
                    _context.prev = 5;
                    _context.t0 = _context["catch"](0);

                    if (!this._writeErrors.length) {
                      _context.next = 10;
                      break;
                    }

                    this._logWriteErrors(log);

                    throw this._writeErrors[0].error;

                  case 10:
                    throw _context.t0;

                  case 11:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[0, 5]]);
          }));

          function complete(_x) {
            return _complete.apply(this, arguments);
          }

          return complete;
        }()
      }, {
        key: "getCause",
        value: function getCause(error) {
          if (error instanceof StorageError) {
            if (error.errcode === "AbortError" && this._writeErrors.length) {
              return this._writeErrors[0].error;
            }
          }

          return error;
        }
      }, {
        key: "abort",
        value: function abort(log) {
          try {
            this._txn.abort();
          } catch (abortErr) {
            log === null || log === void 0 ? void 0 : log.set("couldNotAbortTxn", true);
          }

          if (this._writeErrors.length) {
            this._logWriteErrors(log);
          }
        }
      }, {
        key: "addWriteError",
        value: function addWriteError(error, refItem, operationName, keys) {
          if (error.errcode !== "AbortError" || this._writeErrors.length === 0) {
            this._writeErrors.push(new WriteErrorInfo(error, refItem, operationName, keys));
          }
        }
      }, {
        key: "_logWriteErrors",
        value: function _logWriteErrors(parentItem) {
          var _this = this;

          var callback = function callback(errorGroupItem) {
            if (!parentItem) {
              errorGroupItem.set("allowedStoreNames", _this._allowedStoreNames);
            }

            var _iterator = _createForOfIteratorHelper(_this._writeErrors),
                _step;

            try {
              var _loop = function _loop() {
                var info = _step.value;
                errorGroupItem.wrap({
                  l: info.operationName,
                  id: info.keys
                }, function (item) {
                  if (info.refItem) {
                    item.refDetached(info.refItem);
                  }

                  item.catch(info.error);
                });
              };

              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                _loop();
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          };

          var label = "".concat(this._writeErrors.length, " storage write operation(s) failed");

          if (parentItem) {
            parentItem.wrap(label, callback);
          } else {
            this.logger.run(label, callback);
          }
        }
      }, {
        key: "idbFactory",
        get: function get() {
          return this._storage.idbFactory;
        }
      }, {
        key: "IDBKeyRange",
        get: function get() {
          return this._storage.IDBKeyRange;
        }
      }, {
        key: "databaseName",
        get: function get() {
          return this._storage.databaseName;
        }
      }, {
        key: "logger",
        get: function get() {
          return this._storage.logger;
        }
      }, {
        key: "session",
        get: function get() {
          var _this2 = this;

          return this._store(StoreNames.session, function (idbStore) {
            return new SessionStore(idbStore, _this2._storage.localStorage);
          });
        }
      }, {
        key: "roomSummary",
        get: function get() {
          return this._store(StoreNames.roomSummary, function (idbStore) {
            return new RoomSummaryStore(idbStore);
          });
        }
      }, {
        key: "archivedRoomSummary",
        get: function get() {
          return this._store(StoreNames.archivedRoomSummary, function (idbStore) {
            return new RoomSummaryStore(idbStore);
          });
        }
      }, {
        key: "invites",
        get: function get() {
          return this._store(StoreNames.invites, function (idbStore) {
            return new InviteStore(idbStore);
          });
        }
      }, {
        key: "timelineFragments",
        get: function get() {
          return this._store(StoreNames.timelineFragments, function (idbStore) {
            return new TimelineFragmentStore(idbStore);
          });
        }
      }, {
        key: "timelineEvents",
        get: function get() {
          return this._store(StoreNames.timelineEvents, function (idbStore) {
            return new TimelineEventStore(idbStore);
          });
        }
      }, {
        key: "timelineRelations",
        get: function get() {
          return this._store(StoreNames.timelineRelations, function (idbStore) {
            return new TimelineRelationStore(idbStore);
          });
        }
      }, {
        key: "roomState",
        get: function get() {
          return this._store(StoreNames.roomState, function (idbStore) {
            return new RoomStateStore(idbStore);
          });
        }
      }, {
        key: "roomMembers",
        get: function get() {
          return this._store(StoreNames.roomMembers, function (idbStore) {
            return new RoomMemberStore(idbStore);
          });
        }
      }, {
        key: "pendingEvents",
        get: function get() {
          return this._store(StoreNames.pendingEvents, function (idbStore) {
            return new PendingEventStore(idbStore);
          });
        }
      }, {
        key: "userIdentities",
        get: function get() {
          return this._store(StoreNames.userIdentities, function (idbStore) {
            return new UserIdentityStore(idbStore);
          });
        }
      }, {
        key: "deviceIdentities",
        get: function get() {
          return this._store(StoreNames.deviceIdentities, function (idbStore) {
            return new DeviceIdentityStore(idbStore);
          });
        }
      }, {
        key: "olmSessions",
        get: function get() {
          return this._store(StoreNames.olmSessions, function (idbStore) {
            return new OlmSessionStore(idbStore);
          });
        }
      }, {
        key: "inboundGroupSessions",
        get: function get() {
          return this._store(StoreNames.inboundGroupSessions, function (idbStore) {
            return new InboundGroupSessionStore(idbStore);
          });
        }
      }, {
        key: "outboundGroupSessions",
        get: function get() {
          return this._store(StoreNames.outboundGroupSessions, function (idbStore) {
            return new OutboundGroupSessionStore(idbStore);
          });
        }
      }, {
        key: "groupSessionDecryptions",
        get: function get() {
          return this._store(StoreNames.groupSessionDecryptions, function (idbStore) {
            return new GroupSessionDecryptionStore(idbStore);
          });
        }
      }, {
        key: "operations",
        get: function get() {
          return this._store(StoreNames.operations, function (idbStore) {
            return new OperationStore(idbStore);
          });
        }
      }, {
        key: "accountData",
        get: function get() {
          return this._store(StoreNames.accountData, function (idbStore) {
            return new AccountDataStore(idbStore);
          });
        }
      }]);

      return Transaction;
    }();

    var WEBKITEARLYCLOSETXNBUG_BOGUS_KEY = "782rh281re38-boguskey";
    var Storage = /*#__PURE__*/function () {
      function Storage(idbDatabase, idbFactory, _IDBKeyRange, hasWebkitEarlyCloseTxnBug, localStorage, logger) {
        _classCallCheck(this, Storage);

        this._db = idbDatabase;
        this.idbFactory = idbFactory;
        this.IDBKeyRange = _IDBKeyRange;
        this._hasWebkitEarlyCloseTxnBug = hasWebkitEarlyCloseTxnBug;
        this.storeNames = StoreNames;
        this.localStorage = localStorage;
        this.logger = logger;
      }

      _createClass(Storage, [{
        key: "_validateStoreNames",
        value: function _validateStoreNames(storeNames) {
          var idx = storeNames.findIndex(function (name) {
            return !STORE_NAMES.includes(name);
          });

          if (idx !== -1) {
            throw new StorageError("Tried top, a transaction unknown store ".concat(storeNames[idx]));
          }
        }
      }, {
        key: "readTxn",
        value: function () {
          var _readTxn = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(storeNames) {
            var txn;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this._validateStoreNames(storeNames);

                    _context.prev = 1;
                    txn = this._db.transaction(storeNames, "readonly");

                    if (!this._hasWebkitEarlyCloseTxnBug) {
                      _context.next = 6;
                      break;
                    }

                    _context.next = 6;
                    return reqAsPromise(txn.objectStore(storeNames[0]).get(WEBKITEARLYCLOSETXNBUG_BOGUS_KEY));

                  case 6:
                    return _context.abrupt("return", new Transaction(txn, storeNames, this));

                  case 9:
                    _context.prev = 9;
                    _context.t0 = _context["catch"](1);
                    throw new StorageError("readTxn failed", _context.t0);

                  case 12:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[1, 9]]);
          }));

          function readTxn(_x) {
            return _readTxn.apply(this, arguments);
          }

          return readTxn;
        }()
      }, {
        key: "readWriteTxn",
        value: function () {
          var _readWriteTxn = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(storeNames) {
            var txn;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    this._validateStoreNames(storeNames);

                    _context2.prev = 1;
                    txn = this._db.transaction(storeNames, "readwrite");

                    if (!this._hasWebkitEarlyCloseTxnBug) {
                      _context2.next = 6;
                      break;
                    }

                    _context2.next = 6;
                    return reqAsPromise(txn.objectStore(storeNames[0]).get(WEBKITEARLYCLOSETXNBUG_BOGUS_KEY));

                  case 6:
                    return _context2.abrupt("return", new Transaction(txn, storeNames, this));

                  case 9:
                    _context2.prev = 9;
                    _context2.t0 = _context2["catch"](1);
                    throw new StorageError("readWriteTxn failed", _context2.t0);

                  case 12:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[1, 9]]);
          }));

          function readWriteTxn(_x2) {
            return _readWriteTxn.apply(this, arguments);
          }

          return readWriteTxn;
        }()
      }, {
        key: "close",
        value: function close() {
          this._db.close();
        }
      }, {
        key: "databaseName",
        get: function get() {
          return this._db.name;
        }
      }]);

      return Storage;
    }();

    function exportSession(_x) {
      return _exportSession.apply(this, arguments);
    }

    function _exportSession() {
      _exportSession = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(db) {
        var txn, data;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                txn = db.transaction(STORE_NAMES, "readonly");
                data = {};
                _context2.next = 4;
                return Promise.all(STORE_NAMES.map( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(name) {
                    var results, store;
                    return regeneratorRuntime.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            results = data[name] = [];
                            store = txn.objectStore(name);
                            _context.next = 4;
                            return iterateCursor(store.openCursor(), function (value) {
                              results.push(value);
                              return NOT_DONE;
                            });

                          case 4:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function (_x4) {
                    return _ref.apply(this, arguments);
                  };
                }()));

              case 4:
                return _context2.abrupt("return", data);

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      return _exportSession.apply(this, arguments);
    }

    function importSession(_x2, _x3) {
      return _importSession.apply(this, arguments);
    }

    function _importSession() {
      _importSession = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(db, data) {
        var txn, _iterator, _step, name, store, _iterator2, _step2, value;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                txn = db.transaction(STORE_NAMES, "readwrite");
                _iterator = _createForOfIteratorHelper(STORE_NAMES);

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    name = _step.value;
                    store = txn.objectStore(name);
                    _iterator2 = _createForOfIteratorHelper(data[name]);

                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                        value = _step2.value;
                        store.add(value);
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                _context3.next = 5;
                return txnAsPromise(txn);

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      return _importSession.apply(this, arguments);
    }

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function getPrevContentFromStateEvent(event) {
      var _event$unsigned;

      // where to look for prev_content is a bit of a mess,
      // see https://matrix.to/#/!NasysSDfxKxZBzJJoE:matrix.org/$DvrAbZJiILkOmOIuRsNoHmh2v7UO5CWp_rYhlGk34fQ?via=matrix.org&via=pixie.town&via=amorgan.xyz
      return ((_event$unsigned = event.unsigned) === null || _event$unsigned === void 0 ? void 0 : _event$unsigned.prev_content) || event.prev_content;
    }
    var REDACTION_TYPE = "m.room.redaction";
    function isRedacted(event) {
      var _event$unsigned2;

      return !!(event === null || event === void 0 ? void 0 : (_event$unsigned2 = event.unsigned) === null || _event$unsigned2 === void 0 ? void 0 : _event$unsigned2.redacted_because);
    }

    var EVENT_TYPE = "m.room.member";
    var RoomMember = /*#__PURE__*/function () {
      function RoomMember(data) {
        _classCallCheck(this, RoomMember);

        this._data = data;
      }

      _createClass(RoomMember, [{
        key: "serialize",
        value: function serialize() {
          return this._data;
        }
      }, {
        key: "equals",
        value: function equals(other) {
          var data = this._data;
          var otherData = other._data;
          return data.roomId === otherData.roomId && data.userId === otherData.userId && data.membership === otherData.membership && data.displayName === otherData.displayName && data.avatarUrl === otherData.avatarUrl;
        }
      }, {
        key: "membership",
        get: function get() {
          return this._data.membership;
        }
        /**
         * @return {String?} the display name, if any
         */

      }, {
        key: "displayName",
        get: function get() {
          return this._data.displayName;
        }
        /**
         * @return {String} the display name or userId
         */

      }, {
        key: "name",
        get: function get() {
          return this._data.displayName || this._data.userId;
        }
        /**
         * @return {String?} the avatar mxc url, if any
         */

      }, {
        key: "avatarUrl",
        get: function get() {
          return this._data.avatarUrl;
        }
      }, {
        key: "roomId",
        get: function get() {
          return this._data.roomId;
        }
      }, {
        key: "userId",
        get: function get() {
          return this._data.userId;
        }
      }], [{
        key: "fromUserId",
        value: function fromUserId(roomId, userId, membership) {
          return new RoomMember({
            roomId: roomId,
            userId: userId,
            membership: membership
          });
        }
      }, {
        key: "fromMemberEvent",
        value: function fromMemberEvent(roomId, memberEvent) {
          var userId = memberEvent === null || memberEvent === void 0 ? void 0 : memberEvent.state_key;

          if (typeof userId !== "string") {
            return;
          }

          var content = memberEvent.content;
          var prevContent = getPrevContentFromStateEvent(memberEvent);
          var membership = content === null || content === void 0 ? void 0 : content.membership; // fall back to prev_content for these as synapse doesn't (always?)
          // put them on content for "leave" memberships

          var displayName = (content === null || content === void 0 ? void 0 : content.displayname) || (prevContent === null || prevContent === void 0 ? void 0 : prevContent.displayname);
          var avatarUrl = (content === null || content === void 0 ? void 0 : content.avatar_url) || (prevContent === null || prevContent === void 0 ? void 0 : prevContent.avatar_url);
          return this._validateAndCreateMember(roomId, userId, membership, displayName, avatarUrl);
        }
        /**
         * Creates a (historical) member from a member event that is the next member event
         * after the point in time where we need a member for. This will use `prev_content`.
         */

      }, {
        key: "fromReplacingMemberEvent",
        value: function fromReplacingMemberEvent(roomId, memberEvent) {
          var userId = memberEvent && memberEvent.state_key;

          if (typeof userId !== "string") {
            return;
          }

          var content = getPrevContentFromStateEvent(memberEvent);
          return this._validateAndCreateMember(roomId, userId, content === null || content === void 0 ? void 0 : content.membership, content === null || content === void 0 ? void 0 : content.displayname, content === null || content === void 0 ? void 0 : content.avatar_url);
        }
      }, {
        key: "_validateAndCreateMember",
        value: function _validateAndCreateMember(roomId, userId, membership, displayName, avatarUrl) {
          if (typeof membership !== "string") {
            return;
          }

          return new RoomMember({
            roomId: roomId,
            userId: userId,
            membership: membership,
            avatarUrl: avatarUrl,
            displayName: displayName
          });
        }
      }]);

      return RoomMember;
    }();
    var MemberChange = /*#__PURE__*/function () {
      function MemberChange(member, previousMembership) {
        _classCallCheck(this, MemberChange);

        this.member = member;
        this.previousMembership = previousMembership;
      }

      _createClass(MemberChange, [{
        key: "roomId",
        get: function get() {
          return this.member.roomId;
        }
      }, {
        key: "userId",
        get: function get() {
          return this.member.userId;
        }
      }, {
        key: "membership",
        get: function get() {
          return this.member.membership;
        }
      }, {
        key: "hasLeft",
        get: function get() {
          return this.previousMembership === "join" && this.membership !== "join";
        }
        /** The result can be a false negative when all of these apply:
         *  - the complete set of room members hasn't been fetched yet.
         *  - the member event for this change was received in the
         *    state section and wasn't present in the timeline section.
         *  - the room response was limited, e.g. there was a gap.
         * 
         * This is because during sync, in this case it is not possible
         * to distinguish between a new member that joined the room
         * during a gap and a lazy-loading member.
         * */

      }, {
        key: "hasJoined",
        get: function get() {
          return this.previousMembership !== "join" && this.membership === "join";
        }
      }]);

      return MemberChange;
    }();

    var TRACKING_STATUS_OUTDATED = 0;
    var TRACKING_STATUS_UPTODATE = 1;
    function addRoomToIdentity(identity, userId, roomId) {
      if (!identity) {
        identity = {
          userId: userId,
          roomIds: [roomId],
          deviceTrackingStatus: TRACKING_STATUS_OUTDATED
        };
        return identity;
      } else {
        if (!identity.roomIds.includes(roomId)) {
          identity.roomIds.push(roomId);
          return identity;
        }
      }
    } // map 1 device from /keys/query response to DeviceIdentity

    function deviceKeysAsDeviceIdentity(deviceSection) {
      var _deviceSection$unsign;

      var deviceId = deviceSection["device_id"];
      var userId = deviceSection["user_id"];
      return {
        userId: userId,
        deviceId: deviceId,
        ed25519Key: deviceSection.keys["ed25519:".concat(deviceId)],
        curve25519Key: deviceSection.keys["curve25519:".concat(deviceId)],
        algorithms: deviceSection.algorithms,
        displayName: (_deviceSection$unsign = deviceSection.unsigned) === null || _deviceSection$unsign === void 0 ? void 0 : _deviceSection$unsign.device_display_name
      };
    }

    var DeviceTracker = /*#__PURE__*/function () {
      function DeviceTracker(_ref) {
        var storage = _ref.storage,
            getSyncToken = _ref.getSyncToken,
            olmUtil = _ref.olmUtil,
            ownUserId = _ref.ownUserId,
            ownDeviceId = _ref.ownDeviceId;

        _classCallCheck(this, DeviceTracker);

        this._storage = storage;
        this._getSyncToken = getSyncToken;
        this._identityChangedForRoom = null;
        this._olmUtil = olmUtil;
        this._ownUserId = ownUserId;
        this._ownDeviceId = ownDeviceId;
      }

      _createClass(DeviceTracker, [{
        key: "writeDeviceChanges",
        value: function () {
          var _writeDeviceChanges = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(changed, txn, log) {
            var userIdentities;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    userIdentities = txn.userIdentities; // TODO: should we also look at left here to handle this?:
                    // the usual problem here is that you share a room with a user,
                    // go offline, the remote user leaves the room, changes their devices,
                    // then rejoins the room you share (or another room).
                    // At which point you come online, all of this happens in the gap, 
                    // and you don't notice that they ever left, 
                    // and so the client doesn't invalidate their device cache for the user

                    log.set("changed", changed.length);
                    _context2.next = 4;
                    return Promise.all(changed.map( /*#__PURE__*/function () {
                      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(userId) {
                        var user;
                        return regeneratorRuntime.wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                _context.next = 2;
                                return userIdentities.get(userId);

                              case 2:
                                user = _context.sent;

                                if (user) {
                                  log.log({
                                    l: "outdated",
                                    id: userId
                                  });
                                  user.deviceTrackingStatus = TRACKING_STATUS_OUTDATED;
                                  userIdentities.set(user);
                                }

                              case 4:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee);
                      }));

                      return function (_x4) {
                        return _ref2.apply(this, arguments);
                      };
                    }()));

                  case 4:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          function writeDeviceChanges(_x, _x2, _x3) {
            return _writeDeviceChanges.apply(this, arguments);
          }

          return writeDeviceChanges;
        }()
      }, {
        key: "writeMemberChanges",
        value: function writeMemberChanges(room, memberChanges, txn) {
          var _this = this;

          return Promise.all(Array.from(memberChanges.values()).map( /*#__PURE__*/function () {
            var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(memberChange) {
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      return _context3.abrupt("return", _this._applyMemberChange(memberChange, txn));

                    case 1:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3);
            }));

            return function (_x5) {
              return _ref3.apply(this, arguments);
            };
          }()));
        }
      }, {
        key: "trackRoom",
        value: function () {
          var _trackRoom = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(room, log) {
            var memberList, txn, isTrackingChanges, members;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!(room.isTrackingMembers || !room.isEncrypted)) {
                      _context4.next = 2;
                      break;
                    }

                    return _context4.abrupt("return");

                  case 2:
                    _context4.next = 4;
                    return room.loadMemberList(log);

                  case 4:
                    memberList = _context4.sent;
                    _context4.prev = 5;
                    _context4.next = 8;
                    return this._storage.readWriteTxn([this._storage.storeNames.roomSummary, this._storage.storeNames.userIdentities]);

                  case 8:
                    txn = _context4.sent;
                    _context4.prev = 9;
                    isTrackingChanges = room.writeIsTrackingMembers(true, txn);
                    members = Array.from(memberList.members.values());
                    log.set("members", members.length);
                    _context4.next = 15;
                    return this._writeJoinedMembers(members, txn);

                  case 15:
                    _context4.next = 21;
                    break;

                  case 17:
                    _context4.prev = 17;
                    _context4.t0 = _context4["catch"](9);
                    txn.abort();
                    throw _context4.t0;

                  case 21:
                    _context4.next = 23;
                    return txn.complete();

                  case 23:
                    room.applyIsTrackingMembersChanges(isTrackingChanges);

                  case 24:
                    _context4.prev = 24;
                    memberList.release();
                    return _context4.finish(24);

                  case 27:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this, [[5,, 24, 27], [9, 17]]);
          }));

          function trackRoom(_x6, _x7) {
            return _trackRoom.apply(this, arguments);
          }

          return trackRoom;
        }()
      }, {
        key: "_writeJoinedMembers",
        value: function () {
          var _writeJoinedMembers2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(members, txn) {
            var _this2 = this;

            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    _context6.next = 2;
                    return Promise.all(members.map( /*#__PURE__*/function () {
                      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(member) {
                        return regeneratorRuntime.wrap(function _callee5$(_context5) {
                          while (1) {
                            switch (_context5.prev = _context5.next) {
                              case 0:
                                if (!(member.membership === "join")) {
                                  _context5.next = 3;
                                  break;
                                }

                                _context5.next = 3;
                                return _this2._writeMember(member, txn);

                              case 3:
                              case "end":
                                return _context5.stop();
                            }
                          }
                        }, _callee5);
                      }));

                      return function (_x10) {
                        return _ref4.apply(this, arguments);
                      };
                    }()));

                  case 2:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6);
          }));

          function _writeJoinedMembers(_x8, _x9) {
            return _writeJoinedMembers2.apply(this, arguments);
          }

          return _writeJoinedMembers;
        }()
      }, {
        key: "_writeMember",
        value: function () {
          var _writeMember2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(member, txn) {
            var userIdentities, identity, updatedIdentity;
            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    userIdentities = txn.userIdentities;
                    _context7.next = 3;
                    return userIdentities.get(member.userId);

                  case 3:
                    identity = _context7.sent;
                    updatedIdentity = addRoomToIdentity(identity, member.userId, member.roomId);

                    if (updatedIdentity) {
                      userIdentities.set(updatedIdentity);
                    }

                  case 6:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7);
          }));

          function _writeMember(_x11, _x12) {
            return _writeMember2.apply(this, arguments);
          }

          return _writeMember;
        }()
      }, {
        key: "_removeRoomFromUserIdentity",
        value: function () {
          var _removeRoomFromUserIdentity2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(roomId, userId, txn) {
            var userIdentities, deviceIdentities, identity;
            return regeneratorRuntime.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    userIdentities = txn.userIdentities, deviceIdentities = txn.deviceIdentities;
                    _context8.next = 3;
                    return userIdentities.get(userId);

                  case 3:
                    identity = _context8.sent;

                    if (identity) {
                      identity.roomIds = identity.roomIds.filter(function (id) {
                        return id !== roomId;
                      }); // no more encrypted rooms with this user, remove

                      if (identity.roomIds.length === 0) {
                        userIdentities.remove(userId);
                        deviceIdentities.removeAllForUser(userId);
                      } else {
                        userIdentities.set(identity);
                      }
                    }

                  case 5:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8);
          }));

          function _removeRoomFromUserIdentity(_x13, _x14, _x15) {
            return _removeRoomFromUserIdentity2.apply(this, arguments);
          }

          return _removeRoomFromUserIdentity;
        }()
      }, {
        key: "_applyMemberChange",
        value: function () {
          var _applyMemberChange2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(memberChange, txn) {
            var _this3 = this;

            var roomId, userIds;
            return regeneratorRuntime.wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    if (!memberChange.hasJoined) {
                      _context9.next = 5;
                      break;
                    }

                    _context9.next = 3;
                    return this._writeMember(memberChange.member, txn);

                  case 3:
                    _context9.next = 17;
                    break;

                  case 5:
                    if (!memberChange.hasLeft) {
                      _context9.next = 17;
                      break;
                    }

                    roomId = memberChange.roomId; // if we left the room, remove room from all user identities in the room

                    if (!(memberChange.userId === this._ownUserId)) {
                      _context9.next = 15;
                      break;
                    }

                    _context9.next = 10;
                    return txn.roomMembers.getAllUserIds(roomId);

                  case 10:
                    userIds = _context9.sent;
                    _context9.next = 13;
                    return Promise.all(userIds.map(function (userId) {
                      return _this3._removeRoomFromUserIdentity(roomId, userId, txn);
                    }));

                  case 13:
                    _context9.next = 17;
                    break;

                  case 15:
                    _context9.next = 17;
                    return this._removeRoomFromUserIdentity(roomId, memberChange.userId, txn);

                  case 17:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this);
          }));

          function _applyMemberChange(_x16, _x17) {
            return _applyMemberChange2.apply(this, arguments);
          }

          return _applyMemberChange;
        }()
      }, {
        key: "_queryKeys",
        value: function () {
          var _queryKeys2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(userIds, hsApi, log) {
            var _this4 = this;

            var deviceKeyResponse, verifiedKeysPerUser, txn, deviceIdentities, devicesIdentitiesPerUser;
            return regeneratorRuntime.wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    _context11.next = 2;
                    return hsApi.queryKeys({
                      "timeout": 10000,
                      "device_keys": userIds.reduce(function (deviceKeysMap, userId) {
                        deviceKeysMap[userId] = [];
                        return deviceKeysMap;
                      }, {}),
                      "token": this._getSyncToken()
                    }, {
                      log: log
                    }).response();

                  case 2:
                    deviceKeyResponse = _context11.sent;
                    verifiedKeysPerUser = log.wrap("verify", function (log) {
                      return _this4._filterVerifiedDeviceKeys(deviceKeyResponse["device_keys"], log);
                    });
                    _context11.next = 6;
                    return this._storage.readWriteTxn([this._storage.storeNames.userIdentities, this._storage.storeNames.deviceIdentities]);

                  case 6:
                    txn = _context11.sent;
                    _context11.prev = 7;
                    _context11.next = 10;
                    return Promise.all(verifiedKeysPerUser.map( /*#__PURE__*/function () {
                      var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(_ref5) {
                        var userId, verifiedKeys, deviceIdentities;
                        return regeneratorRuntime.wrap(function _callee10$(_context10) {
                          while (1) {
                            switch (_context10.prev = _context10.next) {
                              case 0:
                                userId = _ref5.userId, verifiedKeys = _ref5.verifiedKeys;
                                deviceIdentities = verifiedKeys.map(deviceKeysAsDeviceIdentity);
                                _context10.next = 4;
                                return _this4._storeQueriedDevicesForUserId(userId, deviceIdentities, txn);

                              case 4:
                                return _context10.abrupt("return", _context10.sent);

                              case 5:
                              case "end":
                                return _context10.stop();
                            }
                          }
                        }, _callee10);
                      }));

                      return function (_x21) {
                        return _ref6.apply(this, arguments);
                      };
                    }()));

                  case 10:
                    devicesIdentitiesPerUser = _context11.sent;
                    deviceIdentities = devicesIdentitiesPerUser.reduce(function (all, devices) {
                      return all.concat(devices);
                    }, []);
                    log.set("devices", deviceIdentities.length);
                    _context11.next = 19;
                    break;

                  case 15:
                    _context11.prev = 15;
                    _context11.t0 = _context11["catch"](7);
                    txn.abort();
                    throw _context11.t0;

                  case 19:
                    _context11.next = 21;
                    return txn.complete();

                  case 21:
                    return _context11.abrupt("return", deviceIdentities);

                  case 22:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this, [[7, 15]]);
          }));

          function _queryKeys(_x18, _x19, _x20) {
            return _queryKeys2.apply(this, arguments);
          }

          return _queryKeys;
        }()
      }, {
        key: "_storeQueriedDevicesForUserId",
        value: function () {
          var _storeQueriedDevicesForUserId2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(userId, deviceIdentities, txn) {
            var knownDeviceIds, _iterator, _step, _loop, allDeviceIdentities, deviceIdentitiesToStore, _i, _deviceIdentitiesToSt, deviceIdentity, identity;

            return regeneratorRuntime.wrap(function _callee13$(_context13) {
              while (1) {
                switch (_context13.prev = _context13.next) {
                  case 0:
                    _context13.next = 2;
                    return txn.deviceIdentities.getAllDeviceIds(userId);

                  case 2:
                    knownDeviceIds = _context13.sent;
                    // delete any devices that we know off but are not in the response anymore.
                    // important this happens before checking if the ed25519 key changed,
                    // otherwise we would end up deleting existing devices with changed keys.
                    _iterator = _createForOfIteratorHelper(knownDeviceIds);

                    try {
                      _loop = function _loop() {
                        var deviceId = _step.value;

                        if (deviceIdentities.every(function (di) {
                          return di.deviceId !== deviceId;
                        })) {
                          txn.deviceIdentities.remove(userId, deviceId);
                        }
                      };

                      for (_iterator.s(); !(_step = _iterator.n()).done;) {
                        _loop();
                      } // all the device identities as we will have them in storage

                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }

                    allDeviceIdentities = [];
                    deviceIdentitiesToStore = []; // filter out devices that have changed their ed25519 key since last time we queried them

                    _context13.next = 9;
                    return Promise.all(deviceIdentities.map( /*#__PURE__*/function () {
                      var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(deviceIdentity) {
                        var existingDevice;
                        return regeneratorRuntime.wrap(function _callee12$(_context12) {
                          while (1) {
                            switch (_context12.prev = _context12.next) {
                              case 0:
                                if (!knownDeviceIds.includes(deviceIdentity.deviceId)) {
                                  _context12.next = 5;
                                  break;
                                }

                                _context12.next = 3;
                                return txn.deviceIdentities.get(deviceIdentity.userId, deviceIdentity.deviceId);

                              case 3:
                                existingDevice = _context12.sent;

                                if (existingDevice.ed25519Key !== deviceIdentity.ed25519Key) {
                                  allDeviceIdentities.push(existingDevice);
                                }

                              case 5:
                                allDeviceIdentities.push(deviceIdentity);
                                deviceIdentitiesToStore.push(deviceIdentity);

                              case 7:
                              case "end":
                                return _context12.stop();
                            }
                          }
                        }, _callee12);
                      }));

                      return function (_x25) {
                        return _ref7.apply(this, arguments);
                      };
                    }()));

                  case 9:
                    deviceIdentities = _context13.sent;

                    // store devices
                    for (_i = 0, _deviceIdentitiesToSt = deviceIdentitiesToStore; _i < _deviceIdentitiesToSt.length; _i++) {
                      deviceIdentity = _deviceIdentitiesToSt[_i];
                      txn.deviceIdentities.set(deviceIdentity);
                    } // mark user identities as up to date


                    _context13.next = 13;
                    return txn.userIdentities.get(userId);

                  case 13:
                    identity = _context13.sent;
                    identity.deviceTrackingStatus = TRACKING_STATUS_UPTODATE;
                    txn.userIdentities.set(identity);
                    return _context13.abrupt("return", allDeviceIdentities);

                  case 17:
                  case "end":
                    return _context13.stop();
                }
              }
            }, _callee13);
          }));

          function _storeQueriedDevicesForUserId(_x22, _x23, _x24) {
            return _storeQueriedDevicesForUserId2.apply(this, arguments);
          }

          return _storeQueriedDevicesForUserId;
        }()
        /**
         * @return {Array<{userId, verifiedKeys: Array<DeviceSection>>}
         */

      }, {
        key: "_filterVerifiedDeviceKeys",
        value: function _filterVerifiedDeviceKeys(keyQueryDeviceKeysResponse, parentLog) {
          var _this5 = this;

          var curve25519Keys = new Set();
          var verifiedKeys = Object.entries(keyQueryDeviceKeysResponse).map(function (_ref8) {
            var _ref9 = _slicedToArray(_ref8, 2),
                userId = _ref9[0],
                keysByDevice = _ref9[1];

            var verifiedEntries = Object.entries(keysByDevice).filter(function (_ref10) {
              var _deviceKeys$keys, _deviceKeys$keys2;

              var _ref11 = _slicedToArray(_ref10, 2),
                  deviceId = _ref11[0],
                  deviceKeys = _ref11[1];

              var deviceIdOnKeys = deviceKeys["device_id"];
              var userIdOnKeys = deviceKeys["user_id"];

              if (userIdOnKeys !== userId) {
                return false;
              }

              if (deviceIdOnKeys !== deviceId) {
                return false;
              }

              var ed25519Key = (_deviceKeys$keys = deviceKeys.keys) === null || _deviceKeys$keys === void 0 ? void 0 : _deviceKeys$keys["ed25519:".concat(deviceId)];
              var curve25519Key = (_deviceKeys$keys2 = deviceKeys.keys) === null || _deviceKeys$keys2 === void 0 ? void 0 : _deviceKeys$keys2["curve25519:".concat(deviceId)];

              if (typeof ed25519Key !== "string" || typeof curve25519Key !== "string") {
                return false;
              }

              if (curve25519Keys.has(curve25519Key)) {
                parentLog.log({
                  l: "ignore device with duplicate curve25519 key",
                  keys: deviceKeys
                }, parentLog.level.Warn);
                return false;
              }

              curve25519Keys.add(curve25519Key);

              var isValid = _this5._hasValidSignature(deviceKeys);

              if (!isValid) {
                parentLog.log({
                  l: "ignore device with invalid signature",
                  keys: deviceKeys
                }, parentLog.level.Warn);
              }

              return isValid;
            });
            var verifiedKeys = verifiedEntries.map(function (_ref12) {
              var _ref13 = _slicedToArray(_ref12, 2),
                  deviceKeys = _ref13[1];

              return deviceKeys;
            });
            return {
              userId: userId,
              verifiedKeys: verifiedKeys
            };
          });
          return verifiedKeys;
        }
      }, {
        key: "_hasValidSignature",
        value: function _hasValidSignature(deviceSection) {
          var _deviceSection$keys;

          var deviceId = deviceSection["device_id"];
          var userId = deviceSection["user_id"];
          var ed25519Key = deviceSection === null || deviceSection === void 0 ? void 0 : (_deviceSection$keys = deviceSection.keys) === null || _deviceSection$keys === void 0 ? void 0 : _deviceSection$keys["".concat(SIGNATURE_ALGORITHM, ":").concat(deviceId)];
          return verifyEd25519Signature(this._olmUtil, userId, deviceId, ed25519Key, deviceSection);
        }
        /**
         * Gives all the device identities for a room that is already tracked.
         * Assumes room is already tracked. Call `trackRoom` first if unsure.
         * @param  {String} roomId [description]
         * @return {[type]}        [description]
         */

      }, {
        key: "devicesForTrackedRoom",
        value: function () {
          var _devicesForTrackedRoom = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(roomId, hsApi, log) {
            var txn, userIds;
            return regeneratorRuntime.wrap(function _callee14$(_context14) {
              while (1) {
                switch (_context14.prev = _context14.next) {
                  case 0:
                    _context14.next = 2;
                    return this._storage.readTxn([this._storage.storeNames.roomMembers, this._storage.storeNames.userIdentities]);

                  case 2:
                    txn = _context14.sent;
                    _context14.next = 5;
                    return txn.roomMembers.getAllUserIds(roomId);

                  case 5:
                    userIds = _context14.sent;
                    _context14.next = 8;
                    return this._devicesForUserIds(roomId, userIds, txn, hsApi, log);

                  case 8:
                    return _context14.abrupt("return", _context14.sent);

                  case 9:
                  case "end":
                    return _context14.stop();
                }
              }
            }, _callee14, this);
          }));

          function devicesForTrackedRoom(_x26, _x27, _x28) {
            return _devicesForTrackedRoom.apply(this, arguments);
          }

          return devicesForTrackedRoom;
        }()
      }, {
        key: "devicesForRoomMembers",
        value: function () {
          var _devicesForRoomMembers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(roomId, userIds, hsApi, log) {
            var txn;
            return regeneratorRuntime.wrap(function _callee15$(_context15) {
              while (1) {
                switch (_context15.prev = _context15.next) {
                  case 0:
                    _context15.next = 2;
                    return this._storage.readTxn([this._storage.storeNames.userIdentities]);

                  case 2:
                    txn = _context15.sent;
                    _context15.next = 5;
                    return this._devicesForUserIds(roomId, userIds, txn, hsApi, log);

                  case 5:
                    return _context15.abrupt("return", _context15.sent);

                  case 6:
                  case "end":
                    return _context15.stop();
                }
              }
            }, _callee15, this);
          }));

          function devicesForRoomMembers(_x29, _x30, _x31, _x32) {
            return _devicesForRoomMembers.apply(this, arguments);
          }

          return devicesForRoomMembers;
        }()
        /**
         * @param  {string} roomId  [description]
         * @param  {Array<string>} userIds a set of user ids to try and find the identity for. Will be check to belong to roomId.
         * @param  {Transaction} userIdentityTxn to read the user identities
         * @param  {HomeServerApi} hsApi
         * @return {Array<DeviceIdentity>}
         */

      }, {
        key: "_devicesForUserIds",
        value: function () {
          var _devicesForUserIds2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(roomId, userIds, userIdentityTxn, hsApi, log) {
            var _this6 = this;

            var allMemberIdentities, identities, upToDateIdentities, outdatedIdentities, queriedDevices, deviceTxn, devicesPerUser, flattenedDevices, devices;
            return regeneratorRuntime.wrap(function _callee16$(_context16) {
              while (1) {
                switch (_context16.prev = _context16.next) {
                  case 0:
                    _context16.next = 2;
                    return Promise.all(userIds.map(function (userId) {
                      return userIdentityTxn.userIdentities.get(userId);
                    }));

                  case 2:
                    allMemberIdentities = _context16.sent;
                    identities = allMemberIdentities.filter(function (identity) {
                      // identity will be missing for any userIds that don't have 
                      // membership join in any of your encrypted rooms
                      return identity && identity.roomIds.includes(roomId);
                    });
                    upToDateIdentities = identities.filter(function (i) {
                      return i.deviceTrackingStatus === TRACKING_STATUS_UPTODATE;
                    });
                    outdatedIdentities = identities.filter(function (i) {
                      return i.deviceTrackingStatus === TRACKING_STATUS_OUTDATED;
                    });
                    log.set("uptodate", upToDateIdentities.length);
                    log.set("outdated", outdatedIdentities.length);

                    if (!outdatedIdentities.length) {
                      _context16.next = 12;
                      break;
                    }

                    _context16.next = 11;
                    return this._queryKeys(outdatedIdentities.map(function (i) {
                      return i.userId;
                    }), hsApi, log);

                  case 11:
                    queriedDevices = _context16.sent;

                  case 12:
                    _context16.next = 14;
                    return this._storage.readTxn([this._storage.storeNames.deviceIdentities]);

                  case 14:
                    deviceTxn = _context16.sent;
                    _context16.next = 17;
                    return Promise.all(upToDateIdentities.map(function (identity) {
                      return deviceTxn.deviceIdentities.getAllForUserId(identity.userId);
                    }));

                  case 17:
                    devicesPerUser = _context16.sent;
                    flattenedDevices = devicesPerUser.reduce(function (all, devicesForUser) {
                      return all.concat(devicesForUser);
                    }, []);

                    if (queriedDevices && queriedDevices.length) {
                      flattenedDevices = flattenedDevices.concat(queriedDevices);
                    } // filter out our own device


                    devices = flattenedDevices.filter(function (device) {
                      var isOwnDevice = device.userId === _this6._ownUserId && device.deviceId === _this6._ownDeviceId;
                      return !isOwnDevice;
                    });
                    return _context16.abrupt("return", devices);

                  case 22:
                  case "end":
                    return _context16.stop();
                }
              }
            }, _callee16, this);
          }));

          function _devicesForUserIds(_x33, _x34, _x35, _x36, _x37) {
            return _devicesForUserIds2.apply(this, arguments);
          }

          return _devicesForUserIds;
        }()
      }, {
        key: "getDeviceByCurve25519Key",
        value: function () {
          var _getDeviceByCurve25519Key = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(curve25519Key, txn) {
            return regeneratorRuntime.wrap(function _callee17$(_context17) {
              while (1) {
                switch (_context17.prev = _context17.next) {
                  case 0:
                    _context17.next = 2;
                    return txn.deviceIdentities.getByCurve25519Key(curve25519Key);

                  case 2:
                    return _context17.abrupt("return", _context17.sent);

                  case 3:
                  case "end":
                    return _context17.stop();
                }
              }
            }, _callee17);
          }));

          function getDeviceByCurve25519Key(_x38, _x39) {
            return _getDeviceByCurve25519Key.apply(this, arguments);
          }

          return getDeviceByCurve25519Key;
        }()
      }]);

      return DeviceTracker;
    }();

    var schema = [createInitialStores, createMemberStore, migrateSession, createE2EEStores, migrateEncryptionFlag, createAccountDataStore, createInviteStore, createArchivedRoomSummaryStore, migrateOperationScopeIndex, createTimelineRelationsStore, fixMissingRoomsInUserIdentities, changeSSSSKeyPrefix, backupAndRestoreE2EEAccountToLocalStorage, clearAllStores];

    function createInitialStores(db) {
      db.createObjectStore("session", {
        keyPath: "key"
      });
      db.createObjectStore("roomSummary", {
        keyPath: "roomId"
      });
      db.createObjectStore("timelineFragments", {
        keyPath: "key"
      });
      var timelineEvents = db.createObjectStore("timelineEvents", {
        keyPath: "key"
      });
      timelineEvents.createIndex("byEventId", "eventIdKey", {
        unique: true
      });
      db.createObjectStore("roomState", {
        keyPath: "key"
      });
      db.createObjectStore("pendingEvents", {
        keyPath: "key"
      });
    }

    function createMemberStore(_x, _x2) {
      return _createMemberStore.apply(this, arguments);
    }

    function _createMemberStore() {
      _createMemberStore = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(db, txn) {
        var roomMembers, roomState;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                roomMembers = new RoomMemberStore(db.createObjectStore("roomMembers", {
                  keyPath: "key"
                }));
                roomState = txn.objectStore("roomState");
                _context.next = 4;
                return iterateCursor(roomState.openCursor(), function (entry) {
                  if (entry.event.type === EVENT_TYPE) {
                    roomState.delete(entry.key);
                    var member = RoomMember.fromMemberEvent(entry.roomId, entry.event);

                    if (member) {
                      roomMembers.set(member.serialize());
                    }
                  }

                  return NOT_DONE;
                });

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return _createMemberStore.apply(this, arguments);
    }

    function migrateSession(_x3, _x4, _x5) {
      return _migrateSession.apply(this, arguments);
    }

    function _migrateSession() {
      _migrateSession = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(db, txn, localStorage) {
        var session, PRE_MIGRATION_KEY, entry, _entry$value, syncToken, syncFilterId, serverVersions, store;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                session = txn.objectStore("session");
                _context2.prev = 1;
                PRE_MIGRATION_KEY = 1;
                _context2.next = 5;
                return reqAsPromise(session.get(PRE_MIGRATION_KEY));

              case 5:
                entry = _context2.sent;

                if (entry) {
                  session.delete(PRE_MIGRATION_KEY);
                  _entry$value = entry.value, syncToken = _entry$value.syncToken, syncFilterId = _entry$value.syncFilterId, serverVersions = _entry$value.serverVersions;
                  store = new SessionStore(session, localStorage);
                  store.set("sync", {
                    token: syncToken,
                    filterId: syncFilterId
                  });
                  store.set("serverVersions", serverVersions);
                }

                _context2.next = 13;
                break;

              case 9:
                _context2.prev = 9;
                _context2.t0 = _context2["catch"](1);
                txn.abort();
                console.error("could not migrate session", _context2.t0.stack);

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[1, 9]]);
      }));
      return _migrateSession.apply(this, arguments);
    }

    function createE2EEStores(db) {
      db.createObjectStore("userIdentities", {
        keyPath: "userId"
      });
      var deviceIdentities = db.createObjectStore("deviceIdentities", {
        keyPath: "key"
      });
      deviceIdentities.createIndex("byCurve25519Key", "curve25519Key", {
        unique: true
      });
      db.createObjectStore("olmSessions", {
        keyPath: "key"
      });
      db.createObjectStore("inboundGroupSessions", {
        keyPath: "key"
      });
      db.createObjectStore("outboundGroupSessions", {
        keyPath: "roomId"
      });
      db.createObjectStore("groupSessionDecryptions", {
        keyPath: "key"
      });
      var operations = db.createObjectStore("operations", {
        keyPath: "id"
      });
      operations.createIndex("byTypeAndScope", "typeScopeKey", {
        unique: false
      });
    }

    function migrateEncryptionFlag(_x6, _x7) {
      return _migrateEncryptionFlag.apply(this, arguments);
    }

    function _migrateEncryptionFlag() {
      _migrateEncryptionFlag = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(db, txn) {
        var roomSummary, roomState, summaries, _i, _summaries, summary, encryptionEntry, _encryptionEntry$even;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                roomSummary = txn.objectStore("roomSummary");
                roomState = txn.objectStore("roomState");
                summaries = [];
                _context3.next = 5;
                return iterateCursor(roomSummary.openCursor(), function (summary) {
                  summaries.push(summary);
                  return NOT_DONE;
                });

              case 5:
                _i = 0, _summaries = summaries;

              case 6:
                if (!(_i < _summaries.length)) {
                  _context3.next = 15;
                  break;
                }

                summary = _summaries[_i];
                _context3.next = 10;
                return reqAsPromise(roomState.get("".concat(summary.roomId, "|m.room.encryption|")));

              case 10:
                encryptionEntry = _context3.sent;

                if (encryptionEntry) {
                  summary.encryption = encryptionEntry === null || encryptionEntry === void 0 ? void 0 : (_encryptionEntry$even = encryptionEntry.event) === null || _encryptionEntry$even === void 0 ? void 0 : _encryptionEntry$even.content;
                  delete summary.isEncrypted;
                  roomSummary.put(summary);
                }

              case 12:
                _i++;
                _context3.next = 6;
                break;

              case 15:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      return _migrateEncryptionFlag.apply(this, arguments);
    }

    function createAccountDataStore(db) {
      db.createObjectStore("accountData", {
        keyPath: "type"
      });
    }

    function createInviteStore(db) {
      db.createObjectStore("invites", {
        keyPath: "roomId"
      });
    }

    function createArchivedRoomSummaryStore(db) {
      db.createObjectStore("archivedRoomSummary", {
        keyPath: "summary.roomId"
      });
    }

    function migrateOperationScopeIndex(_x8, _x9) {
      return _migrateOperationScopeIndex.apply(this, arguments);
    }

    function _migrateOperationScopeIndex() {
      _migrateOperationScopeIndex = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(db, txn) {
        var operations;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.prev = 0;
                operations = txn.objectStore("operations");
                operations.deleteIndex("byTypeAndScope");
                _context4.next = 5;
                return iterateCursor(operations.openCursor(), function (op, key, cur) {
                  var typeScopeKey = op.typeScopeKey;
                  delete op.typeScopeKey;

                  var _typeScopeKey$split = typeScopeKey.split("|"),
                      _typeScopeKey$split2 = _slicedToArray(_typeScopeKey$split, 2),
                      type = _typeScopeKey$split2[0],
                      scope = _typeScopeKey$split2[1];

                  op.scopeTypeKey = encodeScopeTypeKey(scope, type);
                  cur.update(op);
                  return NOT_DONE;
                });

              case 5:
                operations.createIndex("byScopeAndType", "scopeTypeKey", {
                  unique: false
                });
                _context4.next = 12;
                break;

              case 8:
                _context4.prev = 8;
                _context4.t0 = _context4["catch"](0);
                txn.abort();
                console.error("could not migrate operations", _context4.t0.stack);

              case 12:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, null, [[0, 8]]);
      }));
      return _migrateOperationScopeIndex.apply(this, arguments);
    }

    function createTimelineRelationsStore(db) {
      db.createObjectStore("timelineRelations", {
        keyPath: "key"
      });
    }

    function fixMissingRoomsInUserIdentities(_x10, _x11, _x12, _x13) {
      return _fixMissingRoomsInUserIdentities.apply(this, arguments);
    }

    function _fixMissingRoomsInUserIdentities() {
      _fixMissingRoomsInUserIdentities = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(db, txn, localStorage, log) {
        var roomSummaryStore, trackedRoomIds, outboundGroupSessionsStore, userIdentitiesStore, roomMemberStore, _loop, _i2, _trackedRoomIds;

        return regeneratorRuntime.wrap(function _callee6$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                roomSummaryStore = txn.objectStore("roomSummary");
                trackedRoomIds = [];
                _context7.next = 4;
                return iterateCursor(roomSummaryStore.openCursor(), function (roomSummary) {
                  if (roomSummary.isTrackingMembers) {
                    trackedRoomIds.push(roomSummary.roomId);
                  }

                  return NOT_DONE;
                });

              case 4:
                outboundGroupSessionsStore = txn.objectStore("outboundGroupSessions");
                userIdentitiesStore = txn.objectStore("userIdentities");
                roomMemberStore = txn.objectStore("roomMembers");
                _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop() {
                  var roomId, foundMissing, joinedUserIds, memberRange;
                  return regeneratorRuntime.wrap(function _loop$(_context6) {
                    while (1) {
                      switch (_context6.prev = _context6.next) {
                        case 0:
                          roomId = _trackedRoomIds[_i2];
                          foundMissing = false;
                          joinedUserIds = [];
                          memberRange = IDBKeyRange.bound(roomId, "".concat(roomId, "|").concat(MAX_UNICODE), true, true);
                          _context6.next = 6;
                          return log.wrap({
                            l: "room",
                            id: roomId
                          }, /*#__PURE__*/function () {
                            var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(log2) {
                              var _iterator, _step, _identity$roomIds, userId, identity, originalRoomCount, updatedIdentity;

                              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                                while (1) {
                                  switch (_context5.prev = _context5.next) {
                                    case 0:
                                      _context5.next = 2;
                                      return iterateCursor(roomMemberStore.openCursor(memberRange), function (member) {
                                        if (member.membership === "join") {
                                          joinedUserIds.push(member.userId);
                                        }

                                        return NOT_DONE;
                                      });

                                    case 2:
                                      log2.set("joinedUserIds", joinedUserIds.length);
                                      _iterator = _createForOfIteratorHelper(joinedUserIds);
                                      _context5.prev = 4;

                                      _iterator.s();

                                    case 6:
                                      if ((_step = _iterator.n()).done) {
                                        _context5.next = 16;
                                        break;
                                      }

                                      userId = _step.value;
                                      _context5.next = 10;
                                      return reqAsPromise(userIdentitiesStore.get(userId));

                                    case 10:
                                      identity = _context5.sent;
                                      originalRoomCount = identity === null || identity === void 0 ? void 0 : (_identity$roomIds = identity.roomIds) === null || _identity$roomIds === void 0 ? void 0 : _identity$roomIds.length;
                                      updatedIdentity = addRoomToIdentity(identity, userId, roomId);

                                      if (updatedIdentity) {
                                        log2.log({
                                          l: "fixing up",
                                          id: userId,
                                          roomsBefore: originalRoomCount,
                                          roomsAfter: updatedIdentity.roomIds.length
                                        });
                                        userIdentitiesStore.put(updatedIdentity);
                                        foundMissing = true;
                                      }

                                    case 14:
                                      _context5.next = 6;
                                      break;

                                    case 16:
                                      _context5.next = 21;
                                      break;

                                    case 18:
                                      _context5.prev = 18;
                                      _context5.t0 = _context5["catch"](4);

                                      _iterator.e(_context5.t0);

                                    case 21:
                                      _context5.prev = 21;

                                      _iterator.f();

                                      return _context5.finish(21);

                                    case 24:
                                      log2.set("foundMissing", foundMissing);

                                      if (foundMissing) {
                                        outboundGroupSessionsStore.delete(roomId);
                                      }

                                    case 26:
                                    case "end":
                                      return _context5.stop();
                                  }
                                }
                              }, _callee5, null, [[4, 18, 21, 24]]);
                            }));

                            return function (_x22) {
                              return _ref.apply(this, arguments);
                            };
                          }());

                        case 6:
                        case "end":
                          return _context6.stop();
                      }
                    }
                  }, _loop);
                });
                _i2 = 0, _trackedRoomIds = trackedRoomIds;

              case 9:
                if (!(_i2 < _trackedRoomIds.length)) {
                  _context7.next = 14;
                  break;
                }

                return _context7.delegateYield(_loop(), "t0", 11);

              case 11:
                _i2++;
                _context7.next = 9;
                break;

              case 14:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee6);
      }));
      return _fixMissingRoomsInUserIdentities.apply(this, arguments);
    }

    function changeSSSSKeyPrefix(_x14, _x15) {
      return _changeSSSSKeyPrefix.apply(this, arguments);
    }

    function _changeSSSSKeyPrefix() {
      _changeSSSSKeyPrefix = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(db, txn) {
        var session, ssssKey;
        return regeneratorRuntime.wrap(function _callee7$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                session = txn.objectStore("session");
                _context8.next = 3;
                return reqAsPromise(session.get("ssssKey"));

              case 3:
                ssssKey = _context8.sent;

                if (ssssKey) {
                  session.put({
                    key: "".concat(SESSION_E2EE_KEY_PREFIX, "ssssKey"),
                    value: ssssKey.value
                  });
                }

              case 5:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee7);
      }));
      return _changeSSSSKeyPrefix.apply(this, arguments);
    }

    function backupAndRestoreE2EEAccountToLocalStorage(_x16, _x17, _x18, _x19) {
      return _backupAndRestoreE2EEAccountToLocalStorage.apply(this, arguments);
    }

    function _backupAndRestoreE2EEAccountToLocalStorage() {
      _backupAndRestoreE2EEAccountToLocalStorage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(db, txn, localStorage, log) {
        var session, databaseNameHelper, sessionStore, restored;
        return regeneratorRuntime.wrap(function _callee8$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                session = txn.objectStore("session");
                _context9.t0 = db.name;

                _context9.t1 = function addWriteError() {};

                databaseNameHelper = {
                  databaseName: _context9.t0,

                  get idbFactory() {
                    throw new Error("unused");
                  },

                  get IDBKeyRange() {
                    throw new Error("unused");
                  },

                  addWriteError: _context9.t1
                };
                sessionStore = new SessionStore(new Store(session, databaseNameHelper), localStorage);
                sessionStore.writeE2EEIdentityToLocalStorage();
                _context9.next = 8;
                return sessionStore.tryRestoreE2EEIdentityFromLocalStorage(log);

              case 8:
                restored = _context9.sent;
                log.set("restored", restored);

              case 10:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee8);
      }));
      return _backupAndRestoreE2EEAccountToLocalStorage.apply(this, arguments);
    }

    function clearAllStores(_x20, _x21) {
      return _clearAllStores.apply(this, arguments);
    }

    function _clearAllStores() {
      _clearAllStores = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(db, txn) {
        var _iterator2, _step2, storeName, store;

        return regeneratorRuntime.wrap(function _callee9$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _iterator2 = _createForOfIteratorHelper(db.objectStoreNames);
                _context10.prev = 1;

                _iterator2.s();

              case 3:
                if ((_step2 = _iterator2.n()).done) {
                  _context10.next = 17;
                  break;
                }

                storeName = _step2.value;
                store = txn.objectStore(storeName);
                _context10.t0 = storeName;
                _context10.next = _context10.t0 === "inboundGroupSessions" ? 9 : _context10.t0 === "outboundGroupSessions" ? 9 : _context10.t0 === "olmSessions" ? 9 : _context10.t0 === "operations" ? 9 : _context10.t0 === "session" ? 10 : 13;
                break;

              case 9:
                return _context10.abrupt("continue", 15);

              case 10:
                _context10.next = 12;
                return iterateCursor(store.openCursor(), function (value, key, cursor) {
                  if (!key.startsWith(SESSION_E2EE_KEY_PREFIX)) {
                    cursor.delete();
                  }

                  return NOT_DONE;
                });

              case 12:
                return _context10.abrupt("break", 15);

              case 13:
                store.clear();
                return _context10.abrupt("break", 15);

              case 15:
                _context10.next = 3;
                break;

              case 17:
                _context10.next = 22;
                break;

              case 19:
                _context10.prev = 19;
                _context10.t1 = _context10["catch"](1);

                _iterator2.e(_context10.t1);

              case 22:
                _context10.prev = 22;

                _iterator2.f();

                return _context10.finish(22);

              case 25:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee9, null, [[1, 19, 22, 25]]);
      }));
      return _clearAllStores.apply(this, arguments);
    }

    function detectWebkitEarlyCloseTxnBug(_x) {
      return _detectWebkitEarlyCloseTxnBug.apply(this, arguments);
    }

    function _detectWebkitEarlyCloseTxnBug() {
      _detectWebkitEarlyCloseTxnBug = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(idbFactory) {
        var dbName, db, readTxn, writeTxn;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                dbName = "hydrogen_webkit_test_inactive_txn_bug";
                _context.prev = 1;
                _context.next = 4;
                return openDatabase(dbName, function (db2) {
                  db2.createObjectStore("test", {
                    keyPath: "key"
                  });
                }, 1, idbFactory);

              case 4:
                db = _context.sent;
                readTxn = db.transaction(["test"], "readonly");
                _context.next = 8;
                return reqAsPromise(readTxn.objectStore("test").get("somekey"));

              case 8:
                _context.next = 10;
                return new Promise(function (r) {
                  return setTimeout(r, 0);
                });

              case 10:
                writeTxn = db.transaction(["test"], "readwrite");
                _context.next = 13;
                return Promise.resolve();

              case 13:
                writeTxn.objectStore("test").add({
                  key: "somekey",
                  value: "foo"
                });
                _context.next = 16;
                return txnAsPromise(writeTxn);

              case 16:
                db.close();
                _context.next = 23;
                break;

              case 19:
                _context.prev = 19;
                _context.t0 = _context["catch"](1);

                if (!(_context.t0.name === "TransactionInactiveError")) {
                  _context.next = 23;
                  break;
                }

                return _context.abrupt("return", true);

              case 23:
                return _context.abrupt("return", false);

              case 24:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[1, 19]]);
      }));
      return _detectWebkitEarlyCloseTxnBug.apply(this, arguments);
    }

    var sessionName = function sessionName(sessionId) {
      return "hydrogen_session_".concat(sessionId);
    };

    var openDatabaseWithSessionId = function openDatabaseWithSessionId(sessionId, idbFactory, localStorage, log) {
      var create = function create(db, txn, oldVersion, version) {
        return createStores(db, txn, oldVersion, version, localStorage, log);
      };

      return openDatabase(sessionName(sessionId), create, schema.length, idbFactory);
    };

    function requestPersistedStorage() {
      return _requestPersistedStorage.apply(this, arguments);
    }

    function _requestPersistedStorage() {
      _requestPersistedStorage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
        var _glob$navigator, _glob$navigator$stora;

        var glob;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                glob = this;

                if (!(glob === null || glob === void 0 ? void 0 : (_glob$navigator = glob.navigator) === null || _glob$navigator === void 0 ? void 0 : (_glob$navigator$stora = _glob$navigator.storage) === null || _glob$navigator$stora === void 0 ? void 0 : _glob$navigator$stora.persist)) {
                  _context4.next = 7;
                  break;
                }

                _context4.next = 4;
                return glob.navigator.storage.persist();

              case 4:
                return _context4.abrupt("return", _context4.sent);

              case 7:
                if (!(glob === null || glob === void 0 ? void 0 : glob.document.requestStorageAccess)) {
                  _context4.next = 19;
                  break;
                }

                _context4.prev = 8;
                _context4.next = 11;
                return glob.document.requestStorageAccess();

              case 11:
                return _context4.abrupt("return", true);

              case 14:
                _context4.prev = 14;
                _context4.t0 = _context4["catch"](8);
                return _context4.abrupt("return", false);

              case 17:
                _context4.next = 20;
                break;

              case 19:
                return _context4.abrupt("return", false);

              case 20:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[8, 14]]);
      }));
      return _requestPersistedStorage.apply(this, arguments);
    }

    var StorageFactory = /*#__PURE__*/function () {
      function StorageFactory(serviceWorkerHandler) {
        var idbFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.indexedDB;

        var _IDBKeyRange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window.IDBKeyRange;

        var localStorage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : window.localStorage;

        _classCallCheck(this, StorageFactory);

        this._serviceWorkerHandler = serviceWorkerHandler;
        this._idbFactory = idbFactory;
        this._IDBKeyRange = _IDBKeyRange;
        this._localStorage = localStorage;
      }

      _createClass(StorageFactory, [{
        key: "create",
        value: function () {
          var _create = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(sessionId, log) {
            var _this$_serviceWorkerH;

            var hasWebkitEarlyCloseTxnBug, db;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return (_this$_serviceWorkerH = this._serviceWorkerHandler) === null || _this$_serviceWorkerH === void 0 ? void 0 : _this$_serviceWorkerH.preventConcurrentSessionAccess(sessionId);

                  case 2:
                    requestPersistedStorage().then(function (persisted) {
                      if (!persisted) {
                        console.warn("no persisted storage, database can be evicted by browser");
                      }
                    });
                    _context.next = 5;
                    return detectWebkitEarlyCloseTxnBug(this._idbFactory);

                  case 5:
                    hasWebkitEarlyCloseTxnBug = _context.sent;
                    _context.next = 8;
                    return openDatabaseWithSessionId(sessionId, this._idbFactory, this._localStorage, log);

                  case 8:
                    db = _context.sent;
                    return _context.abrupt("return", new Storage(db, this._idbFactory, this._IDBKeyRange, hasWebkitEarlyCloseTxnBug, this._localStorage, log.logger));

                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function create(_x, _x2) {
            return _create.apply(this, arguments);
          }

          return create;
        }()
      }, {
        key: "delete",
        value: function _delete(sessionId) {
          var databaseName = sessionName(sessionId);

          var req = this._idbFactory.deleteDatabase(databaseName);

          return reqAsPromise(req);
        }
      }, {
        key: "export",
        value: function () {
          var _export2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(sessionId, log) {
            var db;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return openDatabaseWithSessionId(sessionId, this._idbFactory, this._localStorage, log);

                  case 2:
                    db = _context2.sent;
                    _context2.next = 5;
                    return exportSession(db);

                  case 5:
                    return _context2.abrupt("return", _context2.sent);

                  case 6:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function _export(_x3, _x4) {
            return _export2.apply(this, arguments);
          }

          return _export;
        }()
      }, {
        key: "import",
        value: function () {
          var _import2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(sessionId, data, log) {
            var db;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return openDatabaseWithSessionId(sessionId, this._idbFactory, this._localStorage, log);

                  case 2:
                    db = _context3.sent;
                    _context3.next = 5;
                    return importSession(db, data);

                  case 5:
                    return _context3.abrupt("return", _context3.sent);

                  case 6:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function _import(_x5, _x6, _x7) {
            return _import2.apply(this, arguments);
          }

          return _import;
        }()
      }]);

      return StorageFactory;
    }();

    function createStores(_x8, _x9, _x10, _x11, _x12, _x13) {
      return _createStores.apply(this, arguments);
    }

    function _createStores() {
      _createStores = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(db, txn, oldVersion, version, localStorage, log) {
        var startIdx;
        return regeneratorRuntime.wrap(function _callee6$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                startIdx = oldVersion || 0;
                return _context7.abrupt("return", log.wrap({
                  l: "storage migration",
                  oldVersion: oldVersion,
                  version: version
                }, /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(log2) {
                    var _loop, i;

                    return regeneratorRuntime.wrap(function _callee5$(_context6) {
                      while (1) {
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop(i) {
                              var migrationFunc;
                              return regeneratorRuntime.wrap(function _loop$(_context5) {
                                while (1) {
                                  switch (_context5.prev = _context5.next) {
                                    case 0:
                                      migrationFunc = schema[i];
                                      _context5.next = 3;
                                      return log2.wrap("v".concat(i + 1), function (log3) {
                                        return migrationFunc(db, txn, localStorage, log3);
                                      });

                                    case 3:
                                    case "end":
                                      return _context5.stop();
                                  }
                                }
                              }, _loop);
                            });
                            i = startIdx;

                          case 2:
                            if (!(i < version)) {
                              _context6.next = 7;
                              break;
                            }

                            return _context6.delegateYield(_loop(i), "t0", 4);

                          case 4:
                            ++i;
                            _context6.next = 2;
                            break;

                          case 7:
                          case "end":
                            return _context6.stop();
                        }
                      }
                    }, _callee5);
                  }));

                  return function (_x14) {
                    return _ref.apply(this, arguments);
                  };
                }()));

              case 2:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee6);
      }));
      return _createStores.apply(this, arguments);
    }

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var SessionInfoStorage = /*#__PURE__*/function () {
      function SessionInfoStorage(name) {
        _classCallCheck(this, SessionInfoStorage);

        this._name = name;
      }

      _createClass(SessionInfoStorage, [{
        key: "getAll",
        value: function getAll() {
          var sessionsJson = localStorage.getItem(this._name);

          if (sessionsJson) {
            var sessions = JSON.parse(sessionsJson);

            if (Array.isArray(sessions)) {
              return Promise.resolve(sessions);
            }
          }

          return Promise.resolve([]);
        }
      }, {
        key: "updateLastUsed",
        value: function () {
          var _updateLastUsed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(id, timestamp) {
            var sessions, session;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this.getAll();

                  case 2:
                    sessions = _context.sent;

                    if (sessions) {
                      session = sessions.find(function (session) {
                        return session.id === id;
                      });

                      if (session) {
                        session.lastUsed = timestamp;
                        localStorage.setItem(this._name, JSON.stringify(sessions));
                      }
                    }

                  case 4:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function updateLastUsed(_x, _x2) {
            return _updateLastUsed.apply(this, arguments);
          }

          return updateLastUsed;
        }()
      }, {
        key: "get",
        value: function () {
          var _get = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(id) {
            var sessions;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this.getAll();

                  case 2:
                    sessions = _context2.sent;

                    if (!sessions) {
                      _context2.next = 5;
                      break;
                    }

                    return _context2.abrupt("return", sessions.find(function (session) {
                      return session.id === id;
                    }));

                  case 5:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function get(_x3) {
            return _get.apply(this, arguments);
          }

          return get;
        }()
      }, {
        key: "add",
        value: function () {
          var _add = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(sessionInfo) {
            var sessions;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this.getAll();

                  case 2:
                    sessions = _context3.sent;
                    sessions.push(sessionInfo);
                    localStorage.setItem(this._name, JSON.stringify(sessions));

                  case 5:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function add(_x4) {
            return _add.apply(this, arguments);
          }

          return add;
        }()
      }, {
        key: "delete",
        value: function () {
          var _delete2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(sessionId) {
            var sessions;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return this.getAll();

                  case 2:
                    sessions = _context4.sent;
                    sessions = sessions.filter(function (s) {
                      return s.id !== sessionId;
                    });
                    localStorage.setItem(this._name, JSON.stringify(sessions));

                  case 5:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function _delete(_x5) {
            return _delete2.apply(this, arguments);
          }

          return _delete;
        }()
      }]);

      return SessionInfoStorage;
    }();

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var SettingsStorage = /*#__PURE__*/function () {
      function SettingsStorage(prefix) {
        _classCallCheck(this, SettingsStorage);

        this._prefix = prefix;
      }

      _createClass(SettingsStorage, [{
        key: "setInt",
        value: function () {
          var _setInt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(key, value) {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this._set(key, value);

                  case 1:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function setInt(_x, _x2) {
            return _setInt.apply(this, arguments);
          }

          return setInt;
        }()
      }, {
        key: "getInt",
        value: function () {
          var _getInt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(key) {
            var defaultValue,
                value,
                _args2 = arguments;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    defaultValue = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 0;
                    value = window.localStorage.getItem("".concat(this._prefix).concat(key));

                    if (!(typeof value === "string")) {
                      _context2.next = 4;
                      break;
                    }

                    return _context2.abrupt("return", parseInt(value, 10));

                  case 4:
                    return _context2.abrupt("return", defaultValue);

                  case 5:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function getInt(_x3) {
            return _getInt.apply(this, arguments);
          }

          return getInt;
        }()
      }, {
        key: "setBool",
        value: function () {
          var _setBool = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(key, value) {
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    this._set(key, value);

                  case 1:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function setBool(_x4, _x5) {
            return _setBool.apply(this, arguments);
          }

          return setBool;
        }()
      }, {
        key: "getBool",
        value: function () {
          var _getBool = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(key) {
            var defaultValue,
                value,
                _args4 = arguments;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    defaultValue = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : false;
                    value = window.localStorage.getItem("".concat(this._prefix).concat(key));

                    if (!(typeof value === "string")) {
                      _context4.next = 4;
                      break;
                    }

                    return _context4.abrupt("return", value === "true");

                  case 4:
                    return _context4.abrupt("return", defaultValue);

                  case 5:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function getBool(_x6) {
            return _getBool.apply(this, arguments);
          }

          return getBool;
        }()
      }, {
        key: "setString",
        value: function () {
          var _setString = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(key, value) {
            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    this._set(key, value);

                  case 1:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));

          function setString(_x7, _x8) {
            return _setString.apply(this, arguments);
          }

          return setString;
        }()
      }, {
        key: "getString",
        value: function () {
          var _getString = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(key) {
            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    return _context6.abrupt("return", window.localStorage.getItem("".concat(this._prefix).concat(key)));

                  case 1:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));

          function getString(_x9) {
            return _getString.apply(this, arguments);
          }

          return getString;
        }()
      }, {
        key: "remove",
        value: function () {
          var _remove = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(key) {
            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    window.localStorage.removeItem("".concat(this._prefix).concat(key));

                  case 1:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));

          function remove(_x10) {
            return _remove.apply(this, arguments);
          }

          return remove;
        }()
      }, {
        key: "_set",
        value: function () {
          var _set2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(key, value) {
            return regeneratorRuntime.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    window.localStorage.setItem("".concat(this._prefix).concat(key), value);

                  case 1:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));

          function _set(_x11, _x12) {
            return _set2.apply(this, arguments);
          }

          return _set;
        }()
      }]);

      return SettingsStorage;
    }();

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var UTF8 = /*#__PURE__*/function () {
      function UTF8() {
        _classCallCheck(this, UTF8);

        this._encoder = null;
        this._decoder = null;
      }

      _createClass(UTF8, [{
        key: "encode",
        value: function encode(str) {
          if (!this._encoder) {
            this._encoder = new TextEncoder();
          }

          return this._encoder.encode(str);
        }
      }, {
        key: "decode",
        value: function decode(buffer) {
          if (!this._decoder) {
            this._decoder = new TextDecoder();
          }

          return this._decoder.decode(buffer);
        }
      }]);

      return UTF8;
    }();

    function createCommonjsModule$1(fn, basedir, module) {
      return module = {
        path: basedir,
        exports: {},
        require: function require(path, base) {
          return commonjsRequire$1(path, base === undefined || base === null ? module.path : base);
        }
      }, fn(module, module.exports), module.exports;
    }

    function commonjsRequire$1() {
      throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var base64Arraybuffer = createCommonjsModule$1(function (module, exports) {
      /*
       * base64-arraybuffer
       * https://github.com/niklasvh/base64-arraybuffer
       *
       * Copyright (c) 2012 Niklas von Hertzen
       * Licensed under the MIT license.
       */
      (function () {
        var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // Use a lookup table to find the index.

        var lookup = new Uint8Array(256);

        for (var i = 0; i < chars.length; i++) {
          lookup[chars.charCodeAt(i)] = i;
        }

        exports.encode = function (arraybuffer) {
          var bytes = new Uint8Array(arraybuffer),
              i,
              len = bytes.length,
              base64 = "";

          for (i = 0; i < len; i += 3) {
            base64 += chars[bytes[i] >> 2];
            base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
            base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
            base64 += chars[bytes[i + 2] & 63];
          }

          if (len % 3 === 2) {
            base64 = base64.substring(0, base64.length - 1) + "=";
          } else if (len % 3 === 1) {
            base64 = base64.substring(0, base64.length - 2) + "==";
          }

          return base64;
        };

        exports.decode = function (base64) {
          var bufferLength = base64.length * 0.75,
              len = base64.length,
              i,
              p = 0,
              encoded1,
              encoded2,
              encoded3,
              encoded4;

          if (base64[base64.length - 1] === "=") {
            bufferLength--;

            if (base64[base64.length - 2] === "=") {
              bufferLength--;
            }
          }

          var arraybuffer = new ArrayBuffer(bufferLength),
              bytes = new Uint8Array(arraybuffer);

          for (i = 0; i < len; i += 4) {
            encoded1 = lookup[base64.charCodeAt(i)];
            encoded2 = lookup[base64.charCodeAt(i + 1)];
            encoded3 = lookup[base64.charCodeAt(i + 2)];
            encoded4 = lookup[base64.charCodeAt(i + 3)];
            bytes[p++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }

          return arraybuffer;
        };
      })();
    });

    var Base64 = /*#__PURE__*/function () {
      function Base64() {
        _classCallCheck(this, Base64);
      }

      _createClass(Base64, [{
        key: "encodeUnpadded",
        value: function encodeUnpadded(buffer) {
          var str = base64Arraybuffer.encode(buffer);
          var paddingIdx = str.indexOf("=");

          if (paddingIdx !== -1) {
            return str.substr(0, paddingIdx);
          } else {
            return str;
          }
        }
      }, {
        key: "encode",
        value: function encode(buffer) {
          return base64Arraybuffer.encode(buffer);
        }
      }, {
        key: "decode",
        value: function decode(str) {
          return base64Arraybuffer.decode(str);
        }
      }]);

      return Base64;
    }();

    var buffer = /*#__PURE__*/function () {
      function Buffer() {
        _classCallCheck(this, Buffer);
      }

      _createClass(Buffer, null, [{
        key: "isBuffer",
        value: function isBuffer(array) {
          return array instanceof Uint8Array;
        }
      }, {
        key: "from",
        value: function from(arrayBuffer) {
          return arrayBuffer;
        }
      }, {
        key: "allocUnsafe",
        value: function allocUnsafe(size) {
          return Buffer.alloc(size);
        }
      }, {
        key: "alloc",
        value: function alloc(size) {
          return new Uint8Array(size);
        }
      }]);

      return Buffer;
    }();

    var Buffer = buffer;
    var safeBuffer = {
      Buffer: Buffer
    }; // base-x encoding / decoding
    // Copyright (c) 2018 base-x contributors
    // Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
    // Distributed under the MIT software license, see the accompanying
    // file LICENSE or http://www.opensource.org/licenses/mit-license.php.
    // @ts-ignore

    var _Buffer = safeBuffer.Buffer;

    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError('Alphabet too long');
      }

      var BASE_MAP = new Uint8Array(256);

      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }

      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);

        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + ' is ambiguous');
        }

        BASE_MAP[xc] = i;
      }

      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up

      var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up

      function encode(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }

        if (!_Buffer.isBuffer(source)) {
          throw new TypeError('Expected Buffer');
        }

        if (source.length === 0) {
          return '';
        } // Skip & count leading zeroes.


        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;

        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        } // Allocate enough space in big-endian base58 representation.


        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size); // Process the bytes.

        while (pbegin !== pend) {
          var carry = source[pbegin]; // Apply "b58 = b58 * 256 + ch".

          var i = 0;

          for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }

          if (carry !== 0) {
            throw new Error('Non-zero carry');
          }

          length = i;
          pbegin++;
        } // Skip leading zeroes in base58 result.


        var it2 = size - length;

        while (it2 !== size && b58[it2] === 0) {
          it2++;
        } // Translate the result into a string.


        var str = LEADER.repeat(zeroes);

        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }

        return str;
      }

      function decodeUnsafe(source) {
        if (typeof source !== 'string') {
          throw new TypeError('Expected String');
        }

        if (source.length === 0) {
          return _Buffer.alloc(0);
        }

        var psz = 0; // Skip leading spaces.

        if (source[psz] === ' ') {
          return;
        } // Skip and count leading '1's.


        var zeroes = 0;
        var length = 0;

        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        } // Allocate enough space in big-endian base256 representation.


        var size = (source.length - psz) * FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.

        var b256 = new Uint8Array(size); // Process the characters.

        while (source[psz]) {
          // Decode character
          var carry = BASE_MAP[source.charCodeAt(psz)]; // Invalid character

          if (carry === 255) {
            return;
          }

          var i = 0;

          for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }

          if (carry !== 0) {
            throw new Error('Non-zero carry');
          }

          length = i;
          psz++;
        } // Skip trailing spaces.


        if (source[psz] === ' ') {
          return;
        } // Skip leading zeroes in b256.


        var it4 = size - length;

        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }

        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));

        vch.fill(0x00, 0, zeroes);
        var j = zeroes;

        while (it4 !== size) {
          vch[j++] = b256[it4++];
        }

        return vch;
      }

      function decode(string) {
        var buffer = decodeUnsafe(string);

        if (buffer) {
          return buffer;
        }

        throw new Error('Non-base' + BASE + ' character');
      }

      return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
      };
    }

    var src = base;
    var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    var bs58 = src(ALPHABET);

    var Base58 = /*#__PURE__*/function () {
      function Base58() {
        _classCallCheck(this, Base58);
      }

      _createClass(Base58, [{
        key: "encode",
        value: function encode(buffer) {
          return bs58.encode(buffer);
        }
      }, {
        key: "decode",
        value: function decode(str) {
          return bs58.decode(str);
        }
      }]);

      return Base58;
    }();

    var Encoding = function Encoding() {
      _classCallCheck(this, Encoding);

      this.utf8 = new UTF8();
      this.base64 = new Base64();
      this.base58 = new Base58();
    };

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var OlmWorker = /*#__PURE__*/function () {
      function OlmWorker(workerPool) {
        _classCallCheck(this, OlmWorker);

        this._workerPool = workerPool;
      }

      _createClass(OlmWorker, [{
        key: "megolmDecrypt",
        value: function megolmDecrypt(session, ciphertext) {
          var sessionKey = session.export_session(session.first_known_index());
          return this._workerPool.send({
            type: "megolm_decrypt",
            ciphertext: ciphertext,
            sessionKey: sessionKey
          });
        }
      }, {
        key: "createAccountAndOTKs",
        value: function () {
          var _createAccountAndOTKs = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(account, otkAmount) {
            var randomValues, pickle;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    // IE11 does not support getRandomValues in a worker, so we have to generate the values upfront.
                    if (window.msCrypto) {
                      randomValues = [window.msCrypto.getRandomValues(new Uint8Array(64)), window.msCrypto.getRandomValues(new Uint8Array(otkAmount * 32))];
                    }

                    _context.next = 3;
                    return this._workerPool.send({
                      type: "olm_create_account_otks",
                      randomValues: randomValues,
                      otkAmount: otkAmount
                    }).response();

                  case 3:
                    pickle = _context.sent;
                    account.unpickle("", pickle);

                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function createAccountAndOTKs(_x, _x2) {
            return _createAccountAndOTKs.apply(this, arguments);
          }

          return createAccountAndOTKs;
        }()
      }, {
        key: "createOutboundOlmSession",
        value: function () {
          var _createOutboundOlmSession = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(account, newSession, theirIdentityKey, theirOneTimeKey) {
            var accountPickle, randomValues, sessionPickle;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    accountPickle = account.pickle("");

                    if (window.msCrypto) {
                      randomValues = [window.msCrypto.getRandomValues(new Uint8Array(64))];
                    }

                    _context2.next = 4;
                    return this._workerPool.send({
                      type: "olm_create_outbound",
                      accountPickle: accountPickle,
                      theirIdentityKey: theirIdentityKey,
                      theirOneTimeKey: theirOneTimeKey,
                      randomValues: randomValues
                    }).response();

                  case 4:
                    sessionPickle = _context2.sent;
                    newSession.unpickle("", sessionPickle);

                  case 6:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function createOutboundOlmSession(_x3, _x4, _x5, _x6) {
            return _createOutboundOlmSession.apply(this, arguments);
          }

          return createOutboundOlmSession;
        }()
      }, {
        key: "dispose",
        value: function dispose() {
          this._workerPool.dispose();
        }
      }]);

      return OlmWorker;
    }();

    var LogItem = /*#__PURE__*/function () {
      function LogItem(labelOrValues, logLevel, logger, filterCreator) {
        _classCallCheck(this, LogItem);

        this._logger = logger;
        this.start = logger._now();
        this._values = typeof labelOrValues === "string" ? {
          l: labelOrValues
        } : labelOrValues;
        this.logLevel = logLevel;
        this._filterCreator = filterCreator;
      }

      _createClass(LogItem, [{
        key: "runDetached",
        value: function runDetached(labelOrValues, callback, logLevel, filterCreator) {
          return this._logger.runDetached(labelOrValues, callback, logLevel, filterCreator);
        }
      }, {
        key: "wrapDetached",
        value: function wrapDetached(labelOrValues, callback, logLevel, filterCreator) {
          this.refDetached(this.runDetached(labelOrValues, callback, logLevel, filterCreator));
        }
      }, {
        key: "refDetached",
        value: function refDetached(logItem, logLevel) {
          logItem.ensureRefId();
          this.log({
            ref: logItem.values.refId
          }, logLevel);
        }
      }, {
        key: "ensureRefId",
        value: function ensureRefId() {
          if (!this._values.refId) {
            this.set("refId", this._logger._createRefId());
          }
        }
      }, {
        key: "wrap",
        value: function wrap(labelOrValues, callback, logLevel, filterCreator) {
          var item = this.child(labelOrValues, logLevel, filterCreator);
          return item.run(callback);
        }
      }, {
        key: "durationWithoutType",
        value: function durationWithoutType(type) {
          var durationOfType = this.durationOfType(type);

          if (this.duration && durationOfType) {
            return this.duration - durationOfType;
          }
        }
      }, {
        key: "durationOfType",
        value: function durationOfType(type) {
          if (this._values.t === type) {
            return this.duration;
          } else if (this._children) {
            return this._children.reduce(function (sum, c) {
              var duration = c.durationOfType(type);
              return sum + (duration !== null && duration !== void 0 ? duration : 0);
            }, 0);
          } else {
            return 0;
          }
        }
      }, {
        key: "log",
        value: function log(labelOrValues, logLevel) {
          var item = this.child(labelOrValues, logLevel);
          item.end = item.start;
        }
      }, {
        key: "set",
        value: function set(key, value) {
          if (_typeof(key) === "object") {
            var values = key;
            Object.assign(this._values, values);
          } else {
            this._values[key] = value;
          }
        }
      }, {
        key: "serialize",
        value: function serialize(filter, parentStartTime, forced) {
          var _this = this;

          if (this._filterCreator) {
            try {
              filter = this._filterCreator(new LogFilter(filter), this);
            } catch (err) {
              console.error("Error creating log filter", err);
            }
          }

          var children = null;

          if (this._children) {
            children = this._children.reduce(function (array, c) {
              var s = c.serialize(filter, _this.start, false);

              if (s) {
                if (array === null) {
                  array = [];
                }

                array.push(s);
              }

              return array;
            }, null);
          }

          if (filter && !filter.filter(this, children)) {
            return;
          }

          var item = {
            s: typeof parentStartTime === "number" ? this.start - parentStartTime : this.start,
            d: this.duration,
            v: this._values,
            l: this.logLevel
          };

          if (this.error) {
            item.e = {
              stack: this.error.stack,
              name: this.error.name,
              message: this.error.message.split("\n")[0]
            };
          }

          if (forced) {
            item.f = true;
          }

          if (children) {
            item.c = children;
          }

          return item;
        }
      }, {
        key: "run",
        value: function run(callback) {
          var _this2 = this;

          if (this.end !== void 0) {
            console.trace("log item is finished, additional logs will likely not be recorded");
          }

          try {
            var result = callback(this);

            if (result instanceof Promise) {
              return result.then(function (promiseResult) {
                _this2.finish();

                return promiseResult;
              }, function (err) {
                throw _this2.catch(err);
              });
            } else {
              this.finish();
              return result;
            }
          } catch (err) {
            throw this.catch(err);
          }
        }
      }, {
        key: "finish",
        value: function finish() {
          if (this.end === void 0) {
            if (this._children) {
              var _iterator = _createForOfIteratorHelper(this._children),
                  _step;

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var c = _step.value;
                  c.finish();
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            }

            this.end = this._logger._now();
          }
        }
      }, {
        key: "catch",
        value: function _catch(err) {
          this.error = err;
          this.logLevel = LogLevel.Error;
          this.finish();
          return err;
        }
      }, {
        key: "child",
        value: function child(labelOrValues, logLevel, filterCreator) {
          if (this.end) {
            console.trace("log item is finished, additional logs will likely not be recorded");
          }

          if (!logLevel) {
            logLevel = this.logLevel || LogLevel.Info;
          }

          var item = new LogItem(labelOrValues, logLevel, this._logger, filterCreator);

          if (!this._children) {
            this._children = [];
          }

          this._children.push(item);

          return item;
        }
      }, {
        key: "duration",
        get: function get() {
          if (this.end) {
            return this.end - this.start;
          } else {
            return void 0;
          }
        }
      }, {
        key: "level",
        get: function get() {
          return LogLevel;
        }
      }, {
        key: "logger",
        get: function get() {
          return this._logger;
        }
      }, {
        key: "values",
        get: function get() {
          return this._values;
        }
      }, {
        key: "children",
        get: function get() {
          return this._children;
        }
      }]);

      return LogItem;
    }();

    var BaseLogger = /*#__PURE__*/function () {
      function BaseLogger(_ref) {
        var platform = _ref.platform;

        _classCallCheck(this, BaseLogger);

        this._openItems = new Set();
        this._platform = platform;
      }

      _createClass(BaseLogger, [{
        key: "log",
        value: function log(labelOrValues) {
          var logLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : LogLevel.Info;
          var item = new LogItem(labelOrValues, logLevel, this);
          item.end = item.start;

          this._persistItem(item, void 0, false);
        }
      }, {
        key: "wrapOrRun",
        value: function wrapOrRun(item, labelOrValues, callback, logLevel, filterCreator) {
          if (item) {
            return item.wrap(labelOrValues, callback, logLevel, filterCreator);
          } else {
            return this.run(labelOrValues, callback, logLevel, filterCreator);
          }
        }
      }, {
        key: "runDetached",
        value: function runDetached(labelOrValues, callback, logLevel, filterCreator) {
          if (!logLevel) {
            logLevel = LogLevel.Info;
          }

          var item = new LogItem(labelOrValues, logLevel, this);

          this._run(item, callback, logLevel, false, filterCreator);

          return item;
        }
      }, {
        key: "run",
        value: function run(labelOrValues, callback, logLevel, filterCreator) {
          if (logLevel === void 0) {
            logLevel = LogLevel.Info;
          }

          var item = new LogItem(labelOrValues, logLevel, this);
          return this._run(item, callback, logLevel, true, filterCreator);
        }
      }, {
        key: "_run",
        value: function _run(item, callback, logLevel, wantResult, filterCreator) {
          var _this = this;

          this._openItems.add(item);

          var finishItem = function finishItem() {
            var filter = new LogFilter();

            if (filterCreator) {
              try {
                filter = filterCreator(filter, item);
              } catch (err) {
                console.error("Error while creating log filter", err);
              }
            } else {
              filter = filter.minLevel(logLevel);
            }

            try {
              _this._persistItem(item, filter, false);
            } catch (err) {
              console.error("Could not persist log item", err);
            }

            _this._openItems.delete(item);
          };

          try {
            var result = item.run(callback);

            if (result instanceof Promise) {
              result = result.then(function (promiseResult) {
                finishItem();
                return promiseResult;
              }, function (err) {
                finishItem();

                if (wantResult) {
                  throw err;
                }
              });

              if (wantResult) {
                return result;
              }
            } else {
              finishItem();

              if (wantResult) {
                return result;
              }
            }
          } catch (err) {
            finishItem();

            if (wantResult) {
              throw err;
            }
          }
        }
      }, {
        key: "_finishOpenItems",
        value: function _finishOpenItems() {
          var _iterator = _createForOfIteratorHelper(this._openItems),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var openItem = _step.value;
              openItem.finish();

              try {
                this._persistItem(openItem, new LogFilter(), true);
              } catch (err) {
                console.error("Could not serialize log item", err);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          this._openItems.clear();
        }
      }, {
        key: "_now",
        value: function _now() {
          return this._platform.clock.now();
        }
      }, {
        key: "_createRefId",
        value: function _createRefId() {
          return Math.round(this._platform.random() * Number.MAX_SAFE_INTEGER);
        }
      }, {
        key: "level",
        get: function get() {
          return LogLevel;
        }
      }]);

      return BaseLogger;
    }();

    var IDBLogger = /*#__PURE__*/function (_BaseLogger) {
      _inherits(IDBLogger, _BaseLogger);

      var _super = _createSuper(IDBLogger);

      function IDBLogger(options) {
        var _this;

        _classCallCheck(this, IDBLogger);

        _this = _super.call(this, options);
        var name = options.name,
            _options$flushInterva = options.flushInterval,
            flushInterval = _options$flushInterva === void 0 ? 60 * 1e3 : _options$flushInterva,
            _options$limit = options.limit,
            limit = _options$limit === void 0 ? 3e3 : _options$limit;
        _this._name = name;
        _this._limit = limit;
        _this._queuedItems = _this._loadQueuedItems();
        window.addEventListener("pagehide", _assertThisInitialized(_this), false);
        _this._flushInterval = _this._platform.clock.createInterval(function () {
          return _this._tryFlush();
        }, flushInterval);
        return _this;
      }

      _createClass(IDBLogger, [{
        key: "dispose",
        value: function dispose() {
          window.removeEventListener("pagehide", this, false);

          this._flushInterval.dispose();
        }
      }, {
        key: "handleEvent",
        value: function handleEvent(evt) {
          if (evt.type === "pagehide") {
            this._finishAllAndFlush();
          }
        }
      }, {
        key: "_tryFlush",
        value: function () {
          var _tryFlush2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var db, txn, logs, amount, _iterator, _step, i, itemCount, deleteAmount;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this._openDB();

                  case 2:
                    db = _context.sent;
                    _context.prev = 3;
                    txn = db.transaction(["logs"], "readwrite");
                    logs = txn.objectStore("logs");
                    amount = this._queuedItems.length;
                    _iterator = _createForOfIteratorHelper(this._queuedItems);

                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done;) {
                        i = _step.value;
                        logs.add(i);
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }

                    _context.next = 11;
                    return reqAsPromise(logs.count());

                  case 11:
                    itemCount = _context.sent;

                    if (!(itemCount > this._limit)) {
                      _context.next = 16;
                      break;
                    }

                    deleteAmount = itemCount - this._limit + Math.round(0.1 * this._limit);
                    _context.next = 16;
                    return iterateCursor(logs.openCursor(), function (_, __, cursor) {
                      cursor.delete();
                      deleteAmount -= 1;
                      return {
                        done: deleteAmount === 0
                      };
                    });

                  case 16:
                    _context.next = 18;
                    return txnAsPromise(txn);

                  case 18:
                    this._queuedItems.splice(0, amount);

                    _context.next = 24;
                    break;

                  case 21:
                    _context.prev = 21;
                    _context.t0 = _context["catch"](3);
                    console.error("Could not flush logs", _context.t0);

                  case 24:
                    _context.prev = 24;

                    try {
                      db.close();
                    } catch (e) {}

                    return _context.finish(24);

                  case 27:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[3, 21, 24, 27]]);
          }));

          function _tryFlush() {
            return _tryFlush2.apply(this, arguments);
          }

          return _tryFlush;
        }()
      }, {
        key: "_finishAllAndFlush",
        value: function _finishAllAndFlush() {
          this._finishOpenItems();

          this.log({
            l: "pagehide, closing logs",
            t: "navigation"
          });

          this._persistQueuedItems(this._queuedItems);
        }
      }, {
        key: "_loadQueuedItems",
        value: function _loadQueuedItems() {
          var key = "".concat(this._name, "_queuedItems");

          try {
            var json = window.localStorage.getItem(key);

            if (json) {
              window.localStorage.removeItem(key);
              return JSON.parse(json);
            }
          } catch (err) {
            console.error("Could not load queued log items", err);
          }

          return [];
        }
      }, {
        key: "_openDB",
        value: function _openDB() {
          return openDatabase(this._name, function (db) {
            return db.createObjectStore("logs", {
              keyPath: "id",
              autoIncrement: true
            });
          }, 1);
        }
      }, {
        key: "_persistItem",
        value: function _persistItem(logItem, filter, forced) {
          var serializedItem = logItem.serialize(filter, void 0, forced);

          this._queuedItems.push({
            json: JSON.stringify(serializedItem)
          });
        }
      }, {
        key: "_persistQueuedItems",
        value: function _persistQueuedItems(items) {
          try {
            window.localStorage.setItem("".concat(this._name, "_queuedItems"), JSON.stringify(items));
          } catch (e) {
            console.error("Could not persist queued log items in localStorage, they will likely be lost", e);
          }
        }
      }, {
        key: "export",
        value: function () {
          var _export2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            var db, txn, logs, storedItems, allItems;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this._openDB();

                  case 2:
                    db = _context2.sent;
                    _context2.prev = 3;
                    txn = db.transaction(["logs"], "readonly");
                    logs = txn.objectStore("logs");
                    _context2.next = 8;
                    return fetchResults(logs.openCursor(), function () {
                      return false;
                    });

                  case 8:
                    storedItems = _context2.sent;
                    allItems = storedItems.concat(this._queuedItems);
                    return _context2.abrupt("return", new IDBLogExport(allItems, this, this._platform));

                  case 11:
                    _context2.prev = 11;

                    try {
                      db.close();
                    } catch (e) {}

                    return _context2.finish(11);

                  case 14:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[3,, 11, 14]]);
          }));

          function _export() {
            return _export2.apply(this, arguments);
          }

          return _export;
        }()
      }, {
        key: "_removeItems",
        value: function () {
          var _removeItems2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(items) {
            var db, txn, logs, _iterator2, _step2, item, queuedIdx;

            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this._openDB();

                  case 2:
                    db = _context3.sent;
                    _context3.prev = 3;
                    txn = db.transaction(["logs"], "readwrite");
                    logs = txn.objectStore("logs");
                    _iterator2 = _createForOfIteratorHelper(items);

                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                        item = _step2.value;

                        if (typeof item.id === "number") {
                          logs.delete(item.id);
                        } else {
                          queuedIdx = this._queuedItems.indexOf(item);

                          if (queuedIdx === -1) {
                            this._queuedItems.splice(queuedIdx, 1);
                          }
                        }
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }

                    _context3.next = 10;
                    return txnAsPromise(txn);

                  case 10:
                    _context3.prev = 10;

                    try {
                      db.close();
                    } catch (e) {}

                    return _context3.finish(10);

                  case 13:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[3,, 10, 13]]);
          }));

          function _removeItems(_x) {
            return _removeItems2.apply(this, arguments);
          }

          return _removeItems;
        }()
      }]);

      return IDBLogger;
    }(BaseLogger);

    var IDBLogExport = /*#__PURE__*/function () {
      function IDBLogExport(items, logger, platform) {
        _classCallCheck(this, IDBLogExport);

        this._items = items;
        this._logger = logger;
        this._platform = platform;
      }

      _createClass(IDBLogExport, [{
        key: "removeFromStore",
        value: function removeFromStore() {
          return this._logger._removeItems(this._items);
        }
      }, {
        key: "asBlob",
        value: function asBlob() {
          var _this$_platform$updat;

          var log = {
            formatVersion: 1,
            appVersion: (_this$_platform$updat = this._platform.updateService) === null || _this$_platform$updat === void 0 ? void 0 : _this$_platform$updat.version,
            items: this._items.map(function (i) {
              return JSON.parse(i.json);
            })
          };
          var json = JSON.stringify(log);

          var buffer = this._platform.encoding.utf8.encode(json);

          var blob = this._platform.createBlob(buffer, "application/json");

          return blob;
        }
      }, {
        key: "count",
        get: function get() {
          return this._items.length;
        }
      }]);

      return IDBLogExport;
    }();

    var ConsoleLogger = /*#__PURE__*/function (_BaseLogger) {
      _inherits(ConsoleLogger, _BaseLogger);

      var _super = _createSuper(ConsoleLogger);

      function ConsoleLogger() {
        _classCallCheck(this, ConsoleLogger);

        return _super.apply(this, arguments);
      }

      _createClass(ConsoleLogger, [{
        key: "_persistItem",
        value: function _persistItem(item) {
          printToConsole(item);
        }
      }, {
        key: "export",
        value: function () {
          var _export2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    return _context.abrupt("return", void 0);

                  case 1:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function _export() {
            return _export2.apply(this, arguments);
          }

          return _export;
        }()
      }]);

      return ConsoleLogger;
    }(BaseLogger);
    var excludedKeysFromTable = ["l", "id"];

    function filterValues(values) {
      return Object.entries(values).filter(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            key = _ref2[0];

        return !excludedKeysFromTable.includes(key);
      }).reduce(function (obj, _ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            key = _ref4[0],
            value = _ref4[1];

        obj = obj || {};
        obj[key] = value;
        return obj;
      }, null);
    }

    function printToConsole(item) {
      var label = "".concat(itemCaption(item), " (").concat(item.duration, "ms)");
      var filteredValues = filterValues(item.values);
      var shouldGroup = item.children || filteredValues;

      if (shouldGroup) {
        if (item.error) {
          console.group(label);
        } else {
          console.groupCollapsed(label);
        }

        if (item.error) {
          console.error(item.error);
        }
      } else {
        if (item.error) {
          console.error(item.error);
        } else {
          console.log(label);
        }
      }

      if (filteredValues) {
        console.table(filteredValues);
      }

      if (item.children) {
        var _iterator = _createForOfIteratorHelper(item.children),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var c = _step.value;
            printToConsole(c);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      if (shouldGroup) {
        console.groupEnd();
      }
    }

    function itemCaption(item) {
      if (item.values.t === "network") {
        return "".concat(item.values.method, " ").concat(item.values.url);
      } else if (item.values.l && typeof item.values.id !== "undefined") {
        return "".concat(item.values.l, " ").concat(item.values.id);
      } else if (item.values.l && typeof item.values.status !== "undefined") {
        return "".concat(item.values.l, " (").concat(item.values.status, ")");
      } else if (item.values.l && item.error) {
        return "".concat(item.values.l, " failed");
      } else if (typeof item.values.ref !== "undefined") {
        return "ref ".concat(item.values.ref);
      } else {
        return item.values.l || item.values.type;
      }
    }

    var _TAG_NAMES;

    function isChildren(children) {
      return _typeof(children) !== "object" || "nodeType" in children || Array.isArray(children);
    }
    function classNames(obj, value) {
      return Object.entries(obj).reduce(function (cn, _ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            name = _ref2[0],
            enabled = _ref2[1];

        if (typeof enabled === "function") {
          enabled = enabled(value);
        }

        if (enabled) {
          return cn + (cn.length ? " " : "") + name;
        } else {
          return cn;
        }
      }, "");
    }
    function setAttribute(el2, name, value) {
      if (name === "className") {
        name = "class";
      }

      if (value === false) {
        el2.removeAttribute(name);
      } else {
        if (value === true) {
          value = name;
        }

        el2.setAttribute(name, value);
      }
    }
    function el(elementName, attributes, children) {
      return elNS(HTML_NS, elementName, attributes, children);
    }
    function elNS(ns, elementName, attributes, children) {
      if (attributes && isChildren(attributes)) {
        children = attributes;
        attributes = void 0;
      }

      var e = document.createElementNS(ns, elementName);

      if (attributes) {
        for (var _i = 0, _Object$entries = Object.entries(attributes); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
              name = _Object$entries$_i[0],
              value = _Object$entries$_i[1];

          if (_typeof(value) === "object") {
            value = value !== null && name === "className" ? classNames(value, void 0) : false;
          }

          setAttribute(e, name, value);
        }
      }

      if (children) {
        if (!Array.isArray(children)) {
          children = [children];
        }

        var _iterator = _createForOfIteratorHelper(children),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var c = _step.value;

            if (typeof c === "string") {
              c = text(c);
            }

            e.appendChild(c);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return e;
    }
    function text(str) {
      return document.createTextNode(str);
    }
    var HTML_NS = "http://www.w3.org/1999/xhtml";
    var SVG_NS = "http://www.w3.org/2000/svg";
    var TAG_NAMES = (_TAG_NAMES = {}, _defineProperty(_TAG_NAMES, HTML_NS, ["br", "a", "ol", "ul", "li", "div", "h1", "h2", "h3", "h4", "h5", "h6", "p", "strong", "em", "span", "img", "section", "main", "article", "aside", "del", "blockquote", "table", "thead", "tbody", "tr", "th", "td", "hr", "pre", "code", "button", "time", "input", "textarea", "label", "form", "progress", "output", "video"]), _defineProperty(_TAG_NAMES, SVG_NS, ["svg", "circle"]), _TAG_NAMES);
    var tag = {};

    var _loop = function _loop() {
      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
          ns = _Object$entries2$_i[0],
          tags = _Object$entries2$_i[1];

      var _iterator2 = _createForOfIteratorHelper(tags),
          _step2;

      try {
        var _loop2 = function _loop2() {
          var tagName = _step2.value;

          tag[tagName] = function (attributes, children) {
            return elNS(ns, tagName, attributes, children);
          };
        };

        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          _loop2();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    };

    for (var _i2 = 0, _Object$entries2 = Object.entries(TAG_NAMES); _i2 < _Object$entries2.length; _i2++) {
      _loop();
    }

    function mountView(view, mountArgs) {
      var node;

      try {
        node = view.mount(mountArgs);
      } catch (err) {
        node = errorToDOM(err);
      }

      return node;
    }
    function errorToDOM(error) {
      var stack = new Error().stack;
      var callee = null;

      if (stack) {
        callee = stack.split("\n")[1];
      }

      return tag.div([tag.h2("Something went wrong…"), tag.h3(error.message), tag.p("This occurred while running ".concat(callee, ".")), tag.pre(error.stack)]);
    }
    function insertAt(parentNode, idx, childNode) {
      var isLast = idx === parentNode.childElementCount;

      if (isLast) {
        parentNode.appendChild(childNode);
      } else {
        var nextDomNode = parentNode.children[idx];
        parentNode.insertBefore(childNode, nextDomNode);
      }
    }
    function removeChildren(parentNode) {
      parentNode.innerHTML = "";
    }

    var ListView = /*#__PURE__*/function () {
      function ListView(_ref, childCreator) {
        var list = _ref.list,
            onItemClick = _ref.onItemClick,
            className = _ref.className,
            _ref$tagName = _ref.tagName,
            tagName = _ref$tagName === void 0 ? "ul" : _ref$tagName,
            _ref$parentProvidesUp = _ref.parentProvidesUpdates,
            parentProvidesUpdates = _ref$parentProvidesUp === void 0 ? true : _ref$parentProvidesUp;

        _classCallCheck(this, ListView);

        this._onItemClick = onItemClick;
        this._list = list;
        this._className = className;
        this._tagName = tagName;
        this._root = void 0;
        this._subscription = void 0;
        this._childCreator = childCreator;
        this._childInstances = void 0;
        this._mountArgs = {
          parentProvidesUpdates: parentProvidesUpdates
        };
      }

      _createClass(ListView, [{
        key: "root",
        value: function root() {
          return this._root;
        }
      }, {
        key: "update",
        value: function update(attributes) {
          if (attributes.list) {
            if (this._subscription) {
              this._unloadList();

              while (this._root.lastChild) {
                this._root.lastChild.remove();
              }
            }

            this._list = attributes.list;
            this.loadList();
          }
        }
      }, {
        key: "mount",
        value: function mount() {
          var attr = {};

          if (this._className) {
            attr.className = this._className;
          }

          var root = this._root = el(this._tagName, attr);
          this.loadList();

          if (this._onItemClick) {
            root.addEventListener("click", this);
          }

          return root;
        }
      }, {
        key: "handleEvent",
        value: function handleEvent(evt) {
          if (evt.type === "click") {
            this._handleClick(evt);
          }
        }
      }, {
        key: "unmount",
        value: function unmount() {
          if (this._list) {
            this._unloadList();
          }
        }
      }, {
        key: "_handleClick",
        value: function _handleClick(event) {
          if (event.target === this._root || !this._onItemClick) {
            return;
          }

          var childNode = event.target;

          while (childNode.parentNode !== this._root) {
            childNode = childNode.parentNode;
          }

          var index = Array.prototype.indexOf.call(this._root.childNodes, childNode);
          var childView = this._childInstances[index];

          if (childView) {
            this._onItemClick(childView, event);
          }
        }
      }, {
        key: "_unloadList",
        value: function _unloadList() {
          this._subscription = this._subscription();

          var _iterator = _createForOfIteratorHelper(this._childInstances),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var child = _step.value;
              child.unmount();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          this._childInstances = void 0;
        }
      }, {
        key: "loadList",
        value: function loadList() {
          if (!this._list) {
            return;
          }

          this._subscription = this._list.subscribe(this);
          this._childInstances = [];
          var fragment = document.createDocumentFragment();

          var _iterator2 = _createForOfIteratorHelper(this._list),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var item = _step2.value;

              var child = this._childCreator(item);

              this._childInstances.push(child);

              fragment.appendChild(mountView(child, this._mountArgs));
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          this._root.appendChild(fragment);
        }
      }, {
        key: "onReset",
        value: function onReset() {
          var _iterator3 = _createForOfIteratorHelper(this._childInstances),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var child = _step3.value;
              child.root().remove();
              child.unmount();
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          this._childInstances.length = 0;
        }
      }, {
        key: "onAdd",
        value: function onAdd(idx, value) {
          this.addChild(idx, value);
        }
      }, {
        key: "onRemove",
        value: function onRemove(idx, value) {
          this.removeChild(idx);
        }
      }, {
        key: "onMove",
        value: function onMove(fromIdx, toIdx, value) {
          this.moveChild(fromIdx, toIdx);
        }
      }, {
        key: "onUpdate",
        value: function onUpdate(i, value, params) {
          this.updateChild(i, value, params);
        }
      }, {
        key: "addChild",
        value: function addChild(childIdx, value) {
          var child = this._childCreator(value);

          this._childInstances.splice(childIdx, 0, child);

          insertAt(this._root, childIdx, mountView(child, this._mountArgs));
        }
      }, {
        key: "removeChild",
        value: function removeChild(childIdx) {
          var _this$_childInstances = this._childInstances.splice(childIdx, 1),
              _this$_childInstances2 = _slicedToArray(_this$_childInstances, 1),
              child = _this$_childInstances2[0];

          child.root().remove();
          child.unmount();
        }
      }, {
        key: "moveChild",
        value: function moveChild(fromChildIdx, toChildIdx) {
          var _this$_childInstances3 = this._childInstances.splice(fromChildIdx, 1),
              _this$_childInstances4 = _slicedToArray(_this$_childInstances3, 1),
              child = _this$_childInstances4[0];

          this._childInstances.splice(toChildIdx, 0, child);

          child.root().remove();
          insertAt(this._root, toChildIdx, child.root());
        }
      }, {
        key: "updateChild",
        value: function updateChild(childIdx, value, params) {
          if (this._childInstances) {
            var instance = this._childInstances[childIdx];
            instance && instance.update(value, params);
          }
        }
      }, {
        key: "recreateItem",
        value: function recreateItem(index, value) {
          if (this._childInstances) {
            var child = this._childCreator(value);

            if (!child) {
              this.onRemove(index, value);
            } else {
              var _this$_childInstances5 = this._childInstances.splice(index, 1, child),
                  _this$_childInstances6 = _slicedToArray(_this$_childInstances5, 1),
                  oldChild = _this$_childInstances6[0];

              this._root.replaceChild(child.mount(this._mountArgs), oldChild.root());

              oldChild.unmount();
            }
          }
        }
      }, {
        key: "getChildInstanceByIndex",
        value: function getChildInstanceByIndex(idx) {
          var _this$_childInstances7;

          return (_this$_childInstances7 = this._childInstances) === null || _this$_childInstances7 === void 0 ? void 0 : _this$_childInstances7[idx];
        }
      }]);

      return ListView;
    }();

    var BaseUpdateView = /*#__PURE__*/function () {
      function BaseUpdateView(value) {
        _classCallCheck(this, BaseUpdateView);

        this._value = value;
        this._boundUpdateFromValue = null;
      }

      _createClass(BaseUpdateView, [{
        key: "subscribeOnMount",
        value: function subscribeOnMount(options) {
          var parentProvidesUpdates = options && options.parentProvidesUpdates;

          if (!parentProvidesUpdates) {
            this._subscribe();
          }
        }
      }, {
        key: "unmount",
        value: function unmount() {
          this._unsubscribe();
        }
      }, {
        key: "_updateFromValue",
        value: function _updateFromValue(changedProps) {
          this.update(this._value, changedProps);
        }
      }, {
        key: "_subscribe",
        value: function _subscribe() {
          var _this$_value;

          if (typeof ((_this$_value = this._value) === null || _this$_value === void 0 ? void 0 : _this$_value.on) === "function") {
            this._boundUpdateFromValue = this._updateFromValue.bind(this);

            this._value.on("change", this._boundUpdateFromValue);
          }
        }
      }, {
        key: "_unsubscribe",
        value: function _unsubscribe() {
          if (this._boundUpdateFromValue) {
            if (typeof this._value.off === "function") {
              this._value.off("change", this._boundUpdateFromValue);
            }

            this._boundUpdateFromValue = null;
          }
        }
      }, {
        key: "value",
        get: function get() {
          return this._value;
        }
      }]);

      return BaseUpdateView;
    }();

    function objHasFns(obj) {
      for (var _i = 0, _Object$values = Object.values(obj); _i < _Object$values.length; _i++) {
        var value = _Object$values[_i];

        if (typeof value === "function") {
          return true;
        }
      }

      return false;
    }

    var TemplateView = /*#__PURE__*/function (_BaseUpdateView) {
      _inherits(TemplateView, _BaseUpdateView);

      var _super = _createSuper(TemplateView);

      function TemplateView(value, render) {
        var _this;

        _classCallCheck(this, TemplateView);

        _this = _super.call(this, value);
        _this._eventListeners = void 0;
        _this._bindings = void 0;
        _this._root = void 0;
        _this._subViews = void 0;
        _this._render = render;
        return _this;
      }

      _createClass(TemplateView, [{
        key: "_attach",
        value: function _attach() {
          if (this._eventListeners) {
            var _iterator = _createForOfIteratorHelper(this._eventListeners),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var _step$value = _step.value,
                    node = _step$value.node,
                    name = _step$value.name,
                    fn = _step$value.fn,
                    useCapture = _step$value.useCapture;
                node.addEventListener(name, fn, useCapture);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }
        }
      }, {
        key: "_detach",
        value: function _detach() {
          if (this._eventListeners) {
            var _iterator2 = _createForOfIteratorHelper(this._eventListeners),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var _step2$value = _step2.value,
                    node = _step2$value.node,
                    name = _step2$value.name,
                    fn = _step2$value.fn,
                    useCapture = _step2$value.useCapture;
                node.removeEventListener(name, fn, useCapture);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        }
      }, {
        key: "mount",
        value: function mount(options) {
          var builder = new TemplateBuilder(this);

          try {
            if (this._render) {
              this._root = this._render(builder, this._value);
            } else if (this["render"]) {
              this._root = this["render"](builder, this._value);
            } else {
              throw new Error("no render function passed in, or overriden in subclass");
            }
          } finally {
            builder.close();
          }

          this.subscribeOnMount(options);

          this._attach();

          return this._root;
        }
      }, {
        key: "unmount",
        value: function unmount() {
          this._detach();

          _get(_getPrototypeOf(TemplateView.prototype), "unmount", this).call(this);

          if (this._subViews) {
            var _iterator3 = _createForOfIteratorHelper(this._subViews),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var v = _step3.value;
                v.unmount();
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
        }
      }, {
        key: "root",
        value: function root() {
          return this._root;
        }
      }, {
        key: "update",
        value: function update(value, props) {
          this._value = value;

          if (this._bindings) {
            var _iterator4 = _createForOfIteratorHelper(this._bindings),
                _step4;

            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var binding = _step4.value;
                binding();
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          }
        }
      }, {
        key: "_addEventListener",
        value: function _addEventListener(node, name, fn) {
          var useCapture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

          if (!this._eventListeners) {
            this._eventListeners = [];
          }

          this._eventListeners.push({
            node: node,
            name: name,
            fn: fn,
            useCapture: useCapture
          });
        }
      }, {
        key: "_addBinding",
        value: function _addBinding(bindingFn) {
          if (!this._bindings) {
            this._bindings = [];
          }

          this._bindings.push(bindingFn);
        }
      }, {
        key: "addSubView",
        value: function addSubView(view) {
          if (!this._subViews) {
            this._subViews = [];
          }

          this._subViews.push(view);
        }
      }, {
        key: "removeSubView",
        value: function removeSubView(view) {
          if (!this._subViews) {
            return;
          }

          var idx = this._subViews.indexOf(view);

          if (idx !== -1) {
            this._subViews.splice(idx, 1);
          }
        }
      }, {
        key: "updateSubViews",
        value: function updateSubViews(value, props) {
          if (this._subViews) {
            var _iterator5 = _createForOfIteratorHelper(this._subViews),
                _step5;

            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var v = _step5.value;
                v.update(value, props);
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          }
        }
      }]);

      return TemplateView;
    }(BaseUpdateView);
    var TemplateBuilder = /*#__PURE__*/function () {
      function TemplateBuilder(templateView) {
        _classCallCheck(this, TemplateBuilder);

        this._closed = false;
        this._templateView = templateView;
      }

      _createClass(TemplateBuilder, [{
        key: "close",
        value: function close() {
          this._closed = true;
        }
      }, {
        key: "_addBinding",
        value: function _addBinding(fn) {
          if (this._closed) {
            console.trace("Adding a binding after render will likely cause memory leaks");
          }

          this._templateView._addBinding(fn);
        }
      }, {
        key: "addEventListener",
        value: function addEventListener(node, name, fn) {
          var useCapture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

          this._templateView._addEventListener(node, name, fn, useCapture);
        }
      }, {
        key: "_addAttributeBinding",
        value: function _addAttributeBinding(node, name, fn) {
          var _this2 = this;

          var prevValue = void 0;

          var binding = function binding() {
            var newValue = fn(_this2._value);

            if (prevValue !== newValue) {
              prevValue = newValue;
              setAttribute(node, name, newValue);
            }
          };

          this._addBinding(binding);

          binding();
        }
      }, {
        key: "_addClassNamesBinding",
        value: function _addClassNamesBinding(node, obj) {
          this._addAttributeBinding(node, "className", function (value) {
            return classNames(obj, value);
          });
        }
      }, {
        key: "_addTextBinding",
        value: function _addTextBinding(fn) {
          var _this3 = this;

          var initialValue = fn(this._value);
          var node = text(initialValue);
          var prevValue = initialValue;

          var binding = function binding() {
            var newValue = fn(_this3._value);

            if (prevValue !== newValue) {
              prevValue = newValue;
              node.textContent = newValue + "";
            }
          };

          this._addBinding(binding);

          return node;
        }
      }, {
        key: "_isEventHandler",
        value: function _isEventHandler(key, value) {
          return key.startsWith("on") && key.length > 2 && typeof value === "function";
        }
      }, {
        key: "_setNodeAttributes",
        value: function _setNodeAttributes(node, attributes) {
          for (var _i2 = 0, _Object$entries = Object.entries(attributes); _i2 < _Object$entries.length; _i2++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
                key = _Object$entries$_i[0],
                value = _Object$entries$_i[1];

            if (_typeof(value) === "object") {
              if (key !== "className" || value === null) {
                continue;
              }

              if (objHasFns(value)) {
                this._addClassNamesBinding(node, value);
              } else {
                setAttribute(node, key, classNames(value, this._value));
              }
            } else if (this._isEventHandler(key, value)) {
              var eventName = key.substr(2, 1).toLowerCase() + key.substr(3);
              var handler = value;

              this._templateView._addEventListener(node, eventName, handler);
            } else if (typeof value === "function") {
              this._addAttributeBinding(node, key, value);
            } else {
              setAttribute(node, key, value);
            }
          }
        }
      }, {
        key: "_setNodeChildren",
        value: function _setNodeChildren(node, children) {
          if (!Array.isArray(children)) {
            children = [children];
          }

          var _iterator6 = _createForOfIteratorHelper(children),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var child = _step6.value;

              if (typeof child === "function") {
                child = this._addTextBinding(child);
              } else if (typeof child === "string") {
                child = text(child);
              }

              node.appendChild(child);
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
        }
      }, {
        key: "_addReplaceNodeBinding",
        value: function _addReplaceNodeBinding(fn, renderNode) {
          var _this4 = this;

          var prevValue = fn(this._value);
          var node = renderNode(null);

          var binding = function binding() {
            var newValue = fn(_this4._value);

            if (prevValue !== newValue) {
              prevValue = newValue;
              var newNode = renderNode(node);

              if (node.parentNode) {
                node.parentNode.replaceChild(newNode, node);
              }

              node = newNode;
            }
          };

          this._addBinding(binding);

          return node;
        }
      }, {
        key: "el",
        value: function el(name, attributes, children) {
          return this.elNS(HTML_NS, name, attributes, children);
        }
      }, {
        key: "elNS",
        value: function elNS(ns, name, attributes, children) {
          if (attributes !== void 0 && isChildren(attributes)) {
            children = attributes;
            attributes = void 0;
          }

          var node = document.createElementNS(ns, name);

          if (attributes) {
            this._setNodeAttributes(node, attributes);
          }

          if (children) {
            this._setNodeChildren(node, children);
          }

          return node;
        }
      }, {
        key: "view",
        value: function view(_view, mountOptions) {
          this._templateView.addSubView(_view);

          return mountView(_view, mountOptions);
        }
      }, {
        key: "mapView",
        value: function mapView(mapFn, viewCreator) {
          var _this5 = this;

          return this._addReplaceNodeBinding(mapFn, function (prevNode) {
            if (prevNode && prevNode.nodeType !== Node.COMMENT_NODE) {
              var subViews = _this5._templateView._subViews;

              if (subViews) {
                var viewIdx = subViews.findIndex(function (v) {
                  return v.root() === prevNode;
                });

                if (viewIdx !== -1) {
                  var _subViews$splice = subViews.splice(viewIdx, 1),
                      _subViews$splice2 = _slicedToArray(_subViews$splice, 1),
                      view2 = _subViews$splice2[0];

                  view2.unmount();
                }
              }
            }

            var view = viewCreator(mapFn(_this5._value));

            if (view) {
              return _this5.view(view);
            } else {
              return document.createComment("node binding placeholder");
            }
          });
        }
      }, {
        key: "map",
        value: function map(mapFn, renderFn) {
          var _this6 = this;

          return this.mapView(mapFn, function (mappedValue) {
            return new TemplateView(_this6._value, function (t, vm) {
              var rootNode = renderFn(mappedValue, t, vm);

              if (!rootNode) {
                return document.createComment("map placeholder");
              }

              return rootNode;
            });
          });
        }
      }, {
        key: "ifView",
        value: function ifView(predicate, viewCreator) {
          var _this7 = this;

          return this.mapView(function (value) {
            return !!predicate(value);
          }, function (enabled) {
            return enabled ? viewCreator(_this7._value) : null;
          });
        }
      }, {
        key: "if",
        value: function _if(predicate, renderFn) {
          return this.ifView(predicate, function (vm) {
            return new TemplateView(vm, renderFn);
          });
        }
      }, {
        key: "mapSideEffect",
        value: function mapSideEffect(mapFn, sideEffect) {
          var _this8 = this;

          var prevValue = mapFn(this._value);

          var binding = function binding() {
            var newValue = mapFn(_this8._value);

            if (prevValue !== newValue) {
              sideEffect(newValue, prevValue);
              prevValue = newValue;
            }
          };

          this._addBinding(binding);

          sideEffect(prevValue, void 0);
        }
      }, {
        key: "_value",
        get: function get() {
          return this._templateView.value;
        }
      }]);

      return TemplateBuilder;
    }();

    var _loop$1 = function _loop() {
      var _Object$entries2$_i = _slicedToArray(_Object$entries2$1[_i3], 2),
          ns = _Object$entries2$_i[0],
          tags = _Object$entries2$_i[1];

      var _iterator7 = _createForOfIteratorHelper(tags),
          _step7;

      try {
        var _loop2 = function _loop2() {
          var tag = _step7.value;

          TemplateBuilder.prototype[tag] = function (attributes, children) {
            return this.elNS(ns, tag, attributes, children);
          };
        };

        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          _loop2();
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
    };

    for (var _i3 = 0, _Object$entries2$1 = Object.entries(TAG_NAMES); _i3 < _Object$entries2$1.length; _i3++) {
      _loop$1();
    }

    /**
     * @param  {Object} vm   view model with {avatarUrl, avatarColorNumber, avatarTitle, avatarLetter}
     * @param  {Number} size
     * @return {Element}
     */

    function renderStaticAvatar(vm, size) {
      var _classNames;

      var extraClasses = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var hasAvatar = !!vm.avatarUrl(size);
      var avatarClasses = classNames((_classNames = {
        avatar: true
      }, _defineProperty(_classNames, "size-".concat(size), true), _defineProperty(_classNames, "usercolor".concat(vm.avatarColorNumber), !hasAvatar), _classNames));

      if (extraClasses) {
        avatarClasses += " ".concat(extraClasses);
      }

      var avatarContent = hasAvatar ? renderImg(vm, size) : text(vm.avatarLetter);
      var avatar = tag.div({
        className: avatarClasses
      }, [avatarContent]);

      if (hasAvatar) {
        setAttribute(avatar, "data-avatar-letter", vm.avatarLetter);
        setAttribute(avatar, "data-avatar-color", vm.avatarColorNumber);
      }

      return avatar;
    }
    function renderImg(vm, size) {
      var sizeStr = size.toString();
      return tag.img({
        src: vm.avatarUrl(size),
        width: sizeStr,
        height: sizeStr,
        title: vm.avatarTitle
      });
    }

    function isAvatarEvent(e) {
      var element = e.target;
      var parent = element.parentElement;
      return element.tagName === "IMG" && parent.classList.contains("avatar");
    }

    function handleAvatarError(e) {
      if (!isAvatarEvent(e)) {
        return;
      }

      var parent = e.target.parentElement;
      var avatarColorNumber = parent.getAttribute("data-avatar-color");
      parent.classList.add("usercolor".concat(avatarColorNumber));
      var avatarLetter = parent.getAttribute("data-avatar-letter");
      parent.textContent = avatarLetter;
    }

    /*
    optimization to not use a sub view when changing between img and text
    because there can be many many instances of this view
    */

    var AvatarView = /*#__PURE__*/function (_BaseUpdateView) {
      _inherits(AvatarView, _BaseUpdateView);

      var _super = _createSuper(AvatarView);

      /**
       * @param  {ViewModel} value   view model with {avatarUrl, avatarColorNumber, avatarTitle, avatarLetter}
       * @param  {Number} size
       */
      function AvatarView(value, size) {
        var _this;

        _classCallCheck(this, AvatarView);

        _this = _super.call(this, value);
        _this._root = null;
        _this._avatarUrl = null;
        _this._avatarTitle = null;
        _this._avatarLetter = null;
        _this._size = size;
        return _this;
      }

      _createClass(AvatarView, [{
        key: "_avatarUrlChanged",
        value: function _avatarUrlChanged() {
          if (this.value.avatarUrl(this._size) !== this._avatarUrl) {
            this._avatarUrl = this.value.avatarUrl(this._size);
            return true;
          }

          return false;
        }
      }, {
        key: "_avatarTitleChanged",
        value: function _avatarTitleChanged() {
          if (this.value.avatarTitle !== this._avatarTitle) {
            this._avatarTitle = this.value.avatarTitle;
            return true;
          }

          return false;
        }
      }, {
        key: "_avatarLetterChanged",
        value: function _avatarLetterChanged() {
          if (this.value.avatarLetter !== this._avatarLetter) {
            this._avatarLetter = this.value.avatarLetter;
            return true;
          }

          return false;
        }
      }, {
        key: "mount",
        value: function mount(options) {
          this._avatarUrlChanged();

          this._avatarLetterChanged();

          this._avatarTitleChanged();

          this._root = renderStaticAvatar(this.value, this._size); // takes care of update being called when needed

          this.subscribeOnMount(options);
          return this._root;
        }
      }, {
        key: "root",
        value: function root() {
          return this._root;
        }
      }, {
        key: "update",
        value: function update(vm) {
          // important to always call _...changed for every prop 
          if (this._avatarUrlChanged()) {
            // avatarColorNumber won't change, it's based on room/user id
            var bgColorClass = "usercolor".concat(vm.avatarColorNumber);

            if (vm.avatarUrl(this._size)) {
              this._root.replaceChild(renderImg(vm, this._size), this._root.firstChild);

              this._root.classList.remove(bgColorClass);
            } else {
              this._root.textContent = vm.avatarLetter;

              this._root.classList.add(bgColorClass);
            }
          }

          var hasAvatar = !!vm.avatarUrl(this._size);

          if (this._avatarTitleChanged() && hasAvatar) {
            var element = this._root.firstChild;

            if (element.tagName === "IMG") {
              element.setAttribute("title", vm.avatarTitle);
            }
          }

          if (this._avatarLetterChanged() && !hasAvatar) {
            this._root.textContent = vm.avatarLetter;
          }
        }
      }]);

      return AvatarView;
    }(BaseUpdateView);

    var RoomTileView = /*#__PURE__*/function (_TemplateView) {
      _inherits(RoomTileView, _TemplateView);

      var _super = _createSuper(RoomTileView);

      function RoomTileView() {
        _classCallCheck(this, RoomTileView);

        return _super.apply(this, arguments);
      }

      _createClass(RoomTileView, [{
        key: "render",
        value: function render(t, vm) {
          var classes = {
            "active": function active(vm) {
              return vm.isOpen;
            },
            "hidden": function hidden(vm) {
              return vm.hidden;
            }
          };
          return t.li({
            "className": classes
          }, [t.a({
            href: vm.url
          }, [t.view(new AvatarView(vm, 32), {
            parentProvidesUpdates: true
          }), t.div({
            className: "description"
          }, [t.div({
            className: {
              "name": true,
              unread: function unread(vm) {
                return vm.isUnread;
              }
            }
          }, function (vm) {
            return vm.name;
          }), t.div({
            className: {
              badge: true,
              highlighted: function highlighted(vm) {
                return vm.isHighlighted;
              },
              hidden: function hidden(vm) {
                return !vm.badgeCount;
              }
            }
          }, function (vm) {
            return vm.badgeCount;
          })])])]);
        }
      }, {
        key: "update",
        value: function update(value, props) {
          _get(_getPrototypeOf(RoomTileView.prototype), "update", this).call(this, value); // update the AvatarView as we told it to not subscribe itself with parentProvidesUpdates


          this.updateSubViews(value, props);
        }
      }]);

      return RoomTileView;
    }(TemplateView);

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var container;
    function spinner(t) {
      var _container;

      var extraClasses = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (container === undefined) {
        container = document.querySelector(".hydrogen");
      }

      if ((_container = container) === null || _container === void 0 ? void 0 : _container.classList.contains("legacy")) {
        return t.div({
          className: "spinner"
        }, [t.div(), t.div(), t.div(), t.div()]);
      } else {
        return t.svg({
          className: Object.assign({
            "spinner": true
          }, extraClasses),
          viewBox: "0 0 100 100"
        }, t.circle({
          cx: "50%",
          cy: "50%",
          r: "45%",
          pathLength: "100"
        }));
      }
    }

    var InviteTileView = /*#__PURE__*/function (_TemplateView) {
      _inherits(InviteTileView, _TemplateView);

      var _super = _createSuper(InviteTileView);

      function InviteTileView() {
        _classCallCheck(this, InviteTileView);

        return _super.apply(this, arguments);
      }

      _createClass(InviteTileView, [{
        key: "render",
        value: function render(t, vm) {
          var classes = {
            "active": function active(vm) {
              return vm.isOpen;
            },
            "hidden": function hidden(vm) {
              return vm.hidden;
            }
          };
          return t.li({
            "className": classes
          }, [t.a({
            href: vm.url
          }, [renderStaticAvatar(vm, 32), t.div({
            className: "description"
          }, [t.div({
            className: "name"
          }, vm.name), t.map(function (vm) {
            return vm.busy;
          }, function (busy) {
            if (busy) {
              return spinner(t);
            } else {
              return t.div({
                className: "badge highlighted"
              }, "!");
            }
          })])])]);
        }
      }]);

      return InviteTileView;
    }(TemplateView);

    function _templateObject9() {
      var data = _taggedTemplateLiteral(["Settings"]);

      _templateObject9 = function _templateObject9() {
        return data;
      };

      return data;
    }

    function _templateObject8() {
      var data = _taggedTemplateLiteral(["Settings"]);

      _templateObject8 = function _templateObject8() {
        return data;
      };

      return data;
    }

    function _templateObject7() {
      var data = _taggedTemplateLiteral(["Filter rooms\u2026"]);

      _templateObject7 = function _templateObject7() {
        return data;
      };

      return data;
    }

    function _templateObject6() {
      var data = _taggedTemplateLiteral(["Back to account list"]);

      _templateObject6 = function _templateObject6() {
        return data;
      };

      return data;
    }

    function _templateObject5() {
      var data = _taggedTemplateLiteral(["Back to account list"]);

      _templateObject5 = function _templateObject5() {
        return data;
      };

      return data;
    }

    function _templateObject4() {
      var data = _taggedTemplateLiteral(["Enable grid layout"]);

      _templateObject4 = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3() {
      var data = _taggedTemplateLiteral(["Show single room"]);

      _templateObject3 = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2() {
      var data = _taggedTemplateLiteral(["Clear"]);

      _templateObject2 = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject() {
      var data = _taggedTemplateLiteral(["Clear"]);

      _templateObject = function _templateObject() {
        return data;
      };

      return data;
    }

    var FilterField = /*#__PURE__*/function (_TemplateView) {
      _inherits(FilterField, _TemplateView);

      var _super = _createSuper(FilterField);

      function FilterField() {
        _classCallCheck(this, FilterField);

        return _super.apply(this, arguments);
      }

      _createClass(FilterField, [{
        key: "render",
        value: function render(t, options) {
          var clear = function clear() {
            filterInput.value = "";
            filterInput.blur();
            clearButton.blur();
            options.clear();
          };

          var filterInput = t.input({
            type: "text",
            placeholder: options === null || options === void 0 ? void 0 : options.label,
            "aria-label": options === null || options === void 0 ? void 0 : options.label,
            autocomplete: options === null || options === void 0 ? void 0 : options.autocomplete,
            enterkeyhint: 'search',
            name: options === null || options === void 0 ? void 0 : options.name,
            onInput: function onInput(event) {
              return options.set(event.target.value);
            },
            onKeydown: function onKeydown(event) {
              if (event.key === "Escape" || event.key === "Esc") {
                clear();
              }
            },
            onFocus: function onFocus() {
              return filterInput.select();
            }
          });
          var clearButton = t.button({
            onClick: clear,
            title: options.i18n(_templateObject()),
            "aria-label": options.i18n(_templateObject2())
          });
          return t.div({
            className: "FilterField"
          }, [filterInput, clearButton]);
        }
      }]);

      return FilterField;
    }(TemplateView);

    var LeftPanelView = /*#__PURE__*/function (_TemplateView2) {
      _inherits(LeftPanelView, _TemplateView2);

      var _super2 = _createSuper(LeftPanelView);

      function LeftPanelView() {
        _classCallCheck(this, LeftPanelView);

        return _super2.apply(this, arguments);
      }

      _createClass(LeftPanelView, [{
        key: "render",
        value: function render(t, vm) {
          var gridButtonLabel = function gridButtonLabel(vm) {
            return vm.gridEnabled ? vm.i18n(_templateObject3()) : vm.i18n(_templateObject4());
          };

          var roomList = t.view(new ListView({
            className: "RoomList",
            list: vm.tileViewModels
          }, function (tileVM) {
            if (tileVM.kind === "invite") {
              return new InviteTileView(tileVM);
            } else {
              return new RoomTileView(tileVM);
            }
          }));
          var utilitiesRow = t.div({
            className: "utilities"
          }, [t.a({
            className: "button-utility close-session",
            href: vm.closeUrl,
            "aria-label": vm.i18n(_templateObject5()),
            title: vm.i18n(_templateObject6())
          }), t.view(new FilterField({
            i18n: vm.i18n,
            label: vm.i18n(_templateObject7()),
            name: "room-filter",
            autocomplete: true,
            set: function set(query) {
              // scroll up if we just started filtering
              if (vm.setFilter(query)) {
                roomList.scrollTop = 0;
              }
            },
            clear: function clear() {
              return vm.clearFilter();
            }
          })), t.button({
            onClick: function onClick() {
              return vm.toggleGrid();
            },
            className: {
              "button-utility": true,
              grid: true,
              on: function on(vm) {
                return vm.gridEnabled;
              }
            },
            title: gridButtonLabel,
            "aria-label": gridButtonLabel
          }), t.a({
            className: "button-utility settings",
            href: vm.settingsUrl,
            "aria-label": vm.i18n(_templateObject8()),
            title: vm.i18n(_templateObject9())
          })]);
          return t.div({
            className: "LeftPanel"
          }, [utilitiesRow, roomList]);
        }
      }]);

      return LeftPanelView;
    }(TemplateView);

    var Popup = /*#__PURE__*/function () {
      function Popup(view) {
        var closeCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        _classCallCheck(this, Popup);

        this._view = view;
        this._target = null;
        this._arrangement = null;
        this._scroller = null;
        this._fakeRoot = null;
        this._trackingTemplateView = null;
        this._closeCallback = closeCallback;
      }

      _createClass(Popup, [{
        key: "_getPopupContainer",
        value: function _getPopupContainer() {
          var appContainer = this._target.closest(".hydrogen");

          var popupContainer = appContainer.querySelector(".popupContainer");

          if (!popupContainer) {
            popupContainer = tag.div({
              className: "popupContainer"
            });
            appContainer.appendChild(popupContainer);
          }

          return popupContainer;
        }
      }, {
        key: "trackInTemplateView",
        value: function trackInTemplateView(templateView) {
          this._trackingTemplateView = templateView;

          this._trackingTemplateView.addSubView(this);
        }
      }, {
        key: "showRelativeTo",
        value: function showRelativeTo(target) {
          var _this = this;

          var verticalPadding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          this._target = target;
          this._verticalPadding = verticalPadding;
          this._scroller = findScrollParent(this._target);

          this._view.mount();

          this._getPopupContainer().appendChild(this._popup);

          this._position();

          if (this._scroller) {
            document.body.addEventListener("scroll", this, true);
          }

          setTimeout(function () {
            document.body.addEventListener("click", _this, false);
          }, 10);
        }
      }, {
        key: "close",
        value: function close() {
          if (this._view) {
            this._view.unmount();

            this._trackingTemplateView.removeSubView(this);

            if (this._scroller) {
              document.body.removeEventListener("scroll", this, true);
            }

            document.body.removeEventListener("click", this, false);

            this._popup.remove();

            this._view = null;

            if (this._closeCallback) {
              this._closeCallback();
            }
          }
        }
      }, {
        key: "handleEvent",
        value: function handleEvent(evt) {
          if (evt.type === "scroll") {
            if (!this._position()) {
              this.close();
            }
          } else if (evt.type === "click") {
            this._onClick(evt);
          }
        }
      }, {
        key: "_onClick",
        value: function _onClick() {
          this.close();
        }
      }, {
        key: "_position",
        value: function _position() {
          var targetPosition = this._target.getBoundingClientRect();

          var popupWidth = this._popup.clientWidth;
          var popupHeight = this._popup.clientHeight;
          var viewport = (this._scroller ? this._scroller : document.documentElement).getBoundingClientRect();

          if (targetPosition.top > viewport.bottom || targetPosition.left > viewport.right || targetPosition.bottom < viewport.top || targetPosition.right < viewport.left) {
            return false;
          }

          if (viewport.bottom >= targetPosition.bottom + popupHeight) {
            // show below
            this._popup.style.top = "".concat(targetPosition.bottom + this._verticalPadding, "px");
          } else if (viewport.top <= targetPosition.top - popupHeight) {
            // show top
            this._popup.style.top = "".concat(targetPosition.top - popupHeight - this._verticalPadding, "px");
          } else {
            return false;
          }

          if (viewport.right >= targetPosition.right + popupWidth) {
            // show right
            this._popup.style.left = "".concat(targetPosition.left, "px");
          } else if (viewport.left <= targetPosition.left - popupWidth) {
            // show left
            this._popup.style.left = "".concat(targetPosition.right - popupWidth, "px");
          } else {
            return false;
          }

          return true;
        }
        /* fake IView api, so it can be tracked by a template view as a subview */

      }, {
        key: "root",
        value: function root() {
          return this._fakeRoot;
        }
      }, {
        key: "mount",
        value: function mount() {
          this._fakeRoot = document.createComment("popup");
          return this._fakeRoot;
        }
      }, {
        key: "unmount",
        value: function unmount() {
          this.close();
        }
      }, {
        key: "update",
        value: function update() {}
      }, {
        key: "isOpen",
        get: function get() {
          return !!this._view;
        }
      }, {
        key: "_popup",
        get: function get() {
          return this._view.root();
        }
      }]);

      return Popup;
    }();

    function findScrollParent(el) {
      var parent = el;

      do {
        parent = parent.parentElement;

        if (parent.scrollHeight > parent.clientHeight) {
          // double check that overflow would allow a scrollbar
          // because some elements, like a button with negative margin to increate the click target
          // can cause the scrollHeight to be larger than the clientHeight in the parent
          // see button.link class
          var style = window.getComputedStyle(parent);
          var overflowY = style.getPropertyValue("overflow-y");

          if (overflowY === "auto" || overflowY === "scroll") {
            return parent;
          }
        }
      } while (parent !== document.body);
    }

    var Menu = /*#__PURE__*/function (_TemplateView) {
      _inherits(Menu, _TemplateView);

      var _super = _createSuper(Menu);

      _createClass(Menu, null, [{
        key: "option",
        value: function option(label, callback) {
          return new MenuOption(label, callback);
        }
      }]);

      function Menu(options) {
        var _this;

        _classCallCheck(this, Menu);

        _this = _super.call(this);
        _this._options = options;
        return _this;
      }

      _createClass(Menu, [{
        key: "render",
        value: function render(t) {
          return t.ul({
            className: "menu",
            role: "menu"
          }, this._options.map(function (o) {
            return o.toDOM(t);
          }));
        }
      }]);

      return Menu;
    }(TemplateView);

    var MenuOption = /*#__PURE__*/function () {
      function MenuOption(label, callback) {
        _classCallCheck(this, MenuOption);

        this.label = label;
        this.callback = callback;
        this.icon = null;
        this.destructive = false;
      }

      _createClass(MenuOption, [{
        key: "setIcon",
        value: function setIcon(className) {
          this.icon = className;
          return this;
        }
      }, {
        key: "setDestructive",
        value: function setDestructive() {
          this.destructive = true;
          return this;
        }
      }, {
        key: "toDOM",
        value: function toDOM(t) {
          var className = {
            destructive: this.destructive
          };

          if (this.icon) {
            className.icon = true;
            className[this.icon] = true;
          }

          return t.li({
            className: className
          }, t.button({
            className: "menu-item",
            onClick: this.callback
          }, this.label));
        }
      }]);

      return MenuOption;
    }();

    function _templateObject2$1() {
      var data = _taggedTemplateLiteral(["Not loading!"]);

      _templateObject2$1 = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$1() {
      var data = _taggedTemplateLiteral(["Loading more messages \u2026"]);

      _templateObject$1 = function _templateObject() {
        return data;
      };

      return data;
    }
    var GapView = /*#__PURE__*/function (_TemplateView) {
      _inherits(GapView, _TemplateView);

      var _super = _createSuper(GapView);

      function GapView() {
        _classCallCheck(this, GapView);

        return _super.apply(this, arguments);
      }

      _createClass(GapView, [{
        key: "render",
        value: function render(t) {
          var className = {
            GapView: true,
            isLoading: function isLoading(vm) {
              return vm.isLoading;
            },
            isAtTop: function isAtTop(vm) {
              return vm.isAtTop;
            }
          };
          return t.li({
            className: className
          }, [spinner(t), t.div(function (vm) {
            return vm.isLoading ? vm.i18n(_templateObject$1()) : vm.i18n(_templateObject2$1());
          }), t.if(function (vm) {
            return vm.error;
          }, function (t) {
            return t.strong(function (vm) {
              return vm.error;
            });
          })]);
        }
        /* This is called by the parent ListView, which just has 1 listener for the whole list */

      }, {
        key: "onClick",
        value: function onClick() {}
      }]);

      return GapView;
    }(TemplateView);

    var ReactionsView = /*#__PURE__*/function (_ListView) {
      _inherits(ReactionsView, _ListView);

      var _super = _createSuper(ReactionsView);

      function ReactionsView(reactionsViewModel) {
        _classCallCheck(this, ReactionsView);

        var options = {
          className: "Timeline_messageReactions",
          tagName: "div",
          list: reactionsViewModel.reactions,
          onItemClick: function onItemClick(reactionView) {
            return reactionView.onClick();
          }
        };
        return _super.call(this, options, function (reactionVM) {
          return new ReactionView(reactionVM);
        });
      }

      return ReactionsView;
    }(ListView);

    var ReactionView = /*#__PURE__*/function (_TemplateView) {
      _inherits(ReactionView, _TemplateView);

      var _super2 = _createSuper(ReactionView);

      function ReactionView() {
        _classCallCheck(this, ReactionView);

        return _super2.apply(this, arguments);
      }

      _createClass(ReactionView, [{
        key: "render",
        value: function render(t, vm) {
          return t.button({
            className: {
              active: function active(vm) {
                return vm.isActive;
              },
              pending: function pending(vm) {
                return vm.isPending;
              }
            }
          }, [vm.key, " ", function (vm) {
            return "".concat(vm.count);
          }]);
        }
      }, {
        key: "onClick",
        value: function onClick() {
          this.value.toggle();
        }
      }]);

      return ReactionView;
    }(TemplateView);

    function _templateObject3$1() {
      var data = _taggedTemplateLiteral(["Delete"]);

      _templateObject3$1 = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$2() {
      var data = _taggedTemplateLiteral(["Cancel"]);

      _templateObject2$2 = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$2() {
      var data = _taggedTemplateLiteral(["Reply"]);

      _templateObject$2 = function _templateObject() {
        return data;
      };

      return data;
    }
    var BaseMessageView = /*#__PURE__*/function (_TemplateView) {
      _inherits(BaseMessageView, _TemplateView);

      var _super = _createSuper(BaseMessageView);

      function BaseMessageView(value) {
        var _this;

        var interactive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var tagName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "li";

        _classCallCheck(this, BaseMessageView);

        _this = _super.call(this, value);
        _this._menuPopup = null;
        _this._tagName = tagName; // TODO An enum could be nice to make code easier to read at call sites.

        _this._interactive = interactive;
        return _this;
      }

      _createClass(BaseMessageView, [{
        key: "render",
        value: function render(t, vm) {
          var _this2 = this;

          var children = [this.renderMessageBody(t, vm)];

          if (this._interactive) {
            children.push(t.button({
              className: "Timeline_messageOptions"
            }, "⋯"));
          }

          var li = t.el(this._tagName, {
            className: {
              "Timeline_message": true,
              own: vm.isOwn,
              unsent: vm.isUnsent,
              unverified: vm.isUnverified,
              disabled: !this._interactive,
              continuation: function continuation(vm) {
                return vm.isContinuation;
              }
            }
          }, children); // given that there can be many tiles, we don't add
          // unneeded DOM nodes in case of a continuation, and we add it
          // with a side-effect binding to not have to create sub views,
          // as the avatar or sender doesn't need any bindings or event handlers.
          // don't use `t` from within the side-effect callback

          t.mapSideEffect(function (vm) {
            return vm.isContinuation;
          }, function (isContinuation, wasContinuation) {
            if (isContinuation && wasContinuation === false) {
              li.removeChild(li.querySelector(".Timeline_messageAvatar"));
              li.removeChild(li.querySelector(".Timeline_messageSender"));
            } else if (!isContinuation) {
              var avatar = tag.a({
                href: vm.memberPanelLink,
                className: "Timeline_messageAvatar"
              }, [renderStaticAvatar(vm, 30)]);
              var sender = tag.div({
                className: "Timeline_messageSender usercolor".concat(vm.avatarColorNumber)
              }, vm.displayName);
              li.insertBefore(avatar, li.firstChild);
              li.insertBefore(sender, li.firstChild);
            }
          }); // similarly, we could do this with a simple ifView,
          // but that adds a comment node to all messages without reactions

          var reactionsView = null;
          t.mapSideEffect(function (vm) {
            return vm.reactions;
          }, function (reactions) {
            if (reactions && _this2._interactive && !reactionsView) {
              reactionsView = new ReactionsView(reactions);

              _this2.addSubView(reactionsView);

              li.appendChild(mountView(reactionsView));
            } else if (!reactions && reactionsView) {
              li.removeChild(reactionsView.root());
              reactionsView.unmount();

              _this2.removeSubView(reactionsView);

              reactionsView = null;
            }
          });
          return li;
        }
        /* This is called by the parent ListView, which just has 1 listener for the whole list */

      }, {
        key: "onClick",
        value: function onClick(evt) {
          if (evt.target.className === "Timeline_messageOptions") {
            this._toggleMenu(evt.target);
          }
        }
      }, {
        key: "_toggleMenu",
        value: function _toggleMenu(button) {
          var _this3 = this;

          if (this._menuPopup && this._menuPopup.isOpen) {
            this._menuPopup.close();
          } else {
            var options = this.createMenuOptions(this.value);

            if (!options.length) {
              return;
            }

            this.root().classList.add("menuOpen");

            var onClose = function onClose() {
              return _this3.root().classList.remove("menuOpen");
            };

            this._menuPopup = new Popup(new Menu(options), onClose);

            this._menuPopup.trackInTemplateView(this);

            this._menuPopup.showRelativeTo(button, 2);
          }
        }
      }, {
        key: "createMenuOptions",
        value: function createMenuOptions(vm) {
          var options = [];

          if (vm.canReact && vm.shape !== "redacted") {
            options.push(new QuickReactionsMenuOption(vm));
            options.push(Menu.option(vm.i18n(_templateObject$2()), function () {
              return vm.startReply();
            }));
          }

          if (vm.canAbortSending) {
            options.push(Menu.option(vm.i18n(_templateObject2$2()), function () {
              return vm.abortSending();
            }));
          } else if (vm.canRedact) {
            options.push(Menu.option(vm.i18n(_templateObject3$1()), function () {
              return vm.redact();
            }).setDestructive());
          }

          return options;
        }
      }, {
        key: "renderMessageBody",
        value: function renderMessageBody() {}
      }]);

      return BaseMessageView;
    }(TemplateView);

    var QuickReactionsMenuOption = /*#__PURE__*/function () {
      function QuickReactionsMenuOption(vm) {
        _classCallCheck(this, QuickReactionsMenuOption);

        this._vm = vm;
      }

      _createClass(QuickReactionsMenuOption, [{
        key: "toDOM",
        value: function toDOM(t) {
          var _this4 = this;

          var emojiButtons = ["👍", "👎", "😄", "🎉", "😕", "❤️", "🚀", "👀"].map(function (emoji) {
            return t.button({
              onClick: function onClick() {
                return _this4._vm.react(emoji);
              }
            }, emoji);
          });
          var customButton = t.button({
            onClick: function onClick() {
              var key = prompt("Enter your reaction (emoji)");

              if (key) {
                _this4._vm.react(key);
              }
            }
          }, "…");
          return t.li({
            className: "quick-reactions"
          }, [].concat(_toConsumableArray(emojiButtons), [customButton]));
        }
      }]);

      return QuickReactionsMenuOption;
    }();

    var TextMessageView = /*#__PURE__*/function (_BaseMessageView) {
      _inherits(TextMessageView, _BaseMessageView);

      var _super = _createSuper(TextMessageView);

      function TextMessageView() {
        _classCallCheck(this, TextMessageView);

        return _super.apply(this, arguments);
      }

      _createClass(TextMessageView, [{
        key: "renderMessageBody",
        value: function renderMessageBody(t, vm) {
          var time = t.time({
            className: {
              hidden: !vm.date
            }
          }, vm.date + " " + vm.time);
          var container = t.div({
            className: {
              "Timeline_messageBody": true,
              statusMessage: function statusMessage(vm) {
                return vm.shape === "message-status";
              }
            }
          });
          t.mapSideEffect(function (vm) {
            return vm.body;
          }, function (body) {
            while (container.lastChild) {
              container.removeChild(container.lastChild);
            }

            var _iterator = _createForOfIteratorHelper(body.parts),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var part = _step.value;
                container.appendChild(renderPart(part));
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            container.appendChild(time);
          });
          return container;
        }
      }]);

      return TextMessageView;
    }(BaseMessageView);

    function renderList(listBlock) {
      var items = listBlock.items.map(function (item) {
        return tag.li(renderParts(item));
      });
      var start = listBlock.startOffset;

      if (start) {
        return tag.ol({
          start: start
        }, items);
      } else {
        return tag.ul(items);
      }
    }

    function renderImage(imagePart) {
      var attributes = {
        src: imagePart.src
      };

      if (imagePart.width) {
        attributes.width = imagePart.width;
      }

      if (imagePart.height) {
        attributes.height = imagePart.height;
      }

      if (imagePart.alt) {
        attributes.alt = imagePart.alt;
      }

      if (imagePart.title) {
        attributes.title = imagePart.title;
      }

      return tag.img(attributes);
    }

    function renderPill(pillPart) {
      // The classes and structure are borrowed from avatar.js;
      // We don't call renderStaticAvatar because that would require
      // an intermediate object that has getAvatarUrl etc.
      var classes = "avatar size-12 usercolor".concat(pillPart.avatarColorNumber);
      var avatar = tag.div({
        class: classes
      }, text(pillPart.avatarInitials));
      var children = renderParts(pillPart.children);
      children.unshift(avatar);
      return tag.a({
        class: "pill",
        href: pillPart.href,
        rel: "noopener",
        target: "_blank"
      }, children);
    }

    function renderTable(tablePart) {
      var children = [];

      if (tablePart.head) {
        var headers = tablePart.head.map(function (cell) {
          return tag.th(renderParts(cell));
        });
        children.push(tag.thead(tag.tr(headers)));
      }

      var rows = [];

      var _iterator2 = _createForOfIteratorHelper(tablePart.body),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var row = _step2.value;
          var data = row.map(function (cell) {
            return tag.td(renderParts(cell));
          });
          rows.push(tag.tr(data));
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      children.push(tag.tbody(rows));
      return tag.table(children);
    }
    /**
     * Map from part to function that outputs DOM for the part
     */


    var formatFunction = {
      header: function header(headerBlock) {
        return tag["h" + Math.min(6, headerBlock.level)](renderParts(headerBlock.inlines));
      },
      codeblock: function codeblock(codeBlock) {
        return tag.pre(tag.code(text(codeBlock.text)));
      },
      table: function table(tableBlock) {
        return renderTable(tableBlock);
      },
      code: function code(codePart) {
        return tag.code(text(codePart.text));
      },
      text: function text$1(textPart) {
        return text(textPart.text);
      },
      link: function link(linkPart) {
        return tag.a({
          href: linkPart.url,
          className: "link",
          target: "_blank",
          rel: "noopener"
        }, renderParts(linkPart.inlines));
      },
      pill: renderPill,
      format: function format(formatPart) {
        return tag[formatPart.format](renderParts(formatPart.children));
      },
      rule: function rule() {
        return tag.hr();
      },
      list: renderList,
      image: renderImage,
      newline: function newline() {
        return tag.br();
      }
    };

    function renderPart(part) {
      var f = formatFunction[part.type];

      if (!f) {
        return text("[unknown part type ".concat(part.type, "]"));
      }

      return f(part);
    }

    function renderParts(parts) {
      return Array.from(parts, renderPart);
    }

    var BaseMediaView = /*#__PURE__*/function (_BaseMessageView) {
      _inherits(BaseMediaView, _BaseMessageView);

      var _super = _createSuper(BaseMediaView);

      function BaseMediaView() {
        _classCallCheck(this, BaseMediaView);

        return _super.apply(this, arguments);
      }

      _createClass(BaseMediaView, [{
        key: "renderMessageBody",
        value: function renderMessageBody(t, vm) {
          var heightRatioPercent = vm.height / vm.width * 100;
          var spacerStyle = "padding-top: ".concat(heightRatioPercent, "%;");

          if (vm.platform.isIE11) {
            // preserving aspect-ratio in a grid with padding percentages
            // does not work in IE11, so we assume people won't use it
            // with viewports narrower than 400px where thumbnails will get
            // scaled. If they do, the thumbnail will still scale, but
            // there will be whitespace underneath the picture
            // An alternative would be to use position: absolute but that
            // can slow down rendering, and was bleeding through the lightbox.
            spacerStyle = "height: ".concat(vm.height, "px");
          }

          var children = [t.div({
            className: "spacer",
            style: spacerStyle
          }), this.renderMedia(t, vm), t.time(vm.date + " " + vm.time)];

          if (vm.isPending) {
            var sendStatus = t.div({
              className: {
                sendStatus: true,
                hidden: function hidden(vm) {
                  return !vm.sendStatus;
                }
              }
            }, function (vm) {
              return vm.sendStatus;
            });
            var progress = t.progress({
              min: 0,
              max: 100,
              value: function value(vm) {
                return vm.uploadPercentage;
              },
              className: {
                hidden: function hidden(vm) {
                  return !vm.isUploading;
                }
              }
            });
            children.push(sendStatus, progress);
          }

          return t.div({
            className: "Timeline_messageBody"
          }, [t.div({
            className: "media",
            style: "max-width: ".concat(vm.width, "px")
          }, children), t.if(function (vm) {
            return vm.error;
          }, function (t) {
            return t.p({
              className: "error"
            }, vm.error);
          })]);
        }
      }]);

      return BaseMediaView;
    }(BaseMessageView);

    var ImageView = /*#__PURE__*/function (_BaseMediaView) {
      _inherits(ImageView, _BaseMediaView);

      var _super = _createSuper(ImageView);

      function ImageView() {
        _classCallCheck(this, ImageView);

        return _super.apply(this, arguments);
      }

      _createClass(ImageView, [{
        key: "renderMedia",
        value: function renderMedia(t, vm) {
          var img = t.img({
            loading: "lazy",
            src: function src(vm) {
              return vm.thumbnailUrl;
            },
            alt: function alt(vm) {
              return vm.label;
            },
            title: function title(vm) {
              return vm.label;
            },
            style: "max-width: ".concat(vm.width, "px; max-height: ").concat(vm.height, "px;")
          });
          return vm.isPending ? img : t.a({
            href: vm.lightboxUrl
          }, img);
        }
      }]);

      return ImageView;
    }(BaseMediaView);

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function domEventAsPromise(element, successEvent) {
      return new Promise(function (resolve, reject) {
        var detach;

        var handleError = function handleError(evt) {
          detach();
          reject(evt.target.error);
        };

        var handleSuccess = function handleSuccess() {
          detach();
          resolve();
        };

        detach = function detach() {
          element.removeEventListener(successEvent, handleSuccess);
          element.removeEventListener("error", handleError);
        };

        element.addEventListener(successEvent, handleSuccess);
        element.addEventListener("error", handleError);
      });
    }

    var VideoView = /*#__PURE__*/function (_BaseMediaView) {
      _inherits(VideoView, _BaseMediaView);

      var _super = _createSuper(VideoView);

      function VideoView() {
        _classCallCheck(this, VideoView);

        return _super.apply(this, arguments);
      }

      _createClass(VideoView, [{
        key: "renderMedia",
        value: function renderMedia(t) {
          var video = t.video({
            // provide empty data url if video is not decrypted yet.
            // Chrome/Electron need this to enable the play button.
            src: function src(vm) {
              return vm.videoUrl || "data:".concat(vm.mimeType, ",");
            },
            title: function title(vm) {
              return vm.label;
            },
            controls: true,
            preload: "none",
            poster: function poster(vm) {
              return vm.thumbnailUrl;
            },
            onPlay: this._onPlay.bind(this),
            style: function style(vm) {
              return "max-width: ".concat(vm.width, "px; max-height: ").concat(vm.height, "px;").concat(vm.isPending ? "z-index: -1" : "");
            }
          });
          video.addEventListener("error", this._onError.bind(this));
          return video;
        }
      }, {
        key: "_onPlay",
        value: function () {
          var _onPlay2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(evt) {
            var vm, video, loadPromise;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    vm = this.value; // download and decrypt the video if needed,

                    if (vm.videoUrl) {
                      _context.next = 15;
                      break;
                    }

                    _context.prev = 2;
                    video = evt.target; // this will trigger the src to update

                    _context.next = 6;
                    return vm.loadVideo();

                  case 6:
                    // important to only listen for this after src has changed,
                    // or we get the error for the placeholder data url
                    loadPromise = domEventAsPromise(video, "loadeddata"); // now, reload the video and play

                    video.load();
                    _context.next = 10;
                    return loadPromise;

                  case 10:
                    video.play();
                    _context.next = 15;
                    break;

                  case 13:
                    _context.prev = 13;
                    _context.t0 = _context["catch"](2);

                  case 15:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[2, 13]]);
          }));

          function _onPlay(_x) {
            return _onPlay2.apply(this, arguments);
          }

          return _onPlay;
        }()
      }, {
        key: "_onError",
        value: function _onError(evt) {
          var vm = this.value;
          var video = evt.target;
          var err = video.error;

          if (err instanceof window.MediaError && err.code === 4) {
            if (!video.src.startsWith("data:")) {
              vm.setViewError(new Error("this browser does not support videos of type ".concat(vm.mimeType, ".")));
            } else {
              // ignore placeholder url failing to load
              return;
            }
          } else {
            vm.setViewError(err);
          }
        }
      }]);

      return VideoView;
    }(BaseMediaView);

    var FileView = /*#__PURE__*/function (_BaseMessageView) {
      _inherits(FileView, _BaseMessageView);

      var _super = _createSuper(FileView);

      function FileView() {
        _classCallCheck(this, FileView);

        return _super.apply(this, arguments);
      }

      _createClass(FileView, [{
        key: "renderMessageBody",
        value: function renderMessageBody(t, vm) {
          var children = [];

          if (vm.isPending) {
            children.push(function (vm) {
              return vm.label;
            });
          } else {
            children.push(t.button({
              className: "link",
              onClick: function onClick() {
                return vm.download();
              }
            }, function (vm) {
              return vm.label;
            }), t.time(vm.date + " " + vm.time));
          }

          return t.p({
            className: "Timeline_messageBody statusMessage"
          }, children);
        }
      }]);

      return FileView;
    }(BaseMessageView);

    var MissingAttachmentView = /*#__PURE__*/function (_BaseMessageView) {
      _inherits(MissingAttachmentView, _BaseMessageView);

      var _super = _createSuper(MissingAttachmentView);

      function MissingAttachmentView() {
        _classCallCheck(this, MissingAttachmentView);

        return _super.apply(this, arguments);
      }

      _createClass(MissingAttachmentView, [{
        key: "renderMessageBody",
        value: function renderMessageBody(t, vm) {
          return t.p({
            className: "Timeline_messageBody statusMessage"
          }, vm.label);
        }
      }]);

      return MissingAttachmentView;
    }(BaseMessageView);

    var AnnouncementView = /*#__PURE__*/function (_TemplateView) {
      _inherits(AnnouncementView, _TemplateView);

      var _super = _createSuper(AnnouncementView);

      function AnnouncementView() {
        _classCallCheck(this, AnnouncementView);

        return _super.apply(this, arguments);
      }

      _createClass(AnnouncementView, [{
        key: "render",
        value: function render(t) {
          return t.li({
            className: "AnnouncementView"
          }, t.div(function (vm) {
            return vm.announcement;
          }));
        }
        /* This is called by the parent ListView, which just has 1 listener for the whole list */

      }, {
        key: "onClick",
        value: function onClick() {}
      }]);

      return AnnouncementView;
    }(TemplateView);

    function _templateObject$3() {
      var data = _taggedTemplateLiteral(["Cancel"]);

      _templateObject$3 = function _templateObject() {
        return data;
      };

      return data;
    }
    var RedactedView = /*#__PURE__*/function (_BaseMessageView) {
      _inherits(RedactedView, _BaseMessageView);

      var _super = _createSuper(RedactedView);

      function RedactedView() {
        _classCallCheck(this, RedactedView);

        return _super.apply(this, arguments);
      }

      _createClass(RedactedView, [{
        key: "renderMessageBody",
        value: function renderMessageBody(t) {
          return t.p({
            className: "Timeline_messageBody statusMessage"
          }, function (vm) {
            return vm.description;
          });
        }
      }, {
        key: "createMenuOptions",
        value: function createMenuOptions(vm) {
          var options = _get(_getPrototypeOf(RedactedView.prototype), "createMenuOptions", this).call(this, vm);

          if (vm.isRedacting) {
            options.push(Menu.option(vm.i18n(_templateObject$3()), function () {
              return vm.abortPendingRedaction();
            }));
          }

          return options;
        }
      }]);

      return RedactedView;
    }(BaseMessageView);

    function viewClassForEntry(entry) {
      switch (entry.shape) {
        case "gap":
          return GapView;

        case "announcement":
          return AnnouncementView;

        case "message":
        case "message-status":
          return TextMessageView;

        case "image":
          return ImageView;

        case "video":
          return VideoView;

        case "file":
          return FileView;

        case "missing-attachment":
          return MissingAttachmentView;

        case "redacted":
          return RedactedView;
      }
    }

    function bottom(node) {
      return node.offsetTop + node.clientHeight;
    }

    function findFirstNodeIndexAtOrBelow(tiles, top) {
      var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : tiles.children.length - 1;

      for (var i = startIndex; i >= 0; i--) {
        var node = tiles.children[i];

        if (node.offsetTop < top) {
          return i;
        }
      }

      return 0;
    }

    var TimelineView = /*#__PURE__*/function (_TemplateView) {
      _inherits(TimelineView, _TemplateView);

      var _super = _createSuper(TimelineView);

      function TimelineView() {
        var _this;

        _classCallCheck(this, TimelineView);

        _this = _super.apply(this, arguments);
        _this.anchoredBottom = 0;
        _this.stickToBottom = true;
        return _this;
      }

      _createClass(TimelineView, [{
        key: "render",
        value: function render(t, vm) {
          var _this2 = this;

          requestAnimationFrame(function () {
            _this2.restoreScrollPosition();
          });
          this.tilesView = new TilesListView(vm.tiles, function () {
            return _this2.restoreScrollPosition();
          });
          var root = t.div({
            className: "Timeline"
          }, [t.div({
            className: "Timeline_scroller bottom-aligned-scroll",
            onScroll: function onScroll() {
              return _this2.onScroll();
            }
          }, t.view(this.tilesView)), t.button({
            className: {
              Timeline_jumpDown: true,
              hidden: function hidden(vm2) {
                return !vm2.showJumpDown;
              }
            },
            title: "Jump down",
            onClick: function onClick() {
              return _this2.jumpDown();
            }
          })]);

          if (typeof ResizeObserver === "function") {
            this.resizeObserver = new ResizeObserver(function () {
              _this2.restoreScrollPosition();
            });
            this.resizeObserver.observe(root);
          }

          return root;
        }
      }, {
        key: "jumpDown",
        value: function jumpDown() {
          var scrollNode = this.scrollNode;
          this.stickToBottom = true;
          scrollNode.scrollTop = scrollNode.scrollHeight;
        }
      }, {
        key: "unmount",
        value: function unmount() {
          _get(_getPrototypeOf(TimelineView.prototype), "unmount", this).call(this);

          if (this.resizeObserver) {
            this.resizeObserver.unobserve(this.root());
            this.resizeObserver = void 0;
          }
        }
      }, {
        key: "restoreScrollPosition",
        value: function restoreScrollPosition() {
          var scrollNode = this.scrollNode,
              tilesNode = this.tilesNode;
          var missingTilesHeight = scrollNode.clientHeight - tilesNode.clientHeight;

          if (missingTilesHeight > 0) {
            tilesNode.style.setProperty("margin-top", "".concat(missingTilesHeight, "px"));
            var len = this.value.tiles.length;
            this.updateVisibleRange(0, len - 1);
          } else {
            tilesNode.style.removeProperty("margin-top");

            if (this.stickToBottom) {
              scrollNode.scrollTop = scrollNode.scrollHeight;
            } else if (this.anchoredNode) {
              var newAnchoredBottom = bottom(this.anchoredNode);

              if (newAnchoredBottom !== this.anchoredBottom) {
                var bottomDiff = newAnchoredBottom - this.anchoredBottom;

                if (typeof scrollNode.scrollBy === "function") {
                  scrollNode.scrollBy(0, bottomDiff);
                } else {
                  scrollNode.scrollTop = scrollNode.scrollTop + bottomDiff;
                }

                this.anchoredBottom = newAnchoredBottom;
              }
            }
          }
        }
      }, {
        key: "onScroll",
        value: function onScroll() {
          var scrollNode = this.scrollNode,
              tilesNode = this.tilesNode;
          var scrollHeight = scrollNode.scrollHeight,
              scrollTop = scrollNode.scrollTop,
              clientHeight = scrollNode.clientHeight;
          var bottomNodeIndex;
          this.stickToBottom = Math.abs(scrollHeight - (scrollTop + clientHeight)) < 1;

          if (this.stickToBottom) {
            var len = this.value.tiles.length;
            bottomNodeIndex = len - 1;
          } else {
            var viewportBottom = scrollTop + clientHeight;
            var anchoredNodeIndex = findFirstNodeIndexAtOrBelow(tilesNode, viewportBottom);
            this.anchoredNode = tilesNode.childNodes[anchoredNodeIndex];
            this.anchoredBottom = bottom(this.anchoredNode);
            bottomNodeIndex = anchoredNodeIndex;
          }

          var topNodeIndex = findFirstNodeIndexAtOrBelow(tilesNode, scrollTop, bottomNodeIndex);
          this.updateVisibleRange(topNodeIndex, bottomNodeIndex);
        }
      }, {
        key: "updateVisibleRange",
        value: function updateVisibleRange(startIndex, endIndex) {
          var firstVisibleChild = this.tilesView.getChildInstanceByIndex(startIndex);
          var lastVisibleChild = this.tilesView.getChildInstanceByIndex(endIndex);
          this.value.setVisibleTileRange(firstVisibleChild === null || firstVisibleChild === void 0 ? void 0 : firstVisibleChild.value, lastVisibleChild === null || lastVisibleChild === void 0 ? void 0 : lastVisibleChild.value);
        }
      }, {
        key: "scrollNode",
        get: function get() {
          return this.root().firstElementChild;
        }
      }, {
        key: "tilesNode",
        get: function get() {
          return this.tilesView.root();
        }
      }]);

      return TimelineView;
    }(TemplateView);

    var TilesListView = /*#__PURE__*/function (_ListView) {
      _inherits(TilesListView, _ListView);

      var _super2 = _createSuper(TilesListView);

      function TilesListView(tiles, onChanged) {
        var _this3;

        _classCallCheck(this, TilesListView);

        var options = {
          list: tiles,
          onItemClick: function onItemClick(tileView, evt) {
            return tileView.onClick(evt);
          }
        };
        _this3 = _super2.call(this, options, function (entry) {
          var View = viewClassForEntry(entry);

          if (View) {
            return new View(entry);
          }
        });
        _this3.onChanged = onChanged;
        return _this3;
      }

      _createClass(TilesListView, [{
        key: "onReset",
        value: function onReset() {
          _get(_getPrototypeOf(TilesListView.prototype), "onReset", this).call(this);

          this.onChanged();
        }
      }, {
        key: "onUpdate",
        value: function onUpdate(index, value, param) {
          if (param === "shape") {
            var ExpectedClass = viewClassForEntry(value);
            var child = this.getChildInstanceByIndex(index);

            if (!ExpectedClass || !(child instanceof ExpectedClass)) {
              _get(_getPrototypeOf(TilesListView.prototype), "recreateItem", this).call(this, index, value);

              return;
            }
          }

          _get(_getPrototypeOf(TilesListView.prototype), "onUpdate", this).call(this, index, value, param);

          this.onChanged();
        }
      }, {
        key: "onAdd",
        value: function onAdd(idx, value) {
          _get(_getPrototypeOf(TilesListView.prototype), "onAdd", this).call(this, idx, value);

          this.onChanged();
        }
      }, {
        key: "onRemove",
        value: function onRemove(idx, value) {
          _get(_getPrototypeOf(TilesListView.prototype), "onRemove", this).call(this, idx, value);

          this.onChanged();
        }
      }, {
        key: "onMove",
        value: function onMove(fromIdx, toIdx, value) {
          _get(_getPrototypeOf(TilesListView.prototype), "onMove", this).call(this, fromIdx, toIdx, value);

          this.onChanged();
        }
      }]);

      return TilesListView;
    }(ListView);

    function _templateObject2$3() {
      var data = _taggedTemplateLiteral(["Loading messages\u2026"]);

      _templateObject2$3 = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$4() {
      var data = _taggedTemplateLiteral(["Loading encrypted messages\u2026"]);

      _templateObject$4 = function _templateObject() {
        return data;
      };

      return data;
    }
    var TimelineLoadingView = /*#__PURE__*/function (_TemplateView) {
      _inherits(TimelineLoadingView, _TemplateView);

      var _super = _createSuper(TimelineLoadingView);

      function TimelineLoadingView() {
        _classCallCheck(this, TimelineLoadingView);

        return _super.apply(this, arguments);
      }

      _createClass(TimelineLoadingView, [{
        key: "render",
        value: function render(t, vm) {
          return t.div({
            className: "TimelineLoadingView"
          }, [spinner(t), t.div(vm.isEncrypted ? vm.i18n(_templateObject$4()) : vm.i18n(_templateObject2$3()))]);
        }
      }]);

      return TimelineLoadingView;
    }(TemplateView);

    function _templateObject7$1() {
      var data = _taggedTemplateLiteral(["Send file"]);

      _templateObject7$1 = function _templateObject7() {
        return data;
      };

      return data;
    }

    function _templateObject6$1() {
      var data = _taggedTemplateLiteral(["Send picture"]);

      _templateObject6$1 = function _templateObject6() {
        return data;
      };

      return data;
    }

    function _templateObject5$1() {
      var data = _taggedTemplateLiteral(["Send video"]);

      _templateObject5$1 = function _templateObject5() {
        return data;
      };

      return data;
    }

    function _templateObject4$1() {
      var data = _taggedTemplateLiteral(["Send"]);

      _templateObject4$1 = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3$2() {
      var data = _taggedTemplateLiteral(["Send"]);

      _templateObject3$2 = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$4() {
      var data = _taggedTemplateLiteral(["Send file"]);

      _templateObject2$4 = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$5() {
      var data = _taggedTemplateLiteral(["Pick attachment"]);

      _templateObject$5 = function _templateObject() {
        return data;
      };

      return data;
    }
    var MessageComposer = /*#__PURE__*/function (_TemplateView) {
      _inherits(MessageComposer, _TemplateView);

      var _super = _createSuper(MessageComposer);

      function MessageComposer(viewModel) {
        var _this;

        _classCallCheck(this, MessageComposer);

        _this = _super.call(this, viewModel);
        _this._input = null;
        _this._attachmentPopup = null;
        _this._focusInput = null;
        _this._rafResizeHandle = undefined;
        return _this;
      }

      _createClass(MessageComposer, [{
        key: "render",
        value: function render(t, vm) {
          var _this2 = this;

          this._input = t.textarea({
            enterkeyhint: 'send',
            onKeydown: function onKeydown(e) {
              return _this2._onKeyDown(e);
            },
            onInput: function onInput() {
              vm.setInput(_this2._input.value);

              if (_this2._input.value) {
                _this2._adjustHeight();
              } else {
                _this2._clearHeight();
              }
            },
            placeholder: vm.isEncrypted ? "Send an encrypted message…" : "Send a message…",
            rows: "1"
          });

          this._focusInput = function () {
            return _this2._input.focus();
          };

          this.value.on("focus", this._focusInput);
          var replyPreview = t.map(function (vm) {
            return vm.replyViewModel;
          }, function (rvm, t) {
            var View = rvm && viewClassForEntry(rvm);

            if (!View) {
              return null;
            }

            return t.div({
              className: "MessageComposer_replyPreview"
            }, [t.span({
              className: "replying"
            }, "Replying"), t.button({
              className: "cancel",
              onClick: function onClick() {
                return _this2._clearReplyingTo();
              }
            }, "Close"), t.view(new View(rvm, false, "div"))]);
          });
          var input = t.div({
            className: "MessageComposer_input"
          }, [this._input, t.button({
            className: "sendFile",
            title: vm.i18n(_templateObject$5()),
            onClick: function onClick(evt) {
              return _this2._toggleAttachmentMenu(evt);
            }
          }, vm.i18n(_templateObject2$4())), t.button({
            className: "send",
            title: vm.i18n(_templateObject3$2()),
            onClick: function onClick() {
              return _this2._trySend();
            }
          }, vm.i18n(_templateObject4$1()))]);
          return t.div({
            className: {
              MessageComposer: true,
              MessageComposer_canSend: function MessageComposer_canSend(vm) {
                return vm.canSend;
              }
            }
          }, [replyPreview, input]);
        }
      }, {
        key: "unmount",
        value: function unmount() {
          if (this._focusInput) {
            this.value.off("focus", this._focusInput);
          }

          _get(_getPrototypeOf(MessageComposer.prototype), "unmount", this).call(this);
        }
      }, {
        key: "_clearReplyingTo",
        value: function _clearReplyingTo() {
          this.value.clearReplyingTo();
        }
      }, {
        key: "_trySend",
        value: function () {
          var _trySend2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var _this3 = this;

            var value, restoreValue;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this._input.focus(); // we clear the composer while enqueuing
                    // and restore it when that didn't work somehow
                    // to prevent the user from sending the message
                    // every time they hit enter while it's still enqueuing.


                    value = this._input.value;

                    restoreValue = function restoreValue() {
                      _this3._input.value = value;

                      _this3._adjustHeight();
                    };

                    this._input.value = "";

                    this._clearHeight();

                    _context.prev = 5;
                    _context.next = 8;
                    return this.value.sendMessage(value);

                  case 8:
                    if (_context.sent) {
                      _context.next = 10;
                      break;
                    }

                    restoreValue();

                  case 10:
                    _context.next = 16;
                    break;

                  case 12:
                    _context.prev = 12;
                    _context.t0 = _context["catch"](5);
                    restoreValue();
                    console.error(_context.t0);

                  case 16:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[5, 12]]);
          }));

          function _trySend() {
            return _trySend2.apply(this, arguments);
          }

          return _trySend;
        }()
      }, {
        key: "_onKeyDown",
        value: function _onKeyDown(event) {
          if (event.key === "Enter" && !event.shiftKey) {
            // don't insert newline into composer
            event.preventDefault();

            this._trySend();
          }
        }
      }, {
        key: "_toggleAttachmentMenu",
        value: function _toggleAttachmentMenu(evt) {
          if (this._attachmentPopup && this._attachmentPopup.isOpen) {
            this._attachmentPopup.close();
          } else {
            var vm = this.value;
            this._attachmentPopup = new Popup(new Menu([Menu.option(vm.i18n(_templateObject5$1()), function () {
              return vm.sendVideo();
            }).setIcon("video"), Menu.option(vm.i18n(_templateObject6$1()), function () {
              return vm.sendPicture();
            }).setIcon("picture"), Menu.option(vm.i18n(_templateObject7$1()), function () {
              return vm.sendFile();
            }).setIcon("file")]));

            this._attachmentPopup.trackInTemplateView(this);

            this._attachmentPopup.showRelativeTo(evt.target, 12);
          }
        }
      }, {
        key: "_adjustHeight",
        value: function _adjustHeight() {
          var _this4 = this;

          if (this._rafResizeHandle) {
            return;
          }

          this._rafResizeHandle = window.requestAnimationFrame(function () {
            var scrollHeight = _this4._input.scrollHeight;
            _this4._input.style.height = "".concat(scrollHeight, "px");
            _this4._rafResizeHandle = undefined;
          });
        }
      }, {
        key: "_clearHeight",
        value: function _clearHeight() {
          this._input.style.removeProperty("height");
        }
      }]);

      return MessageComposer;
    }(TemplateView);

    var RoomArchivedView = /*#__PURE__*/function (_TemplateView) {
      _inherits(RoomArchivedView, _TemplateView);

      var _super = _createSuper(RoomArchivedView);

      function RoomArchivedView() {
        _classCallCheck(this, RoomArchivedView);

        return _super.apply(this, arguments);
      }

      _createClass(RoomArchivedView, [{
        key: "render",
        value: function render(t) {
          return t.div({
            className: "RoomArchivedView"
          }, t.h3(function (vm) {
            return vm.description;
          }));
        }
      }]);

      return RoomArchivedView;
    }(TemplateView);

    function _templateObject7$2() {
      var data = _taggedTemplateLiteral(["Are you sure you want to leave \"", "\"?"]);

      _templateObject7$2 = function _templateObject7() {
        return data;
      };

      return data;
    }

    function _templateObject6$2() {
      var data = _taggedTemplateLiteral(["Rejoin room"]);

      _templateObject6$2 = function _templateObject6() {
        return data;
      };

      return data;
    }

    function _templateObject5$2() {
      var data = _taggedTemplateLiteral(["Forget room"]);

      _templateObject5$2 = function _templateObject5() {
        return data;
      };

      return data;
    }

    function _templateObject4$2() {
      var data = _taggedTemplateLiteral(["Leave room"]);

      _templateObject4$2 = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3$3() {
      var data = _taggedTemplateLiteral(["Room details"]);

      _templateObject3$3 = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$5() {
      var data = _taggedTemplateLiteral(["Room options"]);

      _templateObject2$5 = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$6() {
      var data = _taggedTemplateLiteral(["Close room"]);

      _templateObject$6 = function _templateObject() {
        return data;
      };

      return data;
    }
    var RoomView = /*#__PURE__*/function (_TemplateView) {
      _inherits(RoomView, _TemplateView);

      var _super = _createSuper(RoomView);

      function RoomView(options) {
        var _this;

        _classCallCheck(this, RoomView);

        _this = _super.call(this, options);
        _this._optionsPopup = null;
        return _this;
      }

      _createClass(RoomView, [{
        key: "render",
        value: function render(t, vm) {
          var _this2 = this;

          var bottomView;

          if (vm.composerViewModel.kind === "composer") {
            bottomView = new MessageComposer(vm.composerViewModel);
          } else if (vm.composerViewModel.kind === "archived") {
            bottomView = new RoomArchivedView(vm.composerViewModel);
          }

          return t.main({
            className: "RoomView middle"
          }, [t.div({
            className: "RoomHeader middle-header"
          }, [t.a({
            className: "button-utility close-middle",
            href: vm.closeUrl,
            title: vm.i18n(_templateObject$6())
          }), t.view(new AvatarView(vm, 32)), t.div({
            className: "room-description"
          }, [t.h2(function (vm) {
            return vm.name;
          })]), t.button({
            className: "button-utility room-options",
            "aria-label": vm.i18n(_templateObject2$5()),
            onClick: function onClick(evt) {
              return _this2._toggleOptionsMenu(evt);
            }
          })]), t.div({
            className: "RoomView_body"
          }, [t.div({
            className: "RoomView_error"
          }, function (vm) {
            return vm.error;
          }), t.mapView(function (vm) {
            return vm.timelineViewModel;
          }, function (timelineViewModel) {
            return timelineViewModel ? new TimelineView(timelineViewModel) : new TimelineLoadingView(vm); // vm is just needed for i18n
          }), t.view(bottomView)])]);
        }
      }, {
        key: "_toggleOptionsMenu",
        value: function _toggleOptionsMenu(evt) {
          var _this3 = this;

          if (this._optionsPopup && this._optionsPopup.isOpen) {
            this._optionsPopup.close();
          } else {
            var vm = this.value;
            var options = [];
            options.push(Menu.option(vm.i18n(_templateObject3$3()), function () {
              return vm.openDetailsPanel();
            }));

            if (vm.canLeave) {
              options.push(Menu.option(vm.i18n(_templateObject4$2()), function () {
                return _this3._confirmToLeaveRoom();
              }).setDestructive());
            }

            if (vm.canForget) {
              options.push(Menu.option(vm.i18n(_templateObject5$2()), function () {
                return vm.forgetRoom();
              }).setDestructive());
            }

            if (vm.canRejoin) {
              options.push(Menu.option(vm.i18n(_templateObject6$2()), function () {
                return vm.rejoinRoom();
              }));
            }

            if (!options.length) {
              return;
            }

            this._optionsPopup = new Popup(new Menu(options));

            this._optionsPopup.trackInTemplateView(this);

            this._optionsPopup.showRelativeTo(evt.target, 10);
          }
        }
      }, {
        key: "_confirmToLeaveRoom",
        value: function _confirmToLeaveRoom() {
          if (confirm(this.value.i18n(_templateObject7$2(), this.value.name))) {
            this.value.leaveRoom();
          }
        }
      }]);

      return RoomView;
    }(TemplateView);

    function _templateObject3$4() {
      var data = _taggedTemplateLiteral(["Join room"]);

      _templateObject3$4 = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$6() {
      var data = _taggedTemplateLiteral(["Want to join it?"]);

      _templateObject2$6 = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$7() {
      var data = _taggedTemplateLiteral(["You are currently not in ", "."]);

      _templateObject$7 = function _templateObject() {
        return data;
      };

      return data;
    }
    var UnknownRoomView = /*#__PURE__*/function (_TemplateView) {
      _inherits(UnknownRoomView, _TemplateView);

      var _super = _createSuper(UnknownRoomView);

      function UnknownRoomView() {
        _classCallCheck(this, UnknownRoomView);

        return _super.apply(this, arguments);
      }

      _createClass(UnknownRoomView, [{
        key: "render",
        value: function render(t, vm) {
          return t.main({
            className: "UnknownRoomView middle"
          }, t.div([t.h2([vm.i18n(_templateObject$7(), vm.roomIdOrAlias), t.br(), vm.i18n(_templateObject2$6())]), t.button({
            className: "button-action primary",
            onClick: function onClick() {
              return vm.join();
            },
            disabled: function disabled(vm) {
              return vm.busy;
            }
          }, vm.i18n(_templateObject3$4())), t.if(function (vm) {
            return vm.error;
          }, function (t) {
            return t.p({
              className: "error"
            }, vm.error);
          })]));
        }
      }]);

      return UnknownRoomView;
    }(TemplateView);

    function _templateObject3$5() {
      var data = _taggedTemplateLiteral(["Reject"]);

      _templateObject3$5 = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$7() {
      var data = _taggedTemplateLiteral(["Accept"]);

      _templateObject2$7 = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$8() {
      var data = _taggedTemplateLiteral(["Close invite"]);

      _templateObject$8 = function _templateObject() {
        return data;
      };

      return data;
    }
    var InviteView = /*#__PURE__*/function (_TemplateView) {
      _inherits(InviteView, _TemplateView);

      var _super = _createSuper(InviteView);

      function InviteView() {
        _classCallCheck(this, InviteView);

        return _super.apply(this, arguments);
      }

      _createClass(InviteView, [{
        key: "render",
        value: function render(t, vm) {
          var inviteNodes = [];

          if (vm.isDirectMessage) {
            inviteNodes.push(renderStaticAvatar(vm, 128, "InviteView_dmAvatar"));
          }

          var inviterNodes;

          if (vm.isDirectMessage) {
            var _vm$inviter;

            inviterNodes = [t.strong(vm.name), " (".concat((_vm$inviter = vm.inviter) === null || _vm$inviter === void 0 ? void 0 : _vm$inviter.id, ") wants to chat with you.")];
          } else if (vm.inviter) {
            inviterNodes = [renderStaticAvatar(vm.inviter, 24), t.strong(vm.inviter.name), " (".concat(vm.inviter.id, ") invited you.")];
          } else {
            inviterNodes = "You were invited to join.";
          }

          inviteNodes.push(t.p({
            className: "InviteView_inviter"
          }, inviterNodes));

          if (!vm.isDirectMessage) {
            inviteNodes.push(t.div({
              className: "InviteView_roomProfile"
            }, [renderStaticAvatar(vm, 64, "InviteView_roomAvatar"), t.h3(vm.name), t.p({
              className: "InviteView_roomDescription"
            }, vm.roomDescription)]));
          }

          return t.main({
            className: "InviteView middle"
          }, [t.div({
            className: "RoomHeader middle-header"
          }, [t.a({
            className: "button-utility close-middle",
            href: vm.closeUrl,
            title: vm.i18n(_templateObject$8())
          }), renderStaticAvatar(vm, 32), t.div({
            className: "room-description"
          }, [t.h2(function (vm) {
            return vm.name;
          })])]), t.if(function (vm) {
            return vm.error;
          }, function (t) {
            return t.div({
              className: "RoomView_error"
            }, function (vm) {
              return vm.error;
            });
          }), t.div({
            className: "InviteView_body"
          }, [t.div({
            className: "InviteView_invite"
          }, [].concat(inviteNodes, [t.div({
            className: "InviteView_buttonRow"
          }, t.button({
            className: "button-action primary",
            disabled: function disabled(vm) {
              return vm.busy;
            },
            onClick: function onClick() {
              return vm.accept();
            }
          }, vm.i18n(_templateObject2$7()))), t.div({
            className: "InviteView_buttonRow"
          }, t.button({
            className: "button-action primary destructive",
            disabled: function disabled(vm) {
              return vm.busy;
            },
            onClick: function onClick() {
              return vm.reject();
            }
          }, vm.i18n(_templateObject3$5())))]))])]);
        }
      }]);

      return InviteView;
    }(TemplateView);

    function _templateObject2$8() {
      var data = _taggedTemplateLiteral(["Loading image\u2026"]);

      _templateObject2$8 = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$9() {
      var data = _taggedTemplateLiteral(["Close"]);

      _templateObject$9 = function _templateObject() {
        return data;
      };

      return data;
    }
    var LightboxView = /*#__PURE__*/function (_TemplateView) {
      _inherits(LightboxView, _TemplateView);

      var _super = _createSuper(LightboxView);

      function LightboxView() {
        _classCallCheck(this, LightboxView);

        return _super.apply(this, arguments);
      }

      _createClass(LightboxView, [{
        key: "render",
        value: function render(t, vm) {
          var _this = this;

          var close = t.a({
            href: vm.closeUrl,
            title: vm.i18n(_templateObject$9()),
            className: "close"
          });
          var image = t.div({
            role: "img",
            "aria-label": function ariaLabel(vm) {
              return vm.name;
            },
            title: function title(vm) {
              return vm.name;
            },
            className: {
              picture: true,
              hidden: function hidden(vm) {
                return !vm.imageUrl;
              }
            },
            style: function style(vm) {
              return "background-image: url('".concat(vm.imageUrl, "'); max-width: ").concat(vm.imageWidth, "px; max-height: ").concat(vm.imageHeight, "px;");
            }
          });
          var loading = t.div({
            className: {
              loading: true,
              hidden: function hidden(vm) {
                return !!vm.imageUrl;
              }
            }
          }, [spinner(t), t.div(vm.i18n(_templateObject2$8()))]);
          var details = t.div({
            className: "details"
          }, [t.strong(function (vm) {
            return vm.name;
          }), t.br(), "uploaded by ", t.strong(function (vm) {
            return vm.sender;
          }), function (vm) {
            return " at ".concat(vm.time, " on ").concat(vm.date, ".");
          }]);
          var dialog = t.div({
            role: "dialog",
            className: "lightbox",
            onClick: function onClick(evt) {
              return _this.clickToClose(evt);
            },
            onKeydown: function onKeydown(evt) {
              return _this.closeOnEscKey(evt);
            }
          }, [image, loading, details, close]);
          trapFocus(t, dialog);
          return dialog;
        }
      }, {
        key: "clickToClose",
        value: function clickToClose(evt) {
          if (evt.target === this.root()) {
            this.value.close();
          }
        }
      }, {
        key: "closeOnEscKey",
        value: function closeOnEscKey(evt) {
          if (evt.key === "Escape" || evt.key === "Esc") {
            this.value.close();
          }
        }
      }]);

      return LightboxView;
    }(TemplateView);

    function trapFocus(t, element) {
      var elements = focusables(element);
      var first = elements[0];
      var last = elements[elements.length - 1];
      t.addEventListener(element, "keydown", function (evt) {
        if (evt.key === "Tab") {
          if (evt.shiftKey) {
            if (document.activeElement === first) {
              last.focus();
              evt.preventDefault();
            }
          } else {
            if (document.activeElement === last) {
              first.focus();
              evt.preventDefault();
            }
          }
        }
      }, true);
      Promise.resolve().then(function () {
        first.focus();
      });
    }

    function focusables(element) {
      return element.querySelectorAll('a[href], button, textarea, input, select');
    }

    var StaticView = /*#__PURE__*/function () {
      function StaticView(value) {
        var render = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck(this, StaticView);

        if (typeof value === "function" && !render) {
          render = value;
          value = null;
        }

        this._root = render ? render(tag, value) : this.render(tag, value);
      }

      _createClass(StaticView, [{
        key: "mount",
        value: function mount() {
          return this._root;
        }
      }, {
        key: "root",
        value: function root() {
          return this._root;
        }
      }, {
        key: "unmount",
        value: function unmount() {}
      }, {
        key: "update",
        value: function update() {}
      }]);

      return StaticView;
    }();

    var SessionStatusView = /*#__PURE__*/function (_TemplateView) {
      _inherits(SessionStatusView, _TemplateView);

      var _super = _createSuper(SessionStatusView);

      function SessionStatusView() {
        _classCallCheck(this, SessionStatusView);

        return _super.apply(this, arguments);
      }

      _createClass(SessionStatusView, [{
        key: "render",
        value: function render(t, vm) {
          return t.div({
            className: {
              "SessionStatusView": true,
              "hidden": function hidden(vm) {
                return !vm.isShown;
              }
            }
          }, [spinner(t, {
            hidden: function hidden(vm) {
              return !vm.isWaiting;
            }
          }), t.p(function (vm) {
            return vm.statusLabel;
          }), t.if(function (vm) {
            return vm.isConnectNowShown;
          }, function (t) {
            return t.button({
              className: "link",
              onClick: function onClick() {
                return vm.connectNow();
              }
            }, "Retry now");
          }), t.if(function (vm) {
            return vm.isSecretStorageShown;
          }, function (t) {
            return t.a({
              href: vm.setupSessionBackupUrl
            }, "Go to settings");
          }), t.if(function (vm) {
            return vm.canDismiss;
          }, function (t) {
            return t.div({
              className: "end"
            }, t.button({
              className: "dismiss",
              onClick: function onClick() {
                return vm.dismiss();
              }
            }));
          })]);
        }
      }]);

      return SessionStatusView;
    }(TemplateView);

    function _templateObject2$9() {
      var data = _taggedTemplateLiteral(["Click to select this tile"]);

      _templateObject2$9 = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$a() {
      var data = _taggedTemplateLiteral(["Select a room on the left"]);

      _templateObject$a = function _templateObject() {
        return data;
      };

      return data;
    }
    var RoomGridView = /*#__PURE__*/function (_TemplateView) {
      _inherits(RoomGridView, _TemplateView);

      var _super = _createSuper(RoomGridView);

      function RoomGridView() {
        _classCallCheck(this, RoomGridView);

        return _super.apply(this, arguments);
      }

      _createClass(RoomGridView, [{
        key: "render",
        value: function render(t, vm) {
          var children = [];

          var _loop = function _loop(i) {
            var _className;

            children.push(t.div({
              onClick: function onClick() {
                return vm.focusTile(i);
              },
              onFocusin: function onFocusin() {
                return vm.focusTile(i);
              },
              className: (_className = {
                "container": true
              }, _defineProperty(_className, "tile".concat(i), true), _defineProperty(_className, "focused", function focused(vm) {
                return vm.focusIndex === i;
              }), _className)
            }, t.mapView(function (vm) {
              return vm.roomViewModelAt(i);
            }, function (roomVM) {
              if (roomVM) {
                if (roomVM.kind === "invite") {
                  return new InviteView(roomVM);
                } else {
                  return new RoomView(roomVM);
                }
              } else {
                return new StaticView(function (t) {
                  return t.div({
                    className: "room-placeholder"
                  }, [t.h2({
                    className: "focused"
                  }, vm.i18n(_templateObject$a())), t.h2({
                    className: "unfocused"
                  }, vm.i18n(_templateObject2$9()))]);
                });
              }
            })));
          };

          for (var i = 0; i < vm.height * vm.width; i += 1) {
            _loop(i);
          }

          children.push(t.div({
            className: function className(vm) {
              return "focus-ring tile".concat(vm.focusIndex);
            }
          }));
          return t.div({
            className: "RoomGridView middle layout3x2"
          }, children);
        }
      }]);

      return RoomGridView;
    }(TemplateView);

    function _templateObject17() {
      var data = _taggedTemplateLiteral(["Try double checking that you did not mix up your security key, security phrase and login password as explained above."]);

      _templateObject17 = function _templateObject17() {
        return data;
      };

      return data;
    }

    function _templateObject16() {
      var data = _taggedTemplateLiteral(["Could not enable session backup: ", "."]);

      _templateObject16 = function _templateObject16() {
        return data;
      };

      return data;
    }

    function _templateObject15() {
      var data = _taggedTemplateLiteral(["Back up my device as well ("]);

      _templateObject15 = function _templateObject15() {
        return data;
      };

      return data;
    }

    function _templateObject14() {
      var data = _taggedTemplateLiteral(["."]);

      _templateObject14 = function _templateObject14() {
        return data;
      };

      return data;
    }

    function _templateObject13() {
      var data = _taggedTemplateLiteral(["You can also "]);

      _templateObject13 = function _templateObject13() {
        return data;
      };

      return data;
    }

    function _templateObject12() {
      var data = _taggedTemplateLiteral(["Security phrase"]);

      _templateObject12 = function _templateObject12() {
        return data;
      };

      return data;
    }

    function _templateObject11() {
      var data = _taggedTemplateLiteral(["Enter your secret storage security phrase below to ", ", which will enable you to decrypt messages received before you logged into this session. The security phrase is a freeform secret phrase you optionally chose when setting up security in Element. It is different from your password to login, unless you chose to set them to the same value."]);

      _templateObject11 = function _templateObject11() {
        return data;
      };

      return data;
    }

    function _templateObject10() {
      var data = _taggedTemplateLiteral(["use your security key"]);

      _templateObject10 = function _templateObject10() {
        return data;
      };

      return data;
    }

    function _templateObject9$1() {
      var data = _taggedTemplateLiteral([" if you have one."]);

      _templateObject9$1 = function _templateObject9() {
        return data;
      };

      return data;
    }

    function _templateObject8$1() {
      var data = _taggedTemplateLiteral(["Alternatively, you can "]);

      _templateObject8$1 = function _templateObject8() {
        return data;
      };

      return data;
    }

    function _templateObject7$3() {
      var data = _taggedTemplateLiteral(["Security key"]);

      _templateObject7$3 = function _templateObject7() {
        return data;
      };

      return data;
    }

    function _templateObject6$3() {
      var data = _taggedTemplateLiteral(["Enter your secret storage security key below to ", ", which will enable you to decrypt messages received before you logged into this session. The security key is a code of 12 groups of 4 characters separated by a space that Element created for you when setting up security."]);

      _templateObject6$3 = function _templateObject6() {
        return data;
      };

      return data;
    }

    function _templateObject5$3() {
      var data = _taggedTemplateLiteral(["use a security phrase"]);

      _templateObject5$3 = function _templateObject5() {
        return data;
      };

      return data;
    }

    function _templateObject4$3() {
      var data = _taggedTemplateLiteral(["A dehydrated device id was set up with id ", " which you can use during your next login with your secret storage key."]);

      _templateObject4$3 = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3$6() {
      var data = _taggedTemplateLiteral(["Disable"]);

      _templateObject3$6 = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$a() {
      var data = _taggedTemplateLiteral(["Session backup is enabled, using backup version ", ". "]);

      _templateObject2$a = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$b() {
      var data = _taggedTemplateLiteral(["Waiting to go online\u2026"]);

      _templateObject$b = function _templateObject() {
        return data;
      };

      return data;
    }
    var SessionBackupSettingsView = /*#__PURE__*/function (_TemplateView) {
      _inherits(SessionBackupSettingsView, _TemplateView);

      var _super = _createSuper(SessionBackupSettingsView);

      function SessionBackupSettingsView() {
        _classCallCheck(this, SessionBackupSettingsView);

        return _super.apply(this, arguments);
      }

      _createClass(SessionBackupSettingsView, [{
        key: "render",
        value: function render(t, vm) {
          return t.mapView(function (vm) {
            return vm.status;
          }, function (status) {
            switch (status) {
              case "Enabled":
                return new TemplateView(vm, renderEnabled);

              case "SetupKey":
                return new TemplateView(vm, renderEnableFromKey);

              case "SetupPhrase":
                return new TemplateView(vm, renderEnableFromPhrase);

              case "Pending":
                return new StaticView(vm, function (t) {
                  return t.p(vm.i18n(_templateObject$b()));
                });
            }
          });
        }
      }]);

      return SessionBackupSettingsView;
    }(TemplateView);

    function renderEnabled(t, vm) {
      var items = [t.p([vm.i18n(_templateObject2$a(), vm.backupVersion), t.button({
        onClick: function onClick() {
          return vm.disable();
        }
      }, vm.i18n(_templateObject3$6()))])];

      if (vm.dehydratedDeviceId) {
        items.push(t.p(vm.i18n(_templateObject4$3(), vm.dehydratedDeviceId)));
      }

      return t.div(items);
    }

    function renderEnableFromKey(t, vm) {
      var useASecurityPhrase = t.button({
        className: "link",
        onClick: function onClick() {
          return vm.showPhraseSetup();
        }
      }, vm.i18n(_templateObject5$3()));
      return t.div([t.p(vm.i18n(_templateObject6$3(), vm.purpose)), renderError(t), renderEnableFieldRow(t, vm, vm.i18n(_templateObject7$3()), function (key, setupDehydratedDevice) {
        return vm.enterSecurityKey(key, setupDehydratedDevice);
      }), t.p([vm.i18n(_templateObject8$1()), useASecurityPhrase, vm.i18n(_templateObject9$1())])]);
    }

    function renderEnableFromPhrase(t, vm) {
      var useASecurityKey = t.button({
        className: "link",
        onClick: function onClick() {
          return vm.showKeySetup();
        }
      }, vm.i18n(_templateObject10()));
      return t.div([t.p(vm.i18n(_templateObject11(), vm.purpose)), renderError(t), renderEnableFieldRow(t, vm, vm.i18n(_templateObject12()), function (phrase, setupDehydratedDevice) {
        return vm.enterSecurityPhrase(phrase, setupDehydratedDevice);
      }), t.p([vm.i18n(_templateObject13()), useASecurityKey, vm.i18n(_templateObject14())])]);
    }

    function renderEnableFieldRow(t, vm, label, callback) {
      var setupDehydrationCheck;

      var eventHandler = function eventHandler() {
        var _setupDehydrationChec;

        return callback(input.value, ((_setupDehydrationChec = setupDehydrationCheck) === null || _setupDehydrationChec === void 0 ? void 0 : _setupDehydrationChec.checked) || false);
      };

      var input = t.input({
        type: "password",
        disabled: function disabled(vm) {
          return vm.isBusy;
        },
        placeholder: label
      });
      var children = [t.p([input, t.button({
        disabled: function disabled(vm) {
          return vm.isBusy;
        },
        onClick: eventHandler
      }, vm.decryptAction)])];

      if (vm.offerDehydratedDeviceSetup) {
        setupDehydrationCheck = t.input({
          type: "checkbox",
          id: "enable-dehydrated-device"
        });
        var moreInfo = t.a({
          href: "https://github.com/uhoreg/matrix-doc/blob/dehydration/proposals/2697-device-dehydration.md",
          target: "_blank",
          rel: "noopener"
        }, "more info");
        children.push(t.p([setupDehydrationCheck, t.label({
          for: setupDehydrationCheck.id
        }, [vm.i18n(_templateObject15()), moreInfo, ")"])]));
      }

      return t.div({
        className: "row"
      }, [t.div({
        className: "label"
      }, label), t.div({
        className: "content"
      }, children)]);
    }

    function renderError(t) {
      return t.if(function (vm) {
        return vm.error;
      }, function (t, vm) {
        return t.div([t.p({
          className: "error"
        }, function (vm) {
          return vm.i18n(_templateObject16(), vm.error);
        }), t.p(vm.i18n(_templateObject17()))]);
      });
    }

    function _templateObject19() {
      var data = _taggedTemplateLiteral(["no resizing"]);

      _templateObject19 = function _templateObject19() {
        return data;
      };

      return data;
    }

    function _templateObject18() {
      var data = _taggedTemplateLiteral(["resize to ", "px"]);

      _templateObject18 = function _templateObject18() {
        return data;
      };

      return data;
    }

    function _templateObject17$1() {
      var data = _taggedTemplateLiteral(["Close settings"]);

      _templateObject17$1 = function _templateObject17() {
        return data;
      };

      return data;
    }

    function _templateObject16$1() {
      var data = _taggedTemplateLiteral(["Debug logs"]);

      _templateObject16$1 = function _templateObject16() {
        return data;
      };

      return data;
    }

    function _templateObject15$1() {
      var data = _taggedTemplateLiteral(["Storage usage"]);

      _templateObject15$1 = function _templateObject15() {
        return data;
      };

      return data;
    }

    function _templateObject14$1() {
      var data = _taggedTemplateLiteral(["Version"]);

      _templateObject14$1 = function _templateObject14() {
        return data;
      };

      return data;
    }

    function _templateObject13$1() {
      var data = _taggedTemplateLiteral(["Scale down images when sending"]);

      _templateObject13$1 = function _templateObject13() {
        return data;
      };

      return data;
    }

    function _templateObject12$1() {
      var data = _taggedTemplateLiteral(["Push notifications are not supported on this browser"]);

      _templateObject12$1 = function _templateObject12() {
        return data;
      };

      return data;
    }

    function _templateObject11$1() {
      var data = _taggedTemplateLiteral(["Enable"]);

      _templateObject11$1 = function _templateObject11() {
        return data;
      };

      return data;
    }

    function _templateObject10$1() {
      var data = _taggedTemplateLiteral(["Disable"]);

      _templateObject10$1 = function _templateObject10() {
        return data;
      };

      return data;
    }

    function _templateObject9$2() {
      var data = _taggedTemplateLiteral(["Push notifications are disabled"]);

      _templateObject9$2 = function _templateObject9() {
        return data;
      };

      return data;
    }

    function _templateObject8$2() {
      var data = _taggedTemplateLiteral(["Push notifications are enabled"]);

      _templateObject8$2 = function _templateObject8() {
        return data;
      };

      return data;
    }

    function _templateObject7$4() {
      var data = _taggedTemplateLiteral(["Loading\u2026"]);

      _templateObject7$4 = function _templateObject7() {
        return data;
      };

      return data;
    }

    function _templateObject6$4() {
      var data = _taggedTemplateLiteral(["Log out"]);

      _templateObject6$4 = function _templateObject6() {
        return data;
      };

      return data;
    }

    function _templateObject5$4() {
      var data = _taggedTemplateLiteral(["Are you sure you want to log out?"]);

      _templateObject5$4 = function _templateObject5() {
        return data;
      };

      return data;
    }

    function _templateObject4$4() {
      var data = _taggedTemplateLiteral(["Session key"]);

      _templateObject4$4 = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3$7() {
      var data = _taggedTemplateLiteral(["Session ID"]);

      _templateObject3$7 = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$b() {
      var data = _taggedTemplateLiteral(["User ID"]);

      _templateObject2$b = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$c() {
      var data = _taggedTemplateLiteral(["Check for updates"]);

      _templateObject$c = function _templateObject() {
        return data;
      };

      return data;
    }
    var SettingsView = /*#__PURE__*/function (_TemplateView) {
      _inherits(SettingsView, _TemplateView);

      var _super = _createSuper(SettingsView);

      function SettingsView() {
        _classCallCheck(this, SettingsView);

        return _super.apply(this, arguments);
      }

      _createClass(SettingsView, [{
        key: "render",
        value: function render(t, vm) {
          var version = vm.version;

          if (vm.showUpdateButton) {
            version = t.span([vm.version, t.button({
              onClick: function onClick() {
                return vm.checkForUpdate();
              }
            }, vm.i18n(_templateObject$c()))]);
          }

          var row = function row(t, label, content) {
            var extraClass = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
            return t.div({
              className: "row ".concat(extraClass)
            }, [t.div({
              className: "label"
            }, label), t.div({
              className: "content"
            }, content)]);
          };

          var settingNodes = [];
          settingNodes.push(t.h3("Session"), row(t, vm.i18n(_templateObject2$b()), vm.userId), row(t, vm.i18n(_templateObject3$7()), vm.deviceId, "code"), row(t, vm.i18n(_templateObject4$4()), vm.fingerprintKey, "code"), row(t, "", t.button({
            onClick: function onClick() {
              if (confirm(vm.i18n(_templateObject5$4()))) {
                vm.logout();
              }
            },
            disabled: function disabled(vm) {
              return vm.isLoggingOut;
            }
          }, vm.i18n(_templateObject6$4()))));
          settingNodes.push(t.h3("Session Backup"), t.view(new SessionBackupSettingsView(vm.sessionBackupViewModel)));
          settingNodes.push(t.h3("Notifications"), t.map(function (vm) {
            return vm.pushNotifications.supported;
          }, function (supported, t) {
            if (supported === null) {
              return t.p(vm.i18n(_templateObject7$4()));
            } else if (supported) {
              var label = function label(vm) {
                return vm.pushNotifications.enabled ? vm.i18n(_templateObject8$2()) : vm.i18n(_templateObject9$2());
              };

              var buttonLabel = function buttonLabel(vm) {
                return vm.pushNotifications.enabled ? vm.i18n(_templateObject10$1()) : vm.i18n(_templateObject11$1());
              };

              return row(t, label, t.button({
                onClick: function onClick() {
                  return vm.togglePushNotifications();
                },
                disabled: function disabled(vm) {
                  return vm.pushNotifications.updating;
                }
              }, buttonLabel));
            } else {
              return t.p(vm.i18n(_templateObject12$1()));
            }
          }), t.if(function (vm) {
            return vm.pushNotifications.supported && vm.pushNotifications.enabled;
          }, function (t) {
            return t.div([t.p(["If you think push notifications are not being delivered, ", t.button({
              className: "link",
              onClick: function onClick() {
                return vm.checkPushEnabledOnServer();
              }
            }, "check"), " if they got disabled on the server"]), t.map(function (vm) {
              return vm.pushNotifications.enabledOnServer;
            }, function (enabled, t) {
              if (enabled === true) {
                return t.p("Push notifications are still enabled on the server, so everything should be working. Sometimes notifications can get dropped if they can't be delivered within a given time.");
              } else if (enabled === false) {
                return t.p("Push notifications have been disabled on the server, likely due to a bug. Please re-enable them by clicking Disable and then Enable again above.");
              }
            }), t.map(function (vm) {
              return vm.pushNotifications.serverError;
            }, function (err, t) {
              if (err) {
                return t.p("Couldn't not check on server: " + err.message);
              }
            })]);
          }));
          settingNodes.push(t.h3("Preferences"), row(t, vm.i18n(_templateObject13$1()), this._imageCompressionRange(t, vm)));
          settingNodes.push(t.h3("Application"), row(t, vm.i18n(_templateObject14$1()), version), row(t, vm.i18n(_templateObject15$1()), function (vm) {
            return "".concat(vm.storageUsage, " / ").concat(vm.storageQuota);
          }), row(t, vm.i18n(_templateObject16$1()), t.button({
            onClick: function onClick() {
              return vm.exportLogs();
            }
          }, "Export")), t.p(["Debug logs contain application usage data including your username, the IDs or aliases of the rooms or groups you have visited, the usernames of other users and the names of files you send. They do not contain messages. For more information, review our ", t.a({
            href: "https://element.io/privacy",
            target: "_blank",
            rel: "noopener"
          }, "privacy policy"), "."]));
          return t.main({
            className: "Settings middle"
          }, [t.div({
            className: "middle-header"
          }, [t.a({
            className: "button-utility close-middle",
            href: vm.closeUrl,
            title: vm.i18n(_templateObject17$1())
          }), t.h2("Settings")]), t.div({
            className: "SettingsBody"
          }, settingNodes)]);
        }
      }, {
        key: "_imageCompressionRange",
        value: function _imageCompressionRange(t, vm) {
          var step = 32;
          var min = Math.ceil(vm.minSentImageSizeLimit / step) * step;
          var max = (Math.floor(vm.maxSentImageSizeLimit / step) + 1) * step;

          var updateSetting = function updateSetting(evt) {
            return vm.setSentImageSizeLimit(parseInt(evt.target.value, 10));
          };

          return [t.input({
            type: "range",
            step: step,
            min: min,
            max: max,
            value: function value(vm) {
              return vm.sentImageSizeLimit || max;
            },
            onInput: updateSetting,
            onChange: updateSetting
          }), " ", t.output(function (vm) {
            return vm.sentImageSizeLimit ? vm.i18n(_templateObject18(), vm.sentImageSizeLimit) : vm.i18n(_templateObject19());
          })];
        }
      }]);

      return SettingsView;
    }(TemplateView);

    function _templateObject4$5() {
      var data = _taggedTemplateLiteral(["Encryption"]);

      _templateObject4$5 = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3$8() {
      var data = _taggedTemplateLiteral(["People"]);

      _templateObject3$8 = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$c() {
      var data = _taggedTemplateLiteral(["Off"]);

      _templateObject2$c = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$d() {
      var data = _taggedTemplateLiteral(["On"]);

      _templateObject$d = function _templateObject() {
        return data;
      };

      return data;
    }
    var RoomDetailsView = /*#__PURE__*/function (_TemplateView) {
      _inherits(RoomDetailsView, _TemplateView);

      var _super = _createSuper(RoomDetailsView);

      function RoomDetailsView() {
        _classCallCheck(this, RoomDetailsView);

        return _super.apply(this, arguments);
      }

      _createClass(RoomDetailsView, [{
        key: "render",
        value: function render(t, vm) {
          var encryptionString = function encryptionString() {
            return vm.isEncrypted ? vm.i18n(_templateObject$d()) : vm.i18n(_templateObject2$c());
          };

          return t.div({
            className: "RoomDetailsView"
          }, [t.div({
            className: "RoomDetailsView_avatar"
          }, [t.view(new AvatarView(vm, 52)), t.mapView(function (vm) {
            return vm.isEncrypted;
          }, function (isEncrypted) {
            return new EncryptionIconView(isEncrypted);
          })]), t.div({
            className: "RoomDetailsView_name"
          }, [t.h2(function (vm) {
            return vm.name;
          })]), this._createRoomAliasDisplay(vm), t.div({
            className: "RoomDetailsView_rows"
          }, [this._createRightPanelButtonRow(t, vm.i18n(_templateObject3$8()), {
            MemberCount: true
          }, function (vm) {
            return vm.memberCount;
          }, function () {
            return vm.openPanel("members");
          }), this._createRightPanelRow(t, vm.i18n(_templateObject4$5()), {
            EncryptionStatus: true
          }, encryptionString)])]);
        }
      }, {
        key: "_createRoomAliasDisplay",
        value: function _createRoomAliasDisplay(vm) {
          return vm.canonicalAlias ? tag.div({
            className: "RoomDetailsView_id"
          }, [vm.canonicalAlias]) : "";
        }
      }, {
        key: "_createRightPanelRow",
        value: function _createRightPanelRow(t, label, labelClass, value) {
          var labelClassString = classNames(_objectSpread2({
            RoomDetailsView_label: true
          }, labelClass));
          return t.div({
            className: "RoomDetailsView_row"
          }, [t.div({
            className: labelClassString
          }, [label]), t.div({
            className: "RoomDetailsView_value"
          }, value)]);
        }
      }, {
        key: "_createRightPanelButtonRow",
        value: function _createRightPanelButtonRow(t, label, labelClass, value, onClick) {
          var labelClassString = classNames(_objectSpread2({
            RoomDetailsView_label: true
          }, labelClass));
          return t.button({
            className: "RoomDetailsView_row",
            onClick: onClick
          }, [t.div({
            className: labelClassString
          }, [label]), t.div({
            className: "RoomDetailsView_value"
          }, value)]);
        }
      }]);

      return RoomDetailsView;
    }(TemplateView);

    var EncryptionIconView = /*#__PURE__*/function (_TemplateView2) {
      _inherits(EncryptionIconView, _TemplateView2);

      var _super2 = _createSuper(EncryptionIconView);

      function EncryptionIconView() {
        _classCallCheck(this, EncryptionIconView);

        return _super2.apply(this, arguments);
      }

      _createClass(EncryptionIconView, [{
        key: "render",
        value: function render(t, isEncrypted) {
          return t.div({
            className: "EncryptionIconView"
          }, [t.div({
            className: isEncrypted ? "EncryptionIconView_encrypted" : "EncryptionIconView_unencrypted"
          })]);
        }
      }]);

      return EncryptionIconView;
    }(TemplateView);

    var Range$1 = /*#__PURE__*/function () {
      function Range(start, end) {
        _classCallCheck(this, Range);

        this.start = start;
        this.end = end;
      }

      _createClass(Range, [{
        key: "contains",
        value: function contains(range) {
          return range.start >= this.start && range.end <= this.end;
        }
      }, {
        key: "containsIndex",
        value: function containsIndex(idx) {
          return idx >= this.start && idx < this.end;
        }
      }, {
        key: "toLocalIndex",
        value: function toLocalIndex(idx) {
          return idx - this.start;
        }
      }, {
        key: "intersects",
        value: function intersects(range) {
          return range.start < this.end && this.start < range.end;
        }
      }, {
        key: "forEachInIterator",
        value: function forEachInIterator(it, callback) {
          var i = 0;

          for (i = 0; i < this.start; i += 1) {
            it.next();
          }

          for (i = 0; i < this.length; i += 1) {
            var result = it.next();

            if (result.done) {
              break;
            } else {
              callback(result.value, this.start + i);
            }
          }
        }
      }, {
        key: Symbol.iterator,
        value: function value() {
          return new RangeIterator(this);
        }
      }, {
        key: "reverseIterable",
        value: function reverseIterable() {
          return new ReverseRangeIterator(this);
        }
      }, {
        key: "clampIndex",
        value: function clampIndex(idx) {
          var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.end - 1;
          return Math.min(Math.max(this.start, idx), end);
        }
      }, {
        key: "getIndexZone",
        value: function getIndexZone(idx) {
          if (idx < this.start) {
            return RangeZone.Before;
          } else if (idx < this.end) {
            return RangeZone.Inside;
          } else {
            return RangeZone.After;
          }
        }
      }, {
        key: "length",
        get: function get() {
          return this.end - this.start;
        }
      }]);

      return Range;
    }();
    var RangeZone;

    (function (RangeZone2) {
      RangeZone2[RangeZone2["Before"] = 1] = "Before";
      RangeZone2[RangeZone2["Inside"] = 2] = "Inside";
      RangeZone2[RangeZone2["After"] = 3] = "After";
    })(RangeZone || (RangeZone = {}));

    var RangeIterator = /*#__PURE__*/function () {
      function RangeIterator(range) {
        _classCallCheck(this, RangeIterator);

        this.range = range;
        this.idx = range.start - 1;
      }

      _createClass(RangeIterator, [{
        key: "next",
        value: function next() {
          if (this.idx < this.range.end - 1) {
            this.idx += 1;
            return {
              value: this.idx,
              done: false
            };
          } else {
            return {
              value: void 0,
              done: true
            };
          }
        }
      }]);

      return RangeIterator;
    }();

    var ReverseRangeIterator = /*#__PURE__*/function () {
      function ReverseRangeIterator(range) {
        _classCallCheck(this, ReverseRangeIterator);

        this.range = range;
        this.idx = range.end;
      }

      _createClass(ReverseRangeIterator, [{
        key: Symbol.iterator,
        value: function value() {
          return this;
        }
      }, {
        key: "next",
        value: function next() {
          if (this.idx > this.range.start) {
            this.idx -= 1;
            return {
              value: this.idx,
              done: false
            };
          } else {
            return {
              value: void 0,
              done: true
            };
          }
        }
      }]);

      return ReverseRangeIterator;
    }();

    var BaseObservableList = /*#__PURE__*/function (_BaseObservable) {
      _inherits(BaseObservableList, _BaseObservable);

      var _super = _createSuper(BaseObservableList);

      function BaseObservableList() {
        _classCallCheck(this, BaseObservableList);

        return _super.apply(this, arguments);
      }

      _createClass(BaseObservableList, [{
        key: "emitReset",
        value: function emitReset() {
          var _iterator = _createForOfIteratorHelper(this._handlers),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var h = _step.value;
              h.onReset(this);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }, {
        key: "emitAdd",
        value: function emitAdd(index, value) {
          var _iterator2 = _createForOfIteratorHelper(this._handlers),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var h = _step2.value;
              h.onAdd(index, value, this);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      }, {
        key: "emitUpdate",
        value: function emitUpdate(index, value, params) {
          var _iterator3 = _createForOfIteratorHelper(this._handlers),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var h = _step3.value;
              h.onUpdate(index, value, params, this);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      }, {
        key: "emitRemove",
        value: function emitRemove(index, value) {
          var _iterator4 = _createForOfIteratorHelper(this._handlers),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var h = _step4.value;
              h.onRemove(index, value, this);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }
      }, {
        key: "emitMove",
        value: function emitMove(fromIdx, toIdx, value) {
          var _iterator5 = _createForOfIteratorHelper(this._handlers),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var h = _step5.value;
              h.onMove(fromIdx, toIdx, value, this);
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      }]);

      return BaseObservableList;
    }(BaseObservable);

    var ObservableArray = /*#__PURE__*/function (_BaseObservableList) {
      _inherits(ObservableArray, _BaseObservableList);

      var _super = _createSuper(ObservableArray);

      function ObservableArray() {
        var _this;

        var initialValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        _classCallCheck(this, ObservableArray);

        _this = _super.call(this);
        _this._items = initialValues;
        return _this;
      }

      _createClass(ObservableArray, [{
        key: "append",
        value: function append(item) {
          this._items.push(item);

          this.emitAdd(this._items.length - 1, item);
        }
      }, {
        key: "remove",
        value: function remove(idx) {
          var _this$_items$splice = this._items.splice(idx, 1),
              _this$_items$splice2 = _slicedToArray(_this$_items$splice, 1),
              item = _this$_items$splice2[0];

          this.emitRemove(idx, item);
        }
      }, {
        key: "insertMany",
        value: function insertMany(idx, items) {
          var _iterator = _createForOfIteratorHelper(items),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var item = _step.value;
              this.insert(idx, item);
              idx += 1;
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }, {
        key: "insert",
        value: function insert(idx, item) {
          this._items.splice(idx, 0, item);

          this.emitAdd(idx, item);
        }
      }, {
        key: "move",
        value: function move(fromIdx, toIdx) {
          if (fromIdx < this._items.length && toIdx < this._items.length) {
            var _this$_items$splice3 = this._items.splice(fromIdx, 1),
                _this$_items$splice4 = _slicedToArray(_this$_items$splice3, 1),
                item = _this$_items$splice4[0];

            this._items.splice(toIdx, 0, item);

            this.emitMove(fromIdx, toIdx, item);
          }
        }
      }, {
        key: "update",
        value: function update(idx, item) {
          var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

          if (idx < this._items.length) {
            this._items[idx] = item;
            this.emitUpdate(idx, item, params);
          }
        }
      }, {
        key: "at",
        value: function at(idx) {
          if (this._items && idx >= 0 && idx < this._items.length) {
            return this._items[idx];
          }
        }
      }, {
        key: Symbol.iterator,
        value: function value() {
          return this._items.values();
        }
      }, {
        key: "array",
        get: function get() {
          return this._items;
        }
      }, {
        key: "length",
        get: function get() {
          return this._items.length;
        }
      }]);

      return ObservableArray;
    }(BaseObservableList);

    function skipOnIterator(it, pos) {
      var i = 0;

      while (i < pos) {
        i += 1;

        if (it.next().done) {
          return false;
        }
      }

      return true;
    }

    function getIteratorValueAtIdx(it, idx) {
      if (skipOnIterator(it, idx)) {
        var result = it.next();

        if (!result.done) {
          return result.value;
        }
      }

      return void 0;
    }

    var ResultType;

    (function (ResultType2) {
      ResultType2[ResultType2["Move"] = 0] = "Move";
      ResultType2[ResultType2["Add"] = 1] = "Add";
      ResultType2[ResultType2["Remove"] = 2] = "Remove";
      ResultType2[ResultType2["RemoveAndAdd"] = 3] = "RemoveAndAdd";
      ResultType2[ResultType2["UpdateRange"] = 4] = "UpdateRange";
    })(ResultType || (ResultType = {}));

    var ListRange = /*#__PURE__*/function (_Range) {
      _inherits(ListRange, _Range);

      var _super = _createSuper(ListRange);

      function ListRange(start, end, _totalLength) {
        var _this;

        var _viewportItemCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : end - start;

        _classCallCheck(this, ListRange);

        _this = _super.call(this, start, end);
        _this._totalLength = _totalLength;
        _this._viewportItemCount = _viewportItemCount;
        return _this;
      }

      _createClass(ListRange, [{
        key: "expand",
        value: function expand(amount) {
          if (this.length === 0) {
            return this;
          }

          var newStart = Math.max(0, this.start - amount);
          var newEnd = Math.min(this.totalLength, this.end + amount);
          return new ListRange(newStart, newEnd, this.totalLength, this._viewportItemCount);
        }
      }, {
        key: "queryAdd",
        value: function queryAdd(idx, value, list) {
          var maxAddIdx = this.viewportItemCount > this.length ? this.end : this.end - 1;

          if (idx <= maxAddIdx) {
            var addIdx = this.clampIndex(idx, maxAddIdx);
            var addValue = addIdx === idx ? value : getIteratorValueAtIdx(list[Symbol.iterator](), addIdx);
            return this.createAddResult(addIdx, addValue);
          } else {
            return {
              type: 4,
              newRange: this.deriveRange(1, 0)
            };
          }
        }
      }, {
        key: "queryRemove",
        value: function queryRemove(idx, list) {
          if (idx < this.end) {
            var removeIdx = this.clampIndex(idx);
            return this.createRemoveResult(removeIdx, list);
          } else {
            return {
              type: 4,
              newRange: this.deriveRange(-1, 0)
            };
          }
        }
      }, {
        key: "queryMove",
        value: function queryMove(fromIdx, toIdx, value, list) {
          var fromZone = this.getIndexZone(fromIdx);
          var toZone = this.getIndexZone(toIdx);

          if (fromZone === toZone) {
            if (fromZone === RangeZone.Before || fromZone === RangeZone.After) {
              return;
            } else if (fromZone === RangeZone.Inside) {
              return {
                type: 0,
                fromIdx: fromIdx,
                toIdx: toIdx
              };
            }
          } else {
            var addIdx = this.clampIndex(toIdx);
            var removeIdx = this.clampIndex(fromIdx);
            var addValue = addIdx === toIdx ? value : getIteratorValueAtIdx(list[Symbol.iterator](), addIdx);
            return {
              type: 3,
              removeIdx: removeIdx,
              addIdx: addIdx,
              value: addValue
            };
          }
        }
      }, {
        key: "createAddResult",
        value: function createAddResult(addIdx, value) {
          if (this.viewportItemCount > this.length) {
            return {
              type: 1,
              addIdx: addIdx,
              value: value,
              newRange: this.deriveRange(1, 1)
            };
          } else {
            var removeIdx = this.clampIndex(Number.MAX_SAFE_INTEGER);
            return {
              type: 3,
              removeIdx: removeIdx,
              addIdx: addIdx,
              value: value,
              newRange: this.deriveRange(1, 0)
            };
          }
        }
      }, {
        key: "createRemoveResult",
        value: function createRemoveResult(removeIdx, list) {
          if (this.end < this.totalLength) {
            var addIdx = this.clampIndex(Number.MAX_SAFE_INTEGER);
            var value = getIteratorValueAtIdx(list[Symbol.iterator](), addIdx);
            return {
              type: 3,
              removeIdx: removeIdx,
              value: value,
              addIdx: addIdx,
              newRange: this.deriveRange(-1, 0)
            };
          } else if (this.start !== 0) {
            var newRange = this.deriveRange(-1, 0, 1);
            var _addIdx = newRange.start;

            var _value = getIteratorValueAtIdx(list[Symbol.iterator](), _addIdx);

            return {
              type: 3,
              removeIdx: removeIdx,
              value: _value,
              addIdx: _addIdx,
              newRange: newRange
            };
          } else {
            return {
              type: 2,
              removeIdx: removeIdx,
              newRange: this.deriveRange(-1, 0)
            };
          }
        }
      }, {
        key: "deriveRange",
        value: function deriveRange(totalLengthInc, viewportItemCountDecr) {
          var startDecr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
          var start = this.start - startDecr;
          var totalLength = this.totalLength + totalLengthInc;
          var end = Math.min(Math.max(start, this.end - startDecr + viewportItemCountDecr), totalLength);
          return new ListRange(start, end, totalLength, this.viewportItemCount);
        }
      }, {
        key: "totalLength",
        get: function get() {
          return this._totalLength;
        }
      }, {
        key: "viewportItemCount",
        get: function get() {
          return this._viewportItemCount;
        }
      }], [{
        key: "fromViewport",
        value: function fromViewport(listLength, itemHeight, listHeight, scrollTop) {
          var topCount = Math.min(Math.max(0, Math.floor(scrollTop / itemHeight)), listLength);
          var itemsAfterTop = listLength - topCount;
          var viewportItemCount = listHeight !== 0 ? Math.ceil(listHeight / itemHeight) : 0;
          var renderCount = Math.min(viewportItemCount, itemsAfterTop);
          return new ListRange(topCount, topCount + renderCount, listLength, viewportItemCount);
        }
      }]);

      return ListRange;
    }(Range$1);

    var LazyListView = /*#__PURE__*/function (_ListView) {
      _inherits(LazyListView, _ListView);

      var _super = _createSuper(LazyListView);

      function LazyListView(_ref, childCreator) {
        var _this;

        var itemHeight = _ref.itemHeight,
            _ref$overflowItems = _ref.overflowItems,
            overflowItems = _ref$overflowItems === void 0 ? 20 : _ref$overflowItems,
            options = _objectWithoutProperties(_ref, ["itemHeight", "overflowItems"]);

        _classCallCheck(this, LazyListView);

        _this = _super.call(this, options, childCreator);
        _this.itemHeight = itemHeight;
        _this.overflowItems = overflowItems;
        return _this;
      }

      _createClass(LazyListView, [{
        key: "handleEvent",
        value: function handleEvent(e) {
          if (e.type === "scroll") {
            this.handleScroll();
          } else {
            _get(_getPrototypeOf(LazyListView.prototype), "handleEvent", this).call(this, e);
          }
        }
      }, {
        key: "handleScroll",
        value: function handleScroll() {
          var visibleRange = this._getVisibleRange();

          if (visibleRange.length !== 0 && !this.renderRange.contains(visibleRange)) {
            var prevRenderRange = this.renderRange;
            this.renderRange = visibleRange.expand(this.overflowItems);
            this.renderUpdate(prevRenderRange, this.renderRange);
          }
        }
      }, {
        key: "loadList",
        value: function () {
          var _loadList = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var visibleRange;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return new Promise(function (r) {
                      return requestAnimationFrame(r);
                    });

                  case 2:
                    _context.next = 4;
                    return new Promise(function (r) {
                      return requestAnimationFrame(r);
                    });

                  case 4:
                    if (this._list) {
                      _context.next = 6;
                      break;
                    }

                    return _context.abrupt("return");

                  case 6:
                    this._subscription = this._list.subscribe(this);
                    visibleRange = this._getVisibleRange();
                    this.renderRange = visibleRange.expand(this.overflowItems);
                    this._childInstances = [];
                    this.reRenderFullRange(this.renderRange);

                  case 11:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function loadList() {
            return _loadList.apply(this, arguments);
          }

          return loadList;
        }()
      }, {
        key: "_getVisibleRange",
        value: function _getVisibleRange() {
          var _this$root = this.root(),
              clientHeight = _this$root.clientHeight,
              scrollTop = _this$root.scrollTop;

          if (clientHeight === 0) {
            throw new Error("LazyListView height is 0");
          }

          return ListRange.fromViewport(this._list.length, this.itemHeight, clientHeight, scrollTop);
        }
      }, {
        key: "reRenderFullRange",
        value: function reRenderFullRange(range) {
          var _this2 = this;

          removeChildren(this._listElement);
          var fragment = document.createDocumentFragment();

          var it = this._list[Symbol.iterator]();

          this._childInstances.length = 0;
          range.forEachInIterator(it, function (item) {
            var child = _this2._childCreator(item);

            _this2._childInstances.push(child);

            fragment.appendChild(mountView(child, _this2._mountArgs));
          });

          this._listElement.appendChild(fragment);

          this.adjustPadding(range);
        }
      }, {
        key: "renderUpdate",
        value: function renderUpdate(prevRange, newRange) {
          var _this3 = this;

          if (newRange.intersects(prevRange)) {
            var _iterator = _createForOfIteratorHelper(prevRange.reverseIterable()),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var idxInList = _step.value;

                if (!newRange.containsIndex(idxInList)) {
                  var localIdx = idxInList - prevRange.start;
                  this.removeChild(localIdx);
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            newRange.forEachInIterator(this._list[Symbol.iterator](), function (item, idxInList) {
              if (!prevRange.containsIndex(idxInList)) {
                var localIdx = idxInList - newRange.start;

                _this3.addChild(localIdx, item);
              }
            });
            this.adjustPadding(newRange);
          } else {
            this.reRenderFullRange(newRange);
          }
        }
      }, {
        key: "adjustPadding",
        value: function adjustPadding(range) {
          var paddingTop = range.start * this.itemHeight;
          var paddingBottom = (range.totalLength - range.end) * this.itemHeight;
          var style = this._listElement.style;
          style.paddingTop = "".concat(paddingTop, "px");
          style.paddingBottom = "".concat(paddingBottom, "px");
        }
      }, {
        key: "mount",
        value: function mount() {
          var listElement = _get(_getPrototypeOf(LazyListView.prototype), "mount", this).call(this);

          this.scrollContainer = tag.div({
            className: "LazyListParent"
          }, listElement);
          this.scrollContainer.addEventListener("scroll", this);
          return this.scrollContainer;
        }
      }, {
        key: "unmount",
        value: function unmount() {
          this.root().removeEventListener("scroll", this);
          this.scrollContainer = void 0;

          _get(_getPrototypeOf(LazyListView.prototype), "unmount", this).call(this);
        }
      }, {
        key: "root",
        value: function root() {
          return this.scrollContainer;
        }
      }, {
        key: "onAdd",
        value: function onAdd(idx, value) {
          var result = this.renderRange.queryAdd(idx, value, this._list);
          this.applyRemoveAddResult(result);
        }
      }, {
        key: "onRemove",
        value: function onRemove(idx, value) {
          var result = this.renderRange.queryRemove(idx, this._list);
          this.applyRemoveAddResult(result);
        }
      }, {
        key: "onMove",
        value: function onMove(fromIdx, toIdx, value) {
          var result = this.renderRange.queryMove(fromIdx, toIdx, value, this._list);

          if (result) {
            if (result.type === ResultType.Move) {
              this.moveChild(this.renderRange.toLocalIndex(result.fromIdx), this.renderRange.toLocalIndex(result.toIdx));
            } else {
              this.applyRemoveAddResult(result);
            }
          }
        }
      }, {
        key: "onUpdate",
        value: function onUpdate(i, value, params) {
          if (this.renderRange.containsIndex(i)) {
            this.updateChild(this.renderRange.toLocalIndex(i), value, params);
          }
        }
      }, {
        key: "applyRemoveAddResult",
        value: function applyRemoveAddResult(result) {
          if (result.type === ResultType.Remove || result.type === ResultType.RemoveAndAdd) {
            this.removeChild(this.renderRange.toLocalIndex(result.removeIdx));
          }

          if (result.newRange) {
            this.renderRange = result.newRange;
            this.adjustPadding(this.renderRange);
          }

          if (result.type === ResultType.Add || result.type === ResultType.RemoveAndAdd) {
            this.addChild(this.renderRange.toLocalIndex(result.addIdx), result.value);
          }
        }
      }, {
        key: "_listElement",
        get: function get() {
          return _get(_getPrototypeOf(LazyListView.prototype), "root", this).call(this);
        }
      }]);

      return LazyListView;
    }(ListView);

    var MemberTileView = /*#__PURE__*/function (_TemplateView) {
      _inherits(MemberTileView, _TemplateView);

      var _super = _createSuper(MemberTileView);

      function MemberTileView() {
        _classCallCheck(this, MemberTileView);

        return _super.apply(this, arguments);
      }

      _createClass(MemberTileView, [{
        key: "render",
        value: function render(t, vm) {
          return t.li({
            className: "MemberTileView"
          }, t.a({
            href: vm.detailsUrl
          }, [t.view(new AvatarView(vm, 32)), t.div({
            className: "MemberTileView_name"
          }, function (vm) {
            return vm.name;
          })]));
        }
      }]);

      return MemberTileView;
    }(TemplateView);

    var MemberListView = /*#__PURE__*/function (_LazyListView) {
      _inherits(MemberListView, _LazyListView);

      var _super = _createSuper(MemberListView);

      function MemberListView(vm) {
        _classCallCheck(this, MemberListView);

        return _super.call(this, {
          list: vm.memberTileViewModels,
          className: "MemberListView",
          itemHeight: 40
        }, function (tileViewModel) {
          return new MemberTileView(tileViewModel);
        });
      }

      return MemberListView;
    }(LazyListView);

    var LoadingView = /*#__PURE__*/function (_TemplateView) {
      _inherits(LoadingView, _TemplateView);

      var _super = _createSuper(LoadingView);

      function LoadingView() {
        _classCallCheck(this, LoadingView);

        return _super.apply(this, arguments);
      }

      _createClass(LoadingView, [{
        key: "render",
        value: function render(t) {
          return t.div({
            className: "LoadingView"
          }, [spinner(t), "Loading"]);
        }
      }]);

      return LoadingView;
    }(TemplateView);

    function _templateObject6$5() {
      var data = _taggedTemplateLiteral(["Open Link to User"]);

      _templateObject6$5 = function _templateObject6() {
        return data;
      };

      return data;
    }

    function _templateObject5$5() {
      var data = _taggedTemplateLiteral(["Options"]);

      _templateObject5$5 = function _templateObject5() {
        return data;
      };

      return data;
    }

    function _templateObject4$6() {
      var data = _taggedTemplateLiteral(["Messages in this room are not end-to-end encrypted."]);

      _templateObject4$6 = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3$9() {
      var data = _taggedTemplateLiteral(["Messages in this room are end-to-end encrypted."]);

      _templateObject3$9 = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$d() {
      var data = _taggedTemplateLiteral(["Security"]);

      _templateObject2$d = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$e() {
      var data = _taggedTemplateLiteral(["Role"]);

      _templateObject$e = function _templateObject() {
        return data;
      };

      return data;
    }
    var MemberDetailsView = /*#__PURE__*/function (_TemplateView) {
      _inherits(MemberDetailsView, _TemplateView);

      var _super = _createSuper(MemberDetailsView);

      function MemberDetailsView() {
        _classCallCheck(this, MemberDetailsView);

        return _super.apply(this, arguments);
      }

      _createClass(MemberDetailsView, [{
        key: "render",
        value: function render(t, vm) {
          return t.div({
            className: "MemberDetailsView"
          }, [t.view(new AvatarView(vm, 128)), t.div({
            className: "MemberDetailsView_name"
          }, t.h2(function (vm) {
            return vm.name;
          })), t.div({
            className: "MemberDetailsView_id"
          }, vm.userId), this._createSection(t, vm.i18n(_templateObject$e()), function (vm) {
            return vm.role;
          }), this._createSection(t, vm.i18n(_templateObject2$d()), vm.isEncrypted ? vm.i18n(_templateObject3$9()) : vm.i18n(_templateObject4$6())), this._createOptions(t, vm)]);
        }
      }, {
        key: "_createSection",
        value: function _createSection(t, label, value) {
          return t.div({
            className: "MemberDetailsView_section"
          }, [t.div({
            className: "MemberDetailsView_label"
          }, label), t.div({
            className: "MemberDetailsView_value"
          }, value)]);
        }
      }, {
        key: "_createOptions",
        value: function _createOptions(t, vm) {
          return t.div({
            className: "MemberDetailsView_section"
          }, [t.div({
            className: "MemberDetailsView_label"
          }, vm.i18n(_templateObject5$5())), t.div({
            className: "MemberDetailsView_options"
          }, [t.a({
            href: vm.linkToUser,
            target: "_blank",
            rel: "noopener"
          }, vm.i18n(_templateObject6$5()))])]);
        }
      }]);

      return MemberDetailsView;
    }(TemplateView);

    var RightPanelView = /*#__PURE__*/function (_TemplateView) {
      _inherits(RightPanelView, _TemplateView);

      var _super = _createSuper(RightPanelView);

      function RightPanelView() {
        _classCallCheck(this, RightPanelView);

        return _super.apply(this, arguments);
      }

      _createClass(RightPanelView, [{
        key: "render",
        value: function render(t) {
          var _this = this;

          return t.div({
            className: "RightPanelView"
          }, [t.ifView(function (vm) {
            return vm.activeViewModel;
          }, function (vm) {
            return new ButtonsView(vm);
          }), t.mapView(function (vm) {
            return vm.activeViewModel;
          }, function (vm) {
            return _this._viewFromType(vm);
          })]);
        }
      }, {
        key: "_viewFromType",
        value: function _viewFromType(vm) {
          var type = vm === null || vm === void 0 ? void 0 : vm.type;

          switch (type) {
            case "room-details":
              return new RoomDetailsView(vm);

            case "member-list":
              return new MemberListView(vm);

            case "member-details":
              return new MemberDetailsView(vm);

            default:
              return new LoadingView();
          }
        }
      }]);

      return RightPanelView;
    }(TemplateView);

    var ButtonsView = /*#__PURE__*/function (_TemplateView2) {
      _inherits(ButtonsView, _TemplateView2);

      var _super2 = _createSuper(ButtonsView);

      function ButtonsView() {
        _classCallCheck(this, ButtonsView);

        return _super2.apply(this, arguments);
      }

      _createClass(ButtonsView, [{
        key: "render",
        value: function render(t, vm) {
          return t.div({
            className: "RightPanelView_buttons"
          }, [t.button({
            className: {
              "back": true,
              "button-utility": true,
              "hide": !vm.activeViewModel.shouldShowBackButton
            },
            onClick: function onClick() {
              return vm.showPreviousPanel();
            }
          }), t.button({
            className: "close button-utility",
            onClick: function onClick() {
              return vm.closePanel();
            }
          })]);
        }
      }]);

      return ButtonsView;
    }(TemplateView);

    function _templateObject$f() {
      var data = _taggedTemplateLiteral(["Choose a room on the left side."]);

      _templateObject$f = function _templateObject() {
        return data;
      };

      return data;
    }
    var SessionView = /*#__PURE__*/function (_TemplateView) {
      _inherits(SessionView, _TemplateView);

      var _super = _createSuper(SessionView);

      function SessionView() {
        _classCallCheck(this, SessionView);

        return _super.apply(this, arguments);
      }

      _createClass(SessionView, [{
        key: "render",
        value: function render(t, vm) {
          return t.div({
            className: {
              "SessionView": true,
              "middle-shown": function middleShown(vm) {
                return !!vm.activeMiddleViewModel;
              },
              "right-shown": function rightShown(vm) {
                return !!vm.rightPanelViewModel;
              }
            }
          }, [t.view(new SessionStatusView(vm.sessionStatusViewModel)), t.view(new LeftPanelView(vm.leftPanelViewModel)), t.mapView(function (vm) {
            return vm.activeMiddleViewModel;
          }, function () {
            if (vm.roomGridViewModel) {
              return new RoomGridView(vm.roomGridViewModel);
            } else if (vm.settingsViewModel) {
              return new SettingsView(vm.settingsViewModel);
            } else if (vm.currentRoomViewModel) {
              if (vm.currentRoomViewModel.kind === "invite") {
                return new InviteView(vm.currentRoomViewModel);
              } else if (vm.currentRoomViewModel.kind === "room") {
                return new RoomView(vm.currentRoomViewModel);
              } else {
                return new UnknownRoomView(vm.currentRoomViewModel);
              }
            } else {
              return new StaticView(function (t) {
                return t.div({
                  className: "room-placeholder"
                }, t.h2(vm.i18n(_templateObject$f())));
              });
            }
          }), t.mapView(function (vm) {
            return vm.lightboxViewModel;
          }, function (lightboxViewModel) {
            return lightboxViewModel ? new LightboxView(lightboxViewModel) : null;
          }), t.mapView(function (vm) {
            return vm.rightPanelViewModel;
          }, function (rightPanelViewModel) {
            return rightPanelViewModel ? new RightPanelView(rightPanelViewModel) : null;
          })]);
        }
      }]);

      return SessionView;
    }(TemplateView);

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function hydrogenGithubLink(t) {
      if (window.HYDROGEN_VERSION) {
        return t.a({
          target: "_blank",
          href: "https://github.com/vector-im/hydrogen-web/releases/tag/v".concat(window.HYDROGEN_VERSION)
        }, "Hydrogen v".concat(window.HYDROGEN_VERSION, " (").concat(window.HYDROGEN_GLOBAL_HASH, ") on Github"));
      } else {
        return t.a({
          target: "_blank",
          href: "https://github.com/vector-im/hydrogen-web"
        }, "Hydrogen on Github");
      }
    }

    function _templateObject5$6() {
      var data = _taggedTemplateLiteral(["Log In"]);

      _templateObject5$6 = function _templateObject5() {
        return data;
      };

      return data;
    }

    function _templateObject4$7() {
      var data = _taggedTemplateLiteral(["Password"]);

      _templateObject4$7 = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3$a() {
      var data = _taggedTemplateLiteral(["Username"]);

      _templateObject3$a = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$e() {
      var data = _taggedTemplateLiteral(["Password"]);

      _templateObject2$e = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$g() {
      var data = _taggedTemplateLiteral(["Username"]);

      _templateObject$g = function _templateObject() {
        return data;
      };

      return data;
    }
    var PasswordLoginView = /*#__PURE__*/function (_TemplateView) {
      _inherits(PasswordLoginView, _TemplateView);

      var _super = _createSuper(PasswordLoginView);

      function PasswordLoginView() {
        _classCallCheck(this, PasswordLoginView);

        return _super.apply(this, arguments);
      }

      _createClass(PasswordLoginView, [{
        key: "render",
        value: function render(t, vm) {
          var disabled = function disabled(vm) {
            return !!vm.isBusy;
          };

          var username = t.input({
            id: "username",
            type: "text",
            placeholder: vm.i18n(_templateObject$g()),
            disabled: disabled
          });
          var password = t.input({
            id: "password",
            type: "password",
            placeholder: vm.i18n(_templateObject2$e()),
            disabled: disabled
          });
          return t.div({
            className: "PasswordLoginView form"
          }, [t.if(function (vm) {
            return vm.error;
          }, function (t) {
            return t.div({
              className: "error"
            }, function (vm) {
              return vm.error;
            });
          }), t.form({
            onSubmit: function onSubmit(evnt) {
              evnt.preventDefault();
              vm.login(username.value, password.value);
            }
          }, [t.if(function (vm) {
            return vm.errorMessage;
          }, function (t, vm) {
            return t.p({
              className: "error"
            }, vm.i18n(vm.errorMessage));
          }), t.div({
            className: "form-row"
          }, [t.label({
            for: "username"
          }, vm.i18n(_templateObject3$a())), username]), t.div({
            className: "form-row"
          }, [t.label({
            for: "password"
          }, vm.i18n(_templateObject4$7())), password]), t.div({
            className: "button-row"
          }, [t.button({
            className: "button-action primary",
            type: "submit",
            disabled: disabled
          }, vm.i18n(_templateObject5$6()))])])]);
        }
      }]);

      return PasswordLoginView;
    }(TemplateView);

    function _templateObject5$7() {
      var data = _taggedTemplateLiteral(["Continue without restoring"]);

      _templateObject5$7 = function _templateObject5() {
        return data;
      };

      return data;
    }

    function _templateObject4$8() {
      var data = _taggedTemplateLiteral(["Continue"]);

      _templateObject4$8 = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3$b() {
      var data = _taggedTemplateLiteral(["This will claim the dehydrated device ", ", and will set up a new one."]);

      _templateObject3$b = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$f() {
      var data = _taggedTemplateLiteral(["That worked out, you're good to go!"]);

      _templateObject2$f = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$h() {
      var data = _taggedTemplateLiteral(["Restore your encrypted history?"]);

      _templateObject$h = function _templateObject() {
        return data;
      };

      return data;
    }
    var AccountSetupView = /*#__PURE__*/function (_TemplateView) {
      _inherits(AccountSetupView, _TemplateView);

      var _super = _createSuper(AccountSetupView);

      function AccountSetupView() {
        _classCallCheck(this, AccountSetupView);

        return _super.apply(this, arguments);
      }

      _createClass(AccountSetupView, [{
        key: "render",
        value: function render(t, vm) {
          return t.div({
            className: "Settings"
            /* hack for now to get the layout right*/

          }, [t.h3(vm.i18n(_templateObject$h())), t.ifView(function (vm) {
            return vm.decryptDehydratedDeviceViewModel;
          }, function (vm) {
            return new SessionBackupSettingsView(vm.decryptDehydratedDeviceViewModel);
          }), t.map(function (vm) {
            return vm.deviceDecrypted;
          }, function (decrypted, t) {
            if (decrypted) {
              return t.p(vm.i18n(_templateObject2$f()));
            } else {
              return t.p(vm.i18n(_templateObject3$b(), vm.dehydratedDeviceId));
            }
          }), t.div({
            className: "button-row"
          }, [t.button({
            className: "button-action primary",
            onClick: function onClick() {
              vm.finish();
            },
            type: "button"
          }, function (vm) {
            return vm.deviceDecrypted ? vm.i18n(_templateObject4$8()) : vm.i18n(_templateObject5$7());
          })])]);
        }
      }]);

      return AccountSetupView;
    }(TemplateView);

    function _templateObject2$g() {
      var data = _taggedTemplateLiteral(["Log out"]);

      _templateObject2$g = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$i() {
      var data = _taggedTemplateLiteral(["Export logs"]);

      _templateObject$i = function _templateObject() {
        return data;
      };

      return data;
    }
    /** a view used both in the login view and the loading screen
    to show the current state of loading the session.
    Just a spinner and a label, meant to be used as a paragraph */

    var SessionLoadStatusView = /*#__PURE__*/function (_TemplateView) {
      _inherits(SessionLoadStatusView, _TemplateView);

      var _super = _createSuper(SessionLoadStatusView);

      function SessionLoadStatusView() {
        _classCallCheck(this, SessionLoadStatusView);

        return _super.apply(this, arguments);
      }

      _createClass(SessionLoadStatusView, [{
        key: "render",
        value: function render(t) {
          var exportLogsButtonIfFailed = t.if(function (vm) {
            return vm.hasError;
          }, function (t, vm) {
            return t.button({
              onClick: function onClick() {
                return vm.exportLogs();
              }
            }, vm.i18n(_templateObject$i()));
          });
          var logoutButtonIfFailed = t.if(function (vm) {
            return vm.hasError;
          }, function (t, vm) {
            return t.button({
              onClick: function onClick() {
                return vm.logout();
              }
            }, vm.i18n(_templateObject2$g()));
          });
          return t.div({
            className: "SessionLoadStatusView"
          }, [t.p({
            className: "status"
          }, [spinner(t, {
            hidden: function hidden(vm) {
              return !vm.loading;
            }
          }), t.p(function (vm) {
            return vm.loadLabel;
          }), exportLogsButtonIfFailed, logoutButtonIfFailed]), t.ifView(function (vm) {
            return vm.accountSetupViewModel;
          }, function (vm) {
            return new AccountSetupView(vm.accountSetupViewModel);
          })]);
        }
      }]);

      return SessionLoadStatusView;
    }(TemplateView);

    var CompleteSSOView = /*#__PURE__*/function (_TemplateView) {
      _inherits(CompleteSSOView, _TemplateView);

      var _super = _createSuper(CompleteSSOView);

      function CompleteSSOView() {
        _classCallCheck(this, CompleteSSOView);

        return _super.apply(this, arguments);
      }

      _createClass(CompleteSSOView, [{
        key: "render",
        value: function render(t) {
          return t.div({
            className: "CompleteSSOView"
          }, [t.p({
            className: "CompleteSSOView_title"
          }, "Finishing up your SSO Login"), t.if(function (vm) {
            return vm.errorMessage;
          }, function (t, vm) {
            return t.p({
              className: "error"
            }, vm.i18n(vm.errorMessage));
          }), t.mapView(function (vm) {
            return vm.loadViewModel;
          }, function (loadViewModel) {
            return loadViewModel ? new SessionLoadStatusView(loadViewModel) : null;
          })]);
        }
      }]);

      return CompleteSSOView;
    }(TemplateView);

    function _templateObject6$6() {
      var data = _taggedTemplateLiteral(["Log in with SSO"]);

      _templateObject6$6 = function _templateObject6() {
        return data;
      };

      return data;
    }

    function _templateObject5$8() {
      var data = _taggedTemplateLiteral(["or"]);

      _templateObject5$8 = function _templateObject5() {
        return data;
      };

      return data;
    }

    function _templateObject4$9() {
      var data = _taggedTemplateLiteral(["You will connect to ", "."]);

      _templateObject4$9 = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3$c() {
      var data = _taggedTemplateLiteral(["Your matrix homeserver"]);

      _templateObject3$c = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$h() {
      var data = _taggedTemplateLiteral(["Homeserver"]);

      _templateObject2$h = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$j() {
      var data = _taggedTemplateLiteral(["Sign In"]);

      _templateObject$j = function _templateObject() {
        return data;
      };

      return data;
    }
    var LoginView = /*#__PURE__*/function (_TemplateView) {
      _inherits(LoginView, _TemplateView);

      var _super = _createSuper(LoginView);

      function LoginView() {
        _classCallCheck(this, LoginView);

        return _super.apply(this, arguments);
      }

      _createClass(LoginView, [{
        key: "render",
        value: function render(t, vm) {
          var disabled = function disabled(vm) {
            return vm.isBusy;
          };

          return t.div({
            className: "PreSessionScreen"
          }, [t.button({
            className: "button-utility LoginView_back",
            onClick: function onClick() {
              return vm.goBack();
            },
            disabled: disabled
          }), t.div({
            className: "logo"
          }), t.h1([vm.i18n(_templateObject$j())]), t.mapView(function (vm) {
            return vm.completeSSOLoginViewModel;
          }, function (vm) {
            return vm ? new CompleteSSOView(vm) : null;
          }), t.if(function (vm) {
            return vm.showHomeserver;
          }, function (t, vm) {
            return t.div({
              className: "LoginView_sso form form-row"
            }, [t.label({
              for: "homeserver"
            }, vm.i18n(_templateObject2$h())), t.input({
              id: "homeserver",
              type: "text",
              placeholder: vm.i18n(_templateObject3$c()),
              value: vm.homeserver,
              disabled: disabled,
              onInput: function onInput(event) {
                return vm.setHomeserver(event.target.value);
              },
              onChange: function onChange() {
                return vm.queryHomeserver();
              }
            }), t.p({
              className: {
                LoginView_forwardInfo: true,
                hidden: function hidden(vm) {
                  return !vm.resolvedHomeserver;
                }
              }
            }, function (vm) {
              return vm.i18n(_templateObject4$9(), vm.resolvedHomeserver);
            }), t.if(function (vm) {
              return vm.errorMessage;
            }, function (t, vm) {
              return t.p({
                className: "error"
              }, vm.i18n(vm.errorMessage));
            })]);
          }), t.if(function (vm) {
            return vm.isFetchingLoginOptions;
          }, function (t) {
            return t.div({
              className: "LoginView_query-spinner"
            }, [spinner(t), t.p("Fetching available login options...")]);
          }), t.mapView(function (vm) {
            return vm.passwordLoginViewModel;
          }, function (vm) {
            return vm ? new PasswordLoginView(vm) : null;
          }), t.if(function (vm) {
            return vm.passwordLoginViewModel && vm.startSSOLoginViewModel;
          }, function (t) {
            return t.p({
              className: "LoginView_separator"
            }, vm.i18n(_templateObject5$8()));
          }), t.mapView(function (vm) {
            return vm.startSSOLoginViewModel;
          }, function (vm) {
            return vm ? new StartSSOLoginView(vm) : null;
          }), t.mapView(function (vm) {
            return vm.loadViewModel;
          }, function (loadViewModel) {
            return loadViewModel ? new SessionLoadStatusView(loadViewModel) : null;
          }), // use t.mapView rather than t.if to create a new view when the view model changes too
          t.p(hydrogenGithubLink(t))]);
        }
      }]);

      return LoginView;
    }(TemplateView);

    var StartSSOLoginView = /*#__PURE__*/function (_TemplateView2) {
      _inherits(StartSSOLoginView, _TemplateView2);

      var _super2 = _createSuper(StartSSOLoginView);

      function StartSSOLoginView() {
        _classCallCheck(this, StartSSOLoginView);

        return _super2.apply(this, arguments);
      }

      _createClass(StartSSOLoginView, [{
        key: "render",
        value: function render(t, vm) {
          return t.div({
            className: "StartSSOLoginView"
          }, t.button({
            className: "StartSSOLoginView_button button-action secondary",
            type: "button",
            onClick: function onClick() {
              return vm.startSSOLogin();
            },
            disabled: function disabled(vm) {
              return vm.isBusy;
            }
          }, vm.i18n(_templateObject6$6())));
        }
      }]);

      return StartSSOLoginView;
    }(TemplateView);

    function _templateObject$k() {
      var data = _taggedTemplateLiteral(["Go back"]);

      _templateObject$k = function _templateObject() {
        return data;
      };

      return data;
    }
    var SessionLoadView = /*#__PURE__*/function (_TemplateView) {
      _inherits(SessionLoadView, _TemplateView);

      var _super = _createSuper(SessionLoadView);

      function SessionLoadView() {
        _classCallCheck(this, SessionLoadView);

        return _super.apply(this, arguments);
      }

      _createClass(SessionLoadView, [{
        key: "render",
        value: function render(t, vm) {
          return t.div({
            className: "PreSessionScreen"
          }, [t.div({
            className: "logo"
          }), t.div({
            className: "SessionLoadView"
          }, [t.view(new SessionLoadStatusView(vm))]), t.div({
            className: {
              "button-row": true,
              hidden: function hidden(vm) {
                return vm.loading;
              }
            }
          }, t.a({
            className: "button-action primary",
            href: vm.backUrl
          }, vm.i18n(_templateObject$k())))]);
        }
      }]);

      return SessionLoadView;
    }(TemplateView);

    function _templateObject$l() {
      var data = _taggedTemplateLiteral(["Sign In"]);

      _templateObject$l = function _templateObject() {
        return data;
      };

      return data;
    }

    var SessionPickerItemView = /*#__PURE__*/function (_TemplateView) {
      _inherits(SessionPickerItemView, _TemplateView);

      var _super = _createSuper(SessionPickerItemView);

      function SessionPickerItemView() {
        _classCallCheck(this, SessionPickerItemView);

        return _super.apply(this, arguments);
      }

      _createClass(SessionPickerItemView, [{
        key: "_onDeleteClick",
        value: function _onDeleteClick() {
          if (confirm("Are you sure?")) {
            this.value.delete();
          }
        }
      }, {
        key: "_onClearClick",
        value: function _onClearClick() {
          if (confirm("Are you sure?")) {
            this.value.clear();
          }
        }
      }, {
        key: "render",
        value: function render(t, vm) {
          return t.li([t.a({
            className: "session-info",
            href: vm.openUrl
          }, [t.div({
            className: "avatar usercolor".concat(vm.avatarColorNumber)
          }, function (vm) {
            return vm.avatarInitials;
          }), t.div({
            className: "user-id"
          }, function (vm) {
            return vm.label;
          })])]);
        }
      }]);

      return SessionPickerItemView;
    }(TemplateView);

    var SessionPickerView = /*#__PURE__*/function (_TemplateView2) {
      _inherits(SessionPickerView, _TemplateView2);

      var _super2 = _createSuper(SessionPickerView);

      function SessionPickerView() {
        _classCallCheck(this, SessionPickerView);

        return _super2.apply(this, arguments);
      }

      _createClass(SessionPickerView, [{
        key: "render",
        value: function render(t, vm) {
          var sessionList = new ListView({
            list: vm.sessions,
            parentProvidesUpdates: false
          }, function (sessionInfo) {
            return new SessionPickerItemView(sessionInfo);
          });
          return t.div({
            className: "PreSessionScreen"
          }, [t.div({
            className: "logo"
          }), t.div({
            className: "SessionPickerView"
          }, [t.h1(["Continue as …"]), t.view(sessionList), t.div({
            className: "button-row"
          }, [t.a({
            className: "button-action primary",
            href: vm.cancelUrl
          }, vm.i18n(_templateObject$l()))]), t.ifView(function (vm) {
            return vm.loadViewModel;
          }, function () {
            return new SessionLoadStatusView(vm.loadViewModel);
          }), t.p(hydrogenGithubLink(t))])]);
        }
      }]);

      return SessionPickerView;
    }(TemplateView);

    var RootView = /*#__PURE__*/function (_TemplateView) {
      _inherits(RootView, _TemplateView);

      var _super = _createSuper(RootView);

      function RootView() {
        _classCallCheck(this, RootView);

        return _super.apply(this, arguments);
      }

      _createClass(RootView, [{
        key: "render",
        value: function render(t, vm) {
          return t.mapView(function (vm) {
            return vm.activeSection;
          }, function (activeSection) {
            switch (activeSection) {
              case "error":
                return new StaticView(function (t) {
                  return t.div({
                    className: "StatusView"
                  }, [t.h1("Something went wrong"), t.p(vm.errorText)]);
                });

              case "session":
                return new SessionView(vm.sessionViewModel);

              case "login":
                return new LoginView(vm.loginViewModel);

              case "picker":
                return new SessionPickerView(vm.sessionPickerViewModel);

              case "redirecting":
                return new StaticView(function (t) {
                  return t.p("Redirecting...");
                });

              case "loading":
                return new SessionLoadView(vm.sessionLoadViewModel);

              default:
                throw new Error("Unknown section: ".concat(vm.activeSection));
            }
          });
        }
      }]);

      return RootView;
    }(TemplateView);

    var Timeout = /*#__PURE__*/function () {
      function Timeout(ms) {
        var _this = this;

        _classCallCheck(this, Timeout);

        this._reject = null;
        this._handle = null;
        this._promise = new Promise(function (resolve, reject) {
          _this._reject = reject;
          _this._handle = setTimeout(function () {
            _this._reject = null;
            resolve();
          }, ms);
        });
      }

      _createClass(Timeout, [{
        key: "elapsed",
        value: function elapsed() {
          return this._promise;
        }
      }, {
        key: "abort",
        value: function abort() {
          if (this._reject) {
            this._reject(new AbortError());

            clearTimeout(this._handle);
            this._handle = null;
            this._reject = null;
          }
        }
      }, {
        key: "dispose",
        value: function dispose() {
          this.abort();
        }
      }]);

      return Timeout;
    }();

    var Interval = /*#__PURE__*/function () {
      function Interval(ms, callback) {
        _classCallCheck(this, Interval);

        this._handle = setInterval(callback, ms);
      }

      _createClass(Interval, [{
        key: "dispose",
        value: function dispose() {
          if (this._handle) {
            clearInterval(this._handle);
            this._handle = null;
          }
        }
      }]);

      return Interval;
    }();

    var TimeMeasure = /*#__PURE__*/function () {
      function TimeMeasure() {
        _classCallCheck(this, TimeMeasure);

        this._start = window.performance.now();
      }

      _createClass(TimeMeasure, [{
        key: "measure",
        value: function measure() {
          return window.performance.now() - this._start;
        }
      }]);

      return TimeMeasure;
    }();

    var Clock = /*#__PURE__*/function () {
      function Clock() {
        _classCallCheck(this, Clock);
      }

      _createClass(Clock, [{
        key: "createMeasure",
        value: function createMeasure() {
          return new TimeMeasure();
        }
      }, {
        key: "createTimeout",
        value: function createTimeout(ms) {
          return new Timeout(ms);
        }
      }, {
        key: "createInterval",
        value: function createInterval(callback, ms) {
          return new Interval(ms, callback);
        }
      }, {
        key: "now",
        value: function now() {
          return Date.now();
        }
      }]);

      return Clock;
    }();

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    // 3 (imaginary) interfaces are implemented here:
    // - OfflineAvailability (done by registering the sw)
    // - UpdateService (see checkForUpdate method, and should also emit events rather than showing confirm dialog here)
    // - ConcurrentAccessBlocker (see preventConcurrentSessionAccess method)
    var ServiceWorkerHandler = /*#__PURE__*/function () {
      function ServiceWorkerHandler() {
        _classCallCheck(this, ServiceWorkerHandler);

        this._waitingForReply = new Map();
        this._messageIdCounter = 0;
        this._navigation = null;
        this._registration = null;
        this._registrationPromise = null;
        this._currentController = null;
        this.haltRequests = false;
      }

      _createClass(ServiceWorkerHandler, [{
        key: "setNavigation",
        value: function setNavigation(navigation) {
          this._navigation = navigation;
        }
      }, {
        key: "registerAndStart",
        value: function registerAndStart(path) {
          var _this = this;

          this._registrationPromise = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    navigator.serviceWorker.addEventListener("message", _this);
                    navigator.serviceWorker.addEventListener("controllerchange", _this);
                    _context.next = 4;
                    return navigator.serviceWorker.register(path);

                  case 4:
                    _this._registration = _context.sent;
                    _context.next = 7;
                    return navigator.serviceWorker.ready;

                  case 7:
                    _this._currentController = navigator.serviceWorker.controller;

                    _this._registration.addEventListener("updatefound", _this);

                    _this._registrationPromise = null; // do we have a new service worker waiting to activate?

                    if (_this._registration.waiting && _this._registration.active) {
                      _this._proposeUpdate();
                    }

                    console.log("Service Worker registered");

                  case 12:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }))();
        }
      }, {
        key: "_onMessage",
        value: function _onMessage(event) {
          var data = event.data;
          var replyTo = data.replyTo;

          if (replyTo) {
            var resolve = this._waitingForReply.get(replyTo);

            if (resolve) {
              this._waitingForReply.delete(replyTo);

              resolve(data.payload);
            }
          }

          if (data.type === "hasSessionOpen") {
            var hasOpen = this._navigation.observe("session").get() === data.payload.sessionId;
            event.source.postMessage({
              replyTo: data.id,
              payload: hasOpen
            });
          } else if (data.type === "hasRoomOpen") {
            var hasSessionOpen = this._navigation.observe("session").get() === data.payload.sessionId;
            var hasRoomOpen = this._navigation.observe("room").get() === data.payload.roomId;
            event.source.postMessage({
              replyTo: data.id,
              payload: hasSessionOpen && hasRoomOpen
            });
          } else if (data.type === "closeSession") {
            var sessionId = data.payload.sessionId;

            this._closeSessionIfNeeded(sessionId).finally(function () {
              event.source.postMessage({
                replyTo: data.id
              });
            });
          } else if (data.type === "haltRequests") {
            // this flag is read in fetch.js
            this.haltRequests = true;
            event.source.postMessage({
              replyTo: data.id
            });
          } else if (data.type === "openRoom") {
            this._navigation.push("room", data.payload.roomId);
          }
        }
      }, {
        key: "_closeSessionIfNeeded",
        value: function _closeSessionIfNeeded(sessionId) {
          var _this$_navigation,
              _this2 = this;

          var currentSession = (_this$_navigation = this._navigation) === null || _this$_navigation === void 0 ? void 0 : _this$_navigation.path.get("session");

          if (sessionId && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.value) === sessionId) {
            return new Promise(function (resolve) {
              var unsubscribe = _this2._navigation.pathObservable.subscribe(function (path) {
                var session = path.get("session");

                if (!session || session.value !== sessionId) {
                  unsubscribe();
                  resolve();
                }
              });

              _this2._navigation.push("session");
            });
          } else {
            return Promise.resolve();
          }
        }
      }, {
        key: "_proposeUpdate",
        value: function () {
          var _proposeUpdate2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            var version;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (!document.hidden) {
                      _context2.next = 2;
                      break;
                    }

                    return _context2.abrupt("return");

                  case 2:
                    _context2.next = 4;
                    return this._sendAndWaitForReply("version", null, this._registration.waiting);

                  case 4:
                    version = _context2.sent;

                    if (!confirm("Version ".concat(version.version, " (").concat(version.buildHash, ") is available. Reload to apply?"))) {
                      _context2.next = 9;
                      break;
                    }

                    _context2.next = 8;
                    return this._sendAndWaitForReply("haltRequests");

                  case 8:
                    // only once all requests are blocked, ask the new
                    // service worker to skipWaiting
                    this._send("skipWaiting", null, this._registration.waiting);

                  case 9:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function _proposeUpdate() {
            return _proposeUpdate2.apply(this, arguments);
          }

          return _proposeUpdate;
        }()
      }, {
        key: "handleEvent",
        value: function handleEvent(event) {
          switch (event.type) {
            case "message":
              this._onMessage(event);

              break;

            case "updatefound":
              this._registration.installing.addEventListener("statechange", this);

              break;

            case "statechange":
              {
                if (event.target.state === "installed") {
                  this._proposeUpdate();

                  event.target.removeEventListener("statechange", this);
                }

                break;
              }

            case "controllerchange":
              if (!this._currentController) {
                // Clients.claim() in the SW can trigger a controllerchange event
                // if we had no SW before. This is fine,
                // and now our requests will be served from the SW.
                this._currentController = navigator.serviceWorker.controller;
              } else {
                // active service worker changed,
                // refresh, so we can get all assets 
                // (and not only some if we would not refresh)
                // up to date from it
                document.location.reload();
              }

              break;
          }
        }
      }, {
        key: "_send",
        value: function () {
          var _send2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(type, payload) {
            var worker,
                _args3 = arguments;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    worker = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : undefined;

                    if (!this._registrationPromise) {
                      _context3.next = 4;
                      break;
                    }

                    _context3.next = 4;
                    return this._registrationPromise;

                  case 4:
                    if (!worker) {
                      worker = this._registration.active;
                    }

                    worker.postMessage({
                      type: type,
                      payload: payload
                    });

                  case 6:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function _send(_x, _x2) {
            return _send2.apply(this, arguments);
          }

          return _send;
        }()
      }, {
        key: "_sendAndWaitForReply",
        value: function () {
          var _sendAndWaitForReply2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(type, payload) {
            var _this3 = this;

            var worker,
                id,
                promise,
                _args4 = arguments;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    worker = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : undefined;

                    if (!this._registrationPromise) {
                      _context4.next = 4;
                      break;
                    }

                    _context4.next = 4;
                    return this._registrationPromise;

                  case 4:
                    if (!worker) {
                      worker = this._registration.active;
                    }

                    this._messageIdCounter += 1;
                    id = this._messageIdCounter;
                    promise = new Promise(function (resolve) {
                      _this3._waitingForReply.set(id, resolve);
                    });
                    worker.postMessage({
                      type: type,
                      id: id,
                      payload: payload
                    });
                    _context4.next = 11;
                    return promise;

                  case 11:
                    return _context4.abrupt("return", _context4.sent);

                  case 12:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function _sendAndWaitForReply(_x3, _x4) {
            return _sendAndWaitForReply2.apply(this, arguments);
          }

          return _sendAndWaitForReply;
        }()
      }, {
        key: "checkForUpdate",
        value: function () {
          var _checkForUpdate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (!this._registrationPromise) {
                      _context5.next = 3;
                      break;
                    }

                    _context5.next = 3;
                    return this._registrationPromise;

                  case 3:
                    this._registration.update();

                  case 4:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));

          function checkForUpdate() {
            return _checkForUpdate.apply(this, arguments);
          }

          return checkForUpdate;
        }()
      }, {
        key: "preventConcurrentSessionAccess",
        value: function () {
          var _preventConcurrentSessionAccess = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(sessionId) {
            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    return _context6.abrupt("return", this._sendAndWaitForReply("closeSession", {
                      sessionId: sessionId
                    }));

                  case 1:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));

          function preventConcurrentSessionAccess(_x5) {
            return _preventConcurrentSessionAccess.apply(this, arguments);
          }

          return preventConcurrentSessionAccess;
        }()
      }, {
        key: "getRegistration",
        value: function () {
          var _getRegistration = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    if (!this._registrationPromise) {
                      _context7.next = 3;
                      break;
                    }

                    _context7.next = 3;
                    return this._registrationPromise;

                  case 3:
                    return _context7.abrupt("return", this._registration);

                  case 4:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));

          function getRegistration() {
            return _getRegistration.apply(this, arguments);
          }

          return getRegistration;
        }()
      }, {
        key: "version",
        get: function get() {
          return window.HYDROGEN_VERSION;
        }
      }, {
        key: "buildHash",
        get: function get() {
          return window.HYDROGEN_GLOBAL_HASH;
        }
      }]);

      return ServiceWorkerHandler;
    }();

    /*
    Copyright 2021 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var NotificationService = /*#__PURE__*/function () {
      function NotificationService(serviceWorkerHandler, pushConfig) {
        _classCallCheck(this, NotificationService);

        this._serviceWorkerHandler = serviceWorkerHandler;
        this._pushConfig = pushConfig;
      }

      _createClass(NotificationService, [{
        key: "enablePush",
        value: function () {
          var _enablePush = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(pusherFactory, defaultPayload) {
            var _this$_serviceWorkerH;

            var registration, subscription, subscriptionData, pushkey, data;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return (_this$_serviceWorkerH = this._serviceWorkerHandler) === null || _this$_serviceWorkerH === void 0 ? void 0 : _this$_serviceWorkerH.getRegistration();

                  case 2:
                    registration = _context.sent;

                    if (!(registration === null || registration === void 0 ? void 0 : registration.pushManager)) {
                      _context.next = 11;
                      break;
                    }

                    _context.next = 6;
                    return registration.pushManager.subscribe({
                      userVisibleOnly: true,
                      applicationServerKey: this._pushConfig.applicationServerKey
                    });

                  case 6:
                    subscription = _context.sent;
                    subscriptionData = subscription.toJSON();
                    pushkey = subscriptionData.keys.p256dh;
                    data = {
                      endpoint: subscriptionData.endpoint,
                      auth: subscriptionData.keys.auth,
                      // don't deliver unread count push messages
                      // as we don't want to show a notification in this case
                      events_only: true,
                      default_payload: defaultPayload
                    };
                    return _context.abrupt("return", pusherFactory.httpPusher(this._pushConfig.gatewayUrl, this._pushConfig.appId, pushkey, data));

                  case 11:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function enablePush(_x, _x2) {
            return _enablePush.apply(this, arguments);
          }

          return enablePush;
        }()
      }, {
        key: "disablePush",
        value: function () {
          var _disablePush = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            var _this$_serviceWorkerH2;

            var registration, subscription;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return (_this$_serviceWorkerH2 = this._serviceWorkerHandler) === null || _this$_serviceWorkerH2 === void 0 ? void 0 : _this$_serviceWorkerH2.getRegistration();

                  case 2:
                    registration = _context2.sent;

                    if (!(registration === null || registration === void 0 ? void 0 : registration.pushManager)) {
                      _context2.next = 10;
                      break;
                    }

                    _context2.next = 6;
                    return registration.pushManager.getSubscription();

                  case 6:
                    subscription = _context2.sent;

                    if (!subscription) {
                      _context2.next = 10;
                      break;
                    }

                    _context2.next = 10;
                    return subscription.unsubscribe();

                  case 10:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function disablePush() {
            return _disablePush.apply(this, arguments);
          }

          return disablePush;
        }()
      }, {
        key: "isPushEnabled",
        value: function () {
          var _isPushEnabled = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
            var _this$_serviceWorkerH3;

            var registration, subscription;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return (_this$_serviceWorkerH3 = this._serviceWorkerHandler) === null || _this$_serviceWorkerH3 === void 0 ? void 0 : _this$_serviceWorkerH3.getRegistration();

                  case 2:
                    registration = _context3.sent;

                    if (!(registration === null || registration === void 0 ? void 0 : registration.pushManager)) {
                      _context3.next = 8;
                      break;
                    }

                    _context3.next = 6;
                    return registration.pushManager.getSubscription();

                  case 6:
                    subscription = _context3.sent;
                    return _context3.abrupt("return", !!subscription);

                  case 8:
                    return _context3.abrupt("return", false);

                  case 9:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function isPushEnabled() {
            return _isPushEnabled.apply(this, arguments);
          }

          return isPushEnabled;
        }()
      }, {
        key: "supportsPush",
        value: function () {
          var _supportsPush = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
            var _this$_serviceWorkerH4;

            var registration;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (this._pushConfig) {
                      _context4.next = 2;
                      break;
                    }

                    return _context4.abrupt("return", false);

                  case 2:
                    _context4.next = 4;
                    return (_this$_serviceWorkerH4 = this._serviceWorkerHandler) === null || _this$_serviceWorkerH4 === void 0 ? void 0 : _this$_serviceWorkerH4.getRegistration();

                  case 4:
                    registration = _context4.sent;
                    return _context4.abrupt("return", registration && "pushManager" in registration);

                  case 6:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function supportsPush() {
            return _supportsPush.apply(this, arguments);
          }

          return supportsPush;
        }()
      }, {
        key: "enableNotifications",
        value: function () {
          var _enableNotifications = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (!("Notification" in window)) {
                      _context5.next = 5;
                      break;
                    }

                    _context5.next = 3;
                    return Notification.requestPermission();

                  case 3:
                    _context5.t0 = _context5.sent;
                    return _context5.abrupt("return", _context5.t0 === "granted");

                  case 5:
                    return _context5.abrupt("return", false);

                  case 6:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5);
          }));

          function enableNotifications() {
            return _enableNotifications.apply(this, arguments);
          }

          return enableNotifications;
        }()
      }, {
        key: "supportsNotifications",
        value: function () {
          var _supportsNotifications = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    return _context6.abrupt("return", "Notification" in window);

                  case 1:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6);
          }));

          function supportsNotifications() {
            return _supportsNotifications.apply(this, arguments);
          }

          return supportsNotifications;
        }()
      }, {
        key: "areNotificationsEnabled",
        value: function () {
          var _areNotificationsEnabled = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    if (!("Notification" in window)) {
                      _context7.next = 4;
                      break;
                    }

                    return _context7.abrupt("return", Notification.permission === "granted");

                  case 4:
                    return _context7.abrupt("return", false);

                  case 5:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7);
          }));

          function areNotificationsEnabled() {
            return _areNotificationsEnabled.apply(this, arguments);
          }

          return areNotificationsEnabled;
        }()
      }, {
        key: "showNotification",
        value: function () {
          var _showNotification = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(title) {
            var _this$_serviceWorkerH5;

            var body,
                registration,
                _args8 = arguments;
            return regeneratorRuntime.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    body = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : undefined;

                    if (!("Notification" in window)) {
                      _context8.next = 4;
                      break;
                    }

                    new Notification(title, {
                      body: body
                    });
                    return _context8.abrupt("return");

                  case 4:
                    _context8.next = 6;
                    return (_this$_serviceWorkerH5 = this._serviceWorkerHandler) === null || _this$_serviceWorkerH5 === void 0 ? void 0 : _this$_serviceWorkerH5.getRegistration();

                  case 6:
                    registration = _context8.sent;
                    registration === null || registration === void 0 ? void 0 : registration.showNotification(title, {
                      body: body
                    });

                  case 8:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));

          function showNotification(_x3) {
            return _showNotification.apply(this, arguments);
          }

          return showNotification;
        }()
      }]);

      return NotificationService;
    }();

    var History = /*#__PURE__*/function (_BaseObservableValue) {
      _inherits(History, _BaseObservableValue);

      var _super = _createSuper(History);

      function History() {
        _classCallCheck(this, History);

        return _super.apply(this, arguments);
      }

      _createClass(History, [{
        key: "handleEvent",
        value: function handleEvent(event) {
          if (event.type === "hashchange") {
            this.emit(this.get());

            this._storeHash(this.get());
          }
        }
      }, {
        key: "get",
        value: function get() {
          /*
          All URLS in Hydrogen will use <root>/#/segment/value/...
          But for SSO, we need to handle <root>/?loginToken=<TOKEN>
          Handle that as a special case for now.
          */
          if (document.location.search.includes("loginToken")) {
            return document.location.search;
          }

          return document.location.hash;
        }
        /** does not emit */

      }, {
        key: "replaceUrlSilently",
        value: function replaceUrlSilently(url) {
          window.history.replaceState(null, null, url);

          this._storeHash(url);
        }
        /** does not emit */

      }, {
        key: "pushUrlSilently",
        value: function pushUrlSilently(url) {
          window.history.pushState(null, null, url);

          this._storeHash(url);
        }
      }, {
        key: "pushUrl",
        value: function pushUrl(url) {
          document.location.hash = url;
        }
      }, {
        key: "urlAsPath",
        value: function urlAsPath(url) {
          if (url.startsWith("#")) {
            return url.substr(1);
          } else {
            return url;
          }
        }
      }, {
        key: "pathAsUrl",
        value: function pathAsUrl(path) {
          return "#".concat(path);
        }
      }, {
        key: "onSubscribeFirst",
        value: function onSubscribeFirst() {
          window.addEventListener('hashchange', this);
        }
      }, {
        key: "onUnsubscribeLast",
        value: function onUnsubscribeLast() {
          window.removeEventListener('hashchange', this);
        }
      }, {
        key: "_storeHash",
        value: function _storeHash(hash) {
          var _window$localStorage;

          (_window$localStorage = window.localStorage) === null || _window$localStorage === void 0 ? void 0 : _window$localStorage.setItem("hydrogen_last_url_hash", hash);
        }
      }, {
        key: "getLastUrl",
        value: function getLastUrl() {
          var _window$localStorage2;

          return (_window$localStorage2 = window.localStorage) === null || _window$localStorage2 === void 0 ? void 0 : _window$localStorage2.getItem("hydrogen_last_url_hash");
        }
      }]);

      return History;
    }(BaseObservableValue);

    var OnlineStatus = /*#__PURE__*/function (_BaseObservableValue) {
      _inherits(OnlineStatus, _BaseObservableValue);

      var _super = _createSuper(OnlineStatus);

      function OnlineStatus() {
        var _this;

        _classCallCheck(this, OnlineStatus);

        _this = _super.call(this);
        _this._onOffline = _this._onOffline.bind(_assertThisInitialized(_this));
        _this._onOnline = _this._onOnline.bind(_assertThisInitialized(_this));
        return _this;
      }

      _createClass(OnlineStatus, [{
        key: "_onOffline",
        value: function _onOffline() {
          this.emit(false);
        }
      }, {
        key: "_onOnline",
        value: function _onOnline() {
          this.emit(true);
        }
      }, {
        key: "get",
        value: function get() {
          return navigator.onLine;
        }
      }, {
        key: "onSubscribeFirst",
        value: function onSubscribeFirst() {
          window.addEventListener('offline', this._onOffline);
          window.addEventListener('online', this._onOnline);
        }
      }, {
        key: "onUnsubscribeLast",
        value: function onUnsubscribeLast() {
          window.removeEventListener('offline', this._onOffline);
          window.removeEventListener('online', this._onOnline);
        }
      }]);

      return OnlineStatus;
    }(BaseObservableValue);

    function subtleCryptoResult(promiseOrOp, method) {
      if (promiseOrOp instanceof Promise) {
        return promiseOrOp;
      } else {
        return new Promise(function (resolve, reject) {
          promiseOrOp.oncomplete = function (e) {
            return resolve(e.target.result);
          };

          promiseOrOp.onerror = function () {
            return reject(new Error("Crypto error on " + method));
          };
        });
      }
    }

    var HMACCrypto = /*#__PURE__*/function () {
      function HMACCrypto(subtleCrypto) {
        _classCallCheck(this, HMACCrypto);

        this._subtleCrypto = subtleCrypto;
      }
      /**
       * [hmac description]
       * @param  {BufferSource} key
       * @param  {BufferSource} mac
       * @param  {BufferSource} data
       * @param  {HashName} hash
       * @return {boolean}
       */


      _createClass(HMACCrypto, [{
        key: "verify",
        value: function () {
          var _verify = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(key, mac, data, hash) {
            var opts, hmacKey, isVerified;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    opts = {
                      name: 'HMAC',
                      hash: {
                        name: hashName(hash)
                      }
                    };
                    _context.next = 3;
                    return subtleCryptoResult(this._subtleCrypto.importKey('raw', key, opts, false, ['verify']), "importKey");

                  case 3:
                    hmacKey = _context.sent;
                    _context.next = 6;
                    return subtleCryptoResult(this._subtleCrypto.verify(opts, hmacKey, mac, data), "verify");

                  case 6:
                    isVerified = _context.sent;
                    return _context.abrupt("return", isVerified);

                  case 8:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function verify(_x, _x2, _x3, _x4) {
            return _verify.apply(this, arguments);
          }

          return verify;
        }()
      }, {
        key: "compute",
        value: function () {
          var _compute = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(key, data, hash) {
            var opts, hmacKey, buffer;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    opts = {
                      name: 'HMAC',
                      hash: {
                        name: hashName(hash)
                      }
                    };
                    _context2.next = 3;
                    return subtleCryptoResult(this._subtleCrypto.importKey('raw', key, opts, false, ['sign']), "importKey");

                  case 3:
                    hmacKey = _context2.sent;
                    _context2.next = 6;
                    return subtleCryptoResult(this._subtleCrypto.sign(opts, hmacKey, data), "sign");

                  case 6:
                    buffer = _context2.sent;
                    return _context2.abrupt("return", new Uint8Array(buffer));

                  case 8:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function compute(_x5, _x6, _x7) {
            return _compute.apply(this, arguments);
          }

          return compute;
        }()
      }]);

      return HMACCrypto;
    }();

    var DeriveCrypto = /*#__PURE__*/function () {
      function DeriveCrypto(subtleCrypto, crypto, cryptoExtras) {
        _classCallCheck(this, DeriveCrypto);

        this._subtleCrypto = subtleCrypto;
        this._crypto = crypto;
        this._cryptoExtras = cryptoExtras;
      }
      /**
       * [pbkdf2 description]
       * @param  {BufferSource} password
       * @param  {Number} iterations
       * @param  {BufferSource} salt
       * @param  {HashName} hash
       * @param  {Number} length  the desired length of the generated key, in bits (not bytes!)
       * @return {BufferSource}
       */


      _createClass(DeriveCrypto, [{
        key: "pbkdf2",
        value: function () {
          var _pbkdf = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(password, iterations, salt, hash, length) {
            var key, keybits;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (this._subtleCrypto.deriveBits) {
                      _context3.next = 2;
                      break;
                    }

                    throw new Error("PBKDF2 is not supported");

                  case 2:
                    _context3.next = 4;
                    return subtleCryptoResult(this._subtleCrypto.importKey('raw', password, {
                      name: 'PBKDF2'
                    }, false, ['deriveBits']), "importKey");

                  case 4:
                    key = _context3.sent;
                    _context3.next = 7;
                    return subtleCryptoResult(this._subtleCrypto.deriveBits({
                      name: 'PBKDF2',
                      salt: salt,
                      iterations: iterations,
                      hash: hashName(hash)
                    }, key, length), "deriveBits");

                  case 7:
                    keybits = _context3.sent;
                    return _context3.abrupt("return", new Uint8Array(keybits));

                  case 9:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function pbkdf2(_x8, _x9, _x10, _x11, _x12) {
            return _pbkdf.apply(this, arguments);
          }

          return pbkdf2;
        }()
        /**
         * [hkdf description]
         * @param  {BufferSource} key    [description]
         * @param  {BufferSource} salt   [description]
         * @param  {BufferSource} info   [description]
         * @param  {HashName} hash the hash to use
         * @param  {Number} length desired length of the generated key in bits (not bytes!)
         * @return {[type]}        [description]
         */

      }, {
        key: "hkdf",
        value: function () {
          var _hkdf = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(key, salt, info, hash, length) {
            var hkdfkey, keybits;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (this._subtleCrypto.deriveBits) {
                      _context4.next = 2;
                      break;
                    }

                    return _context4.abrupt("return", this._cryptoExtras.hkdf(this._crypto, key, salt, info, hash, length));

                  case 2:
                    _context4.next = 4;
                    return subtleCryptoResult(this._subtleCrypto.importKey('raw', key, {
                      name: "HKDF"
                    }, false, ["deriveBits"]), "importKey");

                  case 4:
                    hkdfkey = _context4.sent;
                    _context4.next = 7;
                    return subtleCryptoResult(this._subtleCrypto.deriveBits({
                      name: "HKDF",
                      salt: salt,
                      info: info,
                      hash: hashName(hash)
                    }, hkdfkey, length), "deriveBits");

                  case 7:
                    keybits = _context4.sent;
                    return _context4.abrupt("return", new Uint8Array(keybits));

                  case 9:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function hkdf(_x13, _x14, _x15, _x16, _x17) {
            return _hkdf.apply(this, arguments);
          }

          return hkdf;
        }()
      }]);

      return DeriveCrypto;
    }();

    var AESCrypto = /*#__PURE__*/function () {
      function AESCrypto(subtleCrypto, crypto) {
        _classCallCheck(this, AESCrypto);

        this._subtleCrypto = subtleCrypto;
        this._crypto = crypto;
      }
      /**
       * [decrypt description]
       * @param  {BufferSource} key        [description]
       * @param  {Object} jwkKey        [description]
       * @param  {BufferSource} iv         [description]
       * @param  {BufferSource} data [description]
       * @param  {Number}       counterLength the size of the counter, in bits
       * @return {BufferSource}            [description]
       */


      _createClass(AESCrypto, [{
        key: "decryptCTR",
        value: function () {
          var _decryptCTR = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(_ref) {
            var key, jwkKey, iv, data, _ref$counterLength, counterLength, opts, aesKey, selectedKey, format, plaintext;

            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    key = _ref.key, jwkKey = _ref.jwkKey, iv = _ref.iv, data = _ref.data, _ref$counterLength = _ref.counterLength, counterLength = _ref$counterLength === void 0 ? 64 : _ref$counterLength;
                    opts = {
                      name: "AES-CTR",
                      counter: iv,
                      length: counterLength
                    };
                    _context5.prev = 2;
                    selectedKey = key || jwkKey;
                    format = jwkKey ? "jwk" : "raw";
                    _context5.next = 7;
                    return subtleCryptoResult(this._subtleCrypto.importKey(format, selectedKey, opts, false, ['decrypt']), "importKey");

                  case 7:
                    aesKey = _context5.sent;
                    _context5.next = 13;
                    break;

                  case 10:
                    _context5.prev = 10;
                    _context5.t0 = _context5["catch"](2);
                    throw new Error("Could not import key for AES-CTR decryption: ".concat(_context5.t0.message));

                  case 13:
                    _context5.prev = 13;
                    _context5.next = 16;
                    return subtleCryptoResult(this._subtleCrypto.decrypt( // see https://developer.mozilla.org/en-US/docs/Web/API/AesCtrParams
                    opts, aesKey, data), "decrypt");

                  case 16:
                    plaintext = _context5.sent;
                    return _context5.abrupt("return", new Uint8Array(plaintext));

                  case 20:
                    _context5.prev = 20;
                    _context5.t1 = _context5["catch"](13);
                    throw new Error("Could not decrypt with AES-CTR: ".concat(_context5.t1.message));

                  case 23:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this, [[2, 10], [13, 20]]);
          }));

          function decryptCTR(_x18) {
            return _decryptCTR.apply(this, arguments);
          }

          return decryptCTR;
        }()
      }, {
        key: "encryptCTR",
        value: function () {
          var _encryptCTR = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref2) {
            var key, jwkKey, iv, data, opts, aesKey, selectedKey, format, ciphertext;
            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    key = _ref2.key, jwkKey = _ref2.jwkKey, iv = _ref2.iv, data = _ref2.data;
                    opts = {
                      name: "AES-CTR",
                      counter: iv,
                      length: 64
                    };
                    selectedKey = key || jwkKey;
                    format = jwkKey ? "jwk" : "raw";
                    _context6.prev = 4;
                    _context6.next = 7;
                    return subtleCryptoResult(this._subtleCrypto.importKey(format, selectedKey, opts, false, ['encrypt']), "importKey");

                  case 7:
                    aesKey = _context6.sent;
                    _context6.next = 13;
                    break;

                  case 10:
                    _context6.prev = 10;
                    _context6.t0 = _context6["catch"](4);
                    throw new Error("Could not import key for AES-CTR encryption: ".concat(_context6.t0.message));

                  case 13:
                    _context6.prev = 13;
                    _context6.next = 16;
                    return subtleCryptoResult(this._subtleCrypto.encrypt( // see https://developer.mozilla.org/en-US/docs/Web/API/AesCtrParams
                    opts, aesKey, data), "encrypt");

                  case 16:
                    ciphertext = _context6.sent;
                    return _context6.abrupt("return", new Uint8Array(ciphertext));

                  case 20:
                    _context6.prev = 20;
                    _context6.t1 = _context6["catch"](13);
                    throw new Error("Could not encrypt with AES-CTR: ".concat(_context6.t1.message));

                  case 23:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this, [[4, 10], [13, 20]]);
          }));

          function encryptCTR(_x19) {
            return _encryptCTR.apply(this, arguments);
          }

          return encryptCTR;
        }()
        /**
         * Generate a CTR key
         * @param  {String} format "raw" or "jwk"
         * @param  {Number} length 128 or 256
         * @return {Promise<Object>}        an object for jwk, or a BufferSource for raw
         */

      }, {
        key: "generateKey",
        value: function () {
          var _generateKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(format) {
            var length,
                cryptoKey,
                _args7 = arguments;
            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    length = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : 256;
                    _context7.next = 3;
                    return subtleCryptoResult(this._subtleCrypto.generateKey({
                      "name": "AES-CTR",
                      length: length
                    }, true, ["encrypt", "decrypt"]));

                  case 3:
                    cryptoKey = _context7.sent;
                    return _context7.abrupt("return", subtleCryptoResult(this._subtleCrypto.exportKey(format, cryptoKey)));

                  case 5:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));

          function generateKey(_x20) {
            return _generateKey.apply(this, arguments);
          }

          return generateKey;
        }()
      }, {
        key: "generateIV",
        value: function () {
          var _generateIV2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
            return regeneratorRuntime.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    return _context8.abrupt("return", _generateIV(this._crypto));

                  case 1:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));

          function generateIV() {
            return _generateIV2.apply(this, arguments);
          }

          return generateIV;
        }()
      }]);

      return AESCrypto;
    }();

    function _generateIV(crypto) {
      var randomBytes = crypto.getRandomValues(new Uint8Array(8));
      var ivArray = new Uint8Array(16);

      for (var i = 0; i < randomBytes.length; i += 1) {
        ivArray[i] = randomBytes[i];
      }

      return ivArray;
    }

    function jwkKeyToRaw(jwkKey) {
      if (jwkKey.alg !== "A256CTR") {
        throw new Error("Unknown algorithm: ".concat(jwkKey.alg));
      }

      if (!jwkKey.key_ops.includes("decrypt")) {
        throw new Error("decrypt missing from key_ops");
      }

      if (jwkKey.kty !== "oct") {
        throw new Error("Invalid key type, \"oct\" expected: ".concat(jwkKey.kty));
      } // convert base64-url to normal base64


      var base64UrlKey = jwkKey.k;
      var base64Key = base64UrlKey.replace(/-/g, "+").replace(/_/g, "/");
      return base64Arraybuffer.decode(base64Key);
    }

    function encodeUnpaddedBase64(buffer) {
      var str = base64Arraybuffer.encode(buffer);
      var paddingIdx = str.indexOf("=");

      if (paddingIdx !== -1) {
        return str.substr(0, paddingIdx);
      } else {
        return str;
      }
    }

    function encodeUrlBase64(buffer) {
      var unpadded = encodeUnpaddedBase64(buffer);
      return unpadded.replace(/\+/g, "-").replace(/\//g, "_");
    }

    function rawKeyToJwk(key) {
      return {
        "alg": "A256CTR",
        "ext": true,
        "k": encodeUrlBase64(key),
        "key_ops": ["encrypt", "decrypt"],
        "kty": "oct"
      };
    }

    var AESLegacyCrypto = /*#__PURE__*/function () {
      function AESLegacyCrypto(aesjs, crypto) {
        _classCallCheck(this, AESLegacyCrypto);

        this._aesjs = aesjs;
        this._crypto = crypto;
      }
      /**
       * [decrypt description]
       * @param  {BufferSource} key        [description]
       * @param  {BufferSource} iv         [description]
       * @param  {BufferSource} ciphertext [description]
       * @param  {Number}       counterLength the size of the counter, in bits
       * @return {BufferSource}            [description]
       */


      _createClass(AESLegacyCrypto, [{
        key: "decryptCTR",
        value: function () {
          var _decryptCTR2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(_ref3) {
            var key, jwkKey, iv, data, _ref3$counterLength, counterLength, aesjs, aesCtr;

            return regeneratorRuntime.wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    key = _ref3.key, jwkKey = _ref3.jwkKey, iv = _ref3.iv, data = _ref3.data, _ref3$counterLength = _ref3.counterLength, counterLength = _ref3$counterLength === void 0 ? 64 : _ref3$counterLength;

                    if (!(counterLength !== 64)) {
                      _context9.next = 3;
                      break;
                    }

                    throw new Error("Unsupported counter length: ".concat(counterLength));

                  case 3:
                    if (jwkKey) {
                      key = jwkKeyToRaw(jwkKey);
                    }

                    aesjs = this._aesjs;
                    aesCtr = new aesjs.ModeOfOperation.ctr(new Uint8Array(key), new aesjs.Counter(new Uint8Array(iv)));
                    return _context9.abrupt("return", aesCtr.decrypt(new Uint8Array(data)));

                  case 7:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this);
          }));

          function decryptCTR(_x21) {
            return _decryptCTR2.apply(this, arguments);
          }

          return decryptCTR;
        }()
      }, {
        key: "encryptCTR",
        value: function () {
          var _encryptCTR2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(_ref4) {
            var key, jwkKey, iv, data, aesjs, aesCtr;
            return regeneratorRuntime.wrap(function _callee10$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    key = _ref4.key, jwkKey = _ref4.jwkKey, iv = _ref4.iv, data = _ref4.data;

                    if (jwkKey) {
                      key = jwkKeyToRaw(jwkKey);
                    }

                    aesjs = this._aesjs;
                    aesCtr = new aesjs.ModeOfOperation.ctr(new Uint8Array(key), new aesjs.Counter(new Uint8Array(iv)));
                    return _context10.abrupt("return", aesCtr.encrypt(new Uint8Array(data)));

                  case 5:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee10, this);
          }));

          function encryptCTR(_x22) {
            return _encryptCTR2.apply(this, arguments);
          }

          return encryptCTR;
        }()
        /**
         * Generate a CTR key
         * @param  {String} format "raw" or "jwk"
         * @param  {Number} length 128 or 256
         * @return {Promise<Object>}        an object for jwk, or a BufferSource for raw
         */

      }, {
        key: "generateKey",
        value: function () {
          var _generateKey2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(format) {
            var length,
                key,
                _args11 = arguments;
            return regeneratorRuntime.wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    length = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : 256;
                    key = crypto.getRandomValues(new Uint8Array(length / 8));

                    if (format === "jwk") {
                      key = rawKeyToJwk(key);
                    }

                    return _context11.abrupt("return", key);

                  case 4:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11);
          }));

          function generateKey(_x23) {
            return _generateKey2.apply(this, arguments);
          }

          return generateKey;
        }()
      }, {
        key: "generateIV",
        value: function () {
          var _generateIV3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
            return regeneratorRuntime.wrap(function _callee12$(_context12) {
              while (1) {
                switch (_context12.prev = _context12.next) {
                  case 0:
                    return _context12.abrupt("return", _generateIV(this._crypto));

                  case 1:
                  case "end":
                    return _context12.stop();
                }
              }
            }, _callee12, this);
          }));

          function generateIV() {
            return _generateIV3.apply(this, arguments);
          }

          return generateIV;
        }()
      }]);

      return AESLegacyCrypto;
    }();

    function hashName(name) {
      if (name !== "SHA-256" && name !== "SHA-512") {
        throw new Error("Invalid hash name: ".concat(name));
      }

      return name;
    }

    var Crypto = /*#__PURE__*/function () {
      function Crypto(cryptoExtras) {
        _classCallCheck(this, Crypto);

        var crypto = window.crypto || window.msCrypto;
        var subtleCrypto = crypto.subtle || crypto.webkitSubtle;
        this._subtleCrypto = subtleCrypto; // not exactly guaranteeing AES-CTR support
        // but in practice IE11 doesn't have this

        if (!subtleCrypto.deriveBits && (cryptoExtras === null || cryptoExtras === void 0 ? void 0 : cryptoExtras.aesjs)) {
          this.aes = new AESLegacyCrypto(cryptoExtras.aesjs, crypto);
        } else {
          this.aes = new AESCrypto(subtleCrypto, crypto);
        }

        this.hmac = new HMACCrypto(subtleCrypto);
        this.derive = new DeriveCrypto(subtleCrypto, this, cryptoExtras);
      }
      /**
       * [digest description]
       * @param  {HashName} hash
       * @param  {BufferSource} data
       * @return {BufferSource}
       */


      _createClass(Crypto, [{
        key: "digest",
        value: function () {
          var _digest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(hash, data) {
            return regeneratorRuntime.wrap(function _callee13$(_context13) {
              while (1) {
                switch (_context13.prev = _context13.next) {
                  case 0:
                    _context13.next = 2;
                    return subtleCryptoResult(this._subtleCrypto.digest(hashName(hash), data));

                  case 2:
                    return _context13.abrupt("return", _context13.sent);

                  case 3:
                  case "end":
                    return _context13.stop();
                }
              }
            }, _callee13, this);
          }));

          function digest(_x24, _x25) {
            return _digest.apply(this, arguments);
          }

          return digest;
        }()
      }, {
        key: "digestSize",
        value: function digestSize(hash) {
          switch (hashName(hash)) {
            case "SHA-512":
              return 64;

            case "SHA-256":
              return 32;

            default:
              throw new Error("Not implemented for ".concat(hashName(hash)));
          }
        }
      }]);

      return Crypto;
    }();

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function estimateStorageUsage() {
      return _estimateStorageUsage.apply(this, arguments);
    }

    function _estimateStorageUsage() {
      _estimateStorageUsage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _navigator, _navigator$storage;

        var _yield$navigator$stor, quota, usage;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!((_navigator = navigator) === null || _navigator === void 0 ? void 0 : (_navigator$storage = _navigator.storage) === null || _navigator$storage === void 0 ? void 0 : _navigator$storage.estimate)) {
                  _context.next = 9;
                  break;
                }

                _context.next = 3;
                return navigator.storage.estimate();

              case 3:
                _yield$navigator$stor = _context.sent;
                quota = _yield$navigator$stor.quota;
                usage = _yield$navigator$stor.usage;
                return _context.abrupt("return", {
                  quota: quota,
                  usage: usage
                });

              case 9:
                return _context.abrupt("return", {
                  quota: null,
                  usage: null
                });

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return _estimateStorageUsage.apply(this, arguments);
    }

    var WorkerState = /*#__PURE__*/function () {
      function WorkerState(worker) {
        _classCallCheck(this, WorkerState);

        this.worker = worker;
        this.busy = false;
      }

      _createClass(WorkerState, [{
        key: "attach",
        value: function attach(pool) {
          this.worker.addEventListener("message", pool);
          this.worker.addEventListener("error", pool);
        }
      }, {
        key: "detach",
        value: function detach(pool) {
          this.worker.removeEventListener("message", pool);
          this.worker.removeEventListener("error", pool);
        }
      }]);

      return WorkerState;
    }();

    var Request = /*#__PURE__*/function () {
      function Request(message, pool) {
        var _this = this;

        _classCallCheck(this, Request);

        this._promise = new Promise(function (_resolve, _reject) {
          _this._resolve = _resolve;
          _this._reject = _reject;
        });
        this._message = message;
        this._pool = pool;
        this._worker = null;
      }

      _createClass(Request, [{
        key: "abort",
        value: function abort() {
          if (this._isNotDisposed) {
            this._pool._abortRequest(this);

            this._dispose();
          }
        }
      }, {
        key: "response",
        value: function response() {
          return this._promise;
        }
      }, {
        key: "_dispose",
        value: function _dispose() {
          this._reject = null;
          this._resolve = null;
        }
      }, {
        key: "_isNotDisposed",
        get: function get() {
          return this._resolve && this._reject;
        }
      }]);

      return Request;
    }();

    var WorkerPool = /*#__PURE__*/function () {
      // TODO: extract DOM specific bits and write unit tests
      function WorkerPool(path, amount) {
        _classCallCheck(this, WorkerPool);

        this._workers = [];

        for (var i = 0; i < amount; ++i) {
          var worker = new WorkerState(new Worker(path));
          worker.attach(this);
          this._workers[i] = worker;
        }

        this._requests = new Map();
        this._counter = 0;
        this._pendingFlag = false;
        this._init = null;
      }

      _createClass(WorkerPool, [{
        key: "init",
        value: function init() {
          var _this2 = this;

          var promise = new Promise(function (resolve, reject) {
            _this2._init = {
              resolve: resolve,
              reject: reject
            };
          });
          this.sendAll({
            type: "ping"
          }).then(this._init.resolve, this._init.reject).finally(function () {
            _this2._init = null;
          });
          return promise;
        }
      }, {
        key: "handleEvent",
        value: function handleEvent(e) {
          if (e.type === "message") {
            var message = e.data;

            var request = this._requests.get(message.replyToId);

            if (request) {
              request._worker.busy = false;

              if (request._isNotDisposed) {
                if (message.type === "success") {
                  request._resolve(message.payload);
                } else if (message.type === "error") {
                  var err = new Error(message.message);
                  err.stack = message.stack;

                  request._reject(err);
                }

                request._dispose();
              }

              this._requests.delete(message.replyToId);
            }

            this._sendPending();
          } else if (e.type === "error") {
            if (this._init) {
              this._init.reject(new Error("worker error during init"));
            }

            console.error("worker error", e);
          }
        }
      }, {
        key: "_getPendingRequest",
        value: function _getPendingRequest() {
          var _iterator = _createForOfIteratorHelper(this._requests.values()),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var r = _step.value;

              if (!r._worker) {
                return r;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }, {
        key: "_getFreeWorker",
        value: function _getFreeWorker() {
          var _iterator2 = _createForOfIteratorHelper(this._workers),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var w = _step2.value;

              if (!w.busy) {
                return w;
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      }, {
        key: "_sendPending",
        value: function _sendPending() {
          this._pendingFlag = false;
          var success;

          do {
            success = false;

            var request = this._getPendingRequest();

            if (request) {
              var worker = this._getFreeWorker();

              if (worker) {
                this._sendWith(request, worker);

                success = true;
              }
            }
          } while (success);
        }
      }, {
        key: "_sendWith",
        value: function _sendWith(request, worker) {
          request._worker = worker;
          worker.busy = true;
          worker.worker.postMessage(request._message);
        }
      }, {
        key: "_enqueueRequest",
        value: function _enqueueRequest(message) {
          this._counter += 1;
          message.id = this._counter;
          var request = new Request(message, this);

          this._requests.set(message.id, request);

          return request;
        }
      }, {
        key: "send",
        value: function send(message) {
          var request = this._enqueueRequest(message);

          var worker = this._getFreeWorker();

          if (worker) {
            this._sendWith(request, worker);
          }

          return request;
        } // assumes all workers are free atm

      }, {
        key: "sendAll",
        value: function sendAll(message) {
          var _this3 = this;

          var promises = this._workers.map(function (worker) {
            var request = _this3._enqueueRequest(Object.assign({}, message));

            _this3._sendWith(request, worker);

            return request.response();
          });

          return Promise.all(promises);
        }
      }, {
        key: "dispose",
        value: function dispose() {
          var _iterator3 = _createForOfIteratorHelper(this._workers),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var w = _step3.value;
              w.detach(this);
              w.worker.terminate();
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      }, {
        key: "_trySendPendingInNextTick",
        value: function _trySendPendingInNextTick() {
          var _this4 = this;

          if (!this._pendingFlag) {
            this._pendingFlag = true;
            Promise.resolve().then(function () {
              _this4._sendPending();
            });
          }
        }
      }, {
        key: "_abortRequest",
        value: function _abortRequest(request) {
          request._reject(new AbortError());

          if (request._worker) {
            request._worker.busy = false;
          }

          this._requests.delete(request._message.id); // allow more requests to be aborted before trying to send other pending


          this._trySendPendingInNextTick();
        }
      }]);

      return WorkerPool;
    }();

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    // WARNING: We have to be very careful about what mime-types we allow into blobs.
    //
    // This means that the content is rendered using the origin of the script which
    // called createObjectURL(), and so if the content contains any scripting then it
    // will pose a XSS vulnerability when the browser renders it.  This is particularly
    // bad if the user right-clicks the URI and pastes it into a new window or tab,
    // as the blob will then execute with access to Element's full JS environment(!)
    //
    // See https://github.com/matrix-org/matrix-react-sdk/pull/1820#issuecomment-385210647
    // for details.
    //
    // We mitigate this by only allowing mime-types into blobs which we know don't
    // contain any scripting, and instantiate all others as application/octet-stream
    // regardless of what mime-type the event claimed.  Even if the payload itself
    // is some malicious HTML, the fact we instantiate it with a media mimetype or
    // application/octet-stream means the browser doesn't try to render it as such.
    //
    // One interesting edge case is image/svg+xml, which empirically *is* rendered
    // correctly if the blob is set to the src attribute of an img tag (for thumbnails)
    // *even if the mimetype is application/octet-stream*.  However, empirically JS
    // in the SVG isn't executed in this scenario, so we seem to be okay.
    //
    // Tested on Chrome 65 and Firefox 60
    //
    // The list below is taken mainly from
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats
    // N.B. Matrix doesn't currently specify which mimetypes are valid in given
    // events, so we pick the ones which HTML5 browsers should be able to display
    //
    // For the record, mime-types which must NEVER enter this list below include:
    //   text/html, text/xhtml, image/svg, image/svg+xml, image/pdf, and similar.
    var ALLOWED_BLOB_MIMETYPES = {
      'image/jpeg': true,
      'image/gif': true,
      'image/png': true,
      'video/mp4': true,
      'video/webm': true,
      'video/ogg': true,
      'video/quicktime': true,
      'video/VP8': true,
      'audio/mp4': true,
      'audio/webm': true,
      'audio/aac': true,
      'audio/mpeg': true,
      'audio/ogg': true,
      'audio/wave': true,
      'audio/wav': true,
      'audio/x-wav': true,
      'audio/x-pn-wav': true,
      'audio/flac': true,
      'audio/x-flac': true
    };
    var DEFAULT_MIMETYPE = 'application/octet-stream';
    var BlobHandle = /*#__PURE__*/function () {
      function BlobHandle(blob) {
        var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        _classCallCheck(this, BlobHandle);

        this._blob = blob;
        this._buffer = buffer;
        this._url = null;
      }

      _createClass(BlobHandle, [{
        key: "readAsBuffer",
        value: function () {
          var _readAsBuffer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var reader, promise;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!this._buffer) {
                      _context.next = 4;
                      break;
                    }

                    return _context.abrupt("return", this._buffer);

                  case 4:
                    reader = new FileReader();
                    promise = new Promise(function (resolve, reject) {
                      reader.addEventListener("load", function (evt) {
                        return resolve(evt.target.result);
                      });
                      reader.addEventListener("error", function (evt) {
                        return reject(evt.target.error);
                      });
                    });
                    reader.readAsArrayBuffer(this._blob);
                    return _context.abrupt("return", promise);

                  case 8:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function readAsBuffer() {
            return _readAsBuffer.apply(this, arguments);
          }

          return readAsBuffer;
        }()
      }, {
        key: "dispose",
        value: function dispose() {
          if (this._url) {
            URL.revokeObjectURL(this._url);
            this._url = null;
          }
        }
      }, {
        key: "nativeBlob",
        get: function get() {
          return this._blob;
        }
      }, {
        key: "url",
        get: function get() {
          if (!this._url) {
            this._url = URL.createObjectURL(this._blob);
          }

          return this._url;
        }
      }, {
        key: "size",
        get: function get() {
          return this._blob.size;
        }
      }, {
        key: "mimeType",
        get: function get() {
          return this._blob.type || DEFAULT_MIMETYPE;
        }
      }], [{
        key: "fromBuffer",
        value: function fromBuffer(buffer, mimetype) {
          mimetype = mimetype ? mimetype.split(";")[0].trim() : '';

          if (!ALLOWED_BLOB_MIMETYPES[mimetype]) {
            mimetype = DEFAULT_MIMETYPE;
          }

          return new BlobHandle(new Blob([buffer], {
            type: mimetype
          }), buffer);
        }
      }, {
        key: "fromBlob",
        value: function fromBlob(blob) {
          // ok to not filter mimetypes as these are local files
          return new BlobHandle(blob);
        }
      }]);

      return BlobHandle;
    }();

    var ImageHandle = /*#__PURE__*/function () {
      _createClass(ImageHandle, null, [{
        key: "fromBlob",
        value: function () {
          var _fromBlob = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(blob) {
            var img, width, height;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return loadImgFromBlob(blob);

                  case 2:
                    img = _context.sent;
                    width = img.width, height = img.height;
                    return _context.abrupt("return", new ImageHandle(blob, width, height, img));

                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function fromBlob(_x) {
            return _fromBlob.apply(this, arguments);
          }

          return fromBlob;
        }()
      }]);

      function ImageHandle(blob, width, height, imgElement) {
        _classCallCheck(this, ImageHandle);

        this.blob = blob;
        this.width = width;
        this.height = height;
        this._domElement = imgElement;
      }

      _createClass(ImageHandle, [{
        key: "_getDomElement",
        value: function () {
          var _getDomElement2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (this._domElement) {
                      _context2.next = 4;
                      break;
                    }

                    _context2.next = 3;
                    return loadImgFromBlob(this.blob);

                  case 3:
                    this._domElement = _context2.sent;

                  case 4:
                    return _context2.abrupt("return", this._domElement);

                  case 5:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function _getDomElement() {
            return _getDomElement2.apply(this, arguments);
          }

          return _getDomElement;
        }()
      }, {
        key: "scale",
        value: function () {
          var _scale = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(maxDimension) {
            var aspectRatio, scaleFactor, scaledWidth, scaledHeight, canvas, ctx, drawableElement, mimeType, nativeBlob, blob;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    aspectRatio = this.width / this.height;
                    scaleFactor = Math.min(1, maxDimension / (aspectRatio >= 1 ? this.width : this.height));
                    scaledWidth = Math.round(this.width * scaleFactor);
                    scaledHeight = Math.round(this.height * scaleFactor);
                    canvas = document.createElement("canvas");
                    canvas.width = scaledWidth;
                    canvas.height = scaledHeight;
                    ctx = canvas.getContext("2d");
                    _context3.next = 10;
                    return this._getDomElement();

                  case 10:
                    drawableElement = _context3.sent;
                    ctx.drawImage(drawableElement, 0, 0, scaledWidth, scaledHeight);
                    mimeType = this.blob.mimeType === "image/jpeg" ? "image/jpeg" : "image/png";

                    if (!canvas.toBlob) {
                      _context3.next = 19;
                      break;
                    }

                    _context3.next = 16;
                    return new Promise(function (resolve) {
                      return canvas.toBlob(resolve, mimeType);
                    });

                  case 16:
                    nativeBlob = _context3.sent;
                    _context3.next = 25;
                    break;

                  case 19:
                    if (!canvas.msToBlob) {
                      _context3.next = 24;
                      break;
                    }

                    // TODO: provide a mimetype override in blob handle for this case
                    mimeType = "image/png";
                    nativeBlob = canvas.msToBlob();
                    _context3.next = 25;
                    break;

                  case 24:
                    throw new Error("canvas can't be turned into blob");

                  case 25:
                    blob = BlobHandle.fromBlob(nativeBlob);
                    return _context3.abrupt("return", new ImageHandle(blob, scaledWidth, scaledHeight, null));

                  case 27:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function scale(_x2) {
            return _scale.apply(this, arguments);
          }

          return scale;
        }()
      }, {
        key: "dispose",
        value: function dispose() {
          this.blob.dispose();
        }
      }, {
        key: "maxDimension",
        get: function get() {
          return Math.max(this.width, this.height);
        }
      }]);

      return ImageHandle;
    }();
    var VideoHandle = /*#__PURE__*/function (_ImageHandle) {
      _inherits(VideoHandle, _ImageHandle);

      var _super = _createSuper(VideoHandle);

      function VideoHandle() {
        _classCallCheck(this, VideoHandle);

        return _super.apply(this, arguments);
      }

      _createClass(VideoHandle, [{
        key: "duration",
        get: function get() {
          if (typeof this._domElement.duration === "number") {
            return Math.round(this._domElement.duration * 1000);
          }

          return undefined;
        }
      }], [{
        key: "fromBlob",
        value: function () {
          var _fromBlob2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(blob) {
            var video, videoWidth, videoHeight;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return loadVideoFromBlob(blob);

                  case 2:
                    video = _context4.sent;
                    videoWidth = video.videoWidth, videoHeight = video.videoHeight;
                    return _context4.abrupt("return", new VideoHandle(blob, videoWidth, videoHeight, video));

                  case 5:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4);
          }));

          function fromBlob(_x3) {
            return _fromBlob2.apply(this, arguments);
          }

          return fromBlob;
        }()
      }]);

      return VideoHandle;
    }(ImageHandle);
    function hasReadPixelPermission() {
      var canvas = document.createElement("canvas");
      canvas.width = 1;
      canvas.height = 1;
      var ctx = canvas.getContext("2d");
      var rgb = [Math.round(Math.random() * 255), Math.round(Math.random() * 255), Math.round(Math.random() * 255)];
      ctx.fillStyle = "rgb(".concat(rgb[0], ", ").concat(rgb[1], ", ").concat(rgb[2], ")");
      ctx.fillRect(0, 0, 1, 1);
      var data = ctx.getImageData(0, 0, 1, 1).data;
      return data[0] === rgb[0] && data[1] === rgb[1] && data[2] === rgb[2];
    }

    function loadImgFromBlob(_x4) {
      return _loadImgFromBlob.apply(this, arguments);
    }

    function _loadImgFromBlob() {
      _loadImgFromBlob = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(blob) {
        var img, loadPromise;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                img = document.createElement("img");
                loadPromise = domEventAsPromise(img, "load");
                img.src = blob.url;
                _context5.next = 5;
                return loadPromise;

              case 5:
                return _context5.abrupt("return", img);

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));
      return _loadImgFromBlob.apply(this, arguments);
    }

    function loadVideoFromBlob(_x5) {
      return _loadVideoFromBlob.apply(this, arguments);
    }

    function _loadVideoFromBlob() {
      _loadVideoFromBlob = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(blob) {
        var video, loadPromise, seekPromise;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                video = document.createElement("video");
                video.muted = true;
                loadPromise = domEventAsPromise(video, "loadedmetadata");
                video.src = blob.url;
                video.load();
                _context6.next = 7;
                return loadPromise;

              case 7:
                // seek to the first 1/10s to make sure that drawing the video
                // on a canvas won't give a blank image
                seekPromise = domEventAsPromise(video, "seeked"); // needed for safari to reliably fire the seeked event,
                // somewhat hacky but using raf for example didn't do the trick

                _context6.next = 10;
                return new Promise(function (r) {
                  return setTimeout(r, 200);
                });

              case 10:
                video.currentTime = 0.1;
                _context6.next = 13;
                return seekPromise;

              case 13:
                return _context6.abrupt("return", video);

              case 14:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));
      return _loadVideoFromBlob.apply(this, arguments);
    }

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function downloadInIframe(_x, _x2, _x3, _x4, _x5) {
      return _downloadInIframe.apply(this, arguments);
    }

    function _downloadInIframe() {
      _downloadInIframe = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(container, iframeSrc, blobHandle, filename, isIOS) {
        var iframe, detach, buffer;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                iframe = container.querySelector("iframe.downloadSandbox");

                if (iframe) {
                  _context.next = 10;
                  break;
                }

                iframe = document.createElement("iframe");
                iframe.setAttribute("sandbox", "allow-scripts allow-downloads allow-downloads-without-user-activation");
                iframe.setAttribute("src", iframeSrc);
                iframe.className = "hidden downloadSandbox";
                container.appendChild(iframe);
                _context.next = 9;
                return new Promise(function (resolve, reject) {
                  detach = function detach() {
                    iframe.removeEventListener("load", resolve);
                    iframe.removeEventListener("error", reject);
                  };

                  iframe.addEventListener("load", resolve);
                  iframe.addEventListener("error", reject);
                });

              case 9:
                detach();

              case 10:
                if (!isIOS) {
                  _context.next = 17;
                  break;
                }

                _context.next = 13;
                return blobHandle.readAsBuffer();

              case 13:
                buffer = _context.sent;
                iframe.contentWindow.postMessage({
                  type: "downloadBuffer",
                  buffer: buffer,
                  mimeType: blobHandle.mimeType,
                  filename: filename
                }, "*");
                _context.next = 18;
                break;

              case 17:
                iframe.contentWindow.postMessage({
                  type: "downloadBlob",
                  blob: blobHandle.nativeBlob,
                  filename: filename
                }, "*");

              case 18:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return _downloadInIframe.apply(this, arguments);
    }

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function disposeValue(value) {
      if (typeof value === "function") {
        value();
      } else {
        value.dispose();
      }
    }

    function isDisposable(value) {
      return value && (typeof value === "function" || typeof value.dispose === "function");
    }

    var Disposables = /*#__PURE__*/function () {
      function Disposables() {
        _classCallCheck(this, Disposables);

        this._disposables = [];
      }

      _createClass(Disposables, [{
        key: "track",
        value: function track(disposable) {
          if (!isDisposable(disposable)) {
            throw new Error("Not a disposable");
          }

          if (this.isDisposed) {
            console.warn("Disposables already disposed, disposing new value");
            disposeValue(disposable);
            return disposable;
          }

          this._disposables.push(disposable);

          return disposable;
        }
      }, {
        key: "untrack",
        value: function untrack(disposable) {
          var idx = this._disposables.indexOf(disposable);

          if (idx >= 0) {
            this._disposables.splice(idx, 1);
          }

          return null;
        }
      }, {
        key: "dispose",
        value: function dispose() {
          if (this._disposables) {
            var _iterator = _createForOfIteratorHelper(this._disposables),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var d = _step.value;
                disposeValue(d);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            this._disposables = null;
          }
        }
      }, {
        key: "disposeTracked",
        value: function disposeTracked(value) {
          if (value === undefined || value === null || this.isDisposed) {
            return null;
          }

          var idx = this._disposables.indexOf(value);

          if (idx !== -1) {
            var _this$_disposables$sp = this._disposables.splice(idx, 1),
                _this$_disposables$sp2 = _slicedToArray(_this$_disposables$sp, 1),
                foundValue = _this$_disposables$sp2[0];

            disposeValue(foundValue);
          } else {
            console.warn("disposable not found, did it leak?", value);
          }

          return null;
        }
      }, {
        key: "isDisposed",
        get: function get() {
          return this._disposables === null;
        }
      }]);

      return Disposables;
    }();

    /*! @license DOMPurify 2.3.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.0/LICENSE */
    function _toConsumableArray$1(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      } else {
        return Array.from(arr);
      }
    }

    var hasOwnProperty = Object.hasOwnProperty,
        setPrototypeOf = Object.setPrototypeOf,
        isFrozen = Object.isFrozen,
        getPrototypeOf = Object.getPrototypeOf,
        getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var freeze = Object.freeze,
        seal = Object.seal,
        create = Object.create; // eslint-disable-line import/no-mutable-exports

    var _ref = typeof Reflect !== 'undefined' && Reflect,
        apply = _ref.apply,
        construct = _ref.construct;

    if (!apply) {
      apply = function apply(fun, thisValue, args) {
        return fun.apply(thisValue, args);
      };
    }

    if (!freeze) {
      freeze = function freeze(x) {
        return x;
      };
    }

    if (!seal) {
      seal = function seal(x) {
        return x;
      };
    }

    if (!construct) {
      construct = function construct(Func, args) {
        return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray$1(args))))();
      };
    }

    var arrayForEach = unapply(Array.prototype.forEach);
    var arrayPop = unapply(Array.prototype.pop);
    var arrayPush = unapply(Array.prototype.push);
    var stringToLowerCase = unapply(String.prototype.toLowerCase);
    var stringMatch = unapply(String.prototype.match);
    var stringReplace = unapply(String.prototype.replace);
    var stringIndexOf = unapply(String.prototype.indexOf);
    var stringTrim = unapply(String.prototype.trim);
    var regExpTest = unapply(RegExp.prototype.test);
    var typeErrorCreate = unconstruct(TypeError);

    function unapply(func) {
      return function (thisArg) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        return apply(func, thisArg, args);
      };
    }

    function unconstruct(func) {
      return function () {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return construct(func, args);
      };
    }
    /* Add properties to a lookup table */


    function addToSet(set, array) {
      if (setPrototypeOf) {
        // Make 'in' and truthy checks like Boolean(set.constructor)
        // independent of any properties defined on Object.prototype.
        // Prevent prototype setters from intercepting set as a this value.
        setPrototypeOf(set, null);
      }

      var l = array.length;

      while (l--) {
        var element = array[l];

        if (typeof element === 'string') {
          var lcElement = stringToLowerCase(element);

          if (lcElement !== element) {
            // Config presets (e.g. tags.js, attrs.js) are immutable.
            if (!isFrozen(array)) {
              array[l] = lcElement;
            }

            element = lcElement;
          }
        }

        set[element] = true;
      }

      return set;
    }
    /* Shallow clone an object */


    function clone(object) {
      var newObject = create(null);
      var property = void 0;

      for (property in object) {
        if (apply(hasOwnProperty, object, [property])) {
          newObject[property] = object[property];
        }
      }

      return newObject;
    }
    /* IE10 doesn't support __lookupGetter__ so lets'
     * simulate it. It also automatically checks
     * if the prop is function or getter and behaves
     * accordingly. */


    function lookupGetter(object, prop) {
      while (object !== null) {
        var desc = getOwnPropertyDescriptor(object, prop);

        if (desc) {
          if (desc.get) {
            return unapply(desc.get);
          }

          if (typeof desc.value === 'function') {
            return unapply(desc.value);
          }
        }

        object = getPrototypeOf(object);
      }

      function fallbackValue(element) {
        console.warn('fallback value for', element);
        return null;
      }

      return fallbackValue;
    }

    var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG

    var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
    var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']); // List of SVG elements that are disallowed by default.
    // We still need to know them so that we can do namespace
    // checks properly in case one wants to add them to
    // allow-list.

    var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
    var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']); // Similarly to SVG, we want to know all MathML elements,
    // even those that we disallow by default.

    var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
    var text$1 = freeze(['#text']);
    var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);
    var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
    var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
    var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']); // eslint-disable-next-line unicorn/better-regex

    var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode

    var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
    var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape

    var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape

    var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
    );
    var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
    var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
    );

    var _typeof$1 = typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol" ? function (obj) {
      return _typeof(obj);
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
    };

    function _toConsumableArray$1$1(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      } else {
        return Array.from(arr);
      }
    }

    var getGlobal = function getGlobal() {
      return typeof window === 'undefined' ? null : window;
    };
    /**
     * Creates a no-op policy for internal use only.
     * Don't export this function outside this module!
     * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
     * @param {Document} document The document object (to determine policy name suffix)
     * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
     * are not supported).
     */


    var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
      if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof$1(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
        return null;
      } // Allow the callers to control the unique policy name
      // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
      // Policy creation with duplicate names throws in Trusted Types.


      var suffix = null;
      var ATTR_NAME = 'data-tt-policy-suffix';

      if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
        suffix = document.currentScript.getAttribute(ATTR_NAME);
      }

      var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

      try {
        return trustedTypes.createPolicy(policyName, {
          createHTML: function createHTML(html$$1) {
            return html$$1;
          }
        });
      } catch (_) {
        // Policy creation failed (most likely another DOMPurify script has
        // already run). Skip creating the policy, as this will only cause errors
        // if TT are enforced.
        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
        return null;
      }
    };

    function createDOMPurify() {
      var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

      var DOMPurify = function DOMPurify(root) {
        return createDOMPurify(root);
      };
      /**
       * Version label, exposed for easier checks
       * if DOMPurify is up to date or not
       */


      DOMPurify.version = '2.3.0';
      /**
       * Array of elements that DOMPurify removed during sanitation.
       * Empty if nothing was removed.
       */

      DOMPurify.removed = [];

      if (!window || !window.document || window.document.nodeType !== 9) {
        // Not running in a browser, provide a factory function
        // so that you can pass your own Window
        DOMPurify.isSupported = false;
        return DOMPurify;
      }

      var originalDocument = window.document;
      var document = window.document;
      var DocumentFragment = window.DocumentFragment,
          HTMLTemplateElement = window.HTMLTemplateElement,
          Node = window.Node,
          Element = window.Element,
          NodeFilter = window.NodeFilter,
          _window$NamedNodeMap = window.NamedNodeMap,
          NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
          Text = window.Text,
          Comment = window.Comment,
          DOMParser = window.DOMParser,
          trustedTypes = window.trustedTypes;
      var ElementPrototype = Element.prototype;
      var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
      var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
      var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
      var getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // As per issue #47, the web-components registry is inherited by a
      // new document created via createHTMLDocument. As per the spec
      // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
      // a new empty registry is used when creating a template contents owner
      // document, so we use that as our parent document to ensure nothing
      // is inherited.

      if (typeof HTMLTemplateElement === 'function') {
        var template = document.createElement('template');

        if (template.content && template.content.ownerDocument) {
          document = template.content.ownerDocument;
        }
      }

      var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);

      var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';
      var _document = document,
          implementation = _document.implementation,
          createNodeIterator = _document.createNodeIterator,
          createDocumentFragment = _document.createDocumentFragment,
          getElementsByTagName = _document.getElementsByTagName;
      var importNode = originalDocument.importNode;
      var documentMode = {};

      try {
        documentMode = clone(document).documentMode ? document.documentMode : {};
      } catch (_) {}

      var hooks = {};
      /**
       * Expose whether this browser supports running the full DOMPurify.
       */

      DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;
      var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
          ERB_EXPR$$1 = ERB_EXPR,
          DATA_ATTR$$1 = DATA_ATTR,
          ARIA_ATTR$$1 = ARIA_ATTR,
          IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
          ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
      var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;
      /**
       * We consider the elements and attributes below to be safe. Ideally
       * don't add any new ones but feel free to remove unwanted ones.
       */

      /* allowed element names */

      var ALLOWED_TAGS = null;
      var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1$1(html), _toConsumableArray$1$1(svg), _toConsumableArray$1$1(svgFilters), _toConsumableArray$1$1(mathMl), _toConsumableArray$1$1(text$1)));
      /* Allowed attribute names */

      var ALLOWED_ATTR = null;
      var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1$1(html$1), _toConsumableArray$1$1(svg$1), _toConsumableArray$1$1(mathMl$1), _toConsumableArray$1$1(xml)));
      /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */

      var FORBID_TAGS = null;
      /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */

      var FORBID_ATTR = null;
      /* Decide if ARIA attributes are okay */

      var ALLOW_ARIA_ATTR = true;
      /* Decide if custom data attributes are okay */

      var ALLOW_DATA_ATTR = true;
      /* Decide if unknown protocols are okay */

      var ALLOW_UNKNOWN_PROTOCOLS = false;
      /* Output should be safe for common template engines.
       * This means, DOMPurify removes data attributes, mustaches and ERB
       */

      var SAFE_FOR_TEMPLATES = false;
      /* Decide if document with <html>... should be returned */

      var WHOLE_DOCUMENT = false;
      /* Track whether config is already set on this instance of DOMPurify. */

      var SET_CONFIG = false;
      /* Decide if all elements (e.g. style, script) must be children of
       * document.body. By default, browsers might move them to document.head */

      var FORCE_BODY = false;
      /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
       * string (or a TrustedHTML object if Trusted Types are supported).
       * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
       */

      var RETURN_DOM = false;
      /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
       * string  (or a TrustedHTML object if Trusted Types are supported) */

      var RETURN_DOM_FRAGMENT = false;
      /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
       * `Node` is imported into the current `Document`. If this flag is not enabled the
       * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
       * DOMPurify.
       *
       * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`
       * might cause XSS from attacks hidden in closed shadowroots in case the browser
       * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/
       */

      var RETURN_DOM_IMPORT = true;
      /* Try to return a Trusted Type object instead of a string, return a string in
       * case Trusted Types are not supported  */

      var RETURN_TRUSTED_TYPE = false;
      /* Output should be free from DOM clobbering attacks? */

      var SANITIZE_DOM = true;
      /* Keep element content when removing element? */

      var KEEP_CONTENT = true;
      /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
       * of importing it into a new Document and returning a sanitized copy */

      var IN_PLACE = false;
      /* Allow usage of profiles like html, svg and mathMl */

      var USE_PROFILES = {};
      /* Tags to ignore content of when KEEP_CONTENT is true */

      var FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
      /* Tags that are safe for data: URIs */

      var DATA_URI_TAGS = null;
      var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
      /* Attributes safe for values like "javascript:" */

      var URI_SAFE_ATTRIBUTES = null;
      var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);
      var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
      var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
      var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
      /* Document namespace */

      var NAMESPACE = HTML_NAMESPACE;
      var IS_EMPTY_INPUT = false;
      /* Keep a reference to config to pass to hooks */

      var CONFIG = null;
      /* Ideally, do not touch anything below this line */

      /* ______________________________________________ */

      var formElement = document.createElement('form');
      /**
       * _parseConfig
       *
       * @param  {Object} cfg optional config literal
       */
      // eslint-disable-next-line complexity

      var _parseConfig = function _parseConfig(cfg) {
        if (CONFIG && CONFIG === cfg) {
          return;
        }
        /* Shield configuration object from tampering */


        if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof$1(cfg)) !== 'object') {
          cfg = {};
        }
        /* Shield configuration object from prototype pollution */


        cfg = clone(cfg);
        /* Set configuration parameters */

        ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
        ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
        URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
        DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
        FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
        FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
        USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true

        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true

        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false

        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false

        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false

        RETURN_DOM = cfg.RETURN_DOM || false; // Default false

        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false

        RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true

        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false

        FORCE_BODY = cfg.FORCE_BODY || false; // Default false

        SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true

        KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true

        IN_PLACE = cfg.IN_PLACE || false; // Default false

        IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;

        if (SAFE_FOR_TEMPLATES) {
          ALLOW_DATA_ATTR = false;
        }

        if (RETURN_DOM_FRAGMENT) {
          RETURN_DOM = true;
        }
        /* Parse profile info */


        if (USE_PROFILES) {
          ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1$1(text$1)));
          ALLOWED_ATTR = [];

          if (USE_PROFILES.html === true) {
            addToSet(ALLOWED_TAGS, html);
            addToSet(ALLOWED_ATTR, html$1);
          }

          if (USE_PROFILES.svg === true) {
            addToSet(ALLOWED_TAGS, svg);
            addToSet(ALLOWED_ATTR, svg$1);
            addToSet(ALLOWED_ATTR, xml);
          }

          if (USE_PROFILES.svgFilters === true) {
            addToSet(ALLOWED_TAGS, svgFilters);
            addToSet(ALLOWED_ATTR, svg$1);
            addToSet(ALLOWED_ATTR, xml);
          }

          if (USE_PROFILES.mathMl === true) {
            addToSet(ALLOWED_TAGS, mathMl);
            addToSet(ALLOWED_ATTR, mathMl$1);
            addToSet(ALLOWED_ATTR, xml);
          }
        }
        /* Merge configuration parameters */


        if (cfg.ADD_TAGS) {
          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
            ALLOWED_TAGS = clone(ALLOWED_TAGS);
          }

          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
        }

        if (cfg.ADD_ATTR) {
          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
            ALLOWED_ATTR = clone(ALLOWED_ATTR);
          }

          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
        }

        if (cfg.ADD_URI_SAFE_ATTR) {
          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
        }
        /* Add #text in case KEEP_CONTENT is set to true */


        if (KEEP_CONTENT) {
          ALLOWED_TAGS['#text'] = true;
        }
        /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */


        if (WHOLE_DOCUMENT) {
          addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
        }
        /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */


        if (ALLOWED_TAGS.table) {
          addToSet(ALLOWED_TAGS, ['tbody']);
          delete FORBID_TAGS.tbody;
        } // Prevent further manipulation of configuration.
        // Not available in IE8, Safari 5, etc.


        if (freeze) {
          freeze(cfg);
        }

        CONFIG = cfg;
      };

      var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
      var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);
      /* Keep track of all possible SVG and MathML tags
       * so that we can perform the namespace checks
       * correctly. */

      var ALL_SVG_TAGS = addToSet({}, svg);
      addToSet(ALL_SVG_TAGS, svgFilters);
      addToSet(ALL_SVG_TAGS, svgDisallowed);
      var ALL_MATHML_TAGS = addToSet({}, mathMl);
      addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
      /**
       *
       *
       * @param  {Element} element a DOM element whose namespace is being checked
       * @returns {boolean} Return false if the element has a
       *  namespace that a spec-compliant parser would never
       *  return. Return true otherwise.
       */

      var _checkValidNamespace = function _checkValidNamespace(element) {
        var parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode
        // can be null. We just simulate parent in this case.

        if (!parent || !parent.tagName) {
          parent = {
            namespaceURI: HTML_NAMESPACE,
            tagName: 'template'
          };
        }

        var tagName = stringToLowerCase(element.tagName);
        var parentTagName = stringToLowerCase(parent.tagName);

        if (element.namespaceURI === SVG_NAMESPACE) {
          // The only way to switch from HTML namespace to SVG
          // is via <svg>. If it happens via any other tag, then
          // it should be killed.
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === 'svg';
          } // The only way to switch from MathML to SVG is via
          // svg if parent is either <annotation-xml> or MathML
          // text integration points.


          if (parent.namespaceURI === MATHML_NAMESPACE) {
            return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
          } // We only allow elements that are defined in SVG
          // spec. All others are disallowed in SVG namespace.


          return Boolean(ALL_SVG_TAGS[tagName]);
        }

        if (element.namespaceURI === MATHML_NAMESPACE) {
          // The only way to switch from HTML namespace to MathML
          // is via <math>. If it happens via any other tag, then
          // it should be killed.
          if (parent.namespaceURI === HTML_NAMESPACE) {
            return tagName === 'math';
          } // The only way to switch from SVG to MathML is via
          // <math> and HTML integration points


          if (parent.namespaceURI === SVG_NAMESPACE) {
            return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
          } // We only allow elements that are defined in MathML
          // spec. All others are disallowed in MathML namespace.


          return Boolean(ALL_MATHML_TAGS[tagName]);
        }

        if (element.namespaceURI === HTML_NAMESPACE) {
          // The only way to switch from SVG to HTML is via
          // HTML integration points, and from MathML to HTML
          // is via MathML text integration points
          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }

          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
            return false;
          } // Certain elements are allowed in both SVG and HTML
          // namespace. We need to specify them explicitly
          // so that they don't get erronously deleted from
          // HTML namespace.


          var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']); // We disallow tags that are specific for MathML
          // or SVG and should never appear in HTML namespace

          return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
        } // The code should never reach this place (this means
        // that the element somehow got namespace that is not
        // HTML, SVG or MathML). Return false just in case.


        return false;
      };
      /**
       * _forceRemove
       *
       * @param  {Node} node a DOM node
       */


      var _forceRemove = function _forceRemove(node) {
        arrayPush(DOMPurify.removed, {
          element: node
        });

        try {
          // eslint-disable-next-line unicorn/prefer-dom-node-remove
          node.parentNode.removeChild(node);
        } catch (_) {
          try {
            node.outerHTML = emptyHTML;
          } catch (_) {
            node.remove();
          }
        }
      };
      /**
       * _removeAttribute
       *
       * @param  {String} name an Attribute name
       * @param  {Node} node a DOM node
       */


      var _removeAttribute = function _removeAttribute(name, node) {
        try {
          arrayPush(DOMPurify.removed, {
            attribute: node.getAttributeNode(name),
            from: node
          });
        } catch (_) {
          arrayPush(DOMPurify.removed, {
            attribute: null,
            from: node
          });
        }

        node.removeAttribute(name); // We void attribute values for unremovable "is"" attributes

        if (name === 'is' && !ALLOWED_ATTR[name]) {
          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
            try {
              _forceRemove(node);
            } catch (_) {}
          } else {
            try {
              node.setAttribute(name, '');
            } catch (_) {}
          }
        }
      };
      /**
       * _initDocument
       *
       * @param  {String} dirty a string of dirty markup
       * @return {Document} a DOM, filled with the dirty markup
       */


      var _initDocument = function _initDocument(dirty) {
        /* Create a HTML document */
        var doc = void 0;
        var leadingWhitespace = void 0;

        if (FORCE_BODY) {
          dirty = '<remove></remove>' + dirty;
        } else {
          /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
          var matches = stringMatch(dirty, /^[\r\n\t ]+/);
          leadingWhitespace = matches && matches[0];
        }

        var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
        /*
         * Use the DOMParser API by default, fallback later if needs be
         * DOMParser not work for svg when has multiple root element.
         */

        if (NAMESPACE === HTML_NAMESPACE) {
          try {
            doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');
          } catch (_) {}
        }
        /* Use createHTMLDocument in case DOMParser is not available */


        if (!doc || !doc.documentElement) {
          doc = implementation.createDocument(NAMESPACE, 'template', null);

          try {
            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
          } catch (_) {// Syntax error if dirtyPayload is invalid xml
          }
        }

        var body = doc.body || doc.documentElement;

        if (dirty && leadingWhitespace) {
          body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
        }
        /* Work on whole document or just its body */


        if (NAMESPACE === HTML_NAMESPACE) {
          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
        }

        return WHOLE_DOCUMENT ? doc.documentElement : body;
      };
      /**
       * _createIterator
       *
       * @param  {Document} root document/fragment to create iterator for
       * @return {Iterator} iterator instance
       */


      var _createIterator = function _createIterator(root) {
        return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
      };
      /**
       * _isClobbered
       *
       * @param  {Node} elm element to check for clobbering attacks
       * @return {Boolean} true if clobbered, false if safe
       */


      var _isClobbered = function _isClobbered(elm) {
        if (elm instanceof Text || elm instanceof Comment) {
          return false;
        }

        if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {
          return true;
        }

        return false;
      };
      /**
       * _isNode
       *
       * @param  {Node} obj object to check whether it's a DOM node
       * @return {Boolean} true is object is a DOM node
       */


      var _isNode = function _isNode(object) {
        return (typeof Node === 'undefined' ? 'undefined' : _typeof$1(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof$1(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
      };
      /**
       * _executeHook
       * Execute user configurable hooks
       *
       * @param  {String} entryPoint  Name of the hook's entry point
       * @param  {Node} currentNode node to work on with the hook
       * @param  {Object} data additional hook parameters
       */


      var _executeHook = function _executeHook(entryPoint, currentNode, data) {
        if (!hooks[entryPoint]) {
          return;
        }

        arrayForEach(hooks[entryPoint], function (hook) {
          hook.call(DOMPurify, currentNode, data, CONFIG);
        });
      };
      /**
       * _sanitizeElements
       *
       * @protect nodeName
       * @protect textContent
       * @protect removeChild
       *
       * @param   {Node} currentNode to check for permission to exist
       * @return  {Boolean} true if node was killed, false if left alive
       */


      var _sanitizeElements = function _sanitizeElements(currentNode) {
        var content = void 0;
        /* Execute a hook if present */

        _executeHook('beforeSanitizeElements', currentNode, null);
        /* Check if element is clobbered or can clobber */


        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);

          return true;
        }
        /* Check if tagname contains Unicode */


        if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
          _forceRemove(currentNode);

          return true;
        }
        /* Now let's check the element's type and name */


        var tagName = stringToLowerCase(currentNode.nodeName);
        /* Execute a hook if present */

        _executeHook('uponSanitizeElement', currentNode, {
          tagName: tagName,
          allowedTags: ALLOWED_TAGS
        });
        /* Detect mXSS attempts abusing namespace confusion */


        if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
          _forceRemove(currentNode);

          return true;
        }
        /* Remove element if anything forbids its presence */


        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          /* Keep content except for bad-listed elements */
          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
            var parentNode = getParentNode(currentNode) || currentNode.parentNode;
            var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

            if (childNodes && parentNode) {
              var childCount = childNodes.length;

              for (var i = childCount - 1; i >= 0; --i) {
                parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
              }
            }
          }

          _forceRemove(currentNode);

          return true;
        }
        /* Check whether element has a valid namespace */


        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
          _forceRemove(currentNode);

          return true;
        }

        if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
          _forceRemove(currentNode);

          return true;
        }
        /* Sanitize element content to be template-safe */


        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
          /* Get the element's text content */
          content = currentNode.textContent;
          content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');
          content = stringReplace(content, ERB_EXPR$$1, ' ');

          if (currentNode.textContent !== content) {
            arrayPush(DOMPurify.removed, {
              element: currentNode.cloneNode()
            });
            currentNode.textContent = content;
          }
        }
        /* Execute a hook if present */


        _executeHook('afterSanitizeElements', currentNode, null);

        return false;
      };
      /**
       * _isValidAttribute
       *
       * @param  {string} lcTag Lowercase tag name of containing element.
       * @param  {string} lcName Lowercase attribute name.
       * @param  {string} value Attribute value.
       * @return {Boolean} Returns true if `value` is valid, otherwise false.
       */
      // eslint-disable-next-line complexity


      var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
        /* Make sure attribute cannot clobber */
        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
          return false;
        }
        /* Allow valid data-* attributes: At least one character after "-"
            (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
            XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
            We don't need to check the value; it's always URI safe. */


        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ;else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ;else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
          return false;
          /* Check value is safe. First, is attr inert? If so, is safe */
        } else if (URI_SAFE_ATTRIBUTES[lcName]) ;else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ;else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ;else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ;else if (!value) ;else {
          return false;
        }
        return true;
      };
      /**
       * _sanitizeAttributes
       *
       * @protect attributes
       * @protect nodeName
       * @protect removeAttribute
       * @protect setAttribute
       *
       * @param  {Node} currentNode to sanitize
       */


      var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
        var attr = void 0;
        var value = void 0;
        var lcName = void 0;
        var l = void 0;
        /* Execute a hook if present */

        _executeHook('beforeSanitizeAttributes', currentNode, null);

        var attributes = currentNode.attributes;
        /* Check if we have attributes; if not we might have a text node */

        if (!attributes) {
          return;
        }

        var hookEvent = {
          attrName: '',
          attrValue: '',
          keepAttr: true,
          allowedAttributes: ALLOWED_ATTR
        };
        l = attributes.length;
        /* Go backwards over all attributes; safely remove bad ones */

        while (l--) {
          attr = attributes[l];
          var _attr = attr,
              name = _attr.name,
              namespaceURI = _attr.namespaceURI;
          value = stringTrim(attr.value);
          lcName = stringToLowerCase(name);
          /* Execute a hook if present */

          hookEvent.attrName = lcName;
          hookEvent.attrValue = value;
          hookEvent.keepAttr = true;
          hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set

          _executeHook('uponSanitizeAttribute', currentNode, hookEvent);

          value = hookEvent.attrValue;
          /* Did the hooks approve of the attribute? */

          if (hookEvent.forceKeepAttr) {
            continue;
          }
          /* Remove attribute */


          _removeAttribute(name, currentNode);
          /* Did the hooks approve of the attribute? */


          if (!hookEvent.keepAttr) {
            continue;
          }
          /* Work around a security issue in jQuery 3.0 */


          if (regExpTest(/\/>/i, value)) {
            _removeAttribute(name, currentNode);

            continue;
          }
          /* Sanitize attribute content to be template-safe */


          if (SAFE_FOR_TEMPLATES) {
            value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');
            value = stringReplace(value, ERB_EXPR$$1, ' ');
          }
          /* Is `value` valid for this attribute? */


          var lcTag = currentNode.nodeName.toLowerCase();

          if (!_isValidAttribute(lcTag, lcName, value)) {
            continue;
          }
          /* Handle invalid data-* attribute set by try-catching it */


          try {
            if (namespaceURI) {
              currentNode.setAttributeNS(namespaceURI, name, value);
            } else {
              /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
              currentNode.setAttribute(name, value);
            }

            arrayPop(DOMPurify.removed);
          } catch (_) {}
        }
        /* Execute a hook if present */


        _executeHook('afterSanitizeAttributes', currentNode, null);
      };
      /**
       * _sanitizeShadowDOM
       *
       * @param  {DocumentFragment} fragment to iterate over recursively
       */


      var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
        var shadowNode = void 0;

        var shadowIterator = _createIterator(fragment);
        /* Execute a hook if present */


        _executeHook('beforeSanitizeShadowDOM', fragment, null);

        while (shadowNode = shadowIterator.nextNode()) {
          /* Execute a hook if present */
          _executeHook('uponSanitizeShadowNode', shadowNode, null);
          /* Sanitize tags and elements */


          if (_sanitizeElements(shadowNode)) {
            continue;
          }
          /* Deep shadow DOM detected */


          if (shadowNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(shadowNode.content);
          }
          /* Check attributes, sanitize if necessary */


          _sanitizeAttributes(shadowNode);
        }
        /* Execute a hook if present */


        _executeHook('afterSanitizeShadowDOM', fragment, null);
      };
      /**
       * Sanitize
       * Public method providing core sanitation functionality
       *
       * @param {String|Node} dirty string or DOM node
       * @param {Object} configuration object
       */
      // eslint-disable-next-line complexity


      DOMPurify.sanitize = function (dirty, cfg) {
        var body = void 0;
        var importedNode = void 0;
        var currentNode = void 0;
        var oldNode = void 0;
        var returnNode = void 0;
        /* Make sure we have a string to sanitize.
          DO NOT return early, as this will return the wrong type if
          the user has requested a DOM object rather than a string */

        IS_EMPTY_INPUT = !dirty;

        if (IS_EMPTY_INPUT) {
          dirty = '<!-->';
        }
        /* Stringify, in case dirty is an object */


        if (typeof dirty !== 'string' && !_isNode(dirty)) {
          // eslint-disable-next-line no-negated-condition
          if (typeof dirty.toString !== 'function') {
            throw typeErrorCreate('toString is not a function');
          } else {
            dirty = dirty.toString();

            if (typeof dirty !== 'string') {
              throw typeErrorCreate('dirty is not a string, aborting');
            }
          }
        }
        /* Check we can run. Otherwise fall back or ignore */


        if (!DOMPurify.isSupported) {
          if (_typeof$1(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
            if (typeof dirty === 'string') {
              return window.toStaticHTML(dirty);
            }

            if (_isNode(dirty)) {
              return window.toStaticHTML(dirty.outerHTML);
            }
          }

          return dirty;
        }
        /* Assign config vars */


        if (!SET_CONFIG) {
          _parseConfig(cfg);
        }
        /* Clean up removed elements */


        DOMPurify.removed = [];
        /* Check if dirty is correctly typed for IN_PLACE */

        if (typeof dirty === 'string') {
          IN_PLACE = false;
        }

        if (IN_PLACE) ;else if (dirty instanceof Node) {
          /* If dirty is a DOM element, append to an empty document to avoid
             elements being stripped by the parser */
          body = _initDocument('<!---->');
          importedNode = body.ownerDocument.importNode(dirty, true);

          if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
            /* Node is already a body, use as is */
            body = importedNode;
          } else if (importedNode.nodeName === 'HTML') {
            body = importedNode;
          } else {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            body.appendChild(importedNode);
          }
        } else {
          /* Exit directly if we have nothing to do */
          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
          dirty.indexOf('<') === -1) {
            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
          }
          /* Initialize the document to work on */


          body = _initDocument(dirty);
          /* Check we have a DOM node from the data */

          if (!body) {
            return RETURN_DOM ? null : emptyHTML;
          }
        }
        /* Remove first element node (ours) if FORCE_BODY is set */

        if (body && FORCE_BODY) {
          _forceRemove(body.firstChild);
        }
        /* Get node iterator */


        var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
        /* Now start iterating over the created document */


        while (currentNode = nodeIterator.nextNode()) {
          /* Fix IE's strange behavior with manipulated textNodes #89 */
          if (currentNode.nodeType === 3 && currentNode === oldNode) {
            continue;
          }
          /* Sanitize tags and elements */


          if (_sanitizeElements(currentNode)) {
            continue;
          }
          /* Shadow DOM detected, sanitize it */


          if (currentNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(currentNode.content);
          }
          /* Check attributes, sanitize if necessary */


          _sanitizeAttributes(currentNode);

          oldNode = currentNode;
        }

        oldNode = null;
        /* If we sanitized `dirty` in-place, return it. */

        if (IN_PLACE) {
          return dirty;
        }
        /* Return sanitized string or DOM */


        if (RETURN_DOM) {
          if (RETURN_DOM_FRAGMENT) {
            returnNode = createDocumentFragment.call(body.ownerDocument);

            while (body.firstChild) {
              // eslint-disable-next-line unicorn/prefer-dom-node-append
              returnNode.appendChild(body.firstChild);
            }
          } else {
            returnNode = body;
          }

          if (RETURN_DOM_IMPORT) {
            /*
              AdoptNode() is not used because internal state is not reset
              (e.g. the past names map of a HTMLFormElement), this is safe
              in theory but we would rather not risk another attack vector.
              The state that is cloned by importNode() is explicitly defined
              by the specs.
            */
            returnNode = importNode.call(originalDocument, returnNode, true);
          }

          return returnNode;
        }

        var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
        /* Sanitize final string template-safe */

        if (SAFE_FOR_TEMPLATES) {
          serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');
          serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');
        }

        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
      };
      /**
       * Public method to set the configuration once
       * setConfig
       *
       * @param {Object} cfg configuration object
       */


      DOMPurify.setConfig = function (cfg) {
        _parseConfig(cfg);

        SET_CONFIG = true;
      };
      /**
       * Public method to remove the configuration
       * clearConfig
       *
       */


      DOMPurify.clearConfig = function () {
        CONFIG = null;
        SET_CONFIG = false;
      };
      /**
       * Public method to check if an attribute value is valid.
       * Uses last set config, if any. Otherwise, uses config defaults.
       * isValidAttribute
       *
       * @param  {string} tag Tag name of containing element.
       * @param  {string} attr Attribute name.
       * @param  {string} value Attribute value.
       * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
       */


      DOMPurify.isValidAttribute = function (tag, attr, value) {
        /* Initialize shared config vars if necessary. */
        if (!CONFIG) {
          _parseConfig({});
        }

        var lcTag = stringToLowerCase(tag);
        var lcName = stringToLowerCase(attr);
        return _isValidAttribute(lcTag, lcName, value);
      };
      /**
       * AddHook
       * Public method to add DOMPurify hooks
       *
       * @param {String} entryPoint entry point for the hook to add
       * @param {Function} hookFunction function to execute
       */


      DOMPurify.addHook = function (entryPoint, hookFunction) {
        if (typeof hookFunction !== 'function') {
          return;
        }

        hooks[entryPoint] = hooks[entryPoint] || [];
        arrayPush(hooks[entryPoint], hookFunction);
      };
      /**
       * RemoveHook
       * Public method to remove a DOMPurify hook at a given entryPoint
       * (pops it from the stack of hooks if more are present)
       *
       * @param {String} entryPoint entry point for the hook to remove
       */


      DOMPurify.removeHook = function (entryPoint) {
        if (hooks[entryPoint]) {
          arrayPop(hooks[entryPoint]);
        }
      };
      /**
       * RemoveHooks
       * Public method to remove all DOMPurify hooks at a given entryPoint
       *
       * @param  {String} entryPoint entry point for the hooks to remove
       */


      DOMPurify.removeHooks = function (entryPoint) {
        if (hooks[entryPoint]) {
          hooks[entryPoint] = [];
        }
      };
      /**
       * RemoveAllHooks
       * Public method to remove all DOMPurify hooks
       *
       */


      DOMPurify.removeAllHooks = function () {
        hooks = {};
      };

      return DOMPurify;
    }

    var purify = createDOMPurify();

    var HTMLParseResult = /*#__PURE__*/function () {
      function HTMLParseResult(bodyNode) {
        _classCallCheck(this, HTMLParseResult);

        this._bodyNode = bodyNode;
      }

      _createClass(HTMLParseResult, [{
        key: "getChildNodes",
        value: function getChildNodes(node) {
          return Array.from(node.childNodes);
        }
      }, {
        key: "getAttributeNames",
        value: function getAttributeNames(node) {
          return Array.from(node.getAttributeNames());
        }
      }, {
        key: "getAttributeValue",
        value: function getAttributeValue(node, attr) {
          return node.getAttribute(attr);
        }
      }, {
        key: "isTextNode",
        value: function isTextNode(node) {
          return node.nodeType === Node.TEXT_NODE;
        }
      }, {
        key: "getNodeText",
        value: function getNodeText(node) {
          return node.textContent;
        }
      }, {
        key: "isElementNode",
        value: function isElementNode(node) {
          return node.nodeType === Node.ELEMENT_NODE;
        }
      }, {
        key: "getNodeElementName",
        value: function getNodeElementName(node) {
          return node.tagName;
        }
      }, {
        key: "rootNodes",
        get: function get() {
          return Array.from(this._bodyNode.childNodes);
        }
      }]);

      return HTMLParseResult;
    }();

    var sanitizeConfig = {
      ALLOWED_URI_REGEXP: /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|xxx|mxc):|[^a-z]|[a-z+.-]+(?:[^a-z+.-:]|$))/i,
      ADD_TAGS: ['mx-reply']
    };
    function parseHTML(html) {
      // If DOMPurify uses DOMParser, can't we just get the built tree from it
      // instead of re-parsing?
      var sanitized = purify.sanitize(html, sanitizeConfig);
      var bodyNode = new DOMParser().parseFromString(sanitized, "text/html").body;
      return new HTMLParseResult(bodyNode);
    }

    function addScript(src) {
      return new Promise(function (resolve, reject) {
        var s = document.createElement("script");
        s.setAttribute("src", src);
        s.onload = resolve;
        s.onerror = reject;
        document.body.appendChild(s);
      });
    }

    function _loadOlm2(_x) {
      return _loadOlm.apply(this, arguments);
    } // make path relative to basePath,
    // assuming it and basePath are relative to document


    function _loadOlm() {
      _loadOlm = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(olmPaths) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                // make crypto.getRandomValues available without
                // a prefix on IE11, needed by olm to work
                if (window.msCrypto && !window.crypto) {
                  window.crypto = window.msCrypto;
                }

                if (!olmPaths) {
                  _context4.next = 14;
                  break;
                }

                if (!window.WebAssembly) {
                  _context4.next = 9;
                  break;
                }

                _context4.next = 5;
                return addScript(olmPaths.wasmBundle);

              case 5:
                _context4.next = 7;
                return window.Olm.init({
                  locateFile: function locateFile() {
                    return olmPaths.wasm;
                  }
                });

              case 7:
                _context4.next = 13;
                break;

              case 9:
                _context4.next = 11;
                return addScript(olmPaths.legacyBundle);

              case 11:
                _context4.next = 13;
                return window.Olm.init();

              case 13:
                return _context4.abrupt("return", window.Olm);

              case 14:
                return _context4.abrupt("return", null);

              case 15:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      return _loadOlm.apply(this, arguments);
    }

    function relPath(path, basePath) {
      var idx = basePath.lastIndexOf("/");
      var dir = idx === -1 ? "" : basePath.slice(0, idx);
      var dirCount = dir.length ? dir.split("/").length : 0;
      return "../".repeat(dirCount) + path;
    }

    function _loadOlmWorker2(_x2) {
      return _loadOlmWorker.apply(this, arguments);
    } // needed for mobile Safari which shifts the layout viewport up without resizing it
    // when the keyboard shows (see https://bugs.webkit.org/show_bug.cgi?id=141832)


    function _loadOlmWorker() {
      _loadOlmWorker = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(config) {
        var workerPool, path, olmWorker;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                workerPool = new WorkerPool(config.worker, 4);
                _context5.next = 3;
                return workerPool.init();

              case 3:
                path = relPath(config.olm.legacyBundle, config.worker);
                _context5.next = 6;
                return workerPool.sendAll({
                  type: "load_olm",
                  path: path
                });

              case 6:
                olmWorker = new OlmWorker(workerPool);
                return _context5.abrupt("return", olmWorker);

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));
      return _loadOlmWorker.apply(this, arguments);
    }

    function adaptUIOnVisualViewportResize(container) {
      if (!window.visualViewport) {
        return;
      }

      var handler = function handler() {
        var sessionView = container.querySelector('.SessionView');

        if (!sessionView) {
          return;
        }

        var scrollable = container.querySelector('.bottom-aligned-scroll');
        var scrollTopBefore, heightBefore, heightAfter;

        if (scrollable) {
          scrollTopBefore = scrollable.scrollTop;
          heightBefore = scrollable.offsetHeight;
        } // Ideally we'd use window.visualViewport.offsetTop but that seems to occasionally lag
        // behind (last tested on iOS 14.4 simulator) so we have to compute the offset manually


        var offsetTop = sessionView.offsetTop + sessionView.offsetHeight - window.visualViewport.height;
        container.style.setProperty('--ios-viewport-height', window.visualViewport.height.toString() + 'px');
        container.style.setProperty('--ios-viewport-top', offsetTop.toString() + 'px');

        if (scrollable) {
          heightAfter = scrollable.offsetHeight;
          scrollable.scrollTop = scrollTopBefore + heightBefore - heightAfter;
        }
      };

      window.visualViewport.addEventListener('resize', handler);
      return function () {
        window.visualViewport.removeEventListener('resize', handler);
      };
    }

    var Platform = /*#__PURE__*/function () {
      function Platform(container, config) {
        var cryptoExtras = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

        _classCallCheck(this, Platform);

        this._config = config;
        this._container = container;
        this.settingsStorage = new SettingsStorage("hydrogen_setting_v1_");
        this.clock = new Clock();
        this.encoding = new Encoding();
        this.random = Math.random;

        if (options === null || options === void 0 ? void 0 : options.development) {
          this.logger = new ConsoleLogger({
            platform: this
          });
        } else {
          this.logger = new IDBLogger({
            name: "hydrogen_logs",
            platform: this
          });
        }

        this.history = new History();
        this.onlineStatus = new OnlineStatus();
        this._serviceWorkerHandler = null;

        if (config.serviceWorker && "serviceWorker" in navigator) {
          this._serviceWorkerHandler = new ServiceWorkerHandler();

          this._serviceWorkerHandler.registerAndStart(config.serviceWorker);
        }

        this.notificationService = new NotificationService(this._serviceWorkerHandler, config.push);
        this.crypto = new Crypto(cryptoExtras);
        this.storageFactory = new StorageFactory(this._serviceWorkerHandler);
        this.sessionInfoStorage = new SessionInfoStorage("hydrogen_sessions_v1");
        this.estimateStorageUsage = estimateStorageUsage;

        if (typeof fetch === "function") {
          this.request = createFetchRequest(this.clock.createTimeout, this._serviceWorkerHandler);
        } else {
          this.request = xhrRequest;
        }

        var isIE11 = !!window.MSInputMethodContext && !!document.documentMode;
        this.isIE11 = isIE11; // From https://stackoverflow.com/questions/9038625/detect-if-device-is-ios/9039885

        var isIOS = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1 && !window.MSStream;
        this.isIOS = isIOS;
        this._disposables = new Disposables();
      }

      _createClass(Platform, [{
        key: "loadOlm",
        value: function loadOlm() {
          return _loadOlm2(this._config.olm);
        }
      }, {
        key: "loadOlmWorker",
        value: function () {
          var _loadOlmWorker3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (window.WebAssembly) {
                      _context.next = 4;
                      break;
                    }

                    _context.next = 3;
                    return _loadOlmWorker2(this._config);

                  case 3:
                    return _context.abrupt("return", _context.sent);

                  case 4:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function loadOlmWorker() {
            return _loadOlmWorker3.apply(this, arguments);
          }

          return loadOlmWorker;
        }()
      }, {
        key: "createAndMountRootView",
        value: function createAndMountRootView(vm) {
          var _this = this;

          if (this.isIE11) {
            this._container.className += " legacy";
          }

          if (this.isIOS) {
            this._container.className += " ios";
            var disposable = adaptUIOnVisualViewportResize(this._container);

            if (disposable) {
              this._disposables.track(disposable);
            }
          }

          this._container.addEventListener("error", handleAvatarError, true);

          this._disposables.track(function () {
            return _this._container.removeEventListener("error", handleAvatarError, true);
          });

          window.__hydrogenViewModel = vm;
          var view = new RootView(vm);

          this._container.appendChild(view.mount());
        }
      }, {
        key: "setNavigation",
        value: function setNavigation(navigation) {
          var _this$_serviceWorkerH;

          (_this$_serviceWorkerH = this._serviceWorkerHandler) === null || _this$_serviceWorkerH === void 0 ? void 0 : _this$_serviceWorkerH.setNavigation(navigation);
        }
      }, {
        key: "createBlob",
        value: function createBlob(buffer, mimetype) {
          return BlobHandle.fromBuffer(buffer, mimetype);
        }
      }, {
        key: "saveFileAs",
        value: function saveFileAs(blobHandle, filename) {
          if (navigator.msSaveBlob) {
            navigator.msSaveBlob(blobHandle.nativeBlob, filename);
          } else {
            downloadInIframe(this._container, this._config.downloadSandbox, blobHandle, filename, this.isIOS);
          }
        }
      }, {
        key: "openFile",
        value: function openFile() {
          var _this2 = this;

          var mimeType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          var input = document.createElement("input");
          input.setAttribute("type", "file");
          input.className = "hidden";

          if (mimeType) {
            input.setAttribute("accept", mimeType);
          }

          var promise = new Promise(function (resolve) {
            var checkFile = function checkFile() {
              input.removeEventListener("change", checkFile, true);
              var file = input.files[0];

              _this2._container.removeChild(input);

              if (file) {
                resolve({
                  name: file.name,
                  blob: BlobHandle.fromBlob(file)
                });
              } else {
                resolve();
              }
            };

            input.addEventListener("change", checkFile, true);
          }); // IE11 needs the input to be attached to the document

          this._container.appendChild(input);

          input.click();
          return promise;
        }
      }, {
        key: "openUrl",
        value: function openUrl(url) {
          location.href = url;
        }
      }, {
        key: "parseHTML",
        value: function parseHTML$1(html) {
          return parseHTML(html);
        }
      }, {
        key: "loadImage",
        value: function () {
          var _loadImage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(blob) {
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    return _context2.abrupt("return", ImageHandle.fromBlob(blob));

                  case 1:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          function loadImage(_x3) {
            return _loadImage.apply(this, arguments);
          }

          return loadImage;
        }()
      }, {
        key: "loadVideo",
        value: function () {
          var _loadVideo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(blob) {
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    return _context3.abrupt("return", VideoHandle.fromBlob(blob));

                  case 1:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));

          function loadVideo(_x4) {
            return _loadVideo.apply(this, arguments);
          }

          return loadVideo;
        }()
      }, {
        key: "hasReadPixelPermission",
        value: function hasReadPixelPermission$1() {
          return hasReadPixelPermission();
        }
      }, {
        key: "dispose",
        value: function dispose() {
          this._disposables.dispose();
        }
      }, {
        key: "updateService",
        get: function get() {
          return this._serviceWorkerHandler;
        }
      }, {
        key: "config",
        get: function get() {
          return this._config;
        }
      }, {
        key: "devicePixelRatio",
        get: function get() {
          return window.devicePixelRatio || 1;
        }
      }, {
        key: "version",
        get: function get() {
          return window.HYDROGEN_VERSION;
        }
      }]);

      return Platform;
    }();

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function Platform$1(container, paths) {
      return new Platform(container, paths, {
        aesjs: aesJs,
        hkdf: hkdf
      });
    }

    /*
    Copyright 2021 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function normalizeHomeserver(homeserver) {
      try {
        return new URL(homeserver).origin;
      } catch (err) {
        return new URL("https://".concat(homeserver)).origin;
      }
    }

    function getWellKnownResponse(_x, _x2) {
      return _getWellKnownResponse.apply(this, arguments);
    }

    function _getWellKnownResponse() {
      _getWellKnownResponse = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(homeserver, request) {
        var requestOptions, wellKnownUrl;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                requestOptions = {
                  format: "json",
                  timeout: 30000,
                  method: "GET"
                };
                _context.prev = 1;
                wellKnownUrl = "".concat(homeserver, "/.well-known/matrix/client");
                _context.next = 5;
                return request(wellKnownUrl, requestOptions).response();

              case 5:
                return _context.abrupt("return", _context.sent);

              case 8:
                _context.prev = 8;
                _context.t0 = _context["catch"](1);

                if (!(_context.t0.name === "ConnectionError")) {
                  _context.next = 14;
                  break;
                }

                return _context.abrupt("return", null);

              case 14:
                throw _context.t0;

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[1, 8]]);
      }));
      return _getWellKnownResponse.apply(this, arguments);
    }

    function lookupHomeserver(_x3, _x4) {
      return _lookupHomeserver.apply(this, arguments);
    }

    function _lookupHomeserver() {
      _lookupHomeserver = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(homeserver, request) {
        var wellKnownResponse, _body$mHomeserver, body, wellKnownHomeserver;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                homeserver = normalizeHomeserver(homeserver);
                _context2.next = 3;
                return getWellKnownResponse(homeserver, request);

              case 3:
                wellKnownResponse = _context2.sent;

                if (wellKnownResponse && wellKnownResponse.status === 200) {
                  body = wellKnownResponse.body;
                  wellKnownHomeserver = (_body$mHomeserver = body["m.homeserver"]) === null || _body$mHomeserver === void 0 ? void 0 : _body$mHomeserver["base_url"];

                  if (typeof wellKnownHomeserver === "string") {
                    homeserver = normalizeHomeserver(wellKnownHomeserver);
                  }
                }

                return _context2.abrupt("return", homeserver);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      return _lookupHomeserver.apply(this, arguments);
    }

    var AbortableOperation = /*#__PURE__*/function () {
      function AbortableOperation(run) {
        var _this = this;

        _classCallCheck(this, AbortableOperation);

        this._abortable = null;

        var setAbortable = function setAbortable(abortable) {
          _this._abortable = abortable;
          return abortable;
        };

        this.result = run(setAbortable);
      }

      _createClass(AbortableOperation, [{
        key: "abort",
        value: function abort() {
          var _this$_abortable;

          (_this$_abortable = this._abortable) === null || _this$_abortable === void 0 ? void 0 : _this$_abortable.abort();
          this._abortable = null;
        }
      }]);

      return AbortableOperation;
    }();

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function encodeQueryParams(queryParams) {
      return Object.entries(queryParams || {}).filter(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            value = _ref2[1];

        return value !== undefined;
      }).map(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            name = _ref4[0],
            value = _ref4[1];

        if (_typeof(value) === "object") {
          value = JSON.stringify(value);
        }

        return "".concat(encodeURIComponent(name), "=").concat(encodeURIComponent(value));
      }).join("&");
    }
    function encodeBody(body) {
      if (body.nativeBlob && body.mimeType) {
        var blob = body;
        return {
          mimeType: blob.mimeType,
          body: blob,
          // will be unwrapped in request fn
          length: blob.size
        };
      } else if (_typeof(body) === "object") {
        var json = JSON.stringify(body);
        return {
          mimeType: "application/json",
          body: json,
          length: body.length
        };
      } else {
        throw new Error("Unknown body type: " + body);
      }
    }

    var HomeServerRequest = /*#__PURE__*/function () {
      function HomeServerRequest(method, url, sourceRequest, log) {
        var _this = this;

        _classCallCheck(this, HomeServerRequest);

        this._log = log;
        this._sourceRequest = sourceRequest;
        this._promise = sourceRequest.response().then(function (response) {
          log === null || log === void 0 ? void 0 : log.set("status", response.status); // ok?

          if (response.status >= 200 && response.status < 300) {
            log === null || log === void 0 ? void 0 : log.finish();
            return response.body;
          } else {
            var _response$body;

            if (response.status >= 500) {
              var err = new ConnectionError("Internal Server Error");
              log === null || log === void 0 ? void 0 : log.catch(err);
              throw err;
            } else if (response.status >= 400 && !((_response$body = response.body) === null || _response$body === void 0 ? void 0 : _response$body.errcode)) {
              var _err = new ConnectionError("HTTP error status ".concat(response.status, " without errcode in body, assume this is a load balancer complaining the server is offline."));

              log === null || log === void 0 ? void 0 : log.catch(_err);
              throw _err;
            } else {
              var _err2 = new HomeServerError(method, url, response.body, response.status);

              log === null || log === void 0 ? void 0 : log.set("errcode", _err2.errcode);
              log === null || log === void 0 ? void 0 : log.catch(_err2);
              throw _err2;
            }
          }
        }, function (err) {
          // if this._sourceRequest is still set,
          // the abort error came not from calling abort here
          if (err.name === "AbortError" && _this._sourceRequest) {
            // The service worker sometimes (only on Firefox, on long, large request,
            // perhaps it has its own timeout?) aborts the request, see #187.
            // When it happens, the best thing to do seems to be to retry.
            // 
            // In the service worker, we will also actively abort all
            // ongoing requests when trying to get a new service worker to activate
            // (this may surface in the app as a TypeError, which already gets mapped
            // to a ConnectionError in the request function, or an AbortError,
            // depending on the browser), as the service worker will only be
            // replaced when there are no more (fetch) events for the
            // current one to handle.
            // 
            // In that case, the request function (in fetch.js) will check 
            // the haltRequests flag on the service worker handler, and
            // block any new requests, as that would break the update process.
            // 
            // So it is OK to return a ConnectionError here.
            // If we're updating the service worker, the /versions polling will
            // be blocked at the fetch level because haltRequests is set.
            // And for #187, retrying is the right thing to do.
            var _err3 = new ConnectionError("Service worker aborted, either updating or hit #187.");

            log === null || log === void 0 ? void 0 : log.catch(_err3);
            throw _err3;
          } else {
            if (err.name === "ConnectionError") {
              log === null || log === void 0 ? void 0 : log.set("timeout", err.isTimeout);
            }

            log === null || log === void 0 ? void 0 : log.catch(err);
            throw err;
          }
        });
      }

      _createClass(HomeServerRequest, [{
        key: "abort",
        value: function abort() {
          if (this._sourceRequest) {
            var _this$_log;

            (_this$_log = this._log) === null || _this$_log === void 0 ? void 0 : _this$_log.set("aborted", true);

            this._sourceRequest.abort(); // to mark that it was on purpose in above rejection handler


            this._sourceRequest = null;
          }
        }
      }, {
        key: "response",
        value: function response() {
          return this._promise;
        }
      }]);

      return HomeServerRequest;
    }();

    var CS_R0_PREFIX = "/_matrix/client/r0";
    var DEHYDRATION_PREFIX = "/_matrix/client/unstable/org.matrix.msc2697.v2";
    var HomeServerApi = /*#__PURE__*/function () {
      function HomeServerApi(_ref) {
        var homeserver = _ref.homeserver,
            accessToken = _ref.accessToken,
            request = _ref.request,
            reconnector = _ref.reconnector;

        _classCallCheck(this, HomeServerApi);

        // store these both in a closure somehow so it's harder to get at in case of XSS?
        // one could change the homeserver as well so the token gets sent there, so both must be protected from read/write
        this._homeserver = homeserver;
        this._accessToken = accessToken;
        this._requestFn = request;
        this._reconnector = reconnector;
      }

      _createClass(HomeServerApi, [{
        key: "_url",
        value: function _url(csPath) {
          var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CS_R0_PREFIX;
          return this._homeserver + prefix + csPath;
        }
      }, {
        key: "_baseRequest",
        value: function _baseRequest(method, url, queryParams, body, options, accessToken) {
          var _this = this;

          var queryString = encodeQueryParams(queryParams);
          url = "".concat(url, "?").concat(queryString);
          var log;

          if (options === null || options === void 0 ? void 0 : options.log) {
            var parent = options === null || options === void 0 ? void 0 : options.log;
            log = parent.child({
              t: "network",
              url: url,
              method: method
            }, parent.level.Info);
          }

          var encodedBody;
          var headers = new Map();

          if (accessToken) {
            headers.set("Authorization", "Bearer ".concat(accessToken));
          }

          headers.set("Accept", "application/json");

          if (body) {
            var encoded = encodeBody(body);
            headers.set("Content-Type", encoded.mimeType);
            headers.set("Content-Length", encoded.length);
            encodedBody = encoded.body;
          }

          var requestResult = this._requestFn(url, {
            method: method,
            headers: headers,
            body: encodedBody,
            timeout: options === null || options === void 0 ? void 0 : options.timeout,
            uploadProgress: options === null || options === void 0 ? void 0 : options.uploadProgress,
            format: "json" // response format

          });

          var hsRequest = new HomeServerRequest(method, url, requestResult, log);

          if (this._reconnector) {
            hsRequest.response().catch(function (err) {
              // Some endpoints such as /sync legitimately time-out
              // (which is also reported as a ConnectionError) and will re-attempt,
              // but spinning up the reconnector in this case is ok,
              // as all code ran on session and sync start should be reentrant
              if (err.name === "ConnectionError") {
                _this._reconnector.onRequestFailed(_this);
              }
            });
          }

          return hsRequest;
        }
      }, {
        key: "_unauthedRequest",
        value: function _unauthedRequest(method, url, queryParams, body, options) {
          return this._baseRequest(method, url, queryParams, body, options, null);
        }
      }, {
        key: "_authedRequest",
        value: function _authedRequest(method, url, queryParams, body, options) {
          return this._baseRequest(method, url, queryParams, body, options, this._accessToken);
        }
      }, {
        key: "_post",
        value: function _post(csPath, queryParams, body, options) {
          return this._authedRequest("POST", this._url(csPath, (options === null || options === void 0 ? void 0 : options.prefix) || CS_R0_PREFIX), queryParams, body, options);
        }
      }, {
        key: "_put",
        value: function _put(csPath, queryParams, body, options) {
          return this._authedRequest("PUT", this._url(csPath, (options === null || options === void 0 ? void 0 : options.prefix) || CS_R0_PREFIX), queryParams, body, options);
        }
      }, {
        key: "_get",
        value: function _get(csPath, queryParams, body, options) {
          return this._authedRequest("GET", this._url(csPath, (options === null || options === void 0 ? void 0 : options.prefix) || CS_R0_PREFIX), queryParams, body, options);
        }
      }, {
        key: "sync",
        value: function sync(since, filter, timeout) {
          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          return this._get("/sync", {
            since: since,
            timeout: timeout,
            filter: filter
          }, null, options);
        } // params is from, dir and optionally to, limit, filter.

      }, {
        key: "messages",
        value: function messages(roomId, params) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          return this._get("/rooms/".concat(encodeURIComponent(roomId), "/messages"), params, null, options);
        } // params is at, membership and not_membership

      }, {
        key: "members",
        value: function members(roomId, params) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          return this._get("/rooms/".concat(encodeURIComponent(roomId), "/members"), params, null, options);
        }
      }, {
        key: "send",
        value: function send(roomId, eventType, txnId, content) {
          var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          return this._put("/rooms/".concat(encodeURIComponent(roomId), "/send/").concat(encodeURIComponent(eventType), "/").concat(encodeURIComponent(txnId)), {}, content, options);
        }
      }, {
        key: "redact",
        value: function redact(roomId, eventId, txnId, content) {
          var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          return this._put("/rooms/".concat(encodeURIComponent(roomId), "/redact/").concat(encodeURIComponent(eventId), "/").concat(encodeURIComponent(txnId)), {}, content, options);
        }
      }, {
        key: "receipt",
        value: function receipt(roomId, receiptType, eventId) {
          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          return this._post("/rooms/".concat(encodeURIComponent(roomId), "/receipt/").concat(encodeURIComponent(receiptType), "/").concat(encodeURIComponent(eventId)), {}, {}, options);
        }
      }, {
        key: "state",
        value: function state(roomId, eventType, stateKey) {
          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          return this._get("/rooms/".concat(encodeURIComponent(roomId), "/state/").concat(encodeURIComponent(eventType), "/").concat(encodeURIComponent(stateKey)), {}, null, options);
        }
      }, {
        key: "getLoginFlows",
        value: function getLoginFlows() {
          return this._unauthedRequest("GET", this._url("/login"), null, null, null);
        }
      }, {
        key: "passwordLogin",
        value: function passwordLogin(username, password, initialDeviceDisplayName) {
          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          return this._unauthedRequest("POST", this._url("/login"), null, {
            "type": "m.login.password",
            "identifier": {
              "type": "m.id.user",
              "user": username
            },
            "password": password,
            "initial_device_display_name": initialDeviceDisplayName
          }, options);
        }
      }, {
        key: "tokenLogin",
        value: function tokenLogin(loginToken, txnId, initialDeviceDisplayName) {
          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          return this._unauthedRequest("POST", this._url("/login"), null, {
            "type": "m.login.token",
            "identifier": {
              "type": "m.id.user"
            },
            "token": loginToken,
            "txn_id": txnId,
            "initial_device_display_name": initialDeviceDisplayName
          }, options);
        }
      }, {
        key: "createFilter",
        value: function createFilter(userId, filter) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          return this._post("/user/".concat(encodeURIComponent(userId), "/filter"), null, filter, options);
        }
      }, {
        key: "versions",
        value: function versions() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          return this._unauthedRequest("GET", "".concat(this._homeserver, "/_matrix/client/versions"), null, null, options);
        }
      }, {
        key: "uploadKeys",
        value: function uploadKeys(dehydratedDeviceId, payload) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var path = "/keys/upload";

          if (dehydratedDeviceId) {
            path = path + "/".concat(encodeURIComponent(dehydratedDeviceId));
          }

          return this._post(path, null, payload, options);
        }
      }, {
        key: "queryKeys",
        value: function queryKeys(queryRequest) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return this._post("/keys/query", null, queryRequest, options);
        }
      }, {
        key: "claimKeys",
        value: function claimKeys(payload) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return this._post("/keys/claim", null, payload, options);
        }
      }, {
        key: "sendToDevice",
        value: function sendToDevice(type, payload, txnId) {
          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          return this._put("/sendToDevice/".concat(encodeURIComponent(type), "/").concat(encodeURIComponent(txnId)), null, payload, options);
        }
      }, {
        key: "roomKeysVersion",
        value: function roomKeysVersion() {
          var version = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var versionPart = "";

          if (version) {
            versionPart = "/".concat(encodeURIComponent(version));
          }

          return this._get("/room_keys/version".concat(versionPart), null, null, options);
        }
      }, {
        key: "roomKeyForRoomAndSession",
        value: function roomKeyForRoomAndSession(version, roomId, sessionId) {
          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          return this._get("/room_keys/keys/".concat(encodeURIComponent(roomId), "/").concat(encodeURIComponent(sessionId)), {
            version: version
          }, null, options);
        }
      }, {
        key: "uploadAttachment",
        value: function uploadAttachment(blob, filename) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          return this._authedRequest("POST", "".concat(this._homeserver, "/_matrix/media/r0/upload"), {
            filename: filename
          }, blob, options);
        }
      }, {
        key: "setPusher",
        value: function setPusher(pusher) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return this._post("/pushers/set", null, pusher, options);
        }
      }, {
        key: "getPushers",
        value: function getPushers() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          return this._get("/pushers", null, null, options);
        }
      }, {
        key: "join",
        value: function join(roomId) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return this._post("/rooms/".concat(encodeURIComponent(roomId), "/join"), null, null, options);
        }
      }, {
        key: "joinIdOrAlias",
        value: function joinIdOrAlias(roomIdOrAlias) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return this._post("/join/".concat(encodeURIComponent(roomIdOrAlias)), null, null, options);
        }
      }, {
        key: "leave",
        value: function leave(roomId) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return this._post("/rooms/".concat(encodeURIComponent(roomId), "/leave"), null, null, options);
        }
      }, {
        key: "forget",
        value: function forget(roomId) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return this._post("/rooms/".concat(encodeURIComponent(roomId), "/forget"), null, null, options);
        }
      }, {
        key: "logout",
        value: function logout() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          return this._post("/logout", null, null, options);
        }
      }, {
        key: "getDehydratedDevice",
        value: function getDehydratedDevice() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          options.prefix = DEHYDRATION_PREFIX;
          return this._get("/dehydrated_device", null, null, options);
        }
      }, {
        key: "createDehydratedDevice",
        value: function createDehydratedDevice(payload) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          options.prefix = DEHYDRATION_PREFIX;
          return this._put("/dehydrated_device", null, payload, options);
        }
      }, {
        key: "claimDehydratedDevice",
        value: function claimDehydratedDevice(deviceId) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          options.prefix = DEHYDRATION_PREFIX;
          return this._post("/dehydrated_device/claim", null, {
            device_id: deviceId
          }, options);
        }
      }]);

      return HomeServerApi;
    }();

    var ExponentialRetryDelay = /*#__PURE__*/function () {
      function ExponentialRetryDelay(createTimeout) {
        _classCallCheck(this, ExponentialRetryDelay);

        var start = 2000;
        this._start = start;
        this._current = start;
        this._createTimeout = createTimeout;
        this._max = 60 * 5 * 1000; //5 min

        this._timeout = null;
      }

      _createClass(ExponentialRetryDelay, [{
        key: "waitForRetry",
        value: function () {
          var _waitForRetry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var next;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this._timeout = this._createTimeout(this._current);
                    _context.prev = 1;
                    _context.next = 4;
                    return this._timeout.elapsed();

                  case 4:
                    // only increase delay if we didn't get interrupted
                    next = 2 * this._current;
                    this._current = Math.min(this._max, next);
                    _context.next = 12;
                    break;

                  case 8:
                    _context.prev = 8;
                    _context.t0 = _context["catch"](1);

                    if (_context.t0 instanceof AbortError) {
                      _context.next = 12;
                      break;
                    }

                    throw _context.t0;

                  case 12:
                    _context.prev = 12;
                    this._timeout = null;
                    return _context.finish(12);

                  case 15:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[1, 8, 12, 15]]);
          }));

          function waitForRetry() {
            return _waitForRetry.apply(this, arguments);
          }

          return waitForRetry;
        }()
      }, {
        key: "abort",
        value: function abort() {
          if (this._timeout) {
            this._timeout.abort();
          }
        }
      }, {
        key: "reset",
        value: function reset() {
          this._current = this._start;
          this.abort();
        }
      }, {
        key: "nextValue",
        get: function get() {
          return this._current;
        }
      }]);

      return ExponentialRetryDelay;
    }();

    var ConnectionStatus = createEnum("Waiting", "Reconnecting", "Online");
    var Reconnector = /*#__PURE__*/function () {
      function Reconnector(_ref) {
        var retryDelay = _ref.retryDelay,
            createMeasure = _ref.createMeasure,
            onlineStatus = _ref.onlineStatus;

        _classCallCheck(this, Reconnector);

        this._onlineStatus = onlineStatus;
        this._retryDelay = retryDelay;
        this._createTimeMeasure = createMeasure; // assume online, and do our thing when something fails

        this._state = new ObservableValue(ConnectionStatus.Online);
        this._isReconnecting = false;
        this._versionsResponse = null;
      }

      _createClass(Reconnector, [{
        key: "onRequestFailed",
        value: function () {
          var _onRequestFailed = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(hsApi) {
            var _this = this;

            var onlineStatusSubscription;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (this._isReconnecting) {
                      _context.next = 15;
                      break;
                    }

                    this._isReconnecting = true;
                    onlineStatusSubscription = this._onlineStatus && this._onlineStatus.subscribe(function (online) {
                      if (online) {
                        _this.tryNow();
                      }
                    });
                    _context.prev = 3;
                    _context.next = 6;
                    return this._reconnectLoop(hsApi);

                  case 6:
                    _context.next = 11;
                    break;

                  case 8:
                    _context.prev = 8;
                    _context.t0 = _context["catch"](3);
                    // nothing is catching the error above us,
                    // so just log here
                    console.error(_context.t0);

                  case 11:
                    _context.prev = 11;

                    if (onlineStatusSubscription) {
                      // unsubscribe from this._onlineStatus
                      onlineStatusSubscription();
                    }

                    this._isReconnecting = false;
                    return _context.finish(11);

                  case 15:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[3, 8, 11, 15]]);
          }));

          function onRequestFailed(_x) {
            return _onRequestFailed.apply(this, arguments);
          }

          return onRequestFailed;
        }()
      }, {
        key: "tryNow",
        value: function tryNow() {
          if (this._retryDelay) {
            // this will interrupt this._retryDelay.waitForRetry() in _reconnectLoop
            this._retryDelay.abort();
          }
        }
      }, {
        key: "_setState",
        value: function _setState(state) {
          if (state !== this._state.get()) {
            if (state === ConnectionStatus.Waiting) {
              this._stateSince = this._createTimeMeasure();
            } else {
              this._stateSince = null;
            }

            this._state.set(state);
          }
        }
      }, {
        key: "_reconnectLoop",
        value: function () {
          var _reconnectLoop2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(hsApi) {
            var versionsRequest;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    this._versionsResponse = null;

                    this._retryDelay.reset();

                  case 2:
                    if (this._versionsResponse) {
                      _context2.next = 23;
                      break;
                    }

                    _context2.prev = 3;

                    this._setState(ConnectionStatus.Reconnecting); // use 30s timeout, as a tradeoff between not giving up
                    // too quickly on a slow server, and not waiting for
                    // a stale connection when we just came online again


                    versionsRequest = hsApi.versions({
                      timeout: 30000
                    });
                    _context2.next = 8;
                    return versionsRequest.response();

                  case 8:
                    this._versionsResponse = _context2.sent;

                    this._setState(ConnectionStatus.Online);

                    _context2.next = 21;
                    break;

                  case 12:
                    _context2.prev = 12;
                    _context2.t0 = _context2["catch"](3);

                    if (!(_context2.t0.name === "ConnectionError")) {
                      _context2.next = 20;
                      break;
                    }

                    this._setState(ConnectionStatus.Waiting);

                    _context2.next = 18;
                    return this._retryDelay.waitForRetry();

                  case 18:
                    _context2.next = 21;
                    break;

                  case 20:
                    throw _context2.t0;

                  case 21:
                    _context2.next = 2;
                    break;

                  case 23:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[3, 12]]);
          }));

          function _reconnectLoop(_x2) {
            return _reconnectLoop2.apply(this, arguments);
          }

          return _reconnectLoop;
        }()
      }, {
        key: "lastVersionsResponse",
        get: function get() {
          return this._versionsResponse;
        }
      }, {
        key: "connectionStatus",
        get: function get() {
          return this._state;
        }
      }, {
        key: "retryIn",
        get: function get() {
          if (this._state.get() === ConnectionStatus.Waiting) {
            return this._retryDelay.nextValue - this._stateSince.measure();
          }

          return 0;
        }
      }]);

      return Reconnector;
    }();

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */

    /**
     * Decrypt an attachment.
     * @param {ArrayBuffer} ciphertextBuffer The encrypted attachment data buffer.
     * @param {Object} info The information needed to decrypt the attachment.
     * @param {Object} info.key AES-CTR JWK key object.
     * @param {string} info.iv Base64 encoded 16 byte AES-CTR IV.
     * @param {string} info.hashes.sha256 Base64 encoded SHA-256 hash of the ciphertext.
     * @return {Promise} A promise that resolves with an ArrayBuffer when the attachment is decrypted.
     */
    function decryptAttachment(_x, _x2, _x3) {
      return _decryptAttachment.apply(this, arguments);
    }

    function _decryptAttachment() {
      _decryptAttachment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(platform, ciphertextBuffer, info) {
        var crypto, base64, ivArray, expectedSha256base64, digestResult, counterLength, decryptedBuffer;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(info === undefined || info.key === undefined || info.iv === undefined || info.hashes === undefined || info.hashes.sha256 === undefined)) {
                  _context.next = 2;
                  break;
                }

                throw new Error("Invalid info. Missing info.key, info.iv or info.hashes.sha256 key");

              case 2:
                crypto = platform.crypto;
                base64 = platform.encoding.base64;
                ivArray = base64.decode(info.iv); // re-encode to not deal with padded vs unpadded

                expectedSha256base64 = base64.encode(base64.decode(info.hashes.sha256)); // Check the sha256 hash

                _context.next = 8;
                return crypto.digest("SHA-256", ciphertextBuffer);

              case 8:
                digestResult = _context.sent;

                if (!(base64.encode(new Uint8Array(digestResult)) != expectedSha256base64)) {
                  _context.next = 11;
                  break;
                }

                throw new Error("Mismatched SHA-256 digest");

              case 11:
                if (info.v == "v1" || info.v == "v2") {
                  // Version 1 and 2 use a 64 bit counter.
                  counterLength = 64;
                } else {
                  // Version 0 uses a 128 bit counter.
                  counterLength = 128;
                }

                _context.next = 14;
                return crypto.aes.decryptCTR({
                  jwkKey: info.key,
                  iv: ivArray,
                  data: ciphertextBuffer,
                  counterLength: counterLength
                });

              case 14:
                decryptedBuffer = _context.sent;
                return _context.abrupt("return", decryptedBuffer);

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return _decryptAttachment.apply(this, arguments);
    }

    function encryptAttachment(_x4, _x5) {
      return _encryptAttachment.apply(this, arguments);
    }

    function _encryptAttachment() {
      _encryptAttachment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(platform, blob) {
        var crypto, base64, iv, key, buffer, ciphertext, digest;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                crypto = platform.crypto;
                base64 = platform.encoding.base64;
                _context2.next = 4;
                return crypto.aes.generateIV();

              case 4:
                iv = _context2.sent;
                _context2.next = 7;
                return crypto.aes.generateKey("jwk", 256);

              case 7:
                key = _context2.sent;
                _context2.next = 10;
                return blob.readAsBuffer();

              case 10:
                buffer = _context2.sent;
                _context2.next = 13;
                return crypto.aes.encryptCTR({
                  jwkKey: key,
                  iv: iv,
                  data: buffer
                });

              case 13:
                ciphertext = _context2.sent;
                _context2.next = 16;
                return crypto.digest("SHA-256", ciphertext);

              case 16:
                digest = _context2.sent;
                return _context2.abrupt("return", {
                  blob: platform.createBlob(ciphertext, 'application/octet-stream'),
                  info: {
                    v: "v2",
                    key: key,
                    iv: base64.encodeUnpadded(iv),
                    hashes: {
                      sha256: base64.encodeUnpadded(digest)
                    }
                  }
                });

              case 18:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      return _encryptAttachment.apply(this, arguments);
    }

    var MediaRepository = /*#__PURE__*/function () {
      function MediaRepository(_ref) {
        var homeserver = _ref.homeserver,
            platform = _ref.platform;

        _classCallCheck(this, MediaRepository);

        this._homeserver = homeserver;
        this._platform = platform;
      }

      _createClass(MediaRepository, [{
        key: "mxcUrlThumbnail",
        value: function mxcUrlThumbnail(url, width, height, method) {
          var parts = this._parseMxcUrl(url);

          if (parts) {
            var _parts = _slicedToArray(parts, 2),
                serverName = _parts[0],
                mediaId = _parts[1];

            var httpUrl = "".concat(this._homeserver, "/_matrix/media/r0/thumbnail/").concat(encodeURIComponent(serverName), "/").concat(encodeURIComponent(mediaId));
            return httpUrl + "?" + encodeQueryParams({
              width: Math.round(width),
              height: Math.round(height),
              method: method
            });
          }

          return null;
        }
      }, {
        key: "mxcUrl",
        value: function mxcUrl(url) {
          var parts = this._parseMxcUrl(url);

          if (parts) {
            var _parts2 = _slicedToArray(parts, 2),
                serverName = _parts2[0],
                mediaId = _parts2[1];

            return "".concat(this._homeserver, "/_matrix/media/r0/download/").concat(encodeURIComponent(serverName), "/").concat(encodeURIComponent(mediaId));
          } else {
            return null;
          }
        }
      }, {
        key: "_parseMxcUrl",
        value: function _parseMxcUrl(url) {
          var prefix = "mxc://";

          if (url.startsWith(prefix)) {
            return url.substr(prefix.length).split("/", 2);
          } else {
            return null;
          }
        }
      }, {
        key: "downloadEncryptedFile",
        value: function () {
          var _downloadEncryptedFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(fileEntry) {
            var cache,
                url,
                _yield$this$_platform,
                encryptedBuffer,
                decryptedBuffer,
                _args = arguments;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    cache = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;
                    url = this.mxcUrl(fileEntry.url);
                    _context.next = 4;
                    return this._platform.request(url, {
                      method: "GET",
                      format: "buffer",
                      cache: cache
                    }).response();

                  case 4:
                    _yield$this$_platform = _context.sent;
                    encryptedBuffer = _yield$this$_platform.body;
                    _context.next = 8;
                    return decryptAttachment(this._platform, encryptedBuffer, fileEntry);

                  case 8:
                    decryptedBuffer = _context.sent;
                    return _context.abrupt("return", this._platform.createBlob(decryptedBuffer, fileEntry.mimetype));

                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function downloadEncryptedFile(_x) {
            return _downloadEncryptedFile.apply(this, arguments);
          }

          return downloadEncryptedFile;
        }()
      }, {
        key: "downloadPlaintextFile",
        value: function () {
          var _downloadPlaintextFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(mxcUrl, mimetype) {
            var cache,
                url,
                _yield$this$_platform2,
                buffer,
                _args2 = arguments;

            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    cache = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : false;
                    url = this.mxcUrl(mxcUrl);
                    _context2.next = 4;
                    return this._platform.request(url, {
                      method: "GET",
                      format: "buffer",
                      cache: cache
                    }).response();

                  case 4:
                    _yield$this$_platform2 = _context2.sent;
                    buffer = _yield$this$_platform2.body;
                    return _context2.abrupt("return", this._platform.createBlob(buffer, mimetype));

                  case 7:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function downloadPlaintextFile(_x2, _x3) {
            return _downloadPlaintextFile.apply(this, arguments);
          }

          return downloadPlaintextFile;
        }()
      }, {
        key: "downloadAttachment",
        value: function () {
          var _downloadAttachment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(content) {
            var cache,
                _content$info,
                _args3 = arguments;

            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    cache = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : false;

                    if (!content.file) {
                      _context3.next = 5;
                      break;
                    }

                    return _context3.abrupt("return", this.downloadEncryptedFile(content.file, cache));

                  case 5:
                    return _context3.abrupt("return", this.downloadPlaintextFile(content.url, (_content$info = content.info) === null || _content$info === void 0 ? void 0 : _content$info.mimetype, cache));

                  case 6:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function downloadAttachment(_x4) {
            return _downloadAttachment.apply(this, arguments);
          }

          return downloadAttachment;
        }()
      }]);

      return MediaRepository;
    }();

    var Request$1 = /*#__PURE__*/function () {
      function Request(methodName, args) {
        var _this = this;

        _classCallCheck(this, Request);

        this._methodName = methodName;
        this._args = args;
        this._responsePromise = new Promise(function (resolve, reject) {
          _this._resolve = resolve;
          _this._reject = reject;
        });
        this._requestResult = null;
      }

      _createClass(Request, [{
        key: "abort",
        value: function abort() {
          if (this._requestResult) {
            this._requestResult.abort();
          } else {
            this._reject(new AbortError());
          }
        }
      }, {
        key: "response",
        value: function response() {
          return this._responsePromise;
        }
      }]);

      return Request;
    }();

    var HomeServerApiWrapper = function HomeServerApiWrapper(scheduler) {
      _classCallCheck(this, HomeServerApiWrapper);

      this._scheduler = scheduler;
    }; // add request-wrapping methods to prototype


    var _iterator = _createForOfIteratorHelper(Object.getOwnPropertyNames(HomeServerApi.prototype)),
        _step;

    try {
      var _loop$2 = function _loop() {
        var methodName = _step.value;

        if (methodName !== "constructor" && !methodName.startsWith("_")) {
          HomeServerApiWrapper.prototype[methodName] = function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            return this._scheduler._hsApiRequest(methodName, args);
          };
        }
      };

      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        _loop$2();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var RequestScheduler = /*#__PURE__*/function () {
      function RequestScheduler(_ref) {
        var hsApi = _ref.hsApi,
            clock = _ref.clock;

        _classCallCheck(this, RequestScheduler);

        this._hsApi = hsApi;
        this._clock = clock;
        this._requests = new Set();
        this._isRateLimited = false;
        this._isDrainingRateLimit = false;
        this._stopped = true;
        this._wrapper = new HomeServerApiWrapper(this);
      }

      _createClass(RequestScheduler, [{
        key: "stop",
        value: function stop() {
          this._stopped = true;

          var _iterator2 = _createForOfIteratorHelper(this._requests),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var request = _step2.value;
              request.abort();
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          this._requests.clear();
        }
      }, {
        key: "start",
        value: function start() {
          this._stopped = false;
        }
      }, {
        key: "_hsApiRequest",
        value: function _hsApiRequest(name, args) {
          var request = new Request$1(name, args);

          this._doSend(request);

          return request;
        }
      }, {
        key: "_doSend",
        value: function () {
          var _doSend2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(request) {
            var retryDelay, requestResult, response;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this._requests.add(request);

                    _context.prev = 1;

                  case 2:
                    if (this._stopped) {
                      _context.next = 30;
                      break;
                    }

                    _context.prev = 3;
                    requestResult = this._hsApi[request._methodName].apply(this._hsApi, request._args); // so the request can be aborted

                    request._requestResult = requestResult;
                    _context.next = 8;
                    return requestResult.response();

                  case 8:
                    response = _context.sent;

                    request._resolve(response);

                    return _context.abrupt("return");

                  case 13:
                    _context.prev = 13;
                    _context.t0 = _context["catch"](3);

                    if (!(_context.t0 instanceof HomeServerError && _context.t0.errcode === "M_LIMIT_EXCEEDED")) {
                      _context.next = 26;
                      break;
                    }

                    if (!Number.isSafeInteger(_context.t0.retry_after_ms)) {
                      _context.next = 21;
                      break;
                    }

                    _context.next = 19;
                    return this._clock.createTimeout(_context.t0.retry_after_ms).elapsed();

                  case 19:
                    _context.next = 24;
                    break;

                  case 21:
                    if (!retryDelay) {
                      retryDelay = new ExponentialRetryDelay(this._clock.createTimeout);
                    }

                    _context.next = 24;
                    return retryDelay.waitForRetry();

                  case 24:
                    _context.next = 28;
                    break;

                  case 26:
                    request._reject(_context.t0);

                    return _context.abrupt("return");

                  case 28:
                    _context.next = 2;
                    break;

                  case 30:
                    if (this._stopped) {
                      request.abort();
                    }

                  case 31:
                    _context.prev = 31;

                    this._requests.delete(request);

                    return _context.finish(31);

                  case 34:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[1,, 31, 34], [3, 13]]);
          }));

          function _doSend(_x) {
            return _doSend2.apply(this, arguments);
          }

          return _doSend;
        }()
      }, {
        key: "hsApi",
        get: function get() {
          return this._wrapper;
        }
      }]);

      return RequestScheduler;
    }();

    var INCREMENTAL_TIMEOUT = 30000;
    var SyncStatus = createEnum("InitialSync", "CatchupSync", "Syncing", "Stopped");

    function timelineIsEmpty(roomResponse) {
      try {
        var _roomResponse$timelin;

        var events = roomResponse === null || roomResponse === void 0 ? void 0 : (_roomResponse$timelin = roomResponse.timeline) === null || _roomResponse$timelin === void 0 ? void 0 : _roomResponse$timelin.events;
        return Array.isArray(events) && events.length === 0;
      } catch (err) {
        return true;
      }
    }
    /**
     * Sync steps in js-pseudocode:
     * ```js
     * // can only read some stores
     * const preparation = await room.prepareSync(roomResponse, membership, newRoomKeys, prepareTxn);
     * // can do async work that is not related to storage (such as decryption)
     * await room.afterPrepareSync(preparation);
     * // writes and calculates changes
     * const changes = await room.writeSync(roomResponse, isInitialSync, preparation, syncTxn);
     * // applies and emits changes once syncTxn is committed
     * room.afterSync(changes);
     * if (room.needsAfterSyncCompleted(changes)) {
     *     // can do network requests
     *     await room.afterSyncCompleted(changes);
     * }
     * ```
     */


    var Sync = /*#__PURE__*/function () {
      function Sync(_ref) {
        var hsApi = _ref.hsApi,
            session = _ref.session,
            storage = _ref.storage,
            logger = _ref.logger;

        _classCallCheck(this, Sync);

        this._hsApi = hsApi;
        this._logger = logger;
        this._session = session;
        this._storage = storage;
        this._currentRequest = null;
        this._status = new ObservableValue(SyncStatus.Stopped);
        this._error = null;
      }

      _createClass(Sync, [{
        key: "start",
        value: function start() {
          // not already syncing?
          if (this._status.get() !== SyncStatus.Stopped) {
            return;
          }

          this._error = null;
          var syncToken = this._session.syncToken;

          if (syncToken) {
            this._status.set(SyncStatus.CatchupSync);
          } else {
            this._status.set(SyncStatus.InitialSync);
          }

          this._syncLoop(syncToken);
        }
      }, {
        key: "_syncLoop",
        value: function () {
          var _syncLoop2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(syncToken) {
            var _this = this;

            var _loop;

            return regeneratorRuntime.wrap(function _callee2$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop() {
                      var roomStates, sessionChanges, wasCatchupOrInitial;
                      return regeneratorRuntime.wrap(function _loop$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              roomStates = void 0;
                              sessionChanges = void 0;
                              wasCatchupOrInitial = _this._status.get() === SyncStatus.CatchupSync || _this._status.get() === SyncStatus.InitialSync;
                              _context2.next = 5;
                              return _this._logger.run("sync", /*#__PURE__*/function () {
                                var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(log) {
                                  var timeout, syncResult;
                                  return regeneratorRuntime.wrap(function _callee$(_context) {
                                    while (1) {
                                      switch (_context.prev = _context.next) {
                                        case 0:
                                          log.set("token", syncToken);
                                          log.set("status", _this._status.get());
                                          _context.prev = 2;
                                          // unless we are happily syncing already, we want the server to return
                                          // as quickly as possible, even if there are no events queued. This
                                          // serves two purposes:
                                          //
                                          // * When the connection dies, we want to know asap when it comes back,
                                          //   so that we can hide the error from the user. (We don't want to
                                          //   have to wait for an event or a timeout).
                                          //
                                          // * We want to know if the server has any to_device messages queued up
                                          //   for us. We do that by calling it with a zero timeout until it
                                          //   doesn't give us any more to_device messages.
                                          timeout = _this._status.get() === SyncStatus.Syncing ? INCREMENTAL_TIMEOUT : 0;
                                          _context.next = 6;
                                          return _this._syncRequest(syncToken, timeout, log);

                                        case 6:
                                          syncResult = _context.sent;
                                          syncToken = syncResult.syncToken;
                                          roomStates = syncResult.roomStates;
                                          sessionChanges = syncResult.sessionChanges; // initial sync or catchup sync

                                          if (_this._status.get() !== SyncStatus.Syncing && syncResult.hadToDeviceMessages) {
                                            _this._status.set(SyncStatus.CatchupSync);
                                          } else {
                                            _this._status.set(SyncStatus.Syncing);
                                          }

                                          _context.next = 21;
                                          break;

                                        case 13:
                                          _context.prev = 13;
                                          _context.t0 = _context["catch"](2);

                                          if (!(_context.t0.name === "ConnectionError" && _context.t0.isTimeout)) {
                                            _context.next = 17;
                                            break;
                                          }

                                          return _context.abrupt("return");

                                        case 17:
                                          _this._error = _context.t0;

                                          if (_context.t0.name !== "AbortError") {
                                            // sync wasn't asked to stop, but is stopping
                                            // because of the error.
                                            log.error = _context.t0;
                                            log.logLevel = log.level.Fatal;
                                          }

                                          log.set("stopping", true);

                                          _this._status.set(SyncStatus.Stopped);

                                        case 21:
                                          if (!(_this._status.get() !== SyncStatus.Stopped)) {
                                            _context.next = 24;
                                            break;
                                          }

                                          _context.next = 24;
                                          return log.wrap("afterSyncCompleted", function (log) {
                                            return _this._runAfterSyncCompleted(sessionChanges, roomStates, log);
                                          });

                                        case 24:
                                        case "end":
                                          return _context.stop();
                                      }
                                    }
                                  }, _callee, null, [[2, 13]]);
                                }));

                                return function (_x2) {
                                  return _ref2.apply(this, arguments);
                                };
                              }(), _this._logger.level.Info, function (filter, log) {
                                if (log.durationWithoutType("network") >= 2000 || log.error || wasCatchupOrInitial) {
                                  return filter.minLevel(log.level.Detail);
                                } else {
                                  return filter.minLevel(log.level.Info);
                                }
                              });

                            case 5:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _loop);
                    });

                  case 1:
                    if (!(this._status.get() !== SyncStatus.Stopped)) {
                      _context3.next = 5;
                      break;
                    }

                    return _context3.delegateYield(_loop(), "t0", 3);

                  case 3:
                    _context3.next = 1;
                    break;

                  case 5:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee2, this);
          }));

          function _syncLoop(_x) {
            return _syncLoop2.apply(this, arguments);
          }

          return _syncLoop;
        }()
      }, {
        key: "_runAfterSyncCompleted",
        value: function () {
          var _runAfterSyncCompleted2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(sessionChanges, roomStates, log) {
            var _this2 = this;

            var isCatchupSync, sessionPromise, roomsNeedingAfterSyncCompleted, roomsPromises;
            return regeneratorRuntime.wrap(function _callee5$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    isCatchupSync = this._status.get() === SyncStatus.CatchupSync;
                    sessionPromise = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
                      return regeneratorRuntime.wrap(function _callee3$(_context4) {
                        while (1) {
                          switch (_context4.prev = _context4.next) {
                            case 0:
                              _context4.prev = 0;
                              _context4.next = 3;
                              return log.wrap("session", function (log) {
                                return _this2._session.afterSyncCompleted(sessionChanges, isCatchupSync, log);
                              }, log.level.Detail);

                            case 3:
                              _context4.next = 7;
                              break;

                            case 5:
                              _context4.prev = 5;
                              _context4.t0 = _context4["catch"](0);

                            case 7:
                            case "end":
                              return _context4.stop();
                          }
                        }
                      }, _callee3, null, [[0, 5]]);
                    }))();
                    roomsNeedingAfterSyncCompleted = roomStates.filter(function (rs) {
                      return rs.room.needsAfterSyncCompleted(rs.changes);
                    });
                    roomsPromises = roomsNeedingAfterSyncCompleted.map( /*#__PURE__*/function () {
                      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(rs) {
                        return regeneratorRuntime.wrap(function _callee4$(_context5) {
                          while (1) {
                            switch (_context5.prev = _context5.next) {
                              case 0:
                                _context5.prev = 0;
                                _context5.next = 3;
                                return log.wrap("room", function (log) {
                                  return rs.room.afterSyncCompleted(rs.changes, log);
                                }, log.level.Detail);

                              case 3:
                                _context5.next = 7;
                                break;

                              case 5:
                                _context5.prev = 5;
                                _context5.t0 = _context5["catch"](0);

                              case 7:
                              case "end":
                                return _context5.stop();
                            }
                          }
                        }, _callee4, null, [[0, 5]]);
                      }));

                      return function (_x6) {
                        return _ref4.apply(this, arguments);
                      };
                    }()); // run everything in parallel,
                    // we don't want to delay the next sync too much
                    // Also, since all promises won't reject (as they have a try/catch)
                    // it's fine to use Promise.all

                    _context6.next = 6;
                    return Promise.all(roomsPromises.concat(sessionPromise));

                  case 6:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee5, this);
          }));

          function _runAfterSyncCompleted(_x3, _x4, _x5) {
            return _runAfterSyncCompleted2.apply(this, arguments);
          }

          return _runAfterSyncCompleted;
        }()
      }, {
        key: "_syncRequest",
        value: function () {
          var _syncRequest2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(syncToken, timeout, log) {
            var _this3 = this,
                _response$to_device;

            var syncFilterId, totalRequestTimeout, response, isInitialSync, sessionState, inviteStates, _yield$this$_parseRoo, roomStates, archivedRoomStates, toDeviceEvents;

            return regeneratorRuntime.wrap(function _callee7$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    syncFilterId = this._session.syncFilterId;

                    if (!(typeof syncFilterId !== "string")) {
                      _context8.next = 6;
                      break;
                    }

                    this._currentRequest = this._hsApi.createFilter(this._session.user.id, {
                      room: {
                        state: {
                          lazy_load_members: true
                        }
                      }
                    }, {
                      log: log
                    });
                    _context8.next = 5;
                    return this._currentRequest.response();

                  case 5:
                    syncFilterId = _context8.sent.filter_id;

                  case 6:
                    totalRequestTimeout = timeout + 80 * 1000; // same as riot-web, don't get stuck on wedged long requests

                    this._currentRequest = this._hsApi.sync(syncToken, syncFilterId, timeout, {
                      timeout: totalRequestTimeout,
                      log: log
                    });
                    _context8.next = 10;
                    return this._currentRequest.response();

                  case 10:
                    response = _context8.sent;
                    isInitialSync = !syncToken;
                    sessionState = new SessionSyncProcessState();
                    inviteStates = this._parseInvites(response.rooms);
                    _context8.next = 16;
                    return this._parseRoomsResponse(response.rooms, inviteStates, isInitialSync, log);

                  case 16:
                    _yield$this$_parseRoo = _context8.sent;
                    roomStates = _yield$this$_parseRoo.roomStates;
                    archivedRoomStates = _yield$this$_parseRoo.archivedRoomStates;
                    _context8.prev = 19;
                    _context8.next = 22;
                    return log.wrap("obtainSyncLock", function () {
                      return _this3._session.obtainSyncLock(response);
                    });

                  case 22:
                    sessionState.lock = _context8.sent;
                    _context8.next = 25;
                    return log.wrap("prepare", function (log) {
                      return _this3._prepareSync(sessionState, roomStates, response, log);
                    });

                  case 25:
                    _context8.next = 27;
                    return log.wrap("afterPrepareSync", function (log) {
                      return Promise.all(roomStates.map(function (rs) {
                        return rs.room.afterPrepareSync(rs.preparation, log);
                      }));
                    });

                  case 27:
                    _context8.next = 29;
                    return log.wrap("write", /*#__PURE__*/function () {
                      var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(log) {
                        return regeneratorRuntime.wrap(function _callee6$(_context7) {
                          while (1) {
                            switch (_context7.prev = _context7.next) {
                              case 0:
                                return _context7.abrupt("return", _this3._writeSync(sessionState, inviteStates, roomStates, archivedRoomStates, response, syncFilterId, isInitialSync, log));

                              case 1:
                              case "end":
                                return _context7.stop();
                            }
                          }
                        }, _callee6);
                      }));

                      return function (_x10) {
                        return _ref5.apply(this, arguments);
                      };
                    }());

                  case 29:
                    _context8.prev = 29;
                    sessionState.dispose();
                    return _context8.finish(29);

                  case 32:
                    // sync txn comitted, emit updates and apply changes to in-memory state
                    log.wrap("after", function (log) {
                      return _this3._afterSync(sessionState, inviteStates, roomStates, archivedRoomStates, log);
                    });
                    toDeviceEvents = (_response$to_device = response.to_device) === null || _response$to_device === void 0 ? void 0 : _response$to_device.events;
                    return _context8.abrupt("return", {
                      syncToken: response.next_batch,
                      roomStates: roomStates,
                      sessionChanges: sessionState.changes,
                      hadToDeviceMessages: Array.isArray(toDeviceEvents) && toDeviceEvents.length > 0
                    });

                  case 35:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee7, this, [[19,, 29, 32]]);
          }));

          function _syncRequest(_x7, _x8, _x9) {
            return _syncRequest2.apply(this, arguments);
          }

          return _syncRequest;
        }()
      }, {
        key: "_openPrepareSyncTxn",
        value: function _openPrepareSyncTxn() {
          var storeNames = this._storage.storeNames;
          return this._storage.readTxn([storeNames.olmSessions, storeNames.inboundGroupSessions, // to read fragments when loading sync writer when rejoining archived room
          storeNames.timelineFragments, // to read fragments when loading sync writer when rejoining archived room
          // to read events that can now be decrypted
          storeNames.timelineEvents]);
        }
      }, {
        key: "_prepareSync",
        value: function () {
          var _prepareSync2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(sessionState, roomStates, response, log) {
            var _this4 = this,
                _sessionState$prepara;

            var prepareTxn, newKeysByRoom, _hasOwnProperty, _iterator, _step, _response$rooms, roomId, isRoomInResponse, room;

            return regeneratorRuntime.wrap(function _callee10$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    _context11.next = 2;
                    return this._openPrepareSyncTxn();

                  case 2:
                    prepareTxn = _context11.sent;
                    _context11.next = 5;
                    return log.wrap("session", function (log) {
                      return _this4._session.prepareSync(response, sessionState.lock, prepareTxn, log);
                    });

                  case 5:
                    sessionState.preparation = _context11.sent;
                    newKeysByRoom = (_sessionState$prepara = sessionState.preparation) === null || _sessionState$prepara === void 0 ? void 0 : _sessionState$prepara.newKeysByRoom; // add any rooms with new keys but no sync response to the list of rooms to be synced

                    if (newKeysByRoom) {
                      _hasOwnProperty = Object.prototype.hasOwnProperty;
                      _iterator = _createForOfIteratorHelper(newKeysByRoom.keys());

                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done;) {
                          roomId = _step.value;
                          isRoomInResponse = ((_response$rooms = response.rooms) === null || _response$rooms === void 0 ? void 0 : _response$rooms.join) && _hasOwnProperty.call(response.rooms.join, roomId);

                          if (!isRoomInResponse) {
                            room = this._session.rooms.get(roomId);

                            if (room) {
                              roomStates.push(new RoomSyncProcessState(room, false, null, {}, room.membership));
                            }
                          }
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }
                    }

                    _context11.next = 10;
                    return Promise.all(roomStates.map( /*#__PURE__*/function () {
                      var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(rs) {
                        var newKeys;
                        return regeneratorRuntime.wrap(function _callee9$(_context10) {
                          while (1) {
                            switch (_context10.prev = _context10.next) {
                              case 0:
                                newKeys = newKeysByRoom === null || newKeysByRoom === void 0 ? void 0 : newKeysByRoom.get(rs.room.id);
                                _context10.next = 3;
                                return log.wrap("room", /*#__PURE__*/function () {
                                  var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(log) {
                                    return regeneratorRuntime.wrap(function _callee8$(_context9) {
                                      while (1) {
                                        switch (_context9.prev = _context9.next) {
                                          case 0:
                                            if (!rs.isNewRoom) {
                                              _context9.next = 3;
                                              break;
                                            }

                                            _context9.next = 3;
                                            return rs.room.load(null, prepareTxn, log);

                                          case 3:
                                            return _context9.abrupt("return", rs.room.prepareSync(rs.roomResponse, rs.membership, rs.invite, newKeys, prepareTxn, log));

                                          case 4:
                                          case "end":
                                            return _context9.stop();
                                        }
                                      }
                                    }, _callee8);
                                  }));

                                  return function (_x16) {
                                    return _ref7.apply(this, arguments);
                                  };
                                }(), log.level.Detail);

                              case 3:
                                rs.preparation = _context10.sent;

                              case 4:
                              case "end":
                                return _context10.stop();
                            }
                          }
                        }, _callee9);
                      }));

                      return function (_x15) {
                        return _ref6.apply(this, arguments);
                      };
                    }()));

                  case 10:
                    _context11.next = 12;
                    return prepareTxn.complete();

                  case 12:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee10, this);
          }));

          function _prepareSync(_x11, _x12, _x13, _x14) {
            return _prepareSync2.apply(this, arguments);
          }

          return _prepareSync;
        }()
      }, {
        key: "_writeSync",
        value: function () {
          var _writeSync2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(sessionState, inviteStates, roomStates, archivedRoomStates, response, syncFilterId, isInitialSync, log) {
            var _this5 = this;

            var syncTxn;
            return regeneratorRuntime.wrap(function _callee14$(_context15) {
              while (1) {
                switch (_context15.prev = _context15.next) {
                  case 0:
                    _context15.next = 2;
                    return this._openSyncTxn();

                  case 2:
                    syncTxn = _context15.sent;
                    _context15.prev = 3;
                    _context15.next = 6;
                    return log.wrap("session", function (log) {
                      return _this5._session.writeSync(response, syncFilterId, sessionState.preparation, syncTxn, log);
                    });

                  case 6:
                    sessionState.changes = _context15.sent;
                    _context15.next = 9;
                    return Promise.all(inviteStates.map( /*#__PURE__*/function () {
                      var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(is) {
                        return regeneratorRuntime.wrap(function _callee11$(_context12) {
                          while (1) {
                            switch (_context12.prev = _context12.next) {
                              case 0:
                                _context12.next = 2;
                                return log.wrap("invite", function (log) {
                                  return is.invite.writeSync(is.membership, is.roomResponse, syncTxn, log);
                                });

                              case 2:
                                is.changes = _context12.sent;

                              case 3:
                              case "end":
                                return _context12.stop();
                            }
                          }
                        }, _callee11);
                      }));

                      return function (_x25) {
                        return _ref8.apply(this, arguments);
                      };
                    }()));

                  case 9:
                    _context15.next = 11;
                    return Promise.all(roomStates.map( /*#__PURE__*/function () {
                      var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(rs) {
                        return regeneratorRuntime.wrap(function _callee12$(_context13) {
                          while (1) {
                            switch (_context13.prev = _context13.next) {
                              case 0:
                                _context13.next = 2;
                                return log.wrap("room", function (log) {
                                  return rs.room.writeSync(rs.roomResponse, isInitialSync, rs.preparation, syncTxn, log);
                                });

                              case 2:
                                rs.changes = _context13.sent;

                              case 3:
                              case "end":
                                return _context13.stop();
                            }
                          }
                        }, _callee12);
                      }));

                      return function (_x26) {
                        return _ref9.apply(this, arguments);
                      };
                    }()));

                  case 11:
                    _context15.next = 13;
                    return Promise.all(archivedRoomStates.map( /*#__PURE__*/function () {
                      var _ref10 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(ars) {
                        var _ars$roomState;

                        var summaryChanges;
                        return regeneratorRuntime.wrap(function _callee13$(_context14) {
                          while (1) {
                            switch (_context14.prev = _context14.next) {
                              case 0:
                                summaryChanges = (_ars$roomState = ars.roomState) === null || _ars$roomState === void 0 ? void 0 : _ars$roomState.summaryChanges;
                                _context14.next = 3;
                                return log.wrap("archivedRoom", function (log) {
                                  return ars.archivedRoom.writeSync(summaryChanges, ars.roomResponse, ars.membership, syncTxn, log);
                                });

                              case 3:
                                ars.changes = _context14.sent;

                              case 4:
                              case "end":
                                return _context14.stop();
                            }
                          }
                        }, _callee13);
                      }));

                      return function (_x27) {
                        return _ref10.apply(this, arguments);
                      };
                    }()));

                  case 13:
                    _context15.next = 19;
                    break;

                  case 15:
                    _context15.prev = 15;
                    _context15.t0 = _context15["catch"](3);
                    // avoid corrupting state by only
                    // storing the sync up till the point
                    // the exception occurred
                    syncTxn.abort(log);
                    throw syncTxn.getCause(_context15.t0);

                  case 19:
                    _context15.next = 21;
                    return syncTxn.complete(log);

                  case 21:
                  case "end":
                    return _context15.stop();
                }
              }
            }, _callee14, this, [[3, 15]]);
          }));

          function _writeSync(_x17, _x18, _x19, _x20, _x21, _x22, _x23, _x24) {
            return _writeSync2.apply(this, arguments);
          }

          return _writeSync;
        }()
      }, {
        key: "_afterSync",
        value: function _afterSync(sessionState, inviteStates, roomStates, archivedRoomStates, log) {
          var _this6 = this;

          log.wrap("session", function (log) {
            return _this6._session.afterSync(sessionState.changes, log);
          }, log.level.Detail);

          var _iterator2 = _createForOfIteratorHelper(archivedRoomStates),
              _step2;

          try {
            var _loop2 = function _loop2() {
              var ars = _step2.value;
              log.wrap("archivedRoom", function (log) {
                ars.archivedRoom.afterSync(ars.changes, log);
                ars.archivedRoom.release();
              }, log.level.Detail);
            };

            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              _loop2();
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          var _iterator3 = _createForOfIteratorHelper(roomStates),
              _step3;

          try {
            var _loop3 = function _loop3() {
              var rs = _step3.value;
              log.wrap("room", function (log) {
                return rs.room.afterSync(rs.changes, log);
              }, log.level.Detail);
            };

            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              _loop3();
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          var _iterator4 = _createForOfIteratorHelper(inviteStates),
              _step4;

          try {
            var _loop4 = function _loop4() {
              var is = _step4.value;
              log.wrap("invite", function (log) {
                return is.invite.afterSync(is.changes, log);
              }, log.level.Detail);
            };

            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              _loop4();
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          this._session.applyRoomCollectionChangesAfterSync(inviteStates, roomStates, archivedRoomStates);
        }
      }, {
        key: "_openSyncTxn",
        value: function _openSyncTxn() {
          var storeNames = this._storage.storeNames;
          return this._storage.readWriteTxn([storeNames.session, storeNames.roomSummary, storeNames.archivedRoomSummary, storeNames.invites, storeNames.roomState, storeNames.roomMembers, storeNames.timelineEvents, storeNames.timelineRelations, storeNames.timelineFragments, storeNames.pendingEvents, storeNames.userIdentities, storeNames.groupSessionDecryptions, storeNames.deviceIdentities, // to discard outbound session when somebody leaves a room
          // and to create room key messages when somebody joins
          storeNames.outboundGroupSessions, storeNames.operations, storeNames.accountData, // to decrypt and store new room keys
          storeNames.olmSessions, storeNames.inboundGroupSessions]);
        }
      }, {
        key: "_parseRoomsResponse",
        value: function () {
          var _parseRoomsResponse2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(roomsSection, inviteStates, isInitialSync, log) {
            var roomStates, archivedRoomStates, allMemberships, _i, _allMemberships, membership, membershipSection, _i2, _Object$entries, _Object$entries$_i, roomId, roomResponse, invite, roomState, ars;

            return regeneratorRuntime.wrap(function _callee15$(_context16) {
              while (1) {
                switch (_context16.prev = _context16.next) {
                  case 0:
                    roomStates = [];
                    archivedRoomStates = [];

                    if (!roomsSection) {
                      _context16.next = 28;
                      break;
                    }

                    allMemberships = ["join", "leave"];
                    _i = 0, _allMemberships = allMemberships;

                  case 5:
                    if (!(_i < _allMemberships.length)) {
                      _context16.next = 28;
                      break;
                    }

                    membership = _allMemberships[_i];
                    membershipSection = roomsSection[membership];

                    if (!membershipSection) {
                      _context16.next = 25;
                      break;
                    }

                    _i2 = 0, _Object$entries = Object.entries(membershipSection);

                  case 10:
                    if (!(_i2 < _Object$entries.length)) {
                      _context16.next = 25;
                      break;
                    }

                    _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2), roomId = _Object$entries$_i[0], roomResponse = _Object$entries$_i[1];

                    if (!(isInitialSync && timelineIsEmpty(roomResponse))) {
                      _context16.next = 14;
                      break;
                    }

                    return _context16.abrupt("continue", 22);

                  case 14:
                    invite = this._session.invites.get(roomId); // if there is an existing invite, add a process state for it
                    // so its writeSync and afterSync will run and remove the invite

                    if (invite) {
                      inviteStates.push(new InviteSyncProcessState(invite, false, null, membership));
                    }

                    roomState = this._createRoomSyncState(roomId, invite, roomResponse, membership, isInitialSync);

                    if (roomState) {
                      roomStates.push(roomState);
                    }

                    _context16.next = 20;
                    return this._createArchivedRoomSyncState(roomId, roomState, roomResponse, membership, isInitialSync, log);

                  case 20:
                    ars = _context16.sent;

                    if (ars) {
                      archivedRoomStates.push(ars);
                    }

                  case 22:
                    _i2++;
                    _context16.next = 10;
                    break;

                  case 25:
                    _i++;
                    _context16.next = 5;
                    break;

                  case 28:
                    return _context16.abrupt("return", {
                      roomStates: roomStates,
                      archivedRoomStates: archivedRoomStates
                    });

                  case 29:
                  case "end":
                    return _context16.stop();
                }
              }
            }, _callee15, this);
          }));

          function _parseRoomsResponse(_x28, _x29, _x30, _x31) {
            return _parseRoomsResponse2.apply(this, arguments);
          }

          return _parseRoomsResponse;
        }()
      }, {
        key: "_createRoomSyncState",
        value: function _createRoomSyncState(roomId, invite, roomResponse, membership, isInitialSync) {
          var isNewRoom = false;

          var room = this._session.rooms.get(roomId); // create room only either on new join,
          // or for an archived room during initial sync,
          // where we create the summaryChanges with a joined
          // room to then adopt by the archived room.
          // This way the limited timeline, members, ...
          // we receive also gets written.
          // In any case, don't create a room for a rejected invite


          if (!room && (membership === "join" || isInitialSync && membership === "leave")) {
            room = this._session.createRoom(roomId);
            isNewRoom = true;
          }

          if (room) {
            return new RoomSyncProcessState(room, isNewRoom, invite, roomResponse, membership);
          }
        }
      }, {
        key: "_createArchivedRoomSyncState",
        value: function () {
          var _createArchivedRoomSyncState2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(roomId, roomState, roomResponse, membership, isInitialSync, log) {
            var archivedRoom;
            return regeneratorRuntime.wrap(function _callee16$(_context17) {
              while (1) {
                switch (_context17.prev = _context17.next) {
                  case 0:
                    if (!((roomState === null || roomState === void 0 ? void 0 : roomState.shouldAdd) && !isInitialSync)) {
                      _context17.next = 4;
                      break;
                    }

                    // when adding a joined room during incremental sync,
                    // always create the archived room to write the removal
                    // of the archived summary
                    archivedRoom = this._session.createOrGetArchivedRoomForSync(roomId);
                    _context17.next = 12;
                    break;

                  case 4:
                    if (!(membership === "leave")) {
                      _context17.next = 12;
                      break;
                    }

                    if (!roomState) {
                      _context17.next = 9;
                      break;
                    }

                    // we still have a roomState, so we just left it
                    // in this case, create a new archivedRoom
                    archivedRoom = this._session.createOrGetArchivedRoomForSync(roomId);
                    _context17.next = 12;
                    break;

                  case 9:
                    _context17.next = 11;
                    return this._session.loadArchivedRoom(roomId, log);

                  case 11:
                    archivedRoom = _context17.sent;

                  case 12:
                    if (!archivedRoom) {
                      _context17.next = 14;
                      break;
                    }

                    return _context17.abrupt("return", new ArchivedRoomSyncProcessState(archivedRoom, roomState, roomResponse, membership));

                  case 14:
                  case "end":
                    return _context17.stop();
                }
              }
            }, _callee16, this);
          }));

          function _createArchivedRoomSyncState(_x32, _x33, _x34, _x35, _x36, _x37) {
            return _createArchivedRoomSyncState2.apply(this, arguments);
          }

          return _createArchivedRoomSyncState;
        }()
      }, {
        key: "_parseInvites",
        value: function _parseInvites(roomsSection) {
          var inviteStates = [];

          if (roomsSection === null || roomsSection === void 0 ? void 0 : roomsSection.invite) {
            for (var _i3 = 0, _Object$entries2 = Object.entries(roomsSection.invite); _i3 < _Object$entries2.length; _i3++) {
              var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 2),
                  roomId = _Object$entries2$_i[0],
                  roomResponse = _Object$entries2$_i[1];

              var invite = this._session.invites.get(roomId);

              var isNewInvite = false;

              if (!invite) {
                invite = this._session.createInvite(roomId);
                isNewInvite = true;
              }

              inviteStates.push(new InviteSyncProcessState(invite, isNewInvite, roomResponse, "invite"));
            }
          }

          return inviteStates;
        }
      }, {
        key: "stop",
        value: function stop() {
          if (this._status.get() === SyncStatus.Stopped) {
            return;
          }

          this._status.set(SyncStatus.Stopped);

          if (this._currentRequest) {
            this._currentRequest.abort();

            this._currentRequest = null;
          }
        }
      }, {
        key: "status",
        get: function get() {
          return this._status;
        }
        /** the error that made the sync stop */

      }, {
        key: "error",
        get: function get() {
          return this._error;
        }
      }]);

      return Sync;
    }();

    var SessionSyncProcessState = /*#__PURE__*/function () {
      function SessionSyncProcessState() {
        _classCallCheck(this, SessionSyncProcessState);

        this.lock = null;
        this.preparation = null;
        this.changes = null;
      }

      _createClass(SessionSyncProcessState, [{
        key: "dispose",
        value: function dispose() {
          var _this$lock;

          (_this$lock = this.lock) === null || _this$lock === void 0 ? void 0 : _this$lock.release();
        }
      }]);

      return SessionSyncProcessState;
    }();

    var RoomSyncProcessState = /*#__PURE__*/function () {
      function RoomSyncProcessState(room, isNewRoom, invite, roomResponse, membership) {
        _classCallCheck(this, RoomSyncProcessState);

        this.room = room;
        this.isNewRoom = isNewRoom;
        this.invite = invite;
        this.roomResponse = roomResponse;
        this.membership = membership;
        this.preparation = null;
        this.changes = null;
      }

      _createClass(RoomSyncProcessState, [{
        key: "id",
        get: function get() {
          return this.room.id;
        }
      }, {
        key: "shouldAdd",
        get: function get() {
          return this.isNewRoom && this.membership === "join";
        }
      }, {
        key: "shouldRemove",
        get: function get() {
          return !this.isNewRoom && this.membership !== "join";
        }
      }, {
        key: "summaryChanges",
        get: function get() {
          var _this$changes;

          return (_this$changes = this.changes) === null || _this$changes === void 0 ? void 0 : _this$changes.summaryChanges;
        }
      }]);

      return RoomSyncProcessState;
    }();

    var ArchivedRoomSyncProcessState = /*#__PURE__*/function () {
      function ArchivedRoomSyncProcessState(archivedRoom, roomState, roomResponse, membership, isInitialSync) {
        _classCallCheck(this, ArchivedRoomSyncProcessState);

        this.archivedRoom = archivedRoom;
        this.roomState = roomState;
        this.roomResponse = roomResponse;
        this.membership = membership;
        this.isInitialSync = isInitialSync;
        this.changes = null;
      }

      _createClass(ArchivedRoomSyncProcessState, [{
        key: "id",
        get: function get() {
          return this.archivedRoom.id;
        }
      }, {
        key: "shouldAdd",
        get: function get() {
          return (this.roomState || this.isInitialSync) && this.membership === "leave";
        }
      }, {
        key: "shouldRemove",
        get: function get() {
          return this.membership === "join";
        }
      }]);

      return ArchivedRoomSyncProcessState;
    }();

    var InviteSyncProcessState = /*#__PURE__*/function () {
      function InviteSyncProcessState(invite, isNewInvite, roomResponse, membership) {
        _classCallCheck(this, InviteSyncProcessState);

        this.invite = invite;
        this.isNewInvite = isNewInvite;
        this.membership = membership;
        this.roomResponse = roomResponse;
        this.changes = null;
      }

      _createClass(InviteSyncProcessState, [{
        key: "id",
        get: function get() {
          return this.invite.id;
        }
      }, {
        key: "shouldAdd",
        get: function get() {
          return this.isNewInvite;
        }
      }, {
        key: "shouldRemove",
        get: function get() {
          return this.membership !== "invite";
        }
      }]);

      return InviteSyncProcessState;
    }();

    var EventEmitter = /*#__PURE__*/function () {
      function EventEmitter() {
        _classCallCheck(this, EventEmitter);

        this._handlersByName = {};
      }

      _createClass(EventEmitter, [{
        key: "emit",
        value: function emit(name, value) {
          var handlers = this._handlersByName[name];

          if (handlers) {
            handlers.forEach(function (h) {
              return h(value);
            });
          }
        }
      }, {
        key: "disposableOn",
        value: function disposableOn(name, callback) {
          var _this = this;

          this.on(name, callback);
          return function () {
            _this.off(name, callback);
          };
        }
      }, {
        key: "on",
        value: function on(name, callback) {
          var handlers = this._handlersByName[name];

          if (!handlers) {
            this.onFirstSubscriptionAdded(name);
            this._handlersByName[name] = handlers = new Set();
          }

          handlers.add(callback);
        }
      }, {
        key: "off",
        value: function off(name, callback) {
          var handlers = this._handlersByName[name];

          if (handlers) {
            handlers.delete(callback);

            if (handlers.size === 0) {
              delete this._handlersByName[name];
              this.onLastSubscriptionRemoved(name);
            }
          }
        }
      }, {
        key: "onFirstSubscriptionAdded",
        value: function onFirstSubscriptionAdded(name) {}
      }, {
        key: "onLastSubscriptionRemoved",
        value: function onLastSubscriptionRemoved(name) {}
      }]);

      return EventEmitter;
    }();

    function _applyTimelineEntries(data, timelineEntries, isInitialSync, canMarkUnread, ownUserId) {
      if (timelineEntries.length) {
        data = timelineEntries.reduce(function (data, entry) {
          return processTimelineEvent(data, entry, isInitialSync, canMarkUnread, ownUserId);
        }, data);
      }

      return data;
    }

    function reduceStateEvents(roomResponse, callback, value) {
      var _roomResponse$state, _roomResponse$timelin;

      var stateEvents = roomResponse === null || roomResponse === void 0 ? void 0 : (_roomResponse$state = roomResponse.state) === null || _roomResponse$state === void 0 ? void 0 : _roomResponse$state.events; // state comes before timeline

      if (Array.isArray(stateEvents)) {
        value = stateEvents.reduce(callback, value);
      }

      var timelineEvents = roomResponse === null || roomResponse === void 0 ? void 0 : (_roomResponse$timelin = roomResponse.timeline) === null || _roomResponse$timelin === void 0 ? void 0 : _roomResponse$timelin.events; // and after that state events in the timeline

      if (Array.isArray(timelineEvents)) {
        value = timelineEvents.reduce(function (data, event) {
          if (typeof event.state_key === "string") {
            value = callback(value, event);
          }

          return value;
        }, value);
      }

      return value;
    }

    function _applySyncResponse(data, roomResponse, membership) {
      if (roomResponse.summary) {
        data = updateSummary(data, roomResponse.summary);
      }

      if (membership !== data.membership) {
        data = data.cloneIfNeeded();
        data.membership = membership;
      }

      if (roomResponse.account_data) {
        data = roomResponse.account_data.events.reduce(processRoomAccountData, data);
      } // process state events in state and in timeline.
      // non-state events are handled by applyTimelineEntries
      // so decryption is handled properly


      data = reduceStateEvents(roomResponse, processStateEvent, data);
      var unreadNotifications = roomResponse.unread_notifications;

      if (unreadNotifications) {
        data = processNotificationCounts(data, unreadNotifications);
      }

      return data;
    }

    function processNotificationCounts(data, unreadNotifications) {
      var highlightCount = unreadNotifications.highlight_count || 0;

      if (highlightCount !== data.highlightCount) {
        data = data.cloneIfNeeded();
        data.highlightCount = highlightCount;
      }

      var notificationCount = unreadNotifications.notification_count;

      if (notificationCount !== data.notificationCount) {
        data = data.cloneIfNeeded();
        data.notificationCount = notificationCount;
      }

      return data;
    }

    function processRoomAccountData(data, event) {
      if ((event === null || event === void 0 ? void 0 : event.type) === "m.tag") {
        var _event$content;

        var tags = event === null || event === void 0 ? void 0 : (_event$content = event.content) === null || _event$content === void 0 ? void 0 : _event$content.tags;

        if (!tags || Array.isArray(tags) || _typeof(tags) !== "object") {
          tags = null;
        }

        data = data.cloneIfNeeded();
        data.tags = tags;
      }

      return data;
    }

    function processStateEvent(data, event) {
      if (event.type === "m.room.encryption") {
        var _event$content2;

        var algorithm = (_event$content2 = event.content) === null || _event$content2 === void 0 ? void 0 : _event$content2.algorithm;

        if (!data.encryption && algorithm === MEGOLM_ALGORITHM) {
          data = data.cloneIfNeeded();
          data.encryption = event.content;
        }
      } else if (event.type === "m.room.name") {
        var _event$content3;

        var newName = (_event$content3 = event.content) === null || _event$content3 === void 0 ? void 0 : _event$content3.name;

        if (newName !== data.name) {
          data = data.cloneIfNeeded();
          data.name = newName;
        }
      } else if (event.type === "m.room.avatar") {
        var _event$content4;

        var newUrl = (_event$content4 = event.content) === null || _event$content4 === void 0 ? void 0 : _event$content4.url;

        if (newUrl !== data.avatarUrl) {
          data = data.cloneIfNeeded();
          data.avatarUrl = newUrl;
        }
      } else if (event.type === "m.room.canonical_alias") {
        var content = event.content;
        data = data.cloneIfNeeded();
        data.canonicalAlias = content.alias;
      }

      return data;
    }

    function processTimelineEvent(data, eventEntry, isInitialSync, canMarkUnread, ownUserId) {
      if (eventEntry.eventType === "m.room.message") {
        if (!data.lastMessageTimestamp || eventEntry.timestamp > data.lastMessageTimestamp) {
          data = data.cloneIfNeeded();
          data.lastMessageTimestamp = eventEntry.timestamp;
        }

        if (!isInitialSync && eventEntry.sender !== ownUserId && canMarkUnread) {
          data = data.cloneIfNeeded();
          data.isUnread = true;
        }
      }

      return data;
    }

    function updateSummary(data, summary) {
      var heroes = summary["m.heroes"];
      var joinCount = summary["m.joined_member_count"];
      var inviteCount = summary["m.invited_member_count"]; // TODO: we could easily calculate if all members are available here and set hasFetchedMembers?
      // so we can avoid calling /members...
      // we'd need to do a count query in the roomMembers store though ...

      if (heroes && Array.isArray(heroes)) {
        data = data.cloneIfNeeded();
        data.heroes = heroes;
      }

      if (Number.isInteger(inviteCount)) {
        data = data.cloneIfNeeded();
        data.inviteCount = inviteCount;
      }

      if (Number.isInteger(joinCount)) {
        data = data.cloneIfNeeded();
        data.joinCount = joinCount;
      }

      return data;
    }

    function _applyInvite(data, invite) {
      if (data.isDirectMessage !== invite.isDirectMessage) {
        data = data.cloneIfNeeded();
        data.isDirectMessage = invite.isDirectMessage;

        if (invite.isDirectMessage) {
          var _invite$inviter;

          data.dmUserId = (_invite$inviter = invite.inviter) === null || _invite$inviter === void 0 ? void 0 : _invite$inviter.userId;
        } else {
          data.dmUserId = null;
        }
      }

      return data;
    }

    var SummaryData = /*#__PURE__*/function () {
      function SummaryData(copy, roomId) {
        _classCallCheck(this, SummaryData);

        this.roomId = copy ? copy.roomId : roomId;
        this.name = copy ? copy.name : null;
        this.lastMessageTimestamp = copy ? copy.lastMessageTimestamp : null;
        this.isUnread = copy ? copy.isUnread : false;
        this.encryption = copy ? copy.encryption : null;
        this.membership = copy ? copy.membership : null;
        this.inviteCount = copy ? copy.inviteCount : 0;
        this.joinCount = copy ? copy.joinCount : 0;
        this.heroes = copy ? copy.heroes : null;
        this.canonicalAlias = copy ? copy.canonicalAlias : null;
        this.hasFetchedMembers = copy ? copy.hasFetchedMembers : false;
        this.isTrackingMembers = copy ? copy.isTrackingMembers : false;
        this.avatarUrl = copy ? copy.avatarUrl : null;
        this.notificationCount = copy ? copy.notificationCount : 0;
        this.highlightCount = copy ? copy.highlightCount : 0;
        this.tags = copy ? copy.tags : null;
        this.isDirectMessage = copy ? copy.isDirectMessage : false;
        this.dmUserId = copy ? copy.dmUserId : null;
        this.cloned = copy ? true : false;
      }

      _createClass(SummaryData, [{
        key: "diff",
        value: function diff(other) {
          var _this = this;

          var props = Object.getOwnPropertyNames(this);
          return props.reduce(function (diff, prop) {
            if (prop !== "cloned") {
              if (_this[prop] !== other[prop]) {
                diff[prop] = _this[prop];
              }
            }

            return diff;
          }, {});
        }
      }, {
        key: "cloneIfNeeded",
        value: function cloneIfNeeded() {
          if (this.cloned) {
            return this;
          } else {
            return new SummaryData(this);
          }
        }
      }, {
        key: "serialize",
        value: function serialize() {
          return Object.entries(this).reduce(function (obj, _ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                key = _ref2[0],
                value = _ref2[1];

            if (key !== "cloned" && value !== null) {
              obj[key] = value;
            }

            return obj;
          }, {});
        }
      }, {
        key: "applyTimelineEntries",
        value: function applyTimelineEntries(timelineEntries, isInitialSync, canMarkUnread, ownUserId) {
          return _applyTimelineEntries(this, timelineEntries, isInitialSync, canMarkUnread, ownUserId);
        }
      }, {
        key: "applySyncResponse",
        value: function applySyncResponse(roomResponse, membership) {
          return _applySyncResponse(this, roomResponse, membership);
        }
      }, {
        key: "applyInvite",
        value: function applyInvite(invite) {
          return _applyInvite(this, invite);
        }
      }, {
        key: "isNewJoin",
        value: function isNewJoin(oldData) {
          return this.membership === "join" && oldData.membership !== "join";
        }
      }, {
        key: "needsHeroes",
        get: function get() {
          return !this.name && !this.canonicalAlias && this.heroes && this.heroes.length > 0;
        }
      }]);

      return SummaryData;
    }();
    var RoomSummary = /*#__PURE__*/function () {
      function RoomSummary(roomId) {
        _classCallCheck(this, RoomSummary);

        this._data = null;
        this.applyChanges(new SummaryData(null, roomId));
      }

      _createClass(RoomSummary, [{
        key: "writeClearUnread",
        value: function writeClearUnread(txn) {
          var data = new SummaryData(this._data);
          data.isUnread = false;
          data.notificationCount = 0;
          data.highlightCount = 0;
          txn.roomSummary.set(data.serialize());
          return data;
        }
      }, {
        key: "writeHasFetchedMembers",
        value: function writeHasFetchedMembers(value, txn) {
          var data = new SummaryData(this._data);
          data.hasFetchedMembers = value;
          txn.roomSummary.set(data.serialize());
          return data;
        }
      }, {
        key: "writeIsTrackingMembers",
        value: function writeIsTrackingMembers(value, txn) {
          var data = new SummaryData(this._data);
          data.isTrackingMembers = value;
          txn.roomSummary.set(data.serialize());
          return data;
        }
      }, {
        key: "writeData",
        value: function writeData(data, txn) {
          if (data !== this._data) {
            txn.roomSummary.set(data.serialize());
            return data;
          }
        }
        /** move summary to archived store when leaving the room */

      }, {
        key: "writeArchivedData",
        value: function writeArchivedData(data, txn) {
          if (data !== this._data) {
            txn.archivedRoomSummary.set(data.serialize());
            return data;
          }
        }
      }, {
        key: "writeAndApplyData",
        value: function () {
          var _writeAndApplyData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(data, storage) {
            var txn;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!(data === this._data)) {
                      _context.next = 2;
                      break;
                    }

                    return _context.abrupt("return", false);

                  case 2:
                    _context.next = 4;
                    return storage.readWriteTxn([storage.storeNames.roomSummary]);

                  case 4:
                    txn = _context.sent;
                    _context.prev = 5;
                    txn.roomSummary.set(data.serialize());
                    _context.next = 13;
                    break;

                  case 9:
                    _context.prev = 9;
                    _context.t0 = _context["catch"](5);
                    txn.abort();
                    throw _context.t0;

                  case 13:
                    _context.next = 15;
                    return txn.complete();

                  case 15:
                    this.applyChanges(data);
                    return _context.abrupt("return", true);

                  case 17:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[5, 9]]);
          }));

          function writeAndApplyData(_x, _x2) {
            return _writeAndApplyData.apply(this, arguments);
          }

          return writeAndApplyData;
        }()
      }, {
        key: "applyChanges",
        value: function applyChanges(data) {
          this._data = data; // clear cloned flag, so cloneIfNeeded makes a copy and
          // this._data is not modified if any field is changed.

          this._data.cloned = false;
        }
      }, {
        key: "load",
        value: function () {
          var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(summary) {
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    this.applyChanges(new SummaryData(summary));

                  case 1:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function load(_x3) {
            return _load.apply(this, arguments);
          }

          return load;
        }()
      }, {
        key: "data",
        get: function get() {
          return this._data;
        }
      }]);

      return RoomSummary;
    }();

    var PENDING_FRAGMENT_ID = Number.MAX_SAFE_INTEGER;
    var BaseEntry = /*#__PURE__*/function () {
      function BaseEntry(_fragmentIdComparer) {
        _classCallCheck(this, BaseEntry);

        this._fragmentIdComparer = _fragmentIdComparer;
      }

      _createClass(BaseEntry, [{
        key: "compare",
        value: function compare(otherEntry) {
          if (this.fragmentId === otherEntry.fragmentId) {
            return this.entryIndex - otherEntry.entryIndex;
          } else if (this.fragmentId === PENDING_FRAGMENT_ID) {
            return 1;
          } else if (otherEntry.fragmentId === PENDING_FRAGMENT_ID) {
            return -1;
          } else {
            return this._fragmentIdComparer.compare(this.fragmentId, otherEntry.fragmentId);
          }
        }
      }, {
        key: "asEventKey",
        value: function asEventKey() {
          return new EventKey(this.fragmentId, this.entryIndex);
        }
      }]);

      return BaseEntry;
    }();

    /*
    Copyright 2021 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var REACTION_TYPE = "m.reaction";
    var ANNOTATION_RELATION_TYPE = "m.annotation";
    function createAnnotation(targetId, key) {
      return {
        "m.relates_to": {
          "event_id": targetId,
          key: key,
          "rel_type": ANNOTATION_RELATION_TYPE
        }
      };
    }
    function getRelationTarget(relation) {
      var _relation$mIn_reply_;

      return relation.event_id || ((_relation$mIn_reply_ = relation["m.in_reply_to"]) === null || _relation$mIn_reply_ === void 0 ? void 0 : _relation$mIn_reply_.event_id);
    }
    function setRelationTarget(relation, target) {
      if (relation.event_id !== undefined) {
        relation.event_id = target;
      } else if (relation["m.in_reply_to"]) {
        relation["m.in_reply_to"].event_id = target;
      }
    }
    function getRelatedEventId(event) {
      if (event.type === REDACTION_TYPE) {
        return event.redacts;
      } else {
        var relation = getRelation(event);

        if (relation) {
          return getRelationTarget(relation);
        }
      }

      return null;
    }
    function getRelationFromContent(content) {
      return content === null || content === void 0 ? void 0 : content["m.relates_to"];
    }
    function getRelation(event) {
      return getRelationFromContent(event.content);
    }

    /*
    Copyright 2021 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var PendingAnnotation = /*#__PURE__*/function () {
      function PendingAnnotation() {
        _classCallCheck(this, PendingAnnotation);

        // TODO: use simple member for reaction and redaction as we can't/shouldn't really have more than 2 entries
        // this contains both pending annotation entries, and pending redactions of remote annotation entries 
        this._entries = [];
      }

      _createClass(PendingAnnotation, [{
        key: "add",
        value: function add(entry) {
          this._entries.push(entry);
        }
      }, {
        key: "remove",
        value: function remove(entry) {
          var idx = this._entries.indexOf(entry);

          if (idx === -1) {
            return false;
          }

          this._entries.splice(idx, 1);

          return true;
        }
      }, {
        key: "firstTimestamp",
        get: function get() {
          return this._entries.reduce(function (ts, e) {
            if (e.isRedaction) {
              return ts;
            }

            return Math.min(e.timestamp, ts);
          }, Number.MAX_SAFE_INTEGER);
        }
      }, {
        key: "annotationEntry",
        get: function get() {
          return this._entries.find(function (e) {
            return !e.isRedaction;
          });
        }
      }, {
        key: "redactionEntry",
        get: function get() {
          return this._entries.find(function (e) {
            return e.isRedaction;
          });
        }
      }, {
        key: "count",
        get: function get() {
          return this._entries.reduce(function (count, e) {
            return count + (e.isRedaction ? -1 : 1);
          }, 0);
        }
      }, {
        key: "willAnnotate",
        get: function get() {
          var lastEntry = this._entries.reduce(function (lastEntry, e) {
            if (!lastEntry || e.pendingEvent.queueIndex > lastEntry.pendingEvent.queueIndex) {
              return e;
            }

            return lastEntry;
          }, null);

          if (lastEntry) {
            return !lastEntry.isRedaction;
          }

          return false;
        }
      }, {
        key: "isEmpty",
        get: function get() {
          return this._entries.length === 0;
        }
      }]);

      return PendingAnnotation;
    }();

    /*
    Copyright 2021 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function htmlEscape(string) {
      return string.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    function fallbackForNonTextualMessage(msgtype) {
      switch (msgtype) {
        case "m.file":
          return "sent a file.";

        case "m.image":
          return "sent an image.";

        case "m.video":
          return "sent a video.";

        case "m.audio":
          return "sent an audio file.";
      }

      return null;
    }

    function fallbackPrefix(msgtype) {
      return msgtype === "m.emote" ? "* " : "";
    }

    function _createReplyContent(targetId, msgtype, body, formattedBody) {
      return {
        msgtype: msgtype,
        body: body,
        "format": "org.matrix.custom.html",
        "formatted_body": formattedBody,
        "m.relates_to": {
          "m.in_reply_to": {
            "event_id": targetId
          }
        }
      };
    }

    function createReplyContent(entry, msgtype, body) {
      // TODO check for absense of sender / body / msgtype / etc?
      var nonTextual = fallbackForNonTextualMessage(entry.content.msgtype);
      var prefix = fallbackPrefix(entry.content.msgtype);
      var sender = entry.sender;
      var name = entry.displayName || sender;
      var formattedBody = nonTextual || entry.content.formatted_body || entry.content.body && htmlEscape(entry.content.body) || "";
      var formattedFallback = "<mx-reply><blockquote>In reply to ".concat(prefix) + "<a href=\"https://matrix.to/#/".concat(sender, "\">").concat(name, "</a><br />") + "".concat(formattedBody, "</blockquote></mx-reply>");
      var plainBody = nonTextual || entry.content.body || "";
      var bodyLines = plainBody.split("\n");
      bodyLines[0] = "> ".concat(prefix, "<").concat(sender, "> ").concat(bodyLines[0]);
      var plainFallback = bodyLines.join("\n> ");
      var newBody = plainFallback + '\n\n' + body;
      var newFormattedBody = formattedFallback + htmlEscape(body);
      return _createReplyContent(entry.id, msgtype, newBody, newFormattedBody);
    }

    /** Deals mainly with local echo for relations and redactions,
     * so it is shared between PendingEventEntry and EventEntry */

    var BaseEventEntry = /*#__PURE__*/function (_BaseEntry) {
      _inherits(BaseEventEntry, _BaseEntry);

      var _super = _createSuper(BaseEventEntry);

      function BaseEventEntry(fragmentIdComparer) {
        var _this;

        _classCallCheck(this, BaseEventEntry);

        _this = _super.call(this, fragmentIdComparer);
        _this._pendingRedactions = null;
        _this._pendingAnnotations = null;
        return _this;
      }

      _createClass(BaseEventEntry, [{
        key: "addLocalRelation",

        /**
            aggregates local relation or local redaction of remote relation.
            @return [string] returns the name of the field that has changed, if any
        */
        value: function addLocalRelation(entry) {
          if (entry.eventType === REDACTION_TYPE && entry.isRelatedToId(this.id)) {
            if (!this._pendingRedactions) {
              this._pendingRedactions = [];
            }

            this._pendingRedactions.push(entry);

            if (this._pendingRedactions.length === 1) {
              return "isRedacted";
            }
          } else {
            var relationEntry = entry.redactingEntry || entry;

            if (relationEntry.isRelatedToId(this.id)) {
              if (relationEntry.relation.rel_type === ANNOTATION_RELATION_TYPE) {
                if (this._addPendingAnnotation(entry)) {
                  return "pendingAnnotations";
                }
              }
            }
          }
        }
        /**
            deaggregates local relation or a local redaction of a remote relation.
            @return [string] returns the name of the field that has changed, if any
        */

      }, {
        key: "removeLocalRelation",
        value: function removeLocalRelation(entry) {
          if (entry.eventType === REDACTION_TYPE && entry.isRelatedToId(this.id) && this._pendingRedactions) {
            var countBefore = this._pendingRedactions.length;
            this._pendingRedactions = this._pendingRedactions.filter(function (e) {
              return e !== entry;
            });

            if (this._pendingRedactions.length === 0) {
              this._pendingRedactions = null;

              if (countBefore !== 0) {
                return "isRedacted";
              }
            }
          } else {
            var relationEntry = entry.redactingEntry || entry;

            if (relationEntry.isRelatedToId(this.id)) {
              var _relationEntry$relati;

              if (((_relationEntry$relati = relationEntry.relation) === null || _relationEntry$relati === void 0 ? void 0 : _relationEntry$relati.rel_type) === ANNOTATION_RELATION_TYPE && this._pendingAnnotations) {
                if (this._removePendingAnnotation(entry)) {
                  return "pendingAnnotations";
                }
              }
            }
          }
        }
      }, {
        key: "_addPendingAnnotation",
        value: function _addPendingAnnotation(entry) {
          if (!this._pendingAnnotations) {
            this._pendingAnnotations = new Map();
          }

          var key = (entry.redactingEntry || entry).relation.key;

          if (key) {
            var annotation = this._pendingAnnotations.get(key);

            if (!annotation) {
              annotation = new PendingAnnotation();

              this._pendingAnnotations.set(key, annotation);
            }

            annotation.add(entry);
            return true;
          }

          return false;
        }
      }, {
        key: "_removePendingAnnotation",
        value: function _removePendingAnnotation(entry) {
          var key = (entry.redactingEntry || entry).relation.key;

          if (key) {
            var annotation = this._pendingAnnotations.get(key);

            if (annotation.remove(entry) && annotation.isEmpty) {
              this._pendingAnnotations.delete(key);
            }

            if (this._pendingAnnotations.size === 0) {
              this._pendingAnnotations = null;
            }

            return true;
          }

          return false;
        }
      }, {
        key: "abortPendingRedaction",
        value: function () {
          var _abortPendingRedaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var _iterator, _step, pee;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!this._pendingRedactions) {
                      _context.next = 18;
                      break;
                    }

                    _iterator = _createForOfIteratorHelper(this._pendingRedactions);
                    _context.prev = 2;

                    _iterator.s();

                  case 4:
                    if ((_step = _iterator.n()).done) {
                      _context.next = 10;
                      break;
                    }

                    pee = _step.value;
                    _context.next = 8;
                    return pee.pendingEvent.abort();

                  case 8:
                    _context.next = 4;
                    break;

                  case 10:
                    _context.next = 15;
                    break;

                  case 12:
                    _context.prev = 12;
                    _context.t0 = _context["catch"](2);

                    _iterator.e(_context.t0);

                  case 15:
                    _context.prev = 15;

                    _iterator.f();

                    return _context.finish(15);

                  case 18:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[2, 12, 15, 18]]);
          }));

          function abortPendingRedaction() {
            return _abortPendingRedaction.apply(this, arguments);
          }

          return abortPendingRedaction;
        }()
      }, {
        key: "annotate",
        value: function annotate(key) {
          return createAnnotation(this.id, key);
        }
      }, {
        key: "reply",
        value: function reply(msgtype, body) {
          return createReplyContent(this, msgtype, body);
        }
        /** takes both remote event id and local txn id into account, see overriding in PendingEventEntry */

      }, {
        key: "isRelatedToId",
        value: function isRelatedToId(id) {
          return id && this.relatedEventId === id;
        }
      }, {
        key: "haveAnnotation",
        value: function haveAnnotation(key) {
          var _this$annotations, _this$annotations$key, _this$pendingAnnotati;

          var haveRemoteReaction = ((_this$annotations = this.annotations) === null || _this$annotations === void 0 ? void 0 : (_this$annotations$key = _this$annotations[key]) === null || _this$annotations$key === void 0 ? void 0 : _this$annotations$key.me) || false;
          var pendingAnnotation = (_this$pendingAnnotati = this.pendingAnnotations) === null || _this$pendingAnnotati === void 0 ? void 0 : _this$pendingAnnotati.get(key);
          var willAnnotate = (pendingAnnotation === null || pendingAnnotation === void 0 ? void 0 : pendingAnnotation.willAnnotate) || false;
          /*
          We have an annotation in these case:
          - remote annotation with me, no pending
          - remote annotation with me, pending redaction and then annotation
          - pending annotation without redaction after it
          */

          return haveRemoteReaction && (!pendingAnnotation || willAnnotate) || !haveRemoteReaction && willAnnotate;
        }
      }, {
        key: "isReply",
        get: function get() {
          var _this$relation;

          return !!((_this$relation = this.relation) === null || _this$relation === void 0 ? void 0 : _this$relation["m.in_reply_to"]);
        }
      }, {
        key: "isRedacting",
        get: function get() {
          return !!this._pendingRedactions;
        }
      }, {
        key: "isRedacted",
        get: function get() {
          return this.isRedacting;
        }
      }, {
        key: "isRedaction",
        get: function get() {
          return this.eventType === REDACTION_TYPE;
        }
      }, {
        key: "redactionReason",
        get: function get() {
          if (this._pendingRedactions) {
            var _this$_pendingRedacti;

            return (_this$_pendingRedacti = this._pendingRedactions[0].content) === null || _this$_pendingRedacti === void 0 ? void 0 : _this$_pendingRedacti.reason;
          }

          return null;
        }
      }, {
        key: "pendingRedaction",
        get: function get() {
          if (this._pendingRedactions) {
            return this._pendingRedactions[0];
          }

          return null;
        }
      }, {
        key: "relation",
        get: function get() {
          return getRelationFromContent(this.content);
        }
      }, {
        key: "pendingAnnotations",
        get: function get() {
          return this._pendingAnnotations;
        }
      }, {
        key: "annotations",
        get: function get() {
          return null; //overwritten in EventEntry
        }
      }]);

      return BaseEventEntry;
    }(BaseEntry);

    var PendingEventEntry = /*#__PURE__*/function (_BaseEventEntry) {
      _inherits(PendingEventEntry, _BaseEventEntry);

      var _super = _createSuper(PendingEventEntry);

      function PendingEventEntry(_ref) {
        var _this;

        var pendingEvent = _ref.pendingEvent,
            member = _ref.member,
            clock = _ref.clock,
            redactingEntry = _ref.redactingEntry;

        _classCallCheck(this, PendingEventEntry);

        _this = _super.call(this, null);
        _this._pendingEvent = pendingEvent;
        /** @type {RoomMember} */

        _this._member = member; // try to come up with a timestamp that is around construction time and
        // will be roughly sorted by queueIndex, so it can be used to as a secondary
        // sorting dimension for reactions

        _this._timestamp = clock.now() - (100 - pendingEvent.queueIndex);
        _this._redactingEntry = redactingEntry;
        return _this;
      }

      _createClass(PendingEventEntry, [{
        key: "notifyUpdate",
        value: function notifyUpdate() {}
      }, {
        key: "isRelatedToId",
        value: function isRelatedToId(id) {
          if (id && id === this._pendingEvent.relatedTxnId) {
            return true;
          }

          return _get(_getPrototypeOf(PendingEventEntry.prototype), "isRelatedToId", this).call(this, id);
        }
      }, {
        key: "fragmentId",
        get: function get() {
          return PENDING_FRAGMENT_ID;
        }
      }, {
        key: "entryIndex",
        get: function get() {
          return this._pendingEvent.queueIndex;
        }
      }, {
        key: "content",
        get: function get() {
          return this._pendingEvent.content;
        }
      }, {
        key: "event",
        get: function get() {
          return null;
        }
      }, {
        key: "eventType",
        get: function get() {
          return this._pendingEvent.eventType;
        }
      }, {
        key: "stateKey",
        get: function get() {
          return null;
        }
      }, {
        key: "sender",
        get: function get() {
          var _this$_member;

          return (_this$_member = this._member) === null || _this$_member === void 0 ? void 0 : _this$_member.userId;
        }
      }, {
        key: "displayName",
        get: function get() {
          var _this$_member2;

          return (_this$_member2 = this._member) === null || _this$_member2 === void 0 ? void 0 : _this$_member2.name;
        }
      }, {
        key: "avatarUrl",
        get: function get() {
          var _this$_member3;

          return (_this$_member3 = this._member) === null || _this$_member3 === void 0 ? void 0 : _this$_member3.avatarUrl;
        }
      }, {
        key: "timestamp",
        get: function get() {
          return this._timestamp;
        }
      }, {
        key: "isPending",
        get: function get() {
          return true;
        }
      }, {
        key: "id",
        get: function get() {
          return this._pendingEvent.txnId;
        }
      }, {
        key: "pendingEvent",
        get: function get() {
          return this._pendingEvent;
        }
      }, {
        key: "relatedEventId",
        get: function get() {
          return this._pendingEvent.relatedEventId;
        }
      }, {
        key: "redactingEntry",
        get: function get() {
          return this._redactingEntry;
        }
      }]);

      return PendingEventEntry;
    }(BaseEventEntry);

    var SendStatus = createEnum("Waiting", "EncryptingAttachments", "UploadingAttachments", "Encrypting", "Sending", "Sent", "Error");
    var unencryptedContentFields = ["m.relates_to"];
    var PendingEvent = /*#__PURE__*/function () {
      function PendingEvent(_ref) {
        var data = _ref.data,
            remove = _ref.remove,
            emitUpdate = _ref.emitUpdate,
            attachments = _ref.attachments;

        _classCallCheck(this, PendingEvent);

        this._data = data;
        this._attachments = attachments;
        this._emitUpdate = emitUpdate;
        this._removeFromQueueCallback = remove;
        this._aborted = false;
        this._status = SendStatus.Waiting;
        this._sendRequest = null;
        this._attachmentsTotalBytes = 0;

        if (this._attachments) {
          this._attachmentsTotalBytes = Object.values(this._attachments).reduce(function (t, a) {
            return t + a.size;
          }, 0);
        }
      }

      _createClass(PendingEvent, [{
        key: "setRelatedEventId",
        value: function setRelatedEventId(eventId) {
          var relation = getRelationFromContent(this.content);

          if (relation) {
            setRelationTarget(relation, eventId);
          } else {
            this._data.relatedEventId = eventId;
          }
        }
      }, {
        key: "getAttachment",
        value: function getAttachment(key) {
          return this._attachments && this._attachments[key];
        }
      }, {
        key: "setEncrypting",
        value: function setEncrypting() {
          this._status = SendStatus.Encrypting;

          this._emitUpdate("status");
        }
      }, {
        key: "_preserveContentFields",
        value: function _preserveContentFields(into) {
          var content = this._data.content;

          var _iterator = _createForOfIteratorHelper(unencryptedContentFields),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var field = _step.value;

              if (content[field] !== undefined) {
                into[field] = content[field];
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }, {
        key: "setEncrypted",
        value: function setEncrypted(type, content) {
          this._preserveContentFields(content);

          this._data.encryptedEventType = type;
          this._data.encryptedContent = content;
          this._data.needsEncryption = false;
        }
      }, {
        key: "setError",
        value: function setError(error) {
          this._status = SendStatus.Error;
          this._error = error;

          this._emitUpdate("status");
        }
      }, {
        key: "setWaiting",
        value: function setWaiting() {
          this._status = SendStatus.Waiting;

          this._emitUpdate("status");
        }
      }, {
        key: "uploadAttachments",
        value: function () {
          var _uploadAttachments = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(hsApi, log) {
            var _this = this;

            var _loop, _i, _Object$values, entries, _loop2, _i2, _entries;

            return regeneratorRuntime.wrap(function _callee$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (this.needsUpload) {
                      _context3.next = 2;
                      break;
                    }

                    return _context3.abrupt("return");

                  case 2:
                    if (this._attachments) {
                      _context3.next = 4;
                      break;
                    }

                    throw new Error("attachments missing");

                  case 4:
                    if (!this.needsEncryption) {
                      _context3.next = 14;
                      break;
                    }

                    this._status = SendStatus.EncryptingAttachments;

                    this._emitUpdate("status");

                    _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop() {
                      var attachment;
                      return regeneratorRuntime.wrap(function _loop$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              attachment = _Object$values[_i];
                              _context.next = 3;
                              return log.wrap("encrypt", function () {
                                log.set("size", attachment.size);
                                return attachment.encrypt();
                              });

                            case 3:
                              if (!_this.aborted) {
                                _context.next = 5;
                                break;
                              }

                              throw new AbortError();

                            case 5:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _loop);
                    });
                    _i = 0, _Object$values = Object.values(this._attachments);

                  case 9:
                    if (!(_i < _Object$values.length)) {
                      _context3.next = 14;
                      break;
                    }

                    return _context3.delegateYield(_loop(), "t0", 11);

                  case 11:
                    _i++;
                    _context3.next = 9;
                    break;

                  case 14:
                    this._status = SendStatus.UploadingAttachments;

                    this._emitUpdate("status");

                    entries = Object.entries(this._attachments); // upload smallest attachments first

                    entries.sort(function (_ref2, _ref3) {
                      var _ref4 = _slicedToArray(_ref2, 2),
                          a1 = _ref4[1];

                      var _ref5 = _slicedToArray(_ref3, 2),
                          a2 = _ref5[1];

                      return a1.size - a2.size;
                    });
                    _loop2 = /*#__PURE__*/regeneratorRuntime.mark(function _loop2() {
                      var _entries$_i, urlPath, attachment;

                      return regeneratorRuntime.wrap(function _loop2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              _entries$_i = _slicedToArray(_entries[_i2], 2), urlPath = _entries$_i[0], attachment = _entries$_i[1];
                              _context2.next = 3;
                              return log.wrap("upload", function (log) {
                                log.set("size", attachment.size);
                                return attachment.upload(hsApi, function () {
                                  _this._emitUpdate("attachmentsSentBytes");
                                }, log);
                              });

                            case 3:
                              attachment.applyToContent(urlPath, _this.content);

                            case 4:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _loop2);
                    });
                    _i2 = 0, _entries = entries;

                  case 20:
                    if (!(_i2 < _entries.length)) {
                      _context3.next = 25;
                      break;
                    }

                    return _context3.delegateYield(_loop2(), "t1", 22);

                  case 22:
                    _i2++;
                    _context3.next = 20;
                    break;

                  case 25:
                    this._data.needsUpload = false;

                  case 26:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee, this);
          }));

          function uploadAttachments(_x, _x2) {
            return _uploadAttachments.apply(this, arguments);
          }

          return uploadAttachments;
        }()
      }, {
        key: "abort",
        value: function () {
          var _abort = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            var _this$_sendRequest, _i3, _Object$values2, attachment;

            return regeneratorRuntime.wrap(function _callee2$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (this._aborted) {
                      _context4.next = 6;
                      break;
                    }

                    this._aborted = true;

                    if (this._attachments) {
                      for (_i3 = 0, _Object$values2 = Object.values(this._attachments); _i3 < _Object$values2.length; _i3++) {
                        attachment = _Object$values2[_i3];
                        attachment.abort();
                      }
                    }

                    (_this$_sendRequest = this._sendRequest) === null || _this$_sendRequest === void 0 ? void 0 : _this$_sendRequest.abort();
                    _context4.next = 6;
                    return this._removeFromQueueCallback();

                  case 6:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee2, this);
          }));

          function abort() {
            return _abort.apply(this, arguments);
          }

          return abort;
        }()
      }, {
        key: "send",
        value: function () {
          var _send = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(hsApi, log) {
            var eventType, content, response;
            return regeneratorRuntime.wrap(function _callee3$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    this._status = SendStatus.Sending;

                    this._emitUpdate("status");

                    eventType = this._data.encryptedEventType || this._data.eventType;
                    content = this._data.encryptedContent || this._data.content;

                    if (eventType === REDACTION_TYPE) {
                      this._sendRequest = hsApi.redact(this.roomId, this._data.relatedEventId, this.txnId, content, {
                        log: log
                      });
                    } else {
                      this._sendRequest = hsApi.send(this.roomId, eventType, this.txnId, content, {
                        log: log
                      });
                    }

                    _context5.next = 7;
                    return this._sendRequest.response();

                  case 7:
                    response = _context5.sent;
                    this._sendRequest = null; // both /send and /redact have the same response format

                    this._data.remoteId = response.event_id;
                    log.set("id", this._data.remoteId);
                    this._status = SendStatus.Sent;

                    this._emitUpdate("status");

                  case 13:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee3, this);
          }));

          function send(_x3, _x4) {
            return _send.apply(this, arguments);
          }

          return send;
        }()
      }, {
        key: "dispose",
        value: function dispose() {
          if (this._attachments) {
            for (var _i4 = 0, _Object$values3 = Object.values(this._attachments); _i4 < _Object$values3.length; _i4++) {
              var attachment = _Object$values3[_i4];
              attachment.dispose();
            }
          }
        }
      }, {
        key: "roomId",
        get: function get() {
          return this._data.roomId;
        }
      }, {
        key: "queueIndex",
        get: function get() {
          return this._data.queueIndex;
        }
      }, {
        key: "eventType",
        get: function get() {
          return this._data.eventType;
        }
      }, {
        key: "txnId",
        get: function get() {
          return this._data.txnId;
        }
      }, {
        key: "remoteId",
        get: function get() {
          return this._data.remoteId;
        }
      }, {
        key: "content",
        get: function get() {
          return this._data.content;
        }
      }, {
        key: "relatedTxnId",
        get: function get() {
          return this._data.relatedTxnId;
        }
      }, {
        key: "relatedEventId",
        get: function get() {
          var relation = getRelationFromContent(this.content);

          if (relation) {
            // may be null when target is not sent yet, is intended
            return getRelationTarget(relation);
          } else {
            return this._data.relatedEventId;
          }
        }
      }, {
        key: "data",
        get: function get() {
          return this._data;
        }
      }, {
        key: "needsSending",
        get: function get() {
          return !this.remoteId && !this.aborted;
        }
      }, {
        key: "needsEncryption",
        get: function get() {
          return this._data.needsEncryption && !this.aborted;
        }
      }, {
        key: "needsUpload",
        get: function get() {
          return this._data.needsUpload && !this.aborted;
        }
      }, {
        key: "isMissingAttachments",
        get: function get() {
          return this.needsUpload && !this._attachments;
        }
      }, {
        key: "contentForEncryption",
        get: function get() {
          var content = Object.assign({}, this._data.content);

          var _iterator2 = _createForOfIteratorHelper(unencryptedContentFields),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var field = _step2.value;
              delete content[field];
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          return content;
        }
      }, {
        key: "status",
        get: function get() {
          return this._status;
        }
      }, {
        key: "error",
        get: function get() {
          return this._error;
        }
      }, {
        key: "hasStartedSending",
        get: function get() {
          return this._status === SendStatus.Sending || this._status === SendStatus.Sent;
        }
      }, {
        key: "attachmentsTotalBytes",
        get: function get() {
          return this._attachmentsTotalBytes;
        }
      }, {
        key: "attachmentsSentBytes",
        get: function get() {
          return this._attachments && Object.values(this._attachments).reduce(function (t, a) {
            return t + a.sentBytes;
          }, 0);
        }
      }, {
        key: "aborted",
        get: function get() {
          return this._aborted;
        }
      }]);

      return PendingEvent;
    }();

    var EventEntry = /*#__PURE__*/function (_BaseEventEntry) {
      _inherits(EventEntry, _BaseEventEntry);

      var _super = _createSuper(EventEntry);

      function EventEntry(eventEntry, fragmentIdComparer) {
        var _this;

        _classCallCheck(this, EventEntry);

        _this = _super.call(this, fragmentIdComparer);
        _this._eventEntry = eventEntry;
        _this._decryptionError = null;
        _this._decryptionResult = null;
        return _this;
      }

      _createClass(EventEntry, [{
        key: "clone",
        value: function clone() {
          var clone = new EventEntry(this._eventEntry, this._fragmentIdComparer);
          clone.updateFrom(this);
          return clone;
        }
      }, {
        key: "updateFrom",
        value: function updateFrom(other) {
          if (other._decryptionResult && !this._decryptionResult) {
            this._decryptionResult = other._decryptionResult;
          }

          if (other._decryptionError && !this._decryptionError) {
            this._decryptionError = other._decryptionError;
          }
        }
      }, {
        key: "setDecryptionResult",
        value: function setDecryptionResult(result) {
          this._decryptionResult = result;
        }
      }, {
        key: "setDecryptionError",
        value: function setDecryptionError(err) {
          this._decryptionError = err;
        }
      }, {
        key: "event",
        get: function get() {
          return this._eventEntry.event;
        }
      }, {
        key: "fragmentId",
        get: function get() {
          return this._eventEntry.fragmentId;
        }
      }, {
        key: "entryIndex",
        get: function get() {
          return this._eventEntry.eventIndex;
        }
      }, {
        key: "content",
        get: function get() {
          var _this$_decryptionResu, _this$_decryptionResu2;

          return ((_this$_decryptionResu = this._decryptionResult) === null || _this$_decryptionResu === void 0 ? void 0 : (_this$_decryptionResu2 = _this$_decryptionResu.event) === null || _this$_decryptionResu2 === void 0 ? void 0 : _this$_decryptionResu2.content) || this._eventEntry.event.content;
        }
      }, {
        key: "prevContent",
        get: function get() {
          // doesn't look at _decryptionResult because state events are not encrypted
          return getPrevContentFromStateEvent(this._eventEntry.event);
        }
      }, {
        key: "eventType",
        get: function get() {
          var _this$_decryptionResu3, _this$_decryptionResu4;

          return ((_this$_decryptionResu3 = this._decryptionResult) === null || _this$_decryptionResu3 === void 0 ? void 0 : (_this$_decryptionResu4 = _this$_decryptionResu3.event) === null || _this$_decryptionResu4 === void 0 ? void 0 : _this$_decryptionResu4.type) || this._eventEntry.event.type;
        }
      }, {
        key: "stateKey",
        get: function get() {
          return this._eventEntry.event.state_key;
        }
      }, {
        key: "sender",
        get: function get() {
          return this._eventEntry.event.sender;
        }
      }, {
        key: "displayName",
        get: function get() {
          return this._eventEntry.displayName;
        }
      }, {
        key: "avatarUrl",
        get: function get() {
          return this._eventEntry.avatarUrl;
        }
      }, {
        key: "timestamp",
        get: function get() {
          return this._eventEntry.event.origin_server_ts;
        }
      }, {
        key: "id",
        get: function get() {
          return this._eventEntry.event.event_id;
        }
      }, {
        key: "isEncrypted",
        get: function get() {
          return this._eventEntry.event.type === "m.room.encrypted";
        }
      }, {
        key: "isDecrypted",
        get: function get() {
          var _this$_decryptionResu5;

          return !!((_this$_decryptionResu5 = this._decryptionResult) === null || _this$_decryptionResu5 === void 0 ? void 0 : _this$_decryptionResu5.event);
        }
      }, {
        key: "isVerified",
        get: function get() {
          var _this$_decryptionResu6;

          return this.isEncrypted && ((_this$_decryptionResu6 = this._decryptionResult) === null || _this$_decryptionResu6 === void 0 ? void 0 : _this$_decryptionResu6.isVerified);
        }
      }, {
        key: "isUnverified",
        get: function get() {
          var _this$_decryptionResu7;

          return this.isEncrypted && ((_this$_decryptionResu7 = this._decryptionResult) === null || _this$_decryptionResu7 === void 0 ? void 0 : _this$_decryptionResu7.isUnverified);
        }
      }, {
        key: "decryptionError",
        get: function get() {
          return this._decryptionError;
        }
      }, {
        key: "relatedEventId",
        get: function get() {
          return getRelatedEventId(this.event);
        }
      }, {
        key: "isRedacted",
        get: function get() {
          return _get(_getPrototypeOf(EventEntry.prototype), "isRedacted", this) || isRedacted(this._eventEntry.event);
        }
      }, {
        key: "redactionReason",
        get: function get() {
          var _this$_eventEntry$eve;

          var redactionEvent = (_this$_eventEntry$eve = this._eventEntry.event.unsigned) === null || _this$_eventEntry$eve === void 0 ? void 0 : _this$_eventEntry$eve.redacted_because;

          if (redactionEvent) {
            var _redactionEvent$conte;

            return (_redactionEvent$conte = redactionEvent.content) === null || _redactionEvent$conte === void 0 ? void 0 : _redactionEvent$conte.reason;
          } // fall back to local echo reason


          return _get(_getPrototypeOf(EventEntry.prototype), "redactionReason", this);
        }
      }, {
        key: "annotations",
        get: function get() {
          return this._eventEntry.annotations;
        }
      }, {
        key: "relation",
        get: function get() {
          var originalContent = this._eventEntry.event.content;
          var originalRelation = originalContent && getRelationFromContent(originalContent);
          return originalRelation || getRelationFromContent(this.content);
        }
      }]);

      return EventEntry;
    }(BaseEventEntry);

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function isValidFragmentId(id) {
      return typeof id === "number";
    }

    function findBackwardSiblingFragments(current, byId) {
      var sortedSiblings = [];

      while (isValidFragmentId(current.previousId)) {
        var previous = byId.get(current.previousId);

        if (!previous) {
          break;
        }

        if (previous.nextId !== current.id) {
          throw new Error("Previous fragment ".concat(previous.id, " doesn't point back to ").concat(current.id));
        }

        byId.delete(current.previousId);
        sortedSiblings.unshift(previous);
        current = previous;
      }

      return sortedSiblings;
    }

    function findForwardSiblingFragments(current, byId) {
      var sortedSiblings = [];

      while (isValidFragmentId(current.nextId)) {
        var next = byId.get(current.nextId);

        if (!next) {
          break;
        }

        if (next.previousId !== current.id) {
          throw new Error("Next fragment ".concat(next.id, " doesn't point back to ").concat(current.id));
        }

        byId.delete(current.nextId);
        sortedSiblings.push(next);
        current = next;
      }

      return sortedSiblings;
    }

    function createIslands(fragments) {
      var byId = new Map();

      var _iterator = _createForOfIteratorHelper(fragments),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var f = _step.value;
          byId.set(f.id, f);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var islands = [];

      while (byId.size) {
        var current = byId.values().next().value;
        byId.delete(current.id); // new island

        var previousSiblings = findBackwardSiblingFragments(current, byId);
        var nextSiblings = findForwardSiblingFragments(current, byId);
        var island = previousSiblings.concat(current, nextSiblings);
        islands.push(island);
      }

      return islands.map(function (a) {
        return new Island(a);
      });
    }

    var Fragment = function Fragment(id, previousId, nextId) {
      _classCallCheck(this, Fragment);

      this.id = id;
      this.previousId = previousId;
      this.nextId = nextId;
    };

    var Island = /*#__PURE__*/function () {
      function Island(sortedFragments) {
        var _this = this;

        _classCallCheck(this, Island);

        this._idToSortIndex = new Map();
        sortedFragments.forEach(function (f, i) {
          _this._idToSortIndex.set(f.id, i);
        });
      }

      _createClass(Island, [{
        key: "compare",
        value: function compare(idA, idB) {
          var sortIndexA = this._idToSortIndex.get(idA);

          if (sortIndexA === undefined) {
            throw new Error("first id ".concat(idA, " isn't part of this island"));
          }

          var sortIndexB = this._idToSortIndex.get(idB);

          if (sortIndexB === undefined) {
            throw new Error("second id ".concat(idB, " isn't part of this island"));
          }

          return sortIndexA - sortIndexB;
        }
      }, {
        key: "fragmentIds",
        get: function get() {
          return this._idToSortIndex.keys();
        }
      }]);

      return Island;
    }();

    var CompareError = /*#__PURE__*/function (_Error) {
      _inherits(CompareError, _Error);

      var _super = _createSuper(CompareError);

      function CompareError() {
        _classCallCheck(this, CompareError);

        return _super.apply(this, arguments);
      }

      _createClass(CompareError, [{
        key: "name",
        get: function get() {
          return "CompareError";
        }
      }]);

      return CompareError;
    }( /*#__PURE__*/_wrapNativeSuper(Error));
    /*
    index for fast lookup of how two fragments can be sorted
    */

    var FragmentIdComparer = /*#__PURE__*/function () {
      function FragmentIdComparer(fragments) {
        _classCallCheck(this, FragmentIdComparer);

        this._fragmentsById = fragments.reduce(function (map, f) {
          map.set(f.id, f);
          return map;
        }, new Map());
        this.rebuild(fragments);
      }

      _createClass(FragmentIdComparer, [{
        key: "_getIsland",
        value: function _getIsland(id) {
          var island = this._idToIsland.get(id);

          if (island === undefined) {
            throw new CompareError("Unknown fragment id ".concat(id));
          }

          return island;
        }
      }, {
        key: "compare",
        value: function compare(idA, idB) {
          if (idA === idB) {
            return 0;
          }

          var islandA = this._getIsland(idA);

          var islandB = this._getIsland(idB);

          if (islandA !== islandB) {
            throw new CompareError("".concat(idA, " and ").concat(idB, " are on different islands, can't tell order"));
          }

          return islandA.compare(idA, idB);
        }
      }, {
        key: "rebuild",
        value: function rebuild(fragments) {
          var islands = createIslands(fragments);
          this._idToIsland = new Map();

          var _iterator2 = _createForOfIteratorHelper(islands),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var island = _step2.value;

              var _iterator3 = _createForOfIteratorHelper(island.fragmentIds),
                  _step3;

              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  var id = _step3.value;

                  this._idToIsland.set(id, island);
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
        /** use for fragments coming out of persistence, not newly created ones, or also fragments for a new island (like for a permalink) */

      }, {
        key: "add",
        value: function add(fragment) {
          var copy = new Fragment(fragment.id, fragment.previousId, fragment.nextId);

          this._fragmentsById.set(fragment.id, copy);

          this.rebuild(this._fragmentsById.values());
        }
        /** use for appending newly created fragments */

      }, {
        key: "append",
        value: function append(id, previousId) {
          var fragment = new Fragment(id, previousId, null);

          var prevFragment = this._fragmentsById.get(previousId);

          if (prevFragment) {
            prevFragment.nextId = id;
          }

          this._fragmentsById.set(id, fragment);

          this.rebuild(this._fragmentsById.values());
        }
        /** use for prepending newly created fragments */

      }, {
        key: "prepend",
        value: function prepend(id, nextId) {
          var fragment = new Fragment(id, null, nextId);

          var nextFragment = this._fragmentsById.get(nextId);

          if (nextFragment) {
            nextFragment.previousId = id;
          }

          this._fragmentsById.set(id, fragment);

          this.rebuild(this._fragmentsById.values());
        }
      }]);

      return FragmentIdComparer;
    }();

    var RelationWriter = /*#__PURE__*/function () {
      function RelationWriter(_ref) {
        var roomId = _ref.roomId,
            ownUserId = _ref.ownUserId,
            fragmentIdComparer = _ref.fragmentIdComparer;

        _classCallCheck(this, RelationWriter);

        this._roomId = roomId;
        this._ownUserId = ownUserId;
        this._fragmentIdComparer = fragmentIdComparer;
      } // this needs to happen again after decryption too for edits


      _createClass(RelationWriter, [{
        key: "writeRelation",
        value: function () {
          var _writeRelation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(sourceEntry, txn, log) {
            var _this = this;

            var relatedEventId, relation, target, updatedStorageEntries;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    relatedEventId = sourceEntry.relatedEventId;

                    if (!relatedEventId) {
                      _context.next = 13;
                      break;
                    }

                    relation = getRelation(sourceEntry.event);

                    if (relation && relation.rel_type) {
                      // we don't consider replies (which aren't relations in the MSC2674 sense)
                      txn.timelineRelations.add(this._roomId, relation.event_id, relation.rel_type, sourceEntry.id);
                    }

                    _context.next = 6;
                    return txn.timelineEvents.getByEventId(this._roomId, relatedEventId);

                  case 6:
                    target = _context.sent;

                    if (!target) {
                      _context.next = 13;
                      break;
                    }

                    _context.next = 10;
                    return this._applyRelation(sourceEntry, target, txn, log);

                  case 10:
                    updatedStorageEntries = _context.sent;

                    if (!updatedStorageEntries) {
                      _context.next = 13;
                      break;
                    }

                    return _context.abrupt("return", updatedStorageEntries.map(function (e) {
                      txn.timelineEvents.update(e);
                      return new EventEntry(e, _this._fragmentIdComparer);
                    }));

                  case 13:
                    return _context.abrupt("return", null);

                  case 14:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function writeRelation(_x, _x2, _x3) {
            return _writeRelation.apply(this, arguments);
          }

          return writeRelation;
        }()
        /**
         * @param {Object} storageEntry the event object, as it will be stored in storage.
         *        Will be modified (but not written to storage) in case this event is
         *        a relation target for which we've previously received relations.
         * @param {Direction} direction of the gap fill
         * */

      }, {
        key: "writeGapRelation",
        value: function () {
          var _writeGapRelation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(storageEntry, direction, txn, log) {
            var sourceEntry, result, relations, _iterator, _step, r, relationStorageEntry, relationEntry;

            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    sourceEntry = new EventEntry(storageEntry, this._fragmentIdComparer);
                    _context2.next = 3;
                    return this.writeRelation(sourceEntry, txn, log);

                  case 3:
                    result = _context2.sent;

                    if (!(direction.isBackward && !isRedacted(storageEntry.event))) {
                      _context2.next = 31;
                      break;
                    }

                    _context2.next = 7;
                    return txn.timelineRelations.getAllForTarget(this._roomId, sourceEntry.id);

                  case 7:
                    relations = _context2.sent;

                    if (!relations.length) {
                      _context2.next = 31;
                      break;
                    }

                    _iterator = _createForOfIteratorHelper(relations);
                    _context2.prev = 10;

                    _iterator.s();

                  case 12:
                    if ((_step = _iterator.n()).done) {
                      _context2.next = 23;
                      break;
                    }

                    r = _step.value;
                    _context2.next = 16;
                    return txn.timelineEvents.getByEventId(this._roomId, r.sourceEventId);

                  case 16:
                    relationStorageEntry = _context2.sent;

                    if (!relationStorageEntry) {
                      _context2.next = 21;
                      break;
                    }

                    relationEntry = new EventEntry(relationStorageEntry, this._fragmentIdComparer);
                    _context2.next = 21;
                    return this._applyRelation(relationEntry, storageEntry, txn, log);

                  case 21:
                    _context2.next = 12;
                    break;

                  case 23:
                    _context2.next = 28;
                    break;

                  case 25:
                    _context2.prev = 25;
                    _context2.t0 = _context2["catch"](10);

                    _iterator.e(_context2.t0);

                  case 28:
                    _context2.prev = 28;

                    _iterator.f();

                    return _context2.finish(28);

                  case 31:
                    return _context2.abrupt("return", result);

                  case 32:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[10, 25, 28, 31]]);
          }));

          function writeGapRelation(_x4, _x5, _x6, _x7) {
            return _writeGapRelation.apply(this, arguments);
          }

          return writeGapRelation;
        }()
        /**
         * @param {EventEntry} sourceEntry
         * @param {Object} targetStorageEntry event entry as stored in the timelineEvents store
         * @return {[Object]} array of event storage entries that have been updated
         * */

      }, {
        key: "_applyRelation",
        value: function () {
          var _applyRelation2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(sourceEntry, targetStorageEntry, txn, log) {
            var _this2 = this;

            var relation, relType, aggregated;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!(sourceEntry.eventType === REDACTION_TYPE)) {
                      _context4.next = 4;
                      break;
                    }

                    return _context4.abrupt("return", log.wrap("redact", /*#__PURE__*/function () {
                      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(log) {
                        var redactedEvent, relation, redacted, updated, relationTargetStorageEntry;
                        return regeneratorRuntime.wrap(function _callee3$(_context3) {
                          while (1) {
                            switch (_context3.prev = _context3.next) {
                              case 0:
                                redactedEvent = targetStorageEntry.event;
                                relation = getRelation(redactedEvent); // get this before redacting

                                redacted = _this2._applyRedaction(sourceEntry.event, targetStorageEntry, txn, log);

                                if (!redacted) {
                                  _context3.next = 11;
                                  break;
                                }

                                updated = [targetStorageEntry];

                                if (!relation) {
                                  _context3.next = 10;
                                  break;
                                }

                                _context3.next = 8;
                                return _this2._reaggregateRelation(redactedEvent, relation, txn, log);

                              case 8:
                                relationTargetStorageEntry = _context3.sent;

                                if (relationTargetStorageEntry) {
                                  updated.push(relationTargetStorageEntry);
                                }

                              case 10:
                                return _context3.abrupt("return", updated);

                              case 11:
                                return _context3.abrupt("return", null);

                              case 12:
                              case "end":
                                return _context3.stop();
                            }
                          }
                        }, _callee3);
                      }));

                      return function (_x12) {
                        return _ref2.apply(this, arguments);
                      };
                    }()));

                  case 4:
                    relation = getRelation(sourceEntry.event);

                    if (!(relation && !isRedacted(targetStorageEntry.event))) {
                      _context4.next = 11;
                      break;
                    }

                    relType = relation.rel_type;

                    if (!(relType === ANNOTATION_RELATION_TYPE)) {
                      _context4.next = 11;
                      break;
                    }

                    aggregated = log.wrap("react", function (log) {
                      return _this2._aggregateAnnotation(sourceEntry.event, targetStorageEntry, log);
                    });

                    if (!aggregated) {
                      _context4.next = 11;
                      break;
                    }

                    return _context4.abrupt("return", [targetStorageEntry]);

                  case 11:
                    return _context4.abrupt("return", null);

                  case 12:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4);
          }));

          function _applyRelation(_x8, _x9, _x10, _x11) {
            return _applyRelation2.apply(this, arguments);
          }

          return _applyRelation;
        }()
      }, {
        key: "_applyRedaction",
        value: function _applyRedaction(redactionEvent, redactedStorageEntry, txn, log) {
          var redactedEvent = redactedStorageEntry.event;
          log.set("redactionId", redactionEvent.event_id);
          log.set("id", redactedEvent.event_id);
          var relation = getRelation(redactedEvent);

          if (relation && relation.rel_type) {
            txn.timelineRelations.remove(this._roomId, relation.event_id, relation.rel_type, redactedEvent.event_id);
          } // check if we're the target of a relation and remove all relations then as well


          txn.timelineRelations.removeAllForTarget(this._roomId, redactedEvent.event_id);

          for (var _i = 0, _Object$keys = Object.keys(redactedEvent); _i < _Object$keys.length; _i++) {
            var key = _Object$keys[_i];

            if (!_REDACT_KEEP_KEY_MAP[key]) {
              delete redactedEvent[key];
            }
          }

          var content = redactedEvent.content;
          var keepMap = _REDACT_KEEP_CONTENT_MAP[redactedEvent.type];

          for (var _i2 = 0, _Object$keys2 = Object.keys(content); _i2 < _Object$keys2.length; _i2++) {
            var _key = _Object$keys2[_i2];

            if (!(keepMap === null || keepMap === void 0 ? void 0 : keepMap[_key])) {
              delete content[_key];
            }
          }

          redactedEvent.unsigned = redactedEvent.unsigned || {};
          redactedEvent.unsigned.redacted_because = redactionEvent;
          delete redactedStorageEntry.annotations;
          return true;
        }
      }, {
        key: "_aggregateAnnotation",
        value: function _aggregateAnnotation(annotationEvent, targetStorageEntry
        /*, log*/
        ) {
          // TODO: do we want to verify it is a m.reaction event somehow?
          var relation = getRelation(annotationEvent);

          if (!relation) {
            return false;
          }

          var annotations = targetStorageEntry.annotations;

          if (!annotations) {
            targetStorageEntry.annotations = annotations = {};
          }

          var annotation = annotations[relation.key];

          if (!annotation) {
            annotations[relation.key] = annotation = {
              count: 0,
              me: false,
              firstTimestamp: Number.MAX_SAFE_INTEGER
            };
          }

          var sentByMe = annotationEvent.sender === this._ownUserId;
          annotation.me = annotation.me || sentByMe;
          annotation.count += 1;
          annotation.firstTimestamp = Math.min(annotation.firstTimestamp, annotationEvent.origin_server_ts);
          return true;
        }
      }, {
        key: "_reaggregateRelation",
        value: function () {
          var _reaggregateRelation2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(redactedRelationEvent, redactedRelation, txn, log) {
            var _this3 = this;

            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (!(redactedRelation.rel_type === ANNOTATION_RELATION_TYPE)) {
                      _context5.next = 2;
                      break;
                    }

                    return _context5.abrupt("return", log.wrap("reaggregate annotations", function (log) {
                      return _this3._reaggregateAnnotation(redactedRelation.event_id, redactedRelation.key, txn, log);
                    }));

                  case 2:
                    return _context5.abrupt("return", null);

                  case 3:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5);
          }));

          function _reaggregateRelation(_x13, _x14, _x15, _x16) {
            return _reaggregateRelation2.apply(this, arguments);
          }

          return _reaggregateRelation;
        }()
      }, {
        key: "_reaggregateAnnotation",
        value: function () {
          var _reaggregateAnnotation2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(targetId, key, txn, log) {
            var _this4 = this;

            var target, relations;
            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.next = 2;
                    return txn.timelineEvents.getByEventId(this._roomId, targetId);

                  case 2:
                    target = _context7.sent;

                    if (!(!target || !target.annotations)) {
                      _context7.next = 5;
                      break;
                    }

                    return _context7.abrupt("return", null);

                  case 5:
                    log.set("id", targetId);
                    _context7.next = 8;
                    return txn.timelineRelations.getForTargetAndType(this._roomId, targetId, ANNOTATION_RELATION_TYPE);

                  case 8:
                    relations = _context7.sent;
                    log.set("relations", relations.length);
                    delete target.annotations[key];

                    if (isObjectEmpty(target.annotations)) {
                      delete target.annotations;
                    }

                    _context7.next = 14;
                    return Promise.all(relations.map( /*#__PURE__*/function () {
                      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(relation) {
                        var annotation;
                        return regeneratorRuntime.wrap(function _callee6$(_context6) {
                          while (1) {
                            switch (_context6.prev = _context6.next) {
                              case 0:
                                _context6.next = 2;
                                return txn.timelineEvents.getByEventId(_this4._roomId, relation.sourceEventId);

                              case 2:
                                annotation = _context6.sent;

                                if (!annotation) {
                                  log.log({
                                    l: "missing annotation",
                                    id: relation.sourceEventId
                                  });
                                }

                                if (getRelation(annotation.event).key === key) {
                                  _this4._aggregateAnnotation(annotation.event, target, log);
                                }

                              case 5:
                              case "end":
                                return _context6.stop();
                            }
                          }
                        }, _callee6);
                      }));

                      return function (_x21) {
                        return _ref3.apply(this, arguments);
                      };
                    }()));

                  case 14:
                    return _context7.abrupt("return", target);

                  case 15:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));

          function _reaggregateAnnotation(_x17, _x18, _x19, _x20) {
            return _reaggregateAnnotation2.apply(this, arguments);
          }

          return _reaggregateAnnotation;
        }()
      }]);

      return RelationWriter;
    }();

    function isObjectEmpty(obj) {
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          return false;
        }
      }

      return true;
    } // copied over from matrix-js-sdk, copyright 2016 OpenMarket Ltd

    /* _REDACT_KEEP_KEY_MAP gives the keys we keep when an event is redacted
     *
     * This is specified here:
     *  http://matrix.org/speculator/spec/HEAD/client_server/latest.html#redactions
     *
     * Also:
     *  - We keep 'unsigned' since that is created by the local server
     *  - We keep user_id for backwards-compat with v1
     */


    var _REDACT_KEEP_KEY_MAP = ['event_id', 'type', 'room_id', 'user_id', 'sender', 'state_key', 'prev_state', 'content', 'unsigned', 'origin_server_ts'].reduce(function (ret, val) {
      ret[val] = 1;
      return ret;
    }, {}); // a map from event type to the .content keys we keep when an event is redacted


    var _REDACT_KEEP_CONTENT_MAP = {
      'm.room.member': {
        'membership': 1
      },
      'm.room.create': {
        'creator': 1
      },
      'm.room.join_rules': {
        'join_rule': 1
      },
      'm.room.power_levels': {
        'ban': 1,
        'events': 1,
        'events_default': 1,
        'kick': 1,
        'redact': 1,
        'state_default': 1,
        'users': 1,
        'users_default': 1
      },
      'm.room.aliases': {
        'aliases': 1
      }
    }; // end of matrix-js-sdk code

    var Direction = /*#__PURE__*/function () {
      function Direction(isForward) {
        _classCallCheck(this, Direction);

        this.isForward = isForward;
      }

      _createClass(Direction, [{
        key: "asApiString",
        value: function asApiString() {
          return this.isForward ? "f" : "b";
        }
      }, {
        key: "reverse",
        value: function reverse() {
          return this.isForward ? Direction.Backward : Direction.Forward;
        }
      }, {
        key: "isBackward",
        get: function get() {
          return !this.isForward;
        }
      }], [{
        key: "Forward",
        get: function get() {
          return _forward;
        }
      }, {
        key: "Backward",
        get: function get() {
          return _backward;
        }
      }]);

      return Direction;
    }();

    var _forward = new Direction(true);

    var _backward = new Direction(false);

    var FragmentBoundaryEntry = /*#__PURE__*/function (_BaseEntry) {
      _inherits(FragmentBoundaryEntry, _BaseEntry);

      var _super = _createSuper(FragmentBoundaryEntry);

      function FragmentBoundaryEntry(fragment, isFragmentStart, fragmentIdComparer) {
        var _this;

        _classCallCheck(this, FragmentBoundaryEntry);

        _this = _super.call(this, fragmentIdComparer);
        _this._fragment = fragment; // TODO: should isFragmentStart be Direction instead of bool?

        _this._isFragmentStart = isFragmentStart;
        return _this;
      }

      _createClass(FragmentBoundaryEntry, [{
        key: "withUpdatedFragment",
        value: function withUpdatedFragment(fragment) {
          return new FragmentBoundaryEntry(fragment, this._isFragmentStart, this._fragmentIdComparer);
        }
      }, {
        key: "createNeighbourEntry",
        value: function createNeighbourEntry(neighbour) {
          return new FragmentBoundaryEntry(neighbour, !this._isFragmentStart, this._fragmentIdComparer);
        }
      }, {
        key: "addLocalRelation",
        value: function addLocalRelation() {}
      }, {
        key: "removeLocalRelation",
        value: function removeLocalRelation() {}
      }, {
        key: "started",
        get: function get() {
          return this._isFragmentStart;
        }
      }, {
        key: "hasEnded",
        get: function get() {
          return !this.started;
        }
      }, {
        key: "fragment",
        get: function get() {
          return this._fragment;
        }
      }, {
        key: "fragmentId",
        get: function get() {
          return this._fragment.id;
        }
      }, {
        key: "entryIndex",
        get: function get() {
          if (this.started) {
            return KeyLimits.minStorageKey;
          } else {
            return KeyLimits.maxStorageKey;
          }
        }
      }, {
        key: "isGap",
        get: function get() {
          return !!this.token && !this.edgeReached;
        }
      }, {
        key: "token",
        get: function get() {
          if (this.started) {
            return this.fragment.previousToken;
          } else {
            return this.fragment.nextToken;
          }
        },
        set: function set(token) {
          if (this.started) {
            this.fragment.previousToken = token;
          } else {
            this.fragment.nextToken = token;
          }
        }
      }, {
        key: "edgeReached",
        get: function get() {
          if (this.started) {
            return this.fragment.startReached;
          } else {
            return this.fragment.endReached;
          }
        },
        set: function set(reached) {
          if (this.started) {
            this.fragment.startReached = reached;
          } else {
            this.fragment.endReached = reached;
          }
        }
      }, {
        key: "linkedFragmentId",
        get: function get() {
          if (this.started) {
            return this.fragment.previousId;
          } else {
            return this.fragment.nextId;
          }
        },
        set: function set(id) {
          if (this.started) {
            this.fragment.previousId = id;
          } else {
            this.fragment.nextId = id;
          }
        }
      }, {
        key: "hasLinkedFragment",
        get: function get() {
          return isValidFragmentId(this.linkedFragmentId);
        }
      }, {
        key: "direction",
        get: function get() {
          if (this.started) {
            return Direction.Backward;
          } else {
            return Direction.Forward;
          }
        }
      }], [{
        key: "start",
        value: function start(fragment, fragmentIdComparer) {
          return new FragmentBoundaryEntry(fragment, true, fragmentIdComparer);
        }
      }, {
        key: "end",
        value: function end(fragment, fragmentIdComparer) {
          return new FragmentBoundaryEntry(fragment, false, fragmentIdComparer);
        }
      }]);

      return FragmentBoundaryEntry;
    }(BaseEntry);

    // when first syncing the room

    function deduplicateEvents(events) {
      var eventIds = new Set();
      return events.filter(function (e) {
        if (eventIds.has(e.event_id)) {
          return false;
        } else {
          eventIds.add(e.event_id);
          return true;
        }
      });
    }

    var SyncWriter = /*#__PURE__*/function () {
      function SyncWriter(_ref) {
        var roomId = _ref.roomId,
            fragmentIdComparer = _ref.fragmentIdComparer,
            memberWriter = _ref.memberWriter,
            relationWriter = _ref.relationWriter;

        _classCallCheck(this, SyncWriter);

        this._roomId = roomId;
        this._memberWriter = memberWriter;
        this._relationWriter = relationWriter;
        this._fragmentIdComparer = fragmentIdComparer;
        this._lastLiveKey = null;
      }

      _createClass(SyncWriter, [{
        key: "load",
        value: function () {
          var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(txn, log) {
            var liveFragment, _yield$txn$timelineEv, _yield$txn$timelineEv2, lastEvent, eventIndex;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return txn.timelineFragments.liveFragment(this._roomId);

                  case 2:
                    liveFragment = _context.sent;

                    if (!liveFragment) {
                      _context.next = 11;
                      break;
                    }

                    _context.next = 6;
                    return txn.timelineEvents.lastEvents(this._roomId, liveFragment.id, 1);

                  case 6:
                    _yield$txn$timelineEv = _context.sent;
                    _yield$txn$timelineEv2 = _slicedToArray(_yield$txn$timelineEv, 1);
                    lastEvent = _yield$txn$timelineEv2[0];
                    // fall back to the default event index in case the fragment was somehow written but no events
                    // we should only create fragments when really writing timeline events now
                    // (see https://github.com/vector-im/hydrogen-web/issues/112) but can't hurt to be extra robust.
                    eventIndex = lastEvent ? lastEvent.eventIndex : EventKey.defaultLiveKey.eventIndex;
                    this._lastLiveKey = new EventKey(liveFragment.id, eventIndex);

                  case 11:
                    // if there is no live fragment, we don't create it here because load gets a readonly txn.
                    // this is on purpose, load shouldn't modify the store
                    if (this._lastLiveKey) {
                      log.set("live key", this._lastLiveKey.toString());
                    }

                  case 12:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function load(_x, _x2) {
            return _load.apply(this, arguments);
          }

          return load;
        }()
      }, {
        key: "_createLiveFragment",
        value: function () {
          var _createLiveFragment2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(txn, previousToken) {
            var liveFragment, fragment;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return txn.timelineFragments.liveFragment(this._roomId);

                  case 2:
                    liveFragment = _context2.sent;

                    if (liveFragment) {
                      _context2.next = 11;
                      break;
                    }

                    if (!previousToken) {
                      previousToken = null;
                    }

                    fragment = {
                      roomId: this._roomId,
                      id: EventKey.defaultLiveKey.fragmentId,
                      previousId: null,
                      nextId: null,
                      previousToken: previousToken,
                      nextToken: null
                    };
                    txn.timelineFragments.add(fragment);

                    this._fragmentIdComparer.add(fragment);

                    return _context2.abrupt("return", fragment);

                  case 11:
                    return _context2.abrupt("return", liveFragment);

                  case 12:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function _createLiveFragment(_x3, _x4) {
            return _createLiveFragment2.apply(this, arguments);
          }

          return _createLiveFragment;
        }()
      }, {
        key: "_replaceLiveFragment",
        value: function () {
          var _replaceLiveFragment2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(oldFragmentId, newFragmentId, previousToken, txn) {
            var oldFragment, newFragment;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return txn.timelineFragments.get(this._roomId, oldFragmentId);

                  case 2:
                    oldFragment = _context3.sent;

                    if (oldFragment) {
                      _context3.next = 5;
                      break;
                    }

                    throw new Error("old live fragment doesn't exist: ".concat(oldFragmentId));

                  case 5:
                    oldFragment.nextId = newFragmentId;
                    txn.timelineFragments.update(oldFragment);
                    newFragment = {
                      roomId: this._roomId,
                      id: newFragmentId,
                      previousId: oldFragmentId,
                      nextId: null,
                      previousToken: previousToken,
                      nextToken: null
                    };
                    txn.timelineFragments.add(newFragment);

                    this._fragmentIdComparer.append(newFragmentId, oldFragmentId);

                    return _context3.abrupt("return", {
                      oldFragment: oldFragment,
                      newFragment: newFragment
                    });

                  case 11:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function _replaceLiveFragment(_x5, _x6, _x7, _x8) {
            return _replaceLiveFragment2.apply(this, arguments);
          }

          return _replaceLiveFragment;
        }()
        /**
         * creates a new live fragment if the timeline is limited, or if no live fragment is created yet
         * @param  {EventKey} currentKey current key so far, might be none if room hasn't synced yet
         * @param  {Array<BaseEntrie>} entries    array to add fragment boundary entries when creating a new fragment
         * @param  {Object} timeline   timeline part of the room sync response
         * @param  {Transaction} txn        used to read and write from the fragment store
         * @return {EventKey} the new event key to start writing events at
         */

      }, {
        key: "_ensureLiveFragment",
        value: function () {
          var _ensureLiveFragment2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(currentKey, entries, timeline, txn, log) {
            var liveFragment, oldFragmentId, _yield$this$_replaceL, oldFragment, newFragment;

            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (currentKey) {
                      _context4.next = 9;
                      break;
                    }

                    _context4.next = 3;
                    return this._createLiveFragment(txn, timeline.prev_batch);

                  case 3:
                    liveFragment = _context4.sent;
                    currentKey = new EventKey(liveFragment.id, EventKey.defaultLiveKey.eventIndex);
                    entries.push(FragmentBoundaryEntry.start(liveFragment, this._fragmentIdComparer));
                    log.log({
                      l: "live fragment",
                      first: true,
                      id: currentKey.fragmentId
                    });
                    _context4.next = 20;
                    break;

                  case 9:
                    if (!timeline.limited) {
                      _context4.next = 20;
                      break;
                    }

                    // replace live fragment for limited sync, *only* if we had a live fragment already
                    oldFragmentId = currentKey.fragmentId;
                    currentKey = currentKey.nextFragmentKey();
                    _context4.next = 14;
                    return this._replaceLiveFragment(oldFragmentId, currentKey.fragmentId, timeline.prev_batch, txn);

                  case 14:
                    _yield$this$_replaceL = _context4.sent;
                    oldFragment = _yield$this$_replaceL.oldFragment;
                    newFragment = _yield$this$_replaceL.newFragment;
                    entries.push(FragmentBoundaryEntry.end(oldFragment, this._fragmentIdComparer));
                    entries.push(FragmentBoundaryEntry.start(newFragment, this._fragmentIdComparer));
                    log.log({
                      l: "live fragment",
                      limited: true,
                      id: currentKey.fragmentId
                    });

                  case 20:
                    return _context4.abrupt("return", currentKey);

                  case 21:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function _ensureLiveFragment(_x9, _x10, _x11, _x12, _x13) {
            return _ensureLiveFragment2.apply(this, arguments);
          }

          return _ensureLiveFragment;
        }()
      }, {
        key: "_writeStateEvents",
        value: function () {
          var _writeStateEvents2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(stateEvents, txn, log) {
            var nonMemberStateEvents, _iterator, _step, event;

            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    nonMemberStateEvents = 0;
                    _iterator = _createForOfIteratorHelper(stateEvents);

                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done;) {
                        event = _step.value;

                        // member events are written prior by MemberWriter
                        if (event.type !== EVENT_TYPE) {
                          txn.roomState.set(this._roomId, event);
                          nonMemberStateEvents += 1;
                        }
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }

                    log.set("stateEvents", nonMemberStateEvents);

                  case 4:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));

          function _writeStateEvents(_x14, _x15, _x16) {
            return _writeStateEvents2.apply(this, arguments);
          }

          return _writeStateEvents;
        }()
      }, {
        key: "_writeTimeline",
        value: function () {
          var _writeTimeline2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(timelineEvents, timeline, memberSync, currentKey, txn, log) {
            var entries, updatedEntries, timelineStateEventCount, _iterator2, _step2, event, storageEntry, member, couldInsert, entry, updatedRelationTargetEntries;

            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    entries = [];
                    updatedEntries = [];

                    if (!(timelineEvents === null || timelineEvents === void 0 ? void 0 : timelineEvents.length)) {
                      _context6.next = 42;
                      break;
                    }

                    _context6.next = 5;
                    return this._ensureLiveFragment(currentKey, entries, timeline, txn, log);

                  case 5:
                    currentKey = _context6.sent;
                    log.set("timelineEvents", timelineEvents.length);
                    timelineStateEventCount = 0;
                    _iterator2 = _createForOfIteratorHelper(timelineEvents);
                    _context6.prev = 9;

                    _iterator2.s();

                  case 11:
                    if ((_step2 = _iterator2.n()).done) {
                      _context6.next = 33;
                      break;
                    }

                    event = _step2.value;
                    // store event in timeline
                    currentKey = currentKey.nextKey();
                    storageEntry = createEventEntry(currentKey, this._roomId, event);
                    _context6.next = 17;
                    return memberSync.lookupMemberAtEvent(event.sender, event, txn);

                  case 17:
                    member = _context6.sent;

                    if (member) {
                      storageEntry.displayName = member.displayName;
                      storageEntry.avatarUrl = member.avatarUrl;
                    }

                    _context6.next = 21;
                    return txn.timelineEvents.tryInsert(storageEntry, log);

                  case 21:
                    couldInsert = _context6.sent;

                    if (couldInsert) {
                      _context6.next = 24;
                      break;
                    }

                    return _context6.abrupt("continue", 31);

                  case 24:
                    entry = new EventEntry(storageEntry, this._fragmentIdComparer);
                    entries.push(entry);
                    _context6.next = 28;
                    return this._relationWriter.writeRelation(entry, txn, log);

                  case 28:
                    updatedRelationTargetEntries = _context6.sent;

                    if (updatedRelationTargetEntries) {
                      updatedEntries.push.apply(updatedEntries, _toConsumableArray(updatedRelationTargetEntries));
                    } // update state events after writing event, so for a member event,
                    // we only update the member info after having written the member event
                    // to the timeline, as we want that event to have the old profile info.
                    // member events are written prior by MemberWriter.


                    if (typeof event.state_key === "string" && event.type !== EVENT_TYPE) {
                      timelineStateEventCount += 1;
                      txn.roomState.set(this._roomId, event);
                    }

                  case 31:
                    _context6.next = 11;
                    break;

                  case 33:
                    _context6.next = 38;
                    break;

                  case 35:
                    _context6.prev = 35;
                    _context6.t0 = _context6["catch"](9);

                    _iterator2.e(_context6.t0);

                  case 38:
                    _context6.prev = 38;

                    _iterator2.f();

                    return _context6.finish(38);

                  case 41:
                    log.set("timelineStateEventCount", timelineStateEventCount);

                  case 42:
                    return _context6.abrupt("return", {
                      currentKey: currentKey,
                      entries: entries,
                      updatedEntries: updatedEntries
                    });

                  case 43:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this, [[9, 35, 38, 41]]);
          }));

          function _writeTimeline(_x17, _x18, _x19, _x20, _x21, _x22) {
            return _writeTimeline2.apply(this, arguments);
          }

          return _writeTimeline;
        }()
      }, {
        key: "_handleRejoinOverlap",
        value: function () {
          var _handleRejoinOverlap2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(timeline, txn, log) {
            var fragmentId, _yield$txn$timelineEv3, _yield$txn$timelineEv4, lastEvent, lastEventId, events, index;

            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    if (!this._lastLiveKey) {
                      _context7.next = 14;
                      break;
                    }

                    fragmentId = this._lastLiveKey.fragmentId;
                    _context7.next = 4;
                    return txn.timelineEvents.lastEvents(this._roomId, fragmentId, 1);

                  case 4:
                    _yield$txn$timelineEv3 = _context7.sent;
                    _yield$txn$timelineEv4 = _slicedToArray(_yield$txn$timelineEv3, 1);
                    lastEvent = _yield$txn$timelineEv4[0];

                    if (!lastEvent) {
                      _context7.next = 14;
                      break;
                    }

                    lastEventId = lastEvent.event.event_id;
                    events = timeline.events;
                    index = events.findIndex(function (event) {
                      return event.event_id === lastEventId;
                    });

                    if (!(index !== -1)) {
                      _context7.next = 14;
                      break;
                    }

                    log.set("overlap_event_id", lastEventId);
                    return _context7.abrupt("return", Object.assign({}, timeline, {
                      limited: false,
                      events: events.slice(index + 1)
                    }));

                  case 14:
                    if (timeline.limited) {
                      _context7.next = 17;
                      break;
                    }

                    log.set("force_limited_without_overlap", true);
                    return _context7.abrupt("return", Object.assign({}, timeline, {
                      limited: true
                    }));

                  case 17:
                    return _context7.abrupt("return", timeline);

                  case 18:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));

          function _handleRejoinOverlap(_x23, _x24, _x25) {
            return _handleRejoinOverlap2.apply(this, arguments);
          }

          return _handleRejoinOverlap;
        }()
        /**
         * @type {SyncWriterResult}
         * @property {Array<BaseEntry>} entries new timeline entries written
         * @property {EventKey} newLiveKey the advanced key to write events at
         * 
         * @param  {Object}  roomResponse [description]
         * @param  {boolean}  isRejoin whether the room was rejoined in the sync being processed
         * @param  {Transaction}  txn     
         * @return {SyncWriterResult}
         */

      }, {
        key: "writeSync",
        value: function () {
          var _writeSync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(roomResponse, isRejoin, hasFetchedMembers, txn, log) {
            var _timeline;

            var timeline, timelineEvents, state, stateEvents, memberSync, _yield$this$_writeTim, currentKey, entries, updatedEntries, memberChanges;

            return regeneratorRuntime.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    timeline = roomResponse.timeline; // we have rejoined the room after having synced it before,
                    // check for overlap with the last synced event

                    log.set("isRejoin", isRejoin);

                    if (!isRejoin) {
                      _context8.next = 6;
                      break;
                    }

                    _context8.next = 5;
                    return this._handleRejoinOverlap(timeline, txn, log);

                  case 5:
                    timeline = _context8.sent;

                  case 6:
                    if (Array.isArray((_timeline = timeline) === null || _timeline === void 0 ? void 0 : _timeline.events)) {
                      timelineEvents = deduplicateEvents(timeline.events);
                    }

                    state = roomResponse.state;

                    if (Array.isArray(state === null || state === void 0 ? void 0 : state.events)) {
                      stateEvents = state.events;
                    }

                    memberSync = this._memberWriter.prepareMemberSync(stateEvents, timelineEvents, hasFetchedMembers);

                    if (!stateEvents) {
                      _context8.next = 13;
                      break;
                    }

                    _context8.next = 13;
                    return this._writeStateEvents(stateEvents, txn, log);

                  case 13:
                    _context8.next = 15;
                    return this._writeTimeline(timelineEvents, timeline, memberSync, this._lastLiveKey, txn, log);

                  case 15:
                    _yield$this$_writeTim = _context8.sent;
                    currentKey = _yield$this$_writeTim.currentKey;
                    entries = _yield$this$_writeTim.entries;
                    updatedEntries = _yield$this$_writeTim.updatedEntries;
                    _context8.next = 21;
                    return memberSync.write(txn);

                  case 21:
                    memberChanges = _context8.sent;
                    return _context8.abrupt("return", {
                      entries: entries,
                      updatedEntries: updatedEntries,
                      newLiveKey: currentKey,
                      memberChanges: memberChanges
                    });

                  case 23:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));

          function writeSync(_x26, _x27, _x28, _x29, _x30) {
            return _writeSync.apply(this, arguments);
          }

          return writeSync;
        }()
      }, {
        key: "afterSync",
        value: function afterSync(newLiveKey) {
          this._lastLiveKey = newLiveKey;
        }
      }, {
        key: "lastMessageKey",
        get: function get() {
          return this._lastLiveKey;
        }
      }]);

      return SyncWriter;
    }();

    var BaseLRUCache = /*#__PURE__*/function () {
      function BaseLRUCache(limit) {
        _classCallCheck(this, BaseLRUCache);

        this.limit = limit;
        this._entries = [];
      }

      _createClass(BaseLRUCache, [{
        key: "_get",
        value: function _get(findEntryFn) {
          return this._getByIndexAndMoveUp(this._entries.findIndex(findEntryFn));
        }
      }, {
        key: "_getByIndexAndMoveUp",
        value: function _getByIndexAndMoveUp(idx) {
          if (idx !== -1) {
            var entry = this._entries[idx];

            if (idx > 0) {
              this._entries.splice(idx, 1);

              this._entries.unshift(entry);
            }

            return entry;
          }
        }
      }, {
        key: "_set",
        value: function _set(value, findEntryFn) {
          var indexToRemove = findEntryFn ? this._entries.findIndex(findEntryFn) : -1;

          this._entries.unshift(value);

          if (indexToRemove === -1) {
            if (this._entries.length > this.limit) {
              indexToRemove = this._entries.length - 1;
            }
          } else {
            indexToRemove += 1;
          }

          if (indexToRemove !== -1) {
            this.onEvictEntry(this._entries[indexToRemove]);

            this._entries.splice(indexToRemove, 1);
          }
        }
      }, {
        key: "onEvictEntry",
        value: function onEvictEntry(entry) {}
      }, {
        key: "size",
        get: function get() {
          return this._entries.length;
        }
      }]);

      return BaseLRUCache;
    }();
    var LRUCache = /*#__PURE__*/function (_BaseLRUCache) {
      _inherits(LRUCache, _BaseLRUCache);

      var _super = _createSuper(LRUCache);

      function LRUCache(limit, keyFn) {
        var _this;

        _classCallCheck(this, LRUCache);

        _this = _super.call(this, limit);
        _this._keyFn = keyFn;
        return _this;
      }

      _createClass(LRUCache, [{
        key: "get",
        value: function get(key) {
          var _this2 = this;

          return this._get(function (e) {
            return _this2._keyFn(e) === key;
          });
        }
      }, {
        key: "set",
        value: function set(value) {
          var _this3 = this;

          var key = this._keyFn(value);

          this._set(value, function (e) {
            return _this3._keyFn(e) === key;
          });
        }
      }]);

      return LRUCache;
    }(BaseLRUCache);

    var MemberWriter = /*#__PURE__*/function () {
      function MemberWriter(roomId) {
        _classCallCheck(this, MemberWriter);

        this._roomId = roomId;
        this._cache = new LRUCache(5, function (member) {
          return member.userId;
        });
      }

      _createClass(MemberWriter, [{
        key: "prepareMemberSync",
        value: function prepareMemberSync(stateEvents, timelineEvents, hasFetchedMembers) {
          return new MemberSync(this, stateEvents, timelineEvents, hasFetchedMembers);
        }
      }, {
        key: "_writeMember",
        value: function () {
          var _writeMember2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(member, txn) {
            var existingMember, memberData, _existingMember;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    existingMember = this._cache.get(member.userId);

                    if (existingMember) {
                      _context.next = 6;
                      break;
                    }

                    _context.next = 4;
                    return txn.roomMembers.get(this._roomId, member.userId);

                  case 4:
                    memberData = _context.sent;

                    if (memberData) {
                      existingMember = new RoomMember(memberData);
                    }

                  case 6:
                    if (!(!existingMember || !existingMember.equals(member))) {
                      _context.next = 10;
                      break;
                    }

                    txn.roomMembers.set(member.serialize());

                    this._cache.set(member);

                    return _context.abrupt("return", new MemberChange(member, (_existingMember = existingMember) === null || _existingMember === void 0 ? void 0 : _existingMember.membership));

                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function _writeMember(_x, _x2) {
            return _writeMember2.apply(this, arguments);
          }

          return _writeMember;
        }()
      }, {
        key: "lookupMember",
        value: function () {
          var _lookupMember = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(userId, txn) {
            var member, memberData;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    member = this._cache.get(userId);

                    if (member) {
                      _context2.next = 6;
                      break;
                    }

                    _context2.next = 4;
                    return txn.roomMembers.get(this._roomId, userId);

                  case 4:
                    memberData = _context2.sent;

                    if (memberData) {
                      member = new RoomMember(memberData);

                      this._cache.set(member);
                    }

                  case 6:
                    return _context2.abrupt("return", member);

                  case 7:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function lookupMember(_x3, _x4) {
            return _lookupMember.apply(this, arguments);
          }

          return lookupMember;
        }()
      }]);

      return MemberWriter;
    }();

    var MemberSync = /*#__PURE__*/function () {
      function MemberSync(memberWriter, stateEvents, timelineEvents, hasFetchedMembers) {
        _classCallCheck(this, MemberSync);

        this._memberWriter = memberWriter;
        this._timelineEvents = timelineEvents;
        this._hasFetchedMembers = hasFetchedMembers;
        this._newStateMembers = null;

        if (stateEvents) {
          this._newStateMembers = this._stateEventsToMembers(stateEvents);
        }
      }

      _createClass(MemberSync, [{
        key: "_stateEventsToMembers",
        value: function _stateEventsToMembers(stateEvents) {
          var members;

          var _iterator = _createForOfIteratorHelper(stateEvents),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var event = _step.value;

              if (event.type === EVENT_TYPE) {
                var member = RoomMember.fromMemberEvent(this._roomId, event);

                if (member) {
                  if (!members) {
                    members = new Map();
                  }

                  members.set(member.userId, member);
                }
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          return members;
        }
      }, {
        key: "_timelineEventsToMembers",
        value: function _timelineEventsToMembers(timelineEvents) {
          var members; // iterate backwards to only add the last member in the timeline

          for (var i = timelineEvents.length - 1; i >= 0; i--) {
            var _members;

            var e = timelineEvents[i];
            var userId = e.state_key;

            if (e.type === EVENT_TYPE && !((_members = members) === null || _members === void 0 ? void 0 : _members.has(userId))) {
              var member = RoomMember.fromMemberEvent(this._roomId, e);

              if (member) {
                if (!members) {
                  members = new Map();
                }

                members.set(member.userId, member);
              }
            }
          }

          return members;
        }
      }, {
        key: "lookupMemberAtEvent",
        value: function () {
          var _lookupMemberAtEvent = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(userId, event, txn) {
            var _this$_newStateMember;

            var member;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (!this._timelineEvents) {
                      _context3.next = 4;
                      break;
                    }

                    member = this._findPrecedingMemberEventInTimeline(userId, event);

                    if (!member) {
                      _context3.next = 4;
                      break;
                    }

                    return _context3.abrupt("return", member);

                  case 4:
                    member = (_this$_newStateMember = this._newStateMembers) === null || _this$_newStateMember === void 0 ? void 0 : _this$_newStateMember.get(userId);

                    if (!member) {
                      _context3.next = 7;
                      break;
                    }

                    return _context3.abrupt("return", member);

                  case 7:
                    _context3.next = 9;
                    return this._memberWriter.lookupMember(userId, txn);

                  case 9:
                    return _context3.abrupt("return", _context3.sent);

                  case 10:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function lookupMemberAtEvent(_x5, _x6, _x7) {
            return _lookupMemberAtEvent.apply(this, arguments);
          }

          return lookupMemberAtEvent;
        }()
      }, {
        key: "write",
        value: function () {
          var _write = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(txn) {
            var memberChanges, newTimelineMembers, _iterator2, _step2, _newTimelineMembers, member, memberChange, maybeLazyLoadingMember, _iterator3, _step3, _member, _memberChange;

            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    memberChanges = new Map();

                    if (this._timelineEvents) {
                      newTimelineMembers = this._timelineEventsToMembers(this._timelineEvents);
                    }

                    if (!this._newStateMembers) {
                      _context4.next = 23;
                      break;
                    }

                    _iterator2 = _createForOfIteratorHelper(this._newStateMembers.values());
                    _context4.prev = 4;

                    _iterator2.s();

                  case 6:
                    if ((_step2 = _iterator2.n()).done) {
                      _context4.next = 15;
                      break;
                    }

                    member = _step2.value;

                    if ((_newTimelineMembers = newTimelineMembers) === null || _newTimelineMembers === void 0 ? void 0 : _newTimelineMembers.has(member.userId)) {
                      _context4.next = 13;
                      break;
                    }

                    _context4.next = 11;
                    return this._memberWriter._writeMember(member, txn);

                  case 11:
                    memberChange = _context4.sent;

                    if (memberChange) {
                      // if the member event appeared only in the state section,
                      // AND we haven't heard about it AND we haven't fetched all members yet (to avoid #470),
                      // this may be a lazy loading member (if it's not in a gap, we are certain
                      // it is a ll member, in a gap, we can't tell), so we pass in our own membership as
                      // as the previous one so we won't consider it a join to not have false positives (to avoid #192).
                      // see also MemberChange.hasJoined
                      maybeLazyLoadingMember = !this._hasFetchedMembers && !memberChange.previousMembership;

                      if (maybeLazyLoadingMember) {
                        memberChange.previousMembership = member.membership;
                      }

                      memberChanges.set(memberChange.userId, memberChange);
                    }

                  case 13:
                    _context4.next = 6;
                    break;

                  case 15:
                    _context4.next = 20;
                    break;

                  case 17:
                    _context4.prev = 17;
                    _context4.t0 = _context4["catch"](4);

                    _iterator2.e(_context4.t0);

                  case 20:
                    _context4.prev = 20;

                    _iterator2.f();

                    return _context4.finish(20);

                  case 23:
                    if (!newTimelineMembers) {
                      _context4.next = 43;
                      break;
                    }

                    _iterator3 = _createForOfIteratorHelper(newTimelineMembers.values());
                    _context4.prev = 25;

                    _iterator3.s();

                  case 27:
                    if ((_step3 = _iterator3.n()).done) {
                      _context4.next = 35;
                      break;
                    }

                    _member = _step3.value;
                    _context4.next = 31;
                    return this._memberWriter._writeMember(_member, txn);

                  case 31:
                    _memberChange = _context4.sent;

                    if (_memberChange) {
                      memberChanges.set(_memberChange.userId, _memberChange);
                    }

                  case 33:
                    _context4.next = 27;
                    break;

                  case 35:
                    _context4.next = 40;
                    break;

                  case 37:
                    _context4.prev = 37;
                    _context4.t1 = _context4["catch"](25);

                    _iterator3.e(_context4.t1);

                  case 40:
                    _context4.prev = 40;

                    _iterator3.f();

                    return _context4.finish(40);

                  case 43:
                    return _context4.abrupt("return", memberChanges);

                  case 44:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this, [[4, 17, 20, 23], [25, 37, 40, 43]]);
          }));

          function write(_x8) {
            return _write.apply(this, arguments);
          }

          return write;
        }() // try to find the first member event before the given event,
        // so we respect historical display names within the chunk of timeline

      }, {
        key: "_findPrecedingMemberEventInTimeline",
        value: function _findPrecedingMemberEventInTimeline(userId, event) {
          var eventIndex = -1;

          for (var i = this._timelineEvents.length - 1; i >= 0; i--) {
            var e = this._timelineEvents[i];

            if (e.event_id === event.event_id) {
              eventIndex = i;
              break;
            }
          }

          for (var _i = eventIndex - 1; _i >= 0; _i--) {
            var _e = this._timelineEvents[_i];

            if (_e.type === EVENT_TYPE && _e.state_key === userId) {
              var member = RoomMember.fromMemberEvent(this._roomId, _e);

              if (member) {
                return member;
              }
            }
          }
        }
      }, {
        key: "_roomId",
        get: function get() {
          return this._memberWriter._roomId;
        }
      }]);

      return MemberSync;
    }();

    var GapWriter = /*#__PURE__*/function () {
      function GapWriter(_ref) {
        var roomId = _ref.roomId,
            storage = _ref.storage,
            fragmentIdComparer = _ref.fragmentIdComparer,
            relationWriter = _ref.relationWriter;

        _classCallCheck(this, GapWriter);

        this._roomId = roomId;
        this._storage = storage;
        this._fragmentIdComparer = fragmentIdComparer;
        this._relationWriter = relationWriter;
      }

      _createClass(GapWriter, [{
        key: "_findOverlappingEvents",
        value: function () {
          var _findOverlappingEvents2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(fragmentEntry, events, txn, log) {
            var eventIds, existingEventKeyMap, nonOverlappingEvents, neighbourFragmentEntry, _iterator, _step, eventKey, neighbourFragment;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    eventIds = events.map(function (e) {
                      return e.event_id;
                    });
                    _context.next = 3;
                    return txn.timelineEvents.getEventKeysForIds(this._roomId, eventIds);

                  case 3:
                    existingEventKeyMap = _context.sent;
                    log.set("existingEvents", existingEventKeyMap.size);
                    nonOverlappingEvents = events.filter(function (e) {
                      return !existingEventKeyMap.has(e.event_id);
                    });
                    log.set("nonOverlappingEvents", nonOverlappingEvents.length);

                    if (!fragmentEntry.hasLinkedFragment) {
                      _context.next = 31;
                      break;
                    }

                    log.set("linkedFragmentId", fragmentEntry.linkedFragmentId);
                    _iterator = _createForOfIteratorHelper(existingEventKeyMap.values());
                    _context.prev = 10;

                    _iterator.s();

                  case 12:
                    if ((_step = _iterator.n()).done) {
                      _context.next = 23;
                      break;
                    }

                    eventKey = _step.value;

                    if (!(eventKey.fragmentId === fragmentEntry.linkedFragmentId)) {
                      _context.next = 21;
                      break;
                    }

                    log.set("foundLinkedFragment", true);
                    _context.next = 18;
                    return txn.timelineFragments.get(this._roomId, fragmentEntry.linkedFragmentId);

                  case 18:
                    neighbourFragment = _context.sent;
                    neighbourFragmentEntry = fragmentEntry.createNeighbourEntry(neighbourFragment);
                    return _context.abrupt("break", 23);

                  case 21:
                    _context.next = 12;
                    break;

                  case 23:
                    _context.next = 28;
                    break;

                  case 25:
                    _context.prev = 25;
                    _context.t0 = _context["catch"](10);

                    _iterator.e(_context.t0);

                  case 28:
                    _context.prev = 28;

                    _iterator.f();

                    return _context.finish(28);

                  case 31:
                    return _context.abrupt("return", {
                      nonOverlappingEvents: nonOverlappingEvents,
                      neighbourFragmentEntry: neighbourFragmentEntry
                    });

                  case 32:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[10, 25, 28, 31]]);
          }));

          function _findOverlappingEvents(_x, _x2, _x3, _x4) {
            return _findOverlappingEvents2.apply(this, arguments);
          }

          return _findOverlappingEvents;
        }()
      }, {
        key: "_findFragmentEdgeEventKey",
        value: function () {
          var _findFragmentEdgeEventKey2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(fragmentEntry, txn) {
            var fragmentId, direction, event;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    fragmentId = fragmentEntry.fragmentId, direction = fragmentEntry.direction;
                    _context2.next = 3;
                    return this._findFragmentEdgeEvent(fragmentId, direction, txn);

                  case 3:
                    event = _context2.sent;

                    if (!event) {
                      _context2.next = 8;
                      break;
                    }

                    return _context2.abrupt("return", new EventKey(event.fragmentId, event.eventIndex));

                  case 8:
                    return _context2.abrupt("return", EventKey.defaultFragmentKey(fragmentEntry.fragmentId));

                  case 9:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function _findFragmentEdgeEventKey(_x5, _x6) {
            return _findFragmentEdgeEventKey2.apply(this, arguments);
          }

          return _findFragmentEdgeEventKey;
        }()
      }, {
        key: "_findFragmentEdgeEvent",
        value: function () {
          var _findFragmentEdgeEvent2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(fragmentId, direction, txn) {
            var _yield$txn$timelineEv, _yield$txn$timelineEv2, firstEvent, _yield$txn$timelineEv3, _yield$txn$timelineEv4, lastEvent;

            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (!direction.isBackward) {
                      _context3.next = 9;
                      break;
                    }

                    _context3.next = 3;
                    return txn.timelineEvents.firstEvents(this._roomId, fragmentId, 1);

                  case 3:
                    _yield$txn$timelineEv = _context3.sent;
                    _yield$txn$timelineEv2 = _slicedToArray(_yield$txn$timelineEv, 1);
                    firstEvent = _yield$txn$timelineEv2[0];
                    return _context3.abrupt("return", firstEvent);

                  case 9:
                    _context3.next = 11;
                    return txn.timelineEvents.lastEvents(this._roomId, fragmentId, 1);

                  case 11:
                    _yield$txn$timelineEv3 = _context3.sent;
                    _yield$txn$timelineEv4 = _slicedToArray(_yield$txn$timelineEv3, 1);
                    lastEvent = _yield$txn$timelineEv4[0];
                    return _context3.abrupt("return", lastEvent);

                  case 15:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function _findFragmentEdgeEvent(_x7, _x8, _x9) {
            return _findFragmentEdgeEvent2.apply(this, arguments);
          }

          return _findFragmentEdgeEvent;
        }()
      }, {
        key: "_storeEvents",
        value: function () {
          var _storeEvents2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(events, startKey, direction, state, txn, log) {
            var entries, updatedEntries, key, i, event, eventStorageEntry, member, updatedRelationTargetEntries, eventEntry;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    entries = [];
                    updatedEntries = []; // events is in reverse chronological order for backwards pagination,
                    // e.g. order is moving away from the `from` point.

                    key = startKey;
                    i = 0;

                  case 4:
                    if (!(i < events.length)) {
                      _context4.next = 22;
                      break;
                    }

                    event = events[i];
                    key = key.nextKeyForDirection(direction);
                    eventStorageEntry = createEventEntry(key, this._roomId, event);
                    member = this._findMember(event.sender, state, events, i, direction);

                    if (member) {
                      eventStorageEntry.displayName = member.displayName;
                      eventStorageEntry.avatarUrl = member.avatarUrl;
                    } // this will modify eventStorageEntry if it is a relation target


                    _context4.next = 12;
                    return this._relationWriter.writeGapRelation(eventStorageEntry, direction, txn, log);

                  case 12:
                    updatedRelationTargetEntries = _context4.sent;

                    if (updatedRelationTargetEntries) {
                      updatedEntries.push.apply(updatedEntries, _toConsumableArray(updatedRelationTargetEntries));
                    }

                    _context4.next = 16;
                    return txn.timelineEvents.tryInsert(eventStorageEntry, log);

                  case 16:
                    if (!_context4.sent) {
                      _context4.next = 19;
                      break;
                    }

                    eventEntry = new EventEntry(eventStorageEntry, this._fragmentIdComparer);
                    directionalAppend(entries, eventEntry, direction);

                  case 19:
                    ++i;
                    _context4.next = 4;
                    break;

                  case 22:
                    return _context4.abrupt("return", {
                      entries: entries,
                      updatedEntries: updatedEntries
                    });

                  case 23:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function _storeEvents(_x10, _x11, _x12, _x13, _x14, _x15) {
            return _storeEvents2.apply(this, arguments);
          }

          return _storeEvents;
        }()
      }, {
        key: "_findMember",
        value: function _findMember(userId, state, events, index, direction) {
          function isOurUser(event) {
            return event.type === EVENT_TYPE && event.state_key === userId;
          } // older messages are at a higher index in the array when going backwards


          var inc = direction.isBackward ? 1 : -1;

          for (var i = index + inc; i >= 0 && i < events.length; i += inc) {
            var event = events[i];

            if (isOurUser(event)) {
              return RoomMember.fromMemberEvent(this._roomId, event);
            }
          } // look into newer events, but using prev_content if found.
          // We do this before looking into `state` because it is not well specified
          // in the spec whether the events in there represent state before or after `chunk`.
          // So we look both directions first in chunk to make sure it doesn't matter.


          for (var _i = index; _i >= 0 && _i < events.length; _i -= inc) {
            var _event = events[_i];

            if (isOurUser(_event)) {
              return RoomMember.fromReplacingMemberEvent(this._roomId, _event);
            }
          } // assuming the member hasn't changed within the chunk, just take it from state if it's there.
          // Don't assume state is set though, as it can be empty at the top of the timeline in some circumstances 


          var stateMemberEvent = state === null || state === void 0 ? void 0 : state.find(isOurUser);

          if (stateMemberEvent) {
            return RoomMember.fromMemberEvent(this._roomId, stateMemberEvent);
          }
        }
      }, {
        key: "_updateFragments",
        value: function () {
          var _updateFragments2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(fragmentEntry, neighbourFragmentEntry, end, entries, txn, log) {
            var direction, changedFragments;
            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    direction = fragmentEntry.direction;
                    changedFragments = [];
                    directionalAppend(entries, fragmentEntry, direction); // set `end` as token, and if we found an event in the step before, link up the fragments in the fragment entry

                    if (neighbourFragmentEntry) {
                      // if neighbourFragmentEntry was found, it means the events were overlapping,
                      // so no pagination should happen anymore.
                      log.set("closedGapWith", neighbourFragmentEntry.fragmentId);
                      neighbourFragmentEntry.token = null;
                      fragmentEntry.token = null;
                      txn.timelineFragments.update(neighbourFragmentEntry.fragment);
                      directionalAppend(entries, neighbourFragmentEntry, direction); // fragments that need to be changed in the fragmentIdComparer here
                      // after txn succeeds

                      changedFragments.push(fragmentEntry.fragment);
                      changedFragments.push(neighbourFragmentEntry.fragment);
                    } else {
                      fragmentEntry.token = end;
                    }

                    txn.timelineFragments.update(fragmentEntry.fragment);
                    return _context5.abrupt("return", changedFragments);

                  case 6:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5);
          }));

          function _updateFragments(_x16, _x17, _x18, _x19, _x20, _x21) {
            return _updateFragments2.apply(this, arguments);
          }

          return _updateFragments;
        }()
      }, {
        key: "writeFragmentFill",
        value: function () {
          var _writeFragmentFill = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(fragmentEntry, response, txn, log) {
            var _fragmentEntry, fragmentId, direction, chunk, start, state, end, fragment, lastKey, _yield$this$_findOver, nonOverlappingEvents, neighbourFragmentEntry, _yield$this$_storeEve, entries, updatedEntries, fragments;

            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    _fragmentEntry = fragmentEntry, fragmentId = _fragmentEntry.fragmentId, direction = _fragmentEntry.direction; // chunk is in reverse-chronological order when backwards

                    chunk = response.chunk, start = response.start, state = response.state;
                    end = response.end;

                    if (Array.isArray(chunk)) {
                      _context6.next = 5;
                      break;
                    }

                    throw new Error("Invalid chunk in response");

                  case 5:
                    if (!(typeof end !== "string")) {
                      _context6.next = 7;
                      break;
                    }

                    throw new Error("Invalid end token in response");

                  case 7:
                    _context6.next = 9;
                    return txn.timelineFragments.get(this._roomId, fragmentId);

                  case 9:
                    fragment = _context6.sent;

                    if (fragment) {
                      _context6.next = 12;
                      break;
                    }

                    throw new Error("Unknown fragment: ".concat(fragmentId));

                  case 12:
                    fragmentEntry = fragmentEntry.withUpdatedFragment(fragment); // check that the request was done with the token we are aware of (extra care to avoid timeline corruption)

                    if (!(fragmentEntry.token !== start)) {
                      _context6.next = 15;
                      break;
                    }

                    throw new Error("start is not equal to prev_batch or next_batch");

                  case 15:
                    if (!(chunk.length === 0)) {
                      _context6.next = 20;
                      break;
                    }

                    fragmentEntry.edgeReached = true;
                    _context6.next = 19;
                    return txn.timelineFragments.update(fragmentEntry.fragment);

                  case 19:
                    return _context6.abrupt("return", {
                      entries: [fragmentEntry],
                      updatedEntries: [],
                      fragments: []
                    });

                  case 20:
                    _context6.next = 22;
                    return this._findFragmentEdgeEventKey(fragmentEntry, txn);

                  case 22:
                    lastKey = _context6.sent;
                    log.set("lastKey", lastKey.toString()); // find out if any event in chunk is already present using findFirstOrLastOccurringEventId

                    _context6.next = 26;
                    return this._findOverlappingEvents(fragmentEntry, chunk, txn, log);

                  case 26:
                    _yield$this$_findOver = _context6.sent;
                    nonOverlappingEvents = _yield$this$_findOver.nonOverlappingEvents;
                    neighbourFragmentEntry = _yield$this$_findOver.neighbourFragmentEntry;
                    _context6.next = 31;
                    return this._storeEvents(nonOverlappingEvents, lastKey, direction, state, txn, log);

                  case 31:
                    _yield$this$_storeEve = _context6.sent;
                    entries = _yield$this$_storeEve.entries;
                    updatedEntries = _yield$this$_storeEve.updatedEntries;
                    _context6.next = 36;
                    return this._updateFragments(fragmentEntry, neighbourFragmentEntry, end, entries, txn, log);

                  case 36:
                    fragments = _context6.sent;
                    return _context6.abrupt("return", {
                      entries: entries,
                      updatedEntries: updatedEntries,
                      fragments: fragments
                    });

                  case 38:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));

          function writeFragmentFill(_x22, _x23, _x24, _x25) {
            return _writeFragmentFill.apply(this, arguments);
          }

          return writeFragmentFill;
        }()
      }]);

      return GapWriter;
    }();

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */

    /**
     * @license
     * Based off baseSortedIndex function in Lodash <https://lodash.com/>
     * Copyright JS Foundation and other contributors <https://js.foundation/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */
    function sortedIndex(array, value, comparator) {
      var low = 0;
      var high = array.length;

      while (low < high) {
        var mid = low + high >>> 1;
        var cmpResult = comparator(value, array[mid]);

        if (cmpResult > 0) {
          low = mid + 1;
        } else if (cmpResult < 0) {
          high = mid;
        } else {
          low = high = mid;
        }
      }

      return high;
    }

    var BaseObservableMap = /*#__PURE__*/function (_BaseObservable) {
      _inherits(BaseObservableMap, _BaseObservable);

      var _super = _createSuper(BaseObservableMap);

      function BaseObservableMap() {
        _classCallCheck(this, BaseObservableMap);

        return _super.apply(this, arguments);
      }

      _createClass(BaseObservableMap, [{
        key: "emitReset",
        value: function emitReset() {
          var _iterator = _createForOfIteratorHelper(this._handlers),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var h = _step.value;
              h.onReset();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        } // we need batch events, mostly on index based collection though?
        // maybe we should get started without?

      }, {
        key: "emitAdd",
        value: function emitAdd(key, value) {
          var _iterator2 = _createForOfIteratorHelper(this._handlers),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var h = _step2.value;
              h.onAdd(key, value);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      }, {
        key: "emitUpdate",
        value: function emitUpdate(key, value) {
          for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            params[_key - 2] = arguments[_key];
          }

          var _iterator3 = _createForOfIteratorHelper(this._handlers),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var h = _step3.value;
              h.onUpdate.apply(h, [key, value].concat(params));
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      }, {
        key: "emitRemove",
        value: function emitRemove(key, value) {
          var _iterator4 = _createForOfIteratorHelper(this._handlers),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var h = _step4.value;
              h.onRemove(key, value);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }
      }, {
        key: Symbol.iterator,
        value: function value() {
          throw new Error("unimplemented");
        }
      }, {
        key: "get",
        // eslint-disable-next-line no-unused-vars
        value: function get(key) {
          throw new Error("unimplemented");
        }
      }, {
        key: "size",
        get: function get() {
          throw new Error("unimplemented");
        }
      }]);

      return BaseObservableMap;
    }(BaseObservable);

    var ObservableMap = /*#__PURE__*/function (_BaseObservableMap) {
      _inherits(ObservableMap, _BaseObservableMap);

      var _super = _createSuper(ObservableMap);

      function ObservableMap(initialValues) {
        var _this;

        _classCallCheck(this, ObservableMap);

        _this = _super.call(this);
        _this._values = new Map(initialValues);
        return _this;
      }

      _createClass(ObservableMap, [{
        key: "update",
        value: function update(key, params) {
          var value = this._values.get(key);

          if (value !== undefined) {
            // could be the same value, so it's already updated
            // but we don't assume this here
            this._values.set(key, value);

            this.emitUpdate(key, value, params);
            return true;
          }

          return false; // or return existing value?
        }
      }, {
        key: "add",
        value: function add(key, value) {
          if (!this._values.has(key)) {
            this._values.set(key, value);

            this.emitAdd(key, value);
            return true;
          }

          return false; // or return existing value?
        }
      }, {
        key: "remove",
        value: function remove(key) {
          var value = this._values.get(key);

          if (value !== undefined) {
            this._values.delete(key);

            this.emitRemove(key, value);
            return true;
          } else {
            return false;
          }
        }
      }, {
        key: "set",
        value: function set(key, value) {
          if (this._values.has(key)) {
            // We set the value here because update only supports inline updates
            this._values.set(key, value);

            return this.update(key);
          } else {
            return this.add(key, value);
          }
        }
      }, {
        key: "reset",
        value: function reset() {
          this._values.clear();

          this.emitReset();
        }
      }, {
        key: "get",
        value: function get(key) {
          return this._values.get(key);
        }
      }, {
        key: Symbol.iterator,
        value: function value() {
          return this._values.entries();
        }
      }, {
        key: "values",
        value: function values() {
          return this._values.values();
        }
      }, {
        key: "keys",
        value: function keys() {
          return this._values.keys();
        }
      }, {
        key: "size",
        get: function get() {
          return this._values.size;
        }
      }]);

      return ObservableMap;
    }(BaseObservableMap);

    /*

    when a value changes, it sorting order can change. It would still be at the old index prior to firing an onUpdate event.
    So how do you know where it was before it changed, if not by going over all values?

    how to make this fast?

    seems hard to solve with an array, because you need to map the key to it's previous location somehow, to efficiently find it,
    and move it.

    I wonder if we could do better with a binary search tree (BST).
    The tree has a value with {key, value}. There is a plain Map mapping keys to this tuple,
    for easy lookup. Now how do we find the index of this tuple in the BST?

    either we store in every node the amount of nodes on the left and right, or we decend into the part
    of the tree preceding the node we want to know about. Updating the counts upwards would probably be fine as this is log2 of
    the size of the container.

    to be able to go from a key to an index, the value would have the have a link with the tree node though

    so key -> Map<key,value> -> value -> node -> *parentNode -> rootNode
    with a node containing {value, leftCount, rightCount, leftNode, rightNode, parentNode}
    */
    // does not assume whether or not the values are reference
    // types modified outside of the collection (and affecting sort order) or not
    // no duplicates allowed for now

    var SortedMapList = /*#__PURE__*/function (_BaseObservableList) {
      _inherits(SortedMapList, _BaseObservableList);

      var _super = _createSuper(SortedMapList);

      function SortedMapList(sourceMap, comparator) {
        var _this;

        _classCallCheck(this, SortedMapList);

        _this = _super.call(this);
        _this._sourceMap = sourceMap;

        _this._comparator = function (a, b) {
          return comparator(a.value, b.value);
        };

        _this._sortedPairs = null;
        _this._mapSubscription = null;
        return _this;
      }

      _createClass(SortedMapList, [{
        key: "onAdd",
        value: function onAdd(key, value) {
          var pair = {
            key: key,
            value: value
          };
          var idx = sortedIndex(this._sortedPairs, pair, this._comparator);

          this._sortedPairs.splice(idx, 0, pair);

          this.emitAdd(idx, value);
        }
      }, {
        key: "onRemove",
        value: function onRemove(key, value) {
          var pair = {
            key: key,
            value: value
          };
          var idx = sortedIndex(this._sortedPairs, pair, this._comparator); // assert key === this._sortedPairs[idx].key;

          this._sortedPairs.splice(idx, 1);

          this.emitRemove(idx, value);
        }
      }, {
        key: "onUpdate",
        value: function onUpdate(key, value, params) {
          // if an update is emitted while calling source.subscribe() from onSubscribeFirst, ignore it
          if (!this._sortedPairs) {
            return;
          } // TODO: suboptimal for performance, see above for idea with BST to speed this up if we need to


          var oldIdx = this._sortedPairs.findIndex(function (p) {
            return p.key === key;
          }); // neccesary to remove pair from array before
          // doing sortedIndex as it relies on being sorted


          this._sortedPairs.splice(oldIdx, 1);

          var pair = {
            key: key,
            value: value
          };
          var newIdx = sortedIndex(this._sortedPairs, pair, this._comparator);

          this._sortedPairs.splice(newIdx, 0, pair);

          if (oldIdx !== newIdx) {
            this.emitMove(oldIdx, newIdx, value);
          }

          this.emitUpdate(newIdx, value, params);
        }
      }, {
        key: "onReset",
        value: function onReset() {
          this._sortedPairs = [];
          this.emitReset();
        }
      }, {
        key: "onSubscribeFirst",
        value: function onSubscribeFirst() {
          this._mapSubscription = this._sourceMap.subscribe(this);
          this._sortedPairs = new Array(this._sourceMap.size);
          var i = 0;

          var _iterator = _createForOfIteratorHelper(this._sourceMap),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _slicedToArray(_step.value, 2),
                  key = _step$value[0],
                  value = _step$value[1];

              this._sortedPairs[i] = {
                key: key,
                value: value
              };
              ++i;
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          this._sortedPairs.sort(this._comparator);

          _get(_getPrototypeOf(SortedMapList.prototype), "onSubscribeFirst", this).call(this);
        }
      }, {
        key: "onUnsubscribeLast",
        value: function onUnsubscribeLast() {
          _get(_getPrototypeOf(SortedMapList.prototype), "onUnsubscribeLast", this).call(this);

          this._sortedPairs = null;
          this._mapSubscription = this._mapSubscription();
        }
      }, {
        key: "get",
        value: function get(index) {
          return this._sortedPairs[index].value;
        }
      }, {
        key: Symbol.iterator,
        value: function value() {
          var it = this._sortedPairs.values();

          return {
            next: function next() {
              var v = it.next();

              if (v.value) {
                v.value = v.value.value;
              }

              return v;
            }
          };
        }
      }, {
        key: "length",
        get: function get() {
          return this._sourceMap.size;
        }
      }]);

      return SortedMapList;
    }(BaseObservableList);

    var FilteredMap = /*#__PURE__*/function (_BaseObservableMap) {
      _inherits(FilteredMap, _BaseObservableMap);

      var _super = _createSuper(FilteredMap);

      function FilteredMap(source, filter) {
        var _this;

        _classCallCheck(this, FilteredMap);

        _this = _super.call(this);
        _this._source = source;
        _this._filter = filter;
        /** @type {Map<string, bool>} */

        _this._included = null;
        _this._subscription = null;
        return _this;
      }

      _createClass(FilteredMap, [{
        key: "setFilter",
        value: function setFilter(filter) {
          this._filter = filter;

          if (this._subscription) {
            this._reapplyFilter();
          }
        }
        /**
         * reapply the filter
         */

      }, {
        key: "_reapplyFilter",
        value: function _reapplyFilter() {
          var silent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          if (this._filter) {
            var oldIncluded = this._included;
            this._included = this._included || new Map();

            var _iterator = _createForOfIteratorHelper(this._source),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var _step$value = _slicedToArray(_step.value, 2),
                    key = _step$value[0],
                    value = _step$value[1];

                var isIncluded = this._filter(value, key);

                this._included.set(key, isIncluded);

                if (!silent) {
                  var wasIncluded = oldIncluded ? oldIncluded.get(key) : true;

                  this._emitForUpdate(wasIncluded, isIncluded, key, value);
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          } else {
            // no filter
            // did we have a filter before?
            if (this._included && !silent) {
              // add any non-included items again
              var _iterator2 = _createForOfIteratorHelper(this._source),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var _step2$value = _slicedToArray(_step2.value, 2),
                      _key = _step2$value[0],
                      _value = _step2$value[1];

                  if (!this._included.get(_key)) {
                    this.emitAdd(_key, _value);
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }

            this._included = null;
          }
        }
      }, {
        key: "onAdd",
        value: function onAdd(key, value) {
          if (this._filter) {
            var included = this._filter(value, key);

            this._included.set(key, included);

            if (!included) {
              return;
            }
          }

          this.emitAdd(key, value);
        }
      }, {
        key: "onRemove",
        value: function onRemove(key, value) {
          var wasIncluded = !this._filter || this._included.get(key);

          this._included.delete(key);

          if (wasIncluded) {
            this.emitRemove(key, value);
          }
        }
      }, {
        key: "onUpdate",
        value: function onUpdate(key, value, params) {
          // if an update is emitted while calling source.subscribe() from onSubscribeFirst, ignore it
          if (!this._included) {
            return;
          }

          if (this._filter) {
            var wasIncluded = this._included.get(key);

            var isIncluded = this._filter(value, key);

            this._included.set(key, isIncluded);

            this._emitForUpdate(wasIncluded, isIncluded, key, value, params);
          } else {
            this.emitUpdate(key, value, params);
          }
        }
      }, {
        key: "_emitForUpdate",
        value: function _emitForUpdate(wasIncluded, isIncluded, key, value) {
          var params = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

          if (wasIncluded && !isIncluded) {
            this.emitRemove(key, value);
          } else if (!wasIncluded && isIncluded) {
            this.emitAdd(key, value);
          } else if (wasIncluded && isIncluded) {
            this.emitUpdate(key, value, params);
          }
        }
      }, {
        key: "onSubscribeFirst",
        value: function onSubscribeFirst() {
          this._subscription = this._source.subscribe(this);

          this._reapplyFilter(true);

          _get(_getPrototypeOf(FilteredMap.prototype), "onSubscribeFirst", this).call(this);
        }
      }, {
        key: "onUnsubscribeLast",
        value: function onUnsubscribeLast() {
          _get(_getPrototypeOf(FilteredMap.prototype), "onUnsubscribeLast", this).call(this);

          this._included = null;
          this._subscription = this._subscription();
        }
      }, {
        key: "onReset",
        value: function onReset() {
          this._reapplyFilter();

          this.emitReset();
        }
      }, {
        key: Symbol.iterator,
        value: function value() {
          return new FilterIterator(this._source, this._included);
        }
      }, {
        key: "get",
        value: function get(key) {
          var value = this._source.get(key);

          if (value && this._filter(value, key)) {
            return value;
          }
        }
      }, {
        key: "size",
        get: function get() {
          var count = 0;

          this._included.forEach(function (included) {
            if (included) {
              count += 1;
            }
          });

          return count;
        }
      }]);

      return FilteredMap;
    }(BaseObservableMap);

    var FilterIterator = /*#__PURE__*/function () {
      function FilterIterator(map, _included) {
        _classCallCheck(this, FilterIterator);

        this._included = _included;
        this._sourceIterator = map[Symbol.iterator]();
      }

      _createClass(FilterIterator, [{
        key: "next",
        value: function next() {
          // eslint-disable-next-line no-constant-condition
          while (true) {
            var sourceResult = this._sourceIterator.next();

            if (sourceResult.done) {
              return sourceResult;
            }

            var key = sourceResult.value[0];

            if (this._included.get(key)) {
              return sourceResult;
            }
          }
        }
      }]);

      return FilterIterator;
    }();

    /*
    so a mapped value can emit updates on it's own with this._emitSpontaneousUpdate that is passed in the mapping function
    how should the mapped value be notified of an update though? and can it then decide to not propagate the update?
    */

    var MappedMap = /*#__PURE__*/function (_BaseObservableMap) {
      _inherits(MappedMap, _BaseObservableMap);

      var _super = _createSuper(MappedMap);

      function MappedMap(source, mapper, updater) {
        var _this;

        _classCallCheck(this, MappedMap);

        _this = _super.call(this);
        _this._source = source;
        _this._mapper = mapper;
        _this._updater = updater;
        _this._mappedValues = new Map();
        return _this;
      }

      _createClass(MappedMap, [{
        key: "_emitSpontaneousUpdate",
        value: function _emitSpontaneousUpdate(key, params) {
          var value = this._mappedValues.get(key);

          if (value) {
            this.emitUpdate(key, value, params);
          }
        }
      }, {
        key: "onAdd",
        value: function onAdd(key, value) {
          var emitSpontaneousUpdate = this._emitSpontaneousUpdate.bind(this, key);

          var mappedValue = this._mapper(value, emitSpontaneousUpdate);

          this._mappedValues.set(key, mappedValue);

          this.emitAdd(key, mappedValue);
        }
      }, {
        key: "onRemove",
        value: function onRemove(key
        /*, _value*/
        ) {
          var mappedValue = this._mappedValues.get(key);

          if (this._mappedValues.delete(key)) {
            this.emitRemove(key, mappedValue);
          }
        }
      }, {
        key: "onUpdate",
        value: function onUpdate(key, value, params) {
          // if an update is emitted while calling source.subscribe() from onSubscribeFirst, ignore it
          if (!this._mappedValues) {
            return;
          }

          var mappedValue = this._mappedValues.get(key);

          if (mappedValue !== undefined) {
            var _this$_updater;

            (_this$_updater = this._updater) === null || _this$_updater === void 0 ? void 0 : _this$_updater.call(this, mappedValue, params, value); // TODO: map params somehow if needed?

            this.emitUpdate(key, mappedValue, params);
          }
        }
      }, {
        key: "onSubscribeFirst",
        value: function onSubscribeFirst() {
          this._subscription = this._source.subscribe(this);

          var _iterator = _createForOfIteratorHelper(this._source),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _slicedToArray(_step.value, 2),
                  key = _step$value[0],
                  value = _step$value[1];

              var emitSpontaneousUpdate = this._emitSpontaneousUpdate.bind(this, key);

              var mappedValue = this._mapper(value, emitSpontaneousUpdate);

              this._mappedValues.set(key, mappedValue);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          _get(_getPrototypeOf(MappedMap.prototype), "onSubscribeFirst", this).call(this);
        }
      }, {
        key: "onUnsubscribeLast",
        value: function onUnsubscribeLast() {
          _get(_getPrototypeOf(MappedMap.prototype), "onUnsubscribeLast", this).call(this);

          this._subscription = this._subscription();

          this._mappedValues.clear();
        }
      }, {
        key: "onReset",
        value: function onReset() {
          this._mappedValues.clear();

          this.emitReset();
        }
      }, {
        key: Symbol.iterator,
        value: function value() {
          return this._mappedValues.entries();
        }
      }, {
        key: "get",
        value: function get(key) {
          return this._mappedValues.get(key);
        }
      }, {
        key: "size",
        get: function get() {
          return this._mappedValues.size;
        }
      }]);

      return MappedMap;
    }(BaseObservableMap);

    var JoinedMap = /*#__PURE__*/function (_BaseObservableMap) {
      _inherits(JoinedMap, _BaseObservableMap);

      var _super = _createSuper(JoinedMap);

      function JoinedMap(sources) {
        var _this;

        _classCallCheck(this, JoinedMap);

        _this = _super.call(this);
        _this._sources = sources;
        _this._subscriptions = null;
        return _this;
      }

      _createClass(JoinedMap, [{
        key: "onAdd",
        value: function onAdd(source, key, value) {
          if (!this._isKeyAtSourceOccluded(source, key)) {
            var occludingValue = this._getValueFromOccludedSources(source, key);

            if (occludingValue !== undefined) {
              // adding a value that will occlude another one should
              // first emit a remove
              this.emitRemove(key, occludingValue);
            }

            this.emitAdd(key, value);
          }
        }
      }, {
        key: "onRemove",
        value: function onRemove(source, key, value) {
          if (!this._isKeyAtSourceOccluded(source, key)) {
            this.emitRemove(key, value);

            var occludedValue = this._getValueFromOccludedSources(source, key);

            if (occludedValue !== undefined) {
              // removing a value that so far occluded another one should
              // emit an add for the occluded value after the removal
              this.emitAdd(key, occludedValue);
            }
          }
        }
      }, {
        key: "onUpdate",
        value: function onUpdate(source, key, value, params) {
          // if an update is emitted while calling source.subscribe() from onSubscribeFirst, ignore it
          if (!this._subscriptions) {
            return;
          }

          if (!this._isKeyAtSourceOccluded(source, key)) {
            this.emitUpdate(key, value, params);
          }
        }
      }, {
        key: "onReset",
        value: function onReset() {
          this.emitReset();
        }
      }, {
        key: "onSubscribeFirst",
        value: function onSubscribeFirst() {
          var _this2 = this;

          this._subscriptions = this._sources.map(function (source) {
            return new SourceSubscriptionHandler(source, _this2).subscribe();
          });

          _get(_getPrototypeOf(JoinedMap.prototype), "onSubscribeFirst", this).call(this);
        }
      }, {
        key: "_isKeyAtSourceOccluded",
        value: function _isKeyAtSourceOccluded(source, key) {
          // sources that come first in the sources array can
          // hide the keys in later sources, to prevent events
          // being emitted for the same key and different values,
          // so check the key is not present in earlier sources
          var index = this._sources.indexOf(source);

          for (var i = 0; i < index; i += 1) {
            if (this._sources[i].get(key) !== undefined) {
              return true;
            }
          }

          return false;
        } // get the value that the given source and key occlude, if any

      }, {
        key: "_getValueFromOccludedSources",
        value: function _getValueFromOccludedSources(source, key) {
          // sources that come first in the sources array can
          // hide the keys in later sources, to prevent events
          // being emitted for the same key and different values,
          // so check the key is not present in earlier sources
          var index = this._sources.indexOf(source);

          for (var i = index + 1; i < this._sources.length; i += 1) {
            var _source = this._sources[i];

            var occludedValue = _source.get(key);

            if (occludedValue !== undefined) {
              return occludedValue;
            }
          }

          return undefined;
        }
      }, {
        key: "onUnsubscribeLast",
        value: function onUnsubscribeLast() {
          _get(_getPrototypeOf(JoinedMap.prototype), "onUnsubscribeLast", this).call(this);

          var _iterator = _createForOfIteratorHelper(this._subscriptions),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var s = _step.value;
              s.dispose();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }, {
        key: Symbol.iterator,
        value: function value() {
          return new JoinedIterator(this._sources);
        }
      }, {
        key: "get",
        value: function get(key) {
          var _iterator2 = _createForOfIteratorHelper(this._sources),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var s = _step2.value;
              var value = s.get(key);

              if (value) {
                return value;
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          return null;
        }
      }, {
        key: "size",
        get: function get() {
          return this._sources.reduce(function (sum, s) {
            return sum + s.size;
          }, 0);
        }
      }]);

      return JoinedMap;
    }(BaseObservableMap);

    var JoinedIterator = /*#__PURE__*/function () {
      function JoinedIterator(sources) {
        _classCallCheck(this, JoinedIterator);

        this._sources = sources;
        this._sourceIndex = -1;
        this._currentIterator = null;
        this._encounteredKeys = new Set();
      }

      _createClass(JoinedIterator, [{
        key: "next",
        value: function next() {
          var result;

          while (!result) {
            if (!this._currentIterator) {
              this._sourceIndex += 1;

              if (this._sources.length <= this._sourceIndex) {
                return {
                  done: true
                };
              }

              this._currentIterator = this._sources[this._sourceIndex][Symbol.iterator]();
            }

            var sourceResult = this._currentIterator.next();

            if (sourceResult.done) {
              this._currentIterator = null;
              continue;
            } else {
              var key = sourceResult.value[0];

              if (!this._encounteredKeys.has(key)) {
                this._encounteredKeys.add(key);

                result = sourceResult;
              }
            }
          }

          return result;
        }
      }]);

      return JoinedIterator;
    }();

    var SourceSubscriptionHandler = /*#__PURE__*/function () {
      function SourceSubscriptionHandler(source, joinedMap) {
        _classCallCheck(this, SourceSubscriptionHandler);

        this._source = source;
        this._joinedMap = joinedMap;
        this._subscription = null;
      }

      _createClass(SourceSubscriptionHandler, [{
        key: "subscribe",
        value: function subscribe() {
          this._subscription = this._source.subscribe(this);
          return this;
        }
      }, {
        key: "dispose",
        value: function dispose() {
          this._subscription = this._subscription();
        }
      }, {
        key: "onAdd",
        value: function onAdd(key, value) {
          this._joinedMap.onAdd(this._source, key, value);
        }
      }, {
        key: "onRemove",
        value: function onRemove(key, value) {
          this._joinedMap.onRemove(this._source, key, value);
        }
      }, {
        key: "onUpdate",
        value: function onUpdate(key, value, params) {
          this._joinedMap.onUpdate(this._source, key, value, params);
        }
      }, {
        key: "onReset",
        value: function onReset() {
          this._joinedMap.onReset(this._source);
        }
      }]);

      return SourceSubscriptionHandler;
    }();

    function findAndUpdateInArray(predicate, array, observable, updater) {
      var index = array.findIndex(predicate);

      if (index !== -1) {
        var value = array[index];
        var params = updater(value);

        if (params !== false) {
          observable.emitUpdate(index, value, params);
        }

        return true;
      }

      return false;
    }

    var SortedArray = /*#__PURE__*/function (_BaseObservableList) {
      _inherits(SortedArray, _BaseObservableList);

      var _super = _createSuper(SortedArray);

      function SortedArray(comparator) {
        var _this;

        _classCallCheck(this, SortedArray);

        _this = _super.call(this);
        _this._comparator = comparator;
        _this._items = [];
        return _this;
      }

      _createClass(SortedArray, [{
        key: "setManyUnsorted",
        value: function setManyUnsorted(items) {
          this.setManySorted(items);
        }
      }, {
        key: "setManySorted",
        value: function setManySorted(items) {
          // TODO: we can make this way faster by only looking up the first and last key,
          // and merging whatever is inbetween with items
          // if items is not sorted, 💩🌀 will follow!
          // should we check?
          // Also, once bulk events are supported in collections,
          // we can do a bulk add event here probably if there are no updates
          // BAD CODE!
          var _iterator = _createForOfIteratorHelper(items),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var item = _step.value;
              this.set(item);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }, {
        key: "findAndUpdate",
        value: function findAndUpdate(predicate, updater) {
          return findAndUpdateInArray(predicate, this._items, this, updater);
        }
      }, {
        key: "getAndUpdate",
        value: function getAndUpdate(item, updater) {
          var updateParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          var idx = this.indexOf(item);

          if (idx !== -1) {
            var existingItem = this._items[idx];
            var newItem = updater(existingItem, item);
            this._items[idx] = newItem;
            this.emitUpdate(idx, newItem, updateParams);
          }
        }
      }, {
        key: "update",
        value: function update(item) {
          var updateParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var idx = this.indexOf(item);

          if (idx !== -1) {
            this._items[idx] = item;
            this.emitUpdate(idx, item, updateParams);
          }
        }
      }, {
        key: "indexOf",
        value: function indexOf(item) {
          var idx = sortedIndex(this._items, item, this._comparator);

          if (idx < this._items.length && this._comparator(this._items[idx], item) === 0) {
            return idx;
          } else {
            return -1;
          }
        }
      }, {
        key: "_getNext",
        value: function _getNext(item) {
          var idx = sortedIndex(this._items, item, this._comparator);

          while (idx < this._items.length && this._comparator(this._items[idx], item) <= 0) {
            idx += 1;
          }

          return this.get(idx);
        }
      }, {
        key: "set",
        value: function set(item) {
          var updateParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var idx = sortedIndex(this._items, item, this._comparator);

          if (idx >= this._items.length || this._comparator(this._items[idx], item) !== 0) {
            this._items.splice(idx, 0, item);

            this.emitAdd(idx, item);
          } else {
            this._items[idx] = item;
            this.emitUpdate(idx, item, updateParams);
          }
        }
      }, {
        key: "get",
        value: function get(idx) {
          return this._items[idx];
        }
      }, {
        key: "remove",
        value: function remove(idx) {
          var item = this._items[idx];

          this._items.splice(idx, 1);

          this.emitRemove(idx, item);
        }
      }, {
        key: Symbol.iterator,
        value: function value() {
          return new Iterator(this);
        }
      }, {
        key: "array",
        get: function get() {
          return this._items;
        }
      }, {
        key: "length",
        get: function get() {
          return this._items.length;
        }
      }]);

      return SortedArray;
    }(BaseObservableList); // iterator that works even if the current value is removed while iterating

    var Iterator = /*#__PURE__*/function () {
      function Iterator(sortedArray) {
        _classCallCheck(this, Iterator);

        this._sortedArray = sortedArray;
        this._current = null;
      }

      _createClass(Iterator, [{
        key: "next",
        value: function next() {
          if (this._sortedArray) {
            if (this._current) {
              this._current = this._sortedArray._getNext(this._current);
            } else {
              this._current = this._sortedArray.get(0);
            }

            if (this._current) {
              return {
                value: this._current
              };
            } else {
              // cause done below
              this._sortedArray = null;
            }
          }

          if (!this._sortedArray) {
            return {
              done: true
            };
          }
        }
      }]);

      return Iterator;
    }();

    var BaseMappedList = /*#__PURE__*/function (_BaseObservableList) {
      _inherits(BaseMappedList, _BaseObservableList);

      var _super = _createSuper(BaseMappedList);

      function BaseMappedList(sourceList, mapper, updater, removeCallback) {
        var _this;

        _classCallCheck(this, BaseMappedList);

        _this = _super.call(this);
        _this._sourceUnsubscribe = null;
        _this._mappedValues = null;
        _this._sourceList = sourceList;
        _this._mapper = mapper;
        _this._updater = updater;
        _this._removeCallback = removeCallback;
        return _this;
      }

      _createClass(BaseMappedList, [{
        key: "findAndUpdate",
        value: function findAndUpdate(predicate, updater) {
          return findAndUpdateInArray(predicate, this._mappedValues, this, updater);
        }
      }, {
        key: Symbol.iterator,
        value: function value() {
          return this._mappedValues.values();
        }
      }, {
        key: "length",
        get: function get() {
          return this._mappedValues.length;
        }
      }]);

      return BaseMappedList;
    }(BaseObservableList);
    function runAdd(list, index, mappedValue) {
      list._mappedValues.splice(index, 0, mappedValue);

      list.emitAdd(index, mappedValue);
    }
    function runUpdate(list, index, value, params) {
      var mappedValue = list._mappedValues[index];

      if (list._updater) {
        list._updater(mappedValue, params, value);
      }

      list.emitUpdate(index, mappedValue, params);
    }
    function runRemove(list, index) {
      var mappedValue = list._mappedValues[index];

      list._mappedValues.splice(index, 1);

      if (list._removeCallback) {
        list._removeCallback(mappedValue);
      }

      list.emitRemove(index, mappedValue);
    }
    function runMove(list, fromIdx, toIdx) {
      var mappedValue = list._mappedValues[fromIdx];

      list._mappedValues.splice(fromIdx, 1);

      list._mappedValues.splice(toIdx, 0, mappedValue);

      list.emitMove(fromIdx, toIdx, mappedValue);
    }
    function runReset(list) {
      list._mappedValues = [];
      list.emitReset();
    }

    var AsyncMappedList = /*#__PURE__*/function (_BaseMappedList) {
      _inherits(AsyncMappedList, _BaseMappedList);

      var _super = _createSuper(AsyncMappedList);

      function AsyncMappedList(sourceList, mapper, updater, removeCallback) {
        var _this;

        _classCallCheck(this, AsyncMappedList);

        _this = _super.call(this, sourceList, mapper, updater, removeCallback);
        _this._eventQueue = null;
        return _this;
      }

      _createClass(AsyncMappedList, [{
        key: "onSubscribeFirst",
        value: function onSubscribeFirst() {
          this._sourceUnsubscribe = this._sourceList.subscribe(this);
          this._eventQueue = [];
          this._mappedValues = [];
          var idx = 0;

          var _iterator = _createForOfIteratorHelper(this._sourceList),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var item = _step.value;

              this._eventQueue.push(new AddEvent(idx, item));

              idx += 1;
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          this._flush();
        }
      }, {
        key: "_flush",
        value: function () {
          var _flush2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var event;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!this._flushing) {
                      _context.next = 2;
                      break;
                    }

                    return _context.abrupt("return");

                  case 2:
                    this._flushing = true;
                    _context.prev = 3;

                  case 4:
                    if (!this._eventQueue.length) {
                      _context.next = 10;
                      break;
                    }

                    event = this._eventQueue.shift();
                    _context.next = 8;
                    return event.run(this);

                  case 8:
                    _context.next = 4;
                    break;

                  case 10:
                    _context.prev = 10;
                    this._flushing = false;
                    return _context.finish(10);

                  case 13:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[3,, 10, 13]]);
          }));

          function _flush() {
            return _flush2.apply(this, arguments);
          }

          return _flush;
        }()
      }, {
        key: "onReset",
        value: function onReset() {
          if (this._eventQueue) {
            this._eventQueue.push(new ResetEvent());

            this._flush();
          }
        }
      }, {
        key: "onAdd",
        value: function onAdd(index, value) {
          if (this._eventQueue) {
            this._eventQueue.push(new AddEvent(index, value));

            this._flush();
          }
        }
      }, {
        key: "onUpdate",
        value: function onUpdate(index, value, params) {
          if (this._eventQueue) {
            this._eventQueue.push(new UpdateEvent(index, value, params));

            this._flush();
          }
        }
      }, {
        key: "onRemove",
        value: function onRemove(index) {
          if (this._eventQueue) {
            this._eventQueue.push(new RemoveEvent(index));

            this._flush();
          }
        }
      }, {
        key: "onMove",
        value: function onMove(fromIdx, toIdx) {
          if (this._eventQueue) {
            this._eventQueue.push(new MoveEvent(fromIdx, toIdx));

            this._flush();
          }
        }
      }, {
        key: "onUnsubscribeLast",
        value: function onUnsubscribeLast() {
          this._sourceUnsubscribe();

          this._eventQueue = null;
          this._mappedValues = null;
        }
      }]);

      return AsyncMappedList;
    }(BaseMappedList);

    var AddEvent = /*#__PURE__*/function () {
      function AddEvent(index, value) {
        _classCallCheck(this, AddEvent);

        this.index = index;
        this.value = value;
      }

      _createClass(AddEvent, [{
        key: "run",
        value: function () {
          var _run = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(list) {
            var mappedValue;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return list._mapper(this.value);

                  case 2:
                    mappedValue = _context2.sent;
                    runAdd(list, this.index, mappedValue);

                  case 4:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function run(_x) {
            return _run.apply(this, arguments);
          }

          return run;
        }()
      }]);

      return AddEvent;
    }();

    var UpdateEvent = /*#__PURE__*/function () {
      function UpdateEvent(index, value, params) {
        _classCallCheck(this, UpdateEvent);

        this.index = index;
        this.value = value;
        this.params = params;
      }

      _createClass(UpdateEvent, [{
        key: "run",
        value: function () {
          var _run2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(list) {
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    runUpdate(list, this.index, this.value, this.params);

                  case 1:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function run(_x2) {
            return _run2.apply(this, arguments);
          }

          return run;
        }()
      }]);

      return UpdateEvent;
    }();

    var RemoveEvent = /*#__PURE__*/function () {
      function RemoveEvent(index) {
        _classCallCheck(this, RemoveEvent);

        this.index = index;
      }

      _createClass(RemoveEvent, [{
        key: "run",
        value: function () {
          var _run3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(list) {
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    runRemove(list, this.index);

                  case 1:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function run(_x3) {
            return _run3.apply(this, arguments);
          }

          return run;
        }()
      }]);

      return RemoveEvent;
    }();

    var MoveEvent = /*#__PURE__*/function () {
      function MoveEvent(fromIdx, toIdx) {
        _classCallCheck(this, MoveEvent);

        this.fromIdx = fromIdx;
        this.toIdx = toIdx;
      }

      _createClass(MoveEvent, [{
        key: "run",
        value: function () {
          var _run4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(list) {
            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    runMove(list, this.fromIdx, this.toIdx);

                  case 1:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));

          function run(_x4) {
            return _run4.apply(this, arguments);
          }

          return run;
        }()
      }]);

      return MoveEvent;
    }();

    var ResetEvent = /*#__PURE__*/function () {
      function ResetEvent() {
        _classCallCheck(this, ResetEvent);
      }

      _createClass(ResetEvent, [{
        key: "run",
        value: function () {
          var _run5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(list) {
            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    runReset(list);

                  case 1:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6);
          }));

          function run(_x5) {
            return _run5.apply(this, arguments);
          }

          return run;
        }()
      }]);

      return ResetEvent;
    }();

    var ConcatList = /*#__PURE__*/function (_BaseObservableList) {
      _inherits(ConcatList, _BaseObservableList);

      var _super = _createSuper(ConcatList);

      function ConcatList() {
        var _this;

        _classCallCheck(this, ConcatList);

        _this = _super.call(this);

        for (var _len = arguments.length, sourceLists = new Array(_len), _key = 0; _key < _len; _key++) {
          sourceLists[_key] = arguments[_key];
        }

        _this._sourceLists = sourceLists;
        _this._sourceUnsubscribes = null;
        return _this;
      }

      _createClass(ConcatList, [{
        key: "_offsetForSource",
        value: function _offsetForSource(sourceList) {
          var listIdx = this._sourceLists.indexOf(sourceList);

          var offset = 0;

          for (var i = 0; i < listIdx; ++i) {
            offset += this._sourceLists[i].length;
          }

          return offset;
        }
      }, {
        key: "onSubscribeFirst",
        value: function onSubscribeFirst() {
          var _this2 = this;

          this._sourceUnsubscribes = this._sourceLists.map(function (sourceList) {
            return sourceList.subscribe(_this2);
          });
        }
      }, {
        key: "onUnsubscribeLast",
        value: function onUnsubscribeLast() {
          var _iterator = _createForOfIteratorHelper(this._sourceUnsubscribes),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var sourceUnsubscribe = _step.value;
              sourceUnsubscribe();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }, {
        key: "onReset",
        value: function onReset() {
          // TODO: not ideal if other source lists are large
          // but working impl for now
          // reset, and 
          this.emitReset();
          var idx = 0;

          var _iterator2 = _createForOfIteratorHelper(this),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var item = _step2.value;
              this.emitAdd(idx, item);
              idx += 1;
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      }, {
        key: "onAdd",
        value: function onAdd(index, value, sourceList) {
          this.emitAdd(this._offsetForSource(sourceList) + index, value);
        }
      }, {
        key: "onUpdate",
        value: function onUpdate(index, value, params, sourceList) {
          // if an update is emitted while calling source.subscribe() from onSubscribeFirst, ignore it
          // as we are not supposed to call `length` on any uninitialized list
          if (!this._sourceUnsubscribes) {
            return;
          }

          this.emitUpdate(this._offsetForSource(sourceList) + index, value, params);
        }
      }, {
        key: "onRemove",
        value: function onRemove(index, value, sourceList) {
          this.emitRemove(this._offsetForSource(sourceList) + index, value);
        }
      }, {
        key: "onMove",
        value: function onMove(fromIdx, toIdx, value, sourceList) {
          var offset = this._offsetForSource(sourceList);

          this.emitMove(offset + fromIdx, offset + toIdx, value);
        }
      }, {
        key: Symbol.iterator,
        value: function value() {
          var _this3 = this;

          var sourceListIdx = 0;

          var it = this._sourceLists[0][Symbol.iterator]();

          return {
            next: function next() {
              var result = it.next();

              while (result.done) {
                sourceListIdx += 1;

                if (sourceListIdx >= _this3._sourceLists.length) {
                  return result; //done
                }

                it = _this3._sourceLists[sourceListIdx][Symbol.iterator]();
                result = it.next();
              }

              return result;
            }
          };
        }
      }, {
        key: "length",
        get: function get() {
          var len = 0;

          for (var i = 0; i < this._sourceLists.length; ++i) {
            len += this._sourceLists[i].length;
          }

          return len;
        }
      }]);

      return ConcatList;
    }(BaseObservableList);

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    // and BaseObservableMap (as they extend it)

    Object.assign(BaseObservableMap.prototype, {
      sortValues: function sortValues(comparator) {
        return new SortedMapList(this, comparator);
      },
      mapValues: function mapValues(mapper, updater) {
        return new MappedMap(this, mapper, updater);
      },
      filterValues: function filterValues(filter) {
        return new FilteredMap(this, filter);
      },
      join: function join() {
        for (var _len = arguments.length, otherMaps = new Array(_len), _key = 0; _key < _len; _key++) {
          otherMaps[_key] = arguments[_key];
        }

        return new JoinedMap([this].concat(otherMaps));
      }
    });

    var ReaderRequest = /*#__PURE__*/function () {
      function ReaderRequest(fn, log) {
        _classCallCheck(this, ReaderRequest);

        this.decryptRequest = null;
        this._promise = fn(this, log);
      }

      _createClass(ReaderRequest, [{
        key: "complete",
        value: function complete() {
          return this._promise;
        }
      }, {
        key: "dispose",
        value: function dispose() {
          if (this.decryptRequest) {
            this.decryptRequest.dispose();
            this.decryptRequest = null;
          }
        }
      }]);

      return ReaderRequest;
    }();
    /**
     * Raw because it doesn't do decryption and in the future it should not read relations either.
     * It is just about reading entries and following fragment links
     */


    function readRawTimelineEntriesWithTxn(_x, _x2, _x3, _x4, _x5, _x6) {
      return _readRawTimelineEntriesWithTxn.apply(this, arguments);
    }

    function _readRawTimelineEntriesWithTxn() {
      _readRawTimelineEntriesWithTxn = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(roomId, eventKey, direction, amount, fragmentIdComparer, txn) {
        var entries, timelineStore, fragmentStore, eventsWithinFragment, eventEntries, fragment, fragmentEntry, nextFragment, nextFragmentEntry;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                entries = [];
                timelineStore = txn.timelineEvents;
                fragmentStore = txn.timelineFragments;

              case 3:
                if (!(entries.length < amount && eventKey)) {
                  _context4.next = 35;
                  break;
                }

                eventsWithinFragment = void 0;

                if (!direction.isForward) {
                  _context4.next = 11;
                  break;
                }

                _context4.next = 8;
                return timelineStore.eventsAfter(roomId, eventKey, amount);

              case 8:
                eventsWithinFragment = _context4.sent;
                _context4.next = 14;
                break;

              case 11:
                _context4.next = 13;
                return timelineStore.eventsBefore(roomId, eventKey, amount);

              case 13:
                eventsWithinFragment = _context4.sent;

              case 14:
                eventEntries = eventsWithinFragment.map(function (e) {
                  return new EventEntry(e, fragmentIdComparer);
                });
                entries = directionalConcat(entries, eventEntries, direction); // prepend or append eventsWithinFragment to entries, and wrap them in EventEntry

                if (!(entries.length < amount)) {
                  _context4.next = 33;
                  break;
                }

                _context4.next = 19;
                return fragmentStore.get(roomId, eventKey.fragmentId);

              case 19:
                fragment = _context4.sent;
                // TODO: why does the first fragment not need to be added? (the next *is* added below)
                // it looks like this would be fine when loading in the sync island
                // (as the live fragment should be added already) but not for permalinks when we support them
                // 
                // fragmentIdComparer.addFragment(fragment);
                fragmentEntry = new FragmentBoundaryEntry(fragment, direction.isBackward, fragmentIdComparer); // append or prepend fragmentEntry, reuse func from GapWriter?

                directionalAppend(entries, fragmentEntry, direction); // only continue loading if the fragment boundary can't be backfilled

                if (!(!fragmentEntry.token && fragmentEntry.hasLinkedFragment)) {
                  _context4.next = 32;
                  break;
                }

                _context4.next = 25;
                return fragmentStore.get(roomId, fragmentEntry.linkedFragmentId);

              case 25:
                nextFragment = _context4.sent;
                fragmentIdComparer.add(nextFragment);
                nextFragmentEntry = new FragmentBoundaryEntry(nextFragment, direction.isForward, fragmentIdComparer);
                directionalAppend(entries, nextFragmentEntry, direction);
                eventKey = nextFragmentEntry.asEventKey();
                _context4.next = 33;
                break;

              case 32:
                eventKey = null;

              case 33:
                _context4.next = 3;
                break;

              case 35:
                return _context4.abrupt("return", entries);

              case 36:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      return _readRawTimelineEntriesWithTxn.apply(this, arguments);
    }

    var TimelineReader = /*#__PURE__*/function () {
      function TimelineReader(_ref) {
        var roomId = _ref.roomId,
            storage = _ref.storage,
            fragmentIdComparer = _ref.fragmentIdComparer;

        _classCallCheck(this, TimelineReader);

        this._roomId = roomId;
        this._storage = storage;
        this._fragmentIdComparer = fragmentIdComparer;
        this._decryptEntries = null;
      }

      _createClass(TimelineReader, [{
        key: "enableEncryption",
        value: function enableEncryption(decryptEntries) {
          this._decryptEntries = decryptEntries;
        }
      }, {
        key: "readFrom",
        value: function readFrom(eventKey, direction, amount, log) {
          var _this = this;

          return new ReaderRequest( /*#__PURE__*/function () {
            var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(r, log) {
              var txn;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return _this._storage.readTxn(_this.readTxnStores);

                    case 2:
                      txn = _context.sent;
                      _context.next = 5;
                      return _this._readFrom(eventKey, direction, amount, r, txn, log);

                    case 5:
                      return _context.abrupt("return", _context.sent);

                    case 6:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }));

            return function (_x7, _x8) {
              return _ref2.apply(this, arguments);
            };
          }(), log);
        }
      }, {
        key: "readFromEnd",
        value: function readFromEnd(amount) {
          var _this2 = this;

          var existingTxn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var log = arguments.length > 2 ? arguments[2] : undefined;
          return new ReaderRequest( /*#__PURE__*/function () {
            var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(r, log) {
              var txn, liveFragment, entries, liveFragmentEntry, eventKey;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.t0 = existingTxn;

                      if (_context2.t0) {
                        _context2.next = 5;
                        break;
                      }

                      _context2.next = 4;
                      return _this2._storage.readTxn(_this2.readTxnStores);

                    case 4:
                      _context2.t0 = _context2.sent;

                    case 5:
                      txn = _context2.t0;
                      _context2.next = 8;
                      return txn.timelineFragments.liveFragment(_this2._roomId);

                    case 8:
                      liveFragment = _context2.sent;

                      if (liveFragment) {
                        _context2.next = 13;
                        break;
                      }

                      entries = [];
                      _context2.next = 20;
                      break;

                    case 13:
                      _this2._fragmentIdComparer.add(liveFragment);

                      liveFragmentEntry = FragmentBoundaryEntry.end(liveFragment, _this2._fragmentIdComparer);
                      eventKey = liveFragmentEntry.asEventKey();
                      _context2.next = 18;
                      return _this2._readFrom(eventKey, Direction.Backward, amount, r, txn, log);

                    case 18:
                      entries = _context2.sent;
                      entries.unshift(liveFragmentEntry);

                    case 20:
                      return _context2.abrupt("return", entries);

                    case 21:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2);
            }));

            return function (_x9, _x10) {
              return _ref3.apply(this, arguments);
            };
          }(), log);
        }
      }, {
        key: "_readFrom",
        value: function () {
          var _readFrom2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(eventKey, direction, amount, r, txn, log) {
            var entries;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return readRawTimelineEntriesWithTxn(this._roomId, eventKey, direction, amount, this._fragmentIdComparer, txn);

                  case 2:
                    entries = _context3.sent;

                    if (!this._decryptEntries) {
                      _context3.next = 11;
                      break;
                    }

                    r.decryptRequest = this._decryptEntries(entries, txn, log);
                    _context3.prev = 5;
                    _context3.next = 8;
                    return r.decryptRequest.complete();

                  case 8:
                    _context3.prev = 8;
                    r.decryptRequest = null;
                    return _context3.finish(8);

                  case 11:
                    return _context3.abrupt("return", entries);

                  case 12:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[5,, 8, 11]]);
          }));

          function _readFrom(_x11, _x12, _x13, _x14, _x15, _x16) {
            return _readFrom2.apply(this, arguments);
          }

          return _readFrom;
        }()
      }, {
        key: "readTxnStores",
        get: function get() {
          var stores = [this._storage.storeNames.timelineEvents, this._storage.storeNames.timelineFragments];

          if (this._decryptEntries) {
            stores.push(this._storage.storeNames.inboundGroupSessions);
          }

          return stores;
        }
      }]);

      return TimelineReader;
    }();

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var User = /*#__PURE__*/function () {
      function User(userId) {
        _classCallCheck(this, User);

        this._userId = userId;
      }

      _createClass(User, [{
        key: "id",
        get: function get() {
          return this._userId;
        }
      }]);

      return User;
    }();

    var Timeline = /*#__PURE__*/function () {
      function Timeline(_ref) {
        var roomId = _ref.roomId,
            storage = _ref.storage,
            closeCallback = _ref.closeCallback,
            fragmentIdComparer = _ref.fragmentIdComparer,
            pendingEvents = _ref.pendingEvents,
            clock = _ref.clock,
            powerLevelsObservable = _ref.powerLevelsObservable;

        _classCallCheck(this, Timeline);

        this._roomId = roomId;
        this._storage = storage;
        this._closeCallback = closeCallback;
        this._fragmentIdComparer = fragmentIdComparer;
        this._disposables = new Disposables();
        this._pendingEvents = pendingEvents;
        this._clock = clock; // constructing this early avoid some problem while sync and openTimeline race

        this._remoteEntries = new SortedArray(function (a, b) {
          return a.compare(b);
        });
        this._ownMember = null;
        this._timelineReader = new TimelineReader({
          roomId: this._roomId,
          storage: this._storage,
          fragmentIdComparer: this._fragmentIdComparer
        });
        this._readerRequest = null;
        this._allEntries = null;
        this.initializePowerLevels(powerLevelsObservable);
      }

      _createClass(Timeline, [{
        key: "initializePowerLevels",
        value: function initializePowerLevels(observable) {
          var _this = this;

          if (observable) {
            this._powerLevels = observable.get();

            this._disposables.track(observable.subscribe(function (powerLevels) {
              return _this._powerLevels = powerLevels;
            }));
          }
        }
        /** @package */

      }, {
        key: "load",
        value: function () {
          var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(user, membership, log) {
            var txn, memberData, readerRequest, entries;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this._storage.readTxn(this._timelineReader.readTxnStores.concat(this._storage.storeNames.roomMembers, this._storage.storeNames.roomState));

                  case 2:
                    txn = _context.sent;
                    _context.next = 5;
                    return txn.roomMembers.get(this._roomId, user.id);

                  case 5:
                    memberData = _context.sent;

                    if (memberData) {
                      this._ownMember = new RoomMember(memberData);
                    } else {
                      // this should never happen, as our own join into the room would have
                      // made us receive our own member event, but just to be on the safe side and not crash,
                      // fall back to bare user id
                      this._ownMember = RoomMember.fromUserId(this._roomId, user.id, membership);
                    } // it should be fine to not update the local entries,
                    // as they should only populate once the view subscribes to it
                    // if they are populated already, the sender profile would be empty
                    // choose good amount here between showing messages initially and
                    // not spending too much time decrypting messages before showing the timeline.
                    // more messages should be loaded automatically until the viewport is full by the view if needed.


                    readerRequest = this._disposables.track(this._timelineReader.readFromEnd(20, txn, log));
                    _context.prev = 8;
                    _context.next = 11;
                    return readerRequest.complete();

                  case 11:
                    entries = _context.sent;

                    this._setupEntries(entries);

                  case 13:
                    _context.prev = 13;

                    this._disposables.disposeTracked(readerRequest);

                    return _context.finish(13);

                  case 16:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[8,, 13, 16]]);
          }));

          function load(_x, _x2, _x3) {
            return _load.apply(this, arguments);
          }

          return load;
        }()
      }, {
        key: "_setupEntries",
        value: function _setupEntries(timelineEntries) {
          var _this2 = this;

          this._remoteEntries.setManySorted(timelineEntries);

          if (this._pendingEvents) {
            this._localEntries = new AsyncMappedList(this._pendingEvents, function (pe) {
              return _this2._mapPendingEventToEntry(pe);
            }, function (pee, params) {
              // is sending but redacted, who do we detect that here to remove the relation?
              pee.notifyUpdate(params);
            }, function (pee) {
              return _this2._applyAndEmitLocalRelationChange(pee, function (target) {
                return target.removeLocalRelation(pee);
              });
            });
          } else {
            this._localEntries = new ObservableArray();
          }

          this._allEntries = new ConcatList(this._remoteEntries, this._localEntries);
        }
      }, {
        key: "_mapPendingEventToEntry",
        value: function () {
          var _mapPendingEventToEntry2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(pe) {
            var redactingEntry, pee;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (!(pe.eventType === REDACTION_TYPE)) {
                      _context2.next = 4;
                      break;
                    }

                    _context2.next = 3;
                    return this._getOrLoadEntry(pe.relatedTxnId, pe.relatedEventId);

                  case 3:
                    redactingEntry = _context2.sent;

                  case 4:
                    pee = new PendingEventEntry({
                      pendingEvent: pe,
                      member: this._ownMember,
                      clock: this._clock,
                      redactingEntry: redactingEntry
                    });

                    this._applyAndEmitLocalRelationChange(pee, function (target) {
                      return target.addLocalRelation(pee);
                    });

                    return _context2.abrupt("return", pee);

                  case 7:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function _mapPendingEventToEntry(_x4) {
            return _mapPendingEventToEntry2.apply(this, arguments);
          }

          return _mapPendingEventToEntry;
        }()
      }, {
        key: "_applyAndEmitLocalRelationChange",
        value: function _applyAndEmitLocalRelationChange(pee, updater) {
          // this is the contract of findAndUpdate, used in _findAndUpdateRelatedEntry
          var updateOrFalse = function updateOrFalse(e) {
            var params = updater(e);
            return params ? params : false;
          };

          this._findAndUpdateRelatedEntry(pee.pendingEvent.relatedTxnId, pee.relatedEventId, updateOrFalse); // also look for a relation target to update with this redaction


          if (pee.redactingEntry) {
            var _pee$redactingEntry$p;

            // redactingEntry might be a PendingEventEntry or an EventEntry, so don't assume pendingEvent
            var relatedTxnId = (_pee$redactingEntry$p = pee.redactingEntry.pendingEvent) === null || _pee$redactingEntry$p === void 0 ? void 0 : _pee$redactingEntry$p.relatedTxnId;

            this._findAndUpdateRelatedEntry(relatedTxnId, pee.redactingEntry.relatedEventId, updateOrFalse);
          }
        }
      }, {
        key: "_findAndUpdateRelatedEntry",
        value: function _findAndUpdateRelatedEntry(relatedTxnId, relatedEventId, updateOrFalse) {
          var found = false; // first, look in local entries based on txn id

          if (relatedTxnId) {
            found = this._localEntries.findAndUpdate(function (e) {
              return e.id === relatedTxnId;
            }, updateOrFalse);
          } // if not found here, look in remote entries based on event id


          if (!found && relatedEventId) {
            this._remoteEntries.findAndUpdate(function (e) {
              return e.id === relatedEventId;
            }, updateOrFalse);
          }
        }
      }, {
        key: "getOwnAnnotationEntry",
        value: function () {
          var _getOwnAnnotationEntry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(targetId, key) {
            var txn, relations, _iterator, _step, relation, annotation, eventEntry;

            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this._storage.readWriteTxn([this._storage.storeNames.timelineEvents, this._storage.storeNames.timelineRelations]);

                  case 2:
                    txn = _context3.sent;
                    _context3.next = 5;
                    return txn.timelineRelations.getForTargetAndType(this._roomId, targetId, ANNOTATION_RELATION_TYPE);

                  case 5:
                    relations = _context3.sent;
                    _iterator = _createForOfIteratorHelper(relations);
                    _context3.prev = 7;

                    _iterator.s();

                  case 9:
                    if ((_step = _iterator.n()).done) {
                      _context3.next = 20;
                      break;
                    }

                    relation = _step.value;
                    _context3.next = 13;
                    return txn.timelineEvents.getByEventId(this._roomId, relation.sourceEventId);

                  case 13:
                    annotation = _context3.sent;

                    if (!(annotation && annotation.event.sender === this._ownMember.userId && getRelation(annotation.event).key === key)) {
                      _context3.next = 18;
                      break;
                    }

                    eventEntry = new EventEntry(annotation, this._fragmentIdComparer);

                    this._addLocalRelationsToNewRemoteEntries([eventEntry]);

                    return _context3.abrupt("return", eventEntry);

                  case 18:
                    _context3.next = 9;
                    break;

                  case 20:
                    _context3.next = 25;
                    break;

                  case 22:
                    _context3.prev = 22;
                    _context3.t0 = _context3["catch"](7);

                    _iterator.e(_context3.t0);

                  case 25:
                    _context3.prev = 25;

                    _iterator.f();

                    return _context3.finish(25);

                  case 28:
                    return _context3.abrupt("return", null);

                  case 29:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[7, 22, 25, 28]]);
          }));

          function getOwnAnnotationEntry(_x5, _x6) {
            return _getOwnAnnotationEntry.apply(this, arguments);
          }

          return getOwnAnnotationEntry;
        }()
        /** @package */

      }, {
        key: "updateOwnMember",
        value: function updateOwnMember(member) {
          this._ownMember = member;
        }
      }, {
        key: "_addLocalRelationsToNewRemoteEntries",
        value: function _addLocalRelationsToNewRemoteEntries(entries) {
          var _this$_localEntries;

          // because it is not safe to iterate a derived observable collection
          // before it has any subscriptions, we bail out if this isn't
          // the case yet. This can happen when sync adds or replaces entries
          // before load has finished and the view has subscribed to the timeline.
          // 
          // Once the subscription is setup, MappedList will set up the local
          // relations as needed with _applyAndEmitLocalRelationChange,
          // so we're not missing anything by bailing out.
          //
          // _localEntries can also not yet exist
          if (!((_this$_localEntries = this._localEntries) === null || _this$_localEntries === void 0 ? void 0 : _this$_localEntries.hasSubscriptions)) {
            return;
          } // find any local relations to this new remote event


          var _iterator2 = _createForOfIteratorHelper(this._localEntries),
              _step2;

          try {
            var _loop = function _loop() {
              var pee = _step2.value;

              // this will work because we set relatedEventId when removing remote echos
              if (pee.relatedEventId) {
                var relationTarget = entries.find(function (e) {
                  return e.id === pee.relatedEventId;
                }); // no need to emit here as this entry is about to be added

                relationTarget === null || relationTarget === void 0 ? void 0 : relationTarget.addLocalRelation(pee);
              }

              if (pee.redactingEntry) {
                var eventId = pee.redactingEntry.relatedEventId;

                var _relationTarget = entries.find(function (e) {
                  return e.id === eventId;
                });

                _relationTarget === null || _relationTarget === void 0 ? void 0 : _relationTarget.addLocalRelation(pee);
              }
            };

            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              _loop();
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        } // used in replaceEntries

      }, {
        key: "replaceEntries",

        /** @package */
        value: function replaceEntries(entries) {
          this._addLocalRelationsToNewRemoteEntries(entries);

          var _iterator3 = _createForOfIteratorHelper(entries),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var entry = _step3.value;

              try {
                this._remoteEntries.getAndUpdate(entry, Timeline._entryUpdater);
              } catch (err) {
                if (err.name === "CompareError") {
                  // see FragmentIdComparer, if the replacing entry is on a fragment
                  // that is currently not loaded into the FragmentIdComparer, it will
                  // throw a CompareError, and it means that the event is not loaded 
                  // in the timeline (like when receiving a relation for an event
                  // that is not loaded in memory) so we can just drop this error as
                  // replacing an event that is not already loaded is a no-op.
                  continue;
                } else {
                  // don't swallow other errors
                  throw err;
                }
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
        /** @package */

      }, {
        key: "addEntries",
        value: function addEntries(newEntries) {
          this._addLocalRelationsToNewRemoteEntries(newEntries);

          this._remoteEntries.setManySorted(newEntries);
        } // tries to prepend `amount` entries to the `entries` list.

        /**
         * [loadAtTop description]
         * @param  {[type]} amount [description]
         * @return {boolean} true if the top of the timeline has been reached
         * 
         */

      }, {
        key: "loadAtTop",
        value: function () {
          var _loadAtTop = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(amount) {
            var firstEventEntry, readerRequest, entries;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!this._disposables.isDisposed) {
                      _context4.next = 2;
                      break;
                    }

                    return _context4.abrupt("return", true);

                  case 2:
                    firstEventEntry = this._remoteEntries.array.find(function (e) {
                      return !!e.eventType;
                    });

                    if (firstEventEntry) {
                      _context4.next = 5;
                      break;
                    }

                    return _context4.abrupt("return", true);

                  case 5:
                    readerRequest = this._disposables.track(this._timelineReader.readFrom(firstEventEntry.asEventKey(), Direction.Backward, amount));
                    _context4.prev = 6;
                    _context4.next = 9;
                    return readerRequest.complete();

                  case 9:
                    entries = _context4.sent;
                    this.addEntries(entries);
                    return _context4.abrupt("return", entries.length < amount);

                  case 12:
                    _context4.prev = 12;

                    this._disposables.disposeTracked(readerRequest);

                    return _context4.finish(12);

                  case 15:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this, [[6,, 12, 15]]);
          }));

          function loadAtTop(_x7) {
            return _loadAtTop.apply(this, arguments);
          }

          return loadAtTop;
        }()
      }, {
        key: "_getOrLoadEntry",
        value: function () {
          var _getOrLoadEntry2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(txnId, eventId) {
            var _iterator4, _step4, p, loadedEntry, txn, redactionTargetEntry;

            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (!txnId) {
                      _context5.next = 18;
                      break;
                    }

                    // also look for redacting relation in pending events, in case the target is already being sent
                    _iterator4 = _createForOfIteratorHelper(this._localEntries);
                    _context5.prev = 2;

                    _iterator4.s();

                  case 4:
                    if ((_step4 = _iterator4.n()).done) {
                      _context5.next = 10;
                      break;
                    }

                    p = _step4.value;

                    if (!(p.id === txnId)) {
                      _context5.next = 8;
                      break;
                    }

                    return _context5.abrupt("return", p);

                  case 8:
                    _context5.next = 4;
                    break;

                  case 10:
                    _context5.next = 15;
                    break;

                  case 12:
                    _context5.prev = 12;
                    _context5.t0 = _context5["catch"](2);

                    _iterator4.e(_context5.t0);

                  case 15:
                    _context5.prev = 15;

                    _iterator4.f();

                    return _context5.finish(15);

                  case 18:
                    if (!eventId) {
                      _context5.next = 32;
                      break;
                    }

                    loadedEntry = this.getByEventId(eventId);

                    if (!loadedEntry) {
                      _context5.next = 24;
                      break;
                    }

                    return _context5.abrupt("return", loadedEntry);

                  case 24:
                    _context5.next = 26;
                    return this._storage.readWriteTxn([this._storage.storeNames.timelineEvents]);

                  case 26:
                    txn = _context5.sent;
                    _context5.next = 29;
                    return txn.timelineEvents.getByEventId(this._roomId, eventId);

                  case 29:
                    redactionTargetEntry = _context5.sent;

                    if (!redactionTargetEntry) {
                      _context5.next = 32;
                      break;
                    }

                    return _context5.abrupt("return", new EventEntry(redactionTargetEntry, this._fragmentIdComparer));

                  case 32:
                    return _context5.abrupt("return", null);

                  case 33:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this, [[2, 12, 15, 18]]);
          }));

          function _getOrLoadEntry(_x8, _x9) {
            return _getOrLoadEntry2.apply(this, arguments);
          }

          return _getOrLoadEntry;
        }()
      }, {
        key: "getByEventId",
        value: function getByEventId(eventId) {
          for (var i = 0; i < this._remoteEntries.length; i += 1) {
            var entry = this._remoteEntries.get(i);

            if (entry.id === eventId) {
              return entry;
            }
          }

          return null;
        }
        /** @public */

      }, {
        key: "dispose",

        /** @public */
        value: function dispose() {
          if (this._closeCallback) {
            this._disposables.dispose();

            this._closeCallback();

            this._closeCallback = null;
          }
        }
        /** @internal */

      }, {
        key: "enableEncryption",
        value: function enableEncryption(decryptEntries) {
          this._timelineReader.enableEncryption(decryptEntries);
        }
      }, {
        key: "entries",
        get: function get() {
          return this._allEntries;
        }
        /**
         * @internal
         * @return {Array<EventEntry>} remote event entries, should not be modified
         */

      }, {
        key: "remoteEntries",
        get: function get() {
          return this._remoteEntries.array;
        }
      }, {
        key: "powerLevels",
        get: function get() {
          return this._powerLevels;
        }
      }, {
        key: "me",
        get: function get() {
          return this._ownMember;
        }
      }], [{
        key: "_entryUpdater",
        value: function _entryUpdater(existingEntry, entry) {
          entry.updateFrom(existingEntry);
          return entry;
        }
      }]);

      return Timeline;
    }();

    function loadMembers(_x) {
      return _loadMembers.apply(this, arguments);
    }

    function _loadMembers() {
      _loadMembers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
        var roomId, storage, txn, memberDatas;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                roomId = _ref.roomId, storage = _ref.storage;
                _context.next = 3;
                return storage.readTxn([storage.storeNames.roomMembers]);

              case 3:
                txn = _context.sent;
                _context.next = 6;
                return txn.roomMembers.getAll(roomId);

              case 6:
                memberDatas = _context.sent;
                return _context.abrupt("return", memberDatas.map(function (d) {
                  return new RoomMember(d);
                }));

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return _loadMembers.apply(this, arguments);
    }

    function fetchMembers(_x2, _x3) {
      return _fetchMembers.apply(this, arguments);
    }

    function _fetchMembers() {
      _fetchMembers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref2, log) {
        var summary, syncToken, roomId, hsApi, storage, setChangedMembersMap, changedMembersDuringSync, memberResponse, txn, summaryChanges, members, roomMembers, memberEvents;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                summary = _ref2.summary, syncToken = _ref2.syncToken, roomId = _ref2.roomId, hsApi = _ref2.hsApi, storage = _ref2.storage, setChangedMembersMap = _ref2.setChangedMembersMap;
                // if any members are changed by sync while we're fetching members,
                // they will end up here, so we check not to override them
                changedMembersDuringSync = new Map();
                setChangedMembersMap(changedMembersDuringSync);
                _context3.next = 5;
                return hsApi.members(roomId, {
                  at: syncToken
                }, {
                  log: log
                }).response();

              case 5:
                memberResponse = _context3.sent;
                _context3.next = 8;
                return storage.readWriteTxn([storage.storeNames.roomSummary, storage.storeNames.roomMembers]);

              case 8:
                txn = _context3.sent;
                _context3.prev = 9;
                summaryChanges = summary.writeHasFetchedMembers(true, txn);
                roomMembers = txn.roomMembers;
                memberEvents = memberResponse.chunk;

                if (Array.isArray(memberEvents)) {
                  _context3.next = 15;
                  break;
                }

                throw new Error("malformed");

              case 15:
                log.set("members", memberEvents.length);
                _context3.next = 18;
                return Promise.all(memberEvents.map( /*#__PURE__*/function () {
                  var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(memberEvent) {
                    var userId, changedMember, member;
                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            userId = memberEvent === null || memberEvent === void 0 ? void 0 : memberEvent.state_key;

                            if (userId) {
                              _context2.next = 3;
                              break;
                            }

                            throw new Error("malformed");

                          case 3:
                            // this member was changed during a sync that happened while calling /members
                            // and thus is more recent, so don't overwrite
                            changedMember = changedMembersDuringSync.get(userId);

                            if (!changedMember) {
                              _context2.next = 8;
                              break;
                            }

                            return _context2.abrupt("return", changedMember);

                          case 8:
                            member = RoomMember.fromMemberEvent(roomId, memberEvent);

                            if (member) {
                              roomMembers.set(member.serialize());
                            }

                            return _context2.abrupt("return", member);

                          case 11:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function (_x11) {
                    return _ref5.apply(this, arguments);
                  };
                }()));

              case 18:
                members = _context3.sent;
                _context3.next = 25;
                break;

              case 21:
                _context3.prev = 21;
                _context3.t0 = _context3["catch"](9);
                // abort txn on any error
                txn.abort();
                throw _context3.t0;

              case 25:
                _context3.prev = 25;
                // important this gets cleared
                // or otherwise Room remains in "fetching-members" mode
                setChangedMembersMap(null);
                return _context3.finish(25);

              case 28:
                _context3.next = 30;
                return txn.complete();

              case 30:
                summary.applyChanges(summaryChanges);
                return _context3.abrupt("return", members);

              case 32:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[9, 21, 25, 28]]);
      }));
      return _fetchMembers.apply(this, arguments);
    }

    function fetchOrLoadMembers(_x4, _x5) {
      return _fetchOrLoadMembers.apply(this, arguments);
    }

    function _fetchOrLoadMembers() {
      _fetchOrLoadMembers = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(options, logger) {
        var summary;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                summary = options.summary;

                if (summary.data.hasFetchedMembers) {
                  _context4.next = 5;
                  break;
                }

                return _context4.abrupt("return", logger.wrapOrRun(options.log, "fetchMembers", function (log) {
                  return fetchMembers(options, log);
                }));

              case 5:
                return _context4.abrupt("return", loadMembers(options));

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      return _fetchOrLoadMembers.apply(this, arguments);
    }

    function fetchOrLoadMember(_x6, _x7) {
      return _fetchOrLoadMember.apply(this, arguments);
    }

    function _fetchOrLoadMember() {
      _fetchOrLoadMember = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(options, logger) {
        var member, summary;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return loadMember(options);

              case 2:
                member = _context5.sent;
                summary = options.summary;

                if (!(!summary.data.hasFetchedMembers && !member)) {
                  _context5.next = 6;
                  break;
                }

                return _context5.abrupt("return", logger.wrapOrRun(options.log, "fetchMember", function (log) {
                  return fetchMember(options, log);
                }));

              case 6:
                return _context5.abrupt("return", member);

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));
      return _fetchOrLoadMember.apply(this, arguments);
    }

    function loadMember(_x8) {
      return _loadMember.apply(this, arguments);
    }

    function _loadMember() {
      _loadMember = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref3) {
        var roomId, userId, storage, txn, member;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                roomId = _ref3.roomId, userId = _ref3.userId, storage = _ref3.storage;
                _context6.next = 3;
                return storage.readTxn([storage.storeNames.roomMembers]);

              case 3:
                txn = _context6.sent;
                _context6.next = 6;
                return txn.roomMembers.get(roomId, userId);

              case 6:
                member = _context6.sent;
                return _context6.abrupt("return", member ? new RoomMember(member) : null);

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));
      return _loadMember.apply(this, arguments);
    }

    function fetchMember(_x9, _x10) {
      return _fetchMember.apply(this, arguments);
    }

    function _fetchMember() {
      _fetchMember = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(_ref4, log) {
        var roomId, userId, hsApi, storage, memberData, member, txn;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                roomId = _ref4.roomId, userId = _ref4.userId, hsApi = _ref4.hsApi, storage = _ref4.storage;
                _context7.prev = 1;
                _context7.next = 4;
                return hsApi.state(roomId, "m.room.member", userId, {
                  log: log
                }).response();

              case 4:
                memberData = _context7.sent;
                _context7.next = 12;
                break;

              case 7:
                _context7.prev = 7;
                _context7.t0 = _context7["catch"](1);

                if (!(_context7.t0.name === "HomeServerError" && _context7.t0.errcode === "M_NOT_FOUND")) {
                  _context7.next = 11;
                  break;
                }

                return _context7.abrupt("return", null);

              case 11:
                throw _context7.t0;

              case 12:
                member = new RoomMember({
                  roomId: roomId,
                  userId: userId,
                  membership: memberData.membership,
                  avatarUrl: memberData.avatar_url,
                  displayName: memberData.displayname
                });
                _context7.next = 15;
                return storage.readWriteTxn([storage.storeNames.roomMembers]);

              case 15:
                txn = _context7.sent;
                _context7.prev = 16;
                txn.roomMembers.set(member.serialize());
                _context7.next = 24;
                break;

              case 20:
                _context7.prev = 20;
                _context7.t1 = _context7["catch"](16);
                txn.abort();
                throw _context7.t1;

              case 24:
                _context7.next = 26;
                return txn.complete();

              case 26:
                return _context7.abrupt("return", member);

              case 27:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, null, [[1, 7], [16, 20]]);
      }));
      return _fetchMember.apply(this, arguments);
    }

    /*
    Copyright 2021 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var RetainedValue = /*#__PURE__*/function () {
      function RetainedValue(freeCallback) {
        _classCallCheck(this, RetainedValue);

        this._freeCallback = freeCallback;
        this._retentionCount = 1;
      }

      _createClass(RetainedValue, [{
        key: "retain",
        value: function retain() {
          this._retentionCount += 1;
        }
      }, {
        key: "release",
        value: function release() {
          this._retentionCount -= 1;

          if (this._retentionCount === 0) {
            this._freeCallback();
          }
        }
      }]);

      return RetainedValue;
    }();

    var MemberList = /*#__PURE__*/function (_RetainedValue) {
      _inherits(MemberList, _RetainedValue);

      var _super = _createSuper(MemberList);

      function MemberList(_ref) {
        var _this;

        var members = _ref.members,
            closeCallback = _ref.closeCallback;

        _classCallCheck(this, MemberList);

        _this = _super.call(this, closeCallback);
        _this._members = new ObservableMap();

        var _iterator = _createForOfIteratorHelper(members),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var member = _step.value;

            _this._members.add(member.userId, member);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return _this;
      }

      _createClass(MemberList, [{
        key: "afterSync",
        value: function afterSync(memberChanges) {
          var _iterator2 = _createForOfIteratorHelper(memberChanges.entries()),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var _step2$value = _slicedToArray(_step2.value, 2),
                  userId = _step2$value[0],
                  memberChange = _step2$value[1];

              this._members.set(userId, memberChange.member);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      }, {
        key: "members",
        get: function get() {
          return this._members;
        }
      }]);

      return MemberList;
    }(RetainedValue);

    function calculateRoomName(sortedMembers, summaryData, log) {
      var countWithoutMe = summaryData.joinCount + summaryData.inviteCount - 1;

      if (sortedMembers.length >= countWithoutMe) {
        if (sortedMembers.length > 1) {
          var lastMember = sortedMembers[sortedMembers.length - 1];
          var firstMembers = sortedMembers.slice(0, sortedMembers.length - 1);
          return firstMembers.map(function (m) {
            return m.name;
          }).join(", ") + " and " + lastMember.name;
        } else {
          var otherMember = sortedMembers[0];

          if (otherMember) {
            return otherMember.name;
          } else {
            log.log({
              l: "could get get other member name",
              length: sortedMembers.length,
              otherMember: !!otherMember,
              otherMemberMembership: otherMember === null || otherMember === void 0 ? void 0 : otherMember.membership
            });
            return "Unknown DM Name";
          }
        }
      } else if (sortedMembers.length < countWithoutMe) {
        return sortedMembers.map(function (m) {
          return m.name;
        }).join(", ") + " and ".concat(countWithoutMe, " others");
      } else {
        // Empty Room
        return null;
      }
    }

    var Heroes = /*#__PURE__*/function () {
      function Heroes(roomId) {
        _classCallCheck(this, Heroes);

        this._roomId = roomId;
        this._members = new Map();
      }
      /**
       * @param  {string[]} newHeroes      array of user ids
       * @param  {Map<string, MemberChange>} memberChanges map of changed memberships
       * @param  {Transaction} txn
       * @return {Promise}
       */


      _createClass(Heroes, [{
        key: "calculateChanges",
        value: function () {
          var _calculateChanges = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(newHeroes, memberChanges, txn) {
            var updatedHeroMembers, removedUserIds, _iterator, _step, existingUserId, _iterator2, _step2, _step2$value, userId, memberChange, _iterator3, _step3, _userId, memberData, member;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    updatedHeroMembers = new Map();
                    removedUserIds = []; // remove non-present members

                    _iterator = _createForOfIteratorHelper(this._members.keys());

                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done;) {
                        existingUserId = _step.value;

                        if (newHeroes.indexOf(existingUserId) === -1) {
                          removedUserIds.push(existingUserId);
                        }
                      } // update heroes with synced member changes

                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }

                    _iterator2 = _createForOfIteratorHelper(memberChanges.entries());

                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                        _step2$value = _slicedToArray(_step2.value, 2), userId = _step2$value[0], memberChange = _step2$value[1];

                        if (this._members.has(userId) || newHeroes.indexOf(userId) !== -1) {
                          updatedHeroMembers.set(userId, memberChange.member);
                        }
                      } // load member for new heroes from storage

                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }

                    _iterator3 = _createForOfIteratorHelper(newHeroes);
                    _context.prev = 7;

                    _iterator3.s();

                  case 9:
                    if ((_step3 = _iterator3.n()).done) {
                      _context.next = 18;
                      break;
                    }

                    _userId = _step3.value;

                    if (!(!this._members.has(_userId) && !updatedHeroMembers.has(_userId))) {
                      _context.next = 16;
                      break;
                    }

                    _context.next = 14;
                    return txn.roomMembers.get(this._roomId, _userId);

                  case 14:
                    memberData = _context.sent;

                    if (memberData) {
                      member = new RoomMember(memberData);
                      updatedHeroMembers.set(member.userId, member);
                    }

                  case 16:
                    _context.next = 9;
                    break;

                  case 18:
                    _context.next = 23;
                    break;

                  case 20:
                    _context.prev = 20;
                    _context.t0 = _context["catch"](7);

                    _iterator3.e(_context.t0);

                  case 23:
                    _context.prev = 23;

                    _iterator3.f();

                    return _context.finish(23);

                  case 26:
                    return _context.abrupt("return", {
                      updatedHeroMembers: updatedHeroMembers.values(),
                      removedUserIds: removedUserIds
                    });

                  case 27:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[7, 20, 23, 26]]);
          }));

          function calculateChanges(_x, _x2, _x3) {
            return _calculateChanges.apply(this, arguments);
          }

          return calculateChanges;
        }()
      }, {
        key: "applyChanges",
        value: function applyChanges(_ref, summaryData, log) {
          var updatedHeroMembers = _ref.updatedHeroMembers,
              removedUserIds = _ref.removedUserIds;

          var _iterator4 = _createForOfIteratorHelper(removedUserIds),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var userId = _step4.value;

              this._members.delete(userId);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          var _iterator5 = _createForOfIteratorHelper(updatedHeroMembers),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var member = _step5.value;

              this._members.set(member.userId, member);
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }

          var sortedMembers = Array.from(this._members.values()).sort(function (a, b) {
            return a.name.localeCompare(b.name);
          });
          this._roomName = calculateRoomName(sortedMembers, summaryData, log);
        }
      }, {
        key: "roomName",
        get: function get() {
          return this._roomName;
        }
      }, {
        key: "roomAvatarUrl",
        get: function get() {
          if (this._members.size === 1) {
            var _iterator6 = _createForOfIteratorHelper(this._members.values()),
                _step6;

            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var member = _step6.value;
                return member.avatarUrl;
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
          }

          return null;
        }
        /**
         * In DM rooms, we want the room's color to be
         * the same as the other user's color. Thus, if the room
         * only has one hero, we use their ID, instead
         * of the room's, to get the avatar color.
         *
         * @returns {?string} the ID of the single hero.
         */

      }, {
        key: "roomAvatarColorId",
        get: function get() {
          if (this._members.size === 1) {
            var _iterator7 = _createForOfIteratorHelper(this._members.keys()),
                _step7;

            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                var member = _step7.value;
                return member;
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
          }

          return null;
        }
      }]);

      return Heroes;
    }();

    var ObservedEventMap = /*#__PURE__*/function () {
      function ObservedEventMap(notifyEmpty) {
        _classCallCheck(this, ObservedEventMap);

        this._map = new Map();
        this._notifyEmpty = notifyEmpty;
      }

      _createClass(ObservedEventMap, [{
        key: "observe",
        value: function observe(eventId) {
          var eventEntry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          var observable = this._map.get(eventId);

          if (!observable) {
            observable = new ObservedEvent(this, eventEntry, eventId);

            this._map.set(eventId, observable);
          }

          return observable;
        }
      }, {
        key: "updateEvents",
        value: function updateEvents(eventEntries) {
          for (var i = 0; i < eventEntries.length; i += 1) {
            var entry = eventEntries[i];

            var observable = this._map.get(entry.id);

            observable === null || observable === void 0 ? void 0 : observable.update(entry);
          }
        }
      }, {
        key: "_remove",
        value: function _remove(id) {
          this._map.delete(id);

          if (this._map.size === 0) {
            this._notifyEmpty();
          }
        }
      }]);

      return ObservedEventMap;
    }();

    var ObservedEvent = /*#__PURE__*/function (_BaseObservableValue) {
      _inherits(ObservedEvent, _BaseObservableValue);

      var _super = _createSuper(ObservedEvent);

      function ObservedEvent(eventMap, entry, id) {
        var _this;

        _classCallCheck(this, ObservedEvent);

        _this = _super.call(this);
        _this._eventMap = eventMap;
        _this._entry = entry;
        _this._id = id; // remove subscription in microtask after creating it
        // otherwise ObservedEvents would easily never get
        // removed if you never subscribe

        Promise.resolve().then(function () {
          if (!_this.hasSubscriptions) {
            _this._eventMap._remove(_this._id);

            _this._eventMap = null;
          }
        });
        return _this;
      }

      _createClass(ObservedEvent, [{
        key: "subscribe",
        value: function subscribe(handler) {
          if (!this._eventMap) {
            throw new Error("ObservedEvent expired, subscribe right after calling room.observeEvent()");
          }

          return _get(_getPrototypeOf(ObservedEvent.prototype), "subscribe", this).call(this, handler);
        }
      }, {
        key: "onUnsubscribeLast",
        value: function onUnsubscribeLast() {
          this._eventMap._remove(this._id);

          this._eventMap = null;

          _get(_getPrototypeOf(ObservedEvent.prototype), "onUnsubscribeLast", this).call(this);
        }
      }, {
        key: "update",
        value: function update(entry) {
          // entries are mostly updated in-place,
          // apart from when they are created,
          // but doesn't hurt to reassign
          this._entry = entry;
          this.emit(this._entry);
        }
      }, {
        key: "get",
        value: function get() {
          return this._entry;
        }
      }]);

      return ObservedEvent;
    }(BaseObservableValue);

    function ensureLogItem(logItem) {
      return logItem || Instance.item;
    }

    /*
    Copyright 2021 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var EVENT_TYPE$1 = "m.room.power_levels";
    var PowerLevels = /*#__PURE__*/function () {
      function PowerLevels(_ref) {
        var powerLevelEvent = _ref.powerLevelEvent,
            createEvent = _ref.createEvent,
            ownUserId = _ref.ownUserId,
            membership = _ref.membership;

        _classCallCheck(this, PowerLevels);

        this._plEvent = powerLevelEvent;
        this._createEvent = createEvent;
        this._ownUserId = ownUserId;
        this._membership = membership;
      }

      _createClass(PowerLevels, [{
        key: "canRedactFromSender",
        value: function canRedactFromSender(userId) {
          if (userId === this._ownUserId && this._membership === "join") {
            return true;
          } else {
            return this.canRedact;
          }
        }
      }, {
        key: "canSendType",
        value: function canSendType(eventType) {
          return this._myLevel >= this._getEventTypeLevel(eventType);
        }
      }, {
        key: "getUserLevel",
        value: function getUserLevel(userId) {
          if (this._plEvent) {
            var _this$_plEvent$conten, _this$_plEvent$conten2;

            var userLevel = (_this$_plEvent$conten = this._plEvent.content) === null || _this$_plEvent$conten === void 0 ? void 0 : (_this$_plEvent$conten2 = _this$_plEvent$conten.users) === null || _this$_plEvent$conten2 === void 0 ? void 0 : _this$_plEvent$conten2[userId];

            if (typeof userLevel !== "number") {
              var _this$_plEvent$conten3;

              userLevel = (_this$_plEvent$conten3 = this._plEvent.content) === null || _this$_plEvent$conten3 === void 0 ? void 0 : _this$_plEvent$conten3.users_default;
            }

            if (typeof userLevel === "number") {
              return userLevel;
            }
          } else if (this._createEvent) {
            var _this$_createEvent$co;

            if (userId === ((_this$_createEvent$co = this._createEvent.content) === null || _this$_createEvent$co === void 0 ? void 0 : _this$_createEvent$co.creator)) {
              return 100;
            }
          }

          return 0;
        }
        /** @param {string} action either "invite", "kick", "ban" or "redact". */

      }, {
        key: "_getActionLevel",
        value: function _getActionLevel(action) {
          var _this$_plEvent;

          var level = (_this$_plEvent = this._plEvent) === null || _this$_plEvent === void 0 ? void 0 : _this$_plEvent.content[action];

          if (typeof level === "number") {
            return level;
          } else {
            return 50;
          }
        }
      }, {
        key: "_getEventTypeLevel",
        value: function _getEventTypeLevel(eventType) {
          var _this$_plEvent2, _this$_plEvent2$conte;

          var level = (_this$_plEvent2 = this._plEvent) === null || _this$_plEvent2 === void 0 ? void 0 : (_this$_plEvent2$conte = _this$_plEvent2.content.events) === null || _this$_plEvent2$conte === void 0 ? void 0 : _this$_plEvent2$conte[eventType];

          if (typeof level === "number") {
            return level;
          } else {
            var _this$_plEvent3;

            var _level = (_this$_plEvent3 = this._plEvent) === null || _this$_plEvent3 === void 0 ? void 0 : _this$_plEvent3.content.events_default;

            if (typeof _level === "number") {
              return _level;
            } else {
              return 0;
            }
          }
        }
      }, {
        key: "canRedact",
        get: function get() {
          return this._myLevel >= this._getActionLevel("redact");
        }
      }, {
        key: "_myLevel",
        get: function get() {
          if (this._membership !== "join") {
            return Number.MIN_SAFE_INTEGER;
          }

          return this.getUserLevel(this._ownUserId);
        }
      }]);

      return PowerLevels;
    }();

    var EVENT_ENCRYPTED_TYPE = "m.room.encrypted";
    var BaseRoom = /*#__PURE__*/function (_EventEmitter) {
      _inherits(BaseRoom, _EventEmitter);

      var _super = _createSuper(BaseRoom);

      function BaseRoom(_ref) {
        var _this;

        var roomId = _ref.roomId,
            storage = _ref.storage,
            hsApi = _ref.hsApi,
            mediaRepository = _ref.mediaRepository,
            emitCollectionChange = _ref.emitCollectionChange,
            user = _ref.user,
            createRoomEncryption = _ref.createRoomEncryption,
            getSyncToken = _ref.getSyncToken,
            platform = _ref.platform;

        _classCallCheck(this, BaseRoom);

        _this = _super.call(this);
        _this._roomId = roomId;
        _this._storage = storage;
        _this._hsApi = hsApi;
        _this._mediaRepository = mediaRepository;
        _this._summary = new RoomSummary(roomId);
        _this._fragmentIdComparer = new FragmentIdComparer([]);
        _this._emitCollectionChange = emitCollectionChange;
        _this._timeline = null;
        _this._user = user;
        _this._changedMembersDuringSync = null;
        _this._memberList = null;
        _this._createRoomEncryption = createRoomEncryption;
        _this._roomEncryption = null;
        _this._getSyncToken = getSyncToken;
        _this._platform = platform;
        _this._observedEvents = null;
        _this._powerLevels = null;
        _this._powerLevelLoading = null;
        _this._observedMembers = null;
        return _this;
      }

      _createClass(BaseRoom, [{
        key: "_eventIdsToEntries",
        value: function () {
          var _eventIdsToEntries2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(eventIds, txn) {
            var _this2 = this;

            var retryEntries;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    retryEntries = [];
                    _context2.next = 3;
                    return Promise.all(eventIds.map( /*#__PURE__*/function () {
                      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(eventId) {
                        var storageEntry;
                        return regeneratorRuntime.wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                _context.next = 2;
                                return txn.timelineEvents.getByEventId(_this2._roomId, eventId);

                              case 2:
                                storageEntry = _context.sent;

                                if (storageEntry) {
                                  retryEntries.push(new EventEntry(storageEntry, _this2._fragmentIdComparer));
                                }

                              case 4:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee);
                      }));

                      return function (_x3) {
                        return _ref2.apply(this, arguments);
                      };
                    }()));

                  case 3:
                    return _context2.abrupt("return", retryEntries);

                  case 4:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          function _eventIdsToEntries(_x, _x2) {
            return _eventIdsToEntries2.apply(this, arguments);
          }

          return _eventIdsToEntries;
        }()
      }, {
        key: "_getAdditionalTimelineRetryEntries",
        value: function _getAdditionalTimelineRetryEntries(otherRetryEntries, roomKeys) {
          var retryTimelineEntries = this._roomEncryption.filterUndecryptedEventEntriesForKeys(this._timeline.remoteEntries, roomKeys); // filter out any entries already in retryEntries so we don't decrypt them twice


          var existingIds = otherRetryEntries.reduce(function (ids, e) {
            ids.add(e.id);
            return ids;
          }, new Set());
          retryTimelineEntries = retryTimelineEntries.filter(function (e) {
            return !existingIds.has(e.id);
          });
          return retryTimelineEntries;
        }
        /**
         * Used for retrying decryption from other sources than sync, like key backup.
         * @internal
         * @param  {RoomKey} roomKey
         * @param  {Array<string>} eventIds any event ids that should be retried. There might be more in the timeline though for this key.
         * @return {Promise}
         */

      }, {
        key: "notifyRoomKey",
        value: function () {
          var _notifyRoomKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(roomKey, eventIds, log) {
            var txn, retryEntries, retryTimelineEntries, _this$_timeline, decryptRequest, changes;

            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (this._roomEncryption) {
                      _context3.next = 2;
                      break;
                    }

                    return _context3.abrupt("return");

                  case 2:
                    _context3.next = 4;
                    return this._storage.readTxn([this._storage.storeNames.timelineEvents, this._storage.storeNames.inboundGroupSessions]);

                  case 4:
                    txn = _context3.sent;
                    _context3.next = 7;
                    return this._eventIdsToEntries(eventIds, txn);

                  case 7:
                    retryEntries = _context3.sent;

                    if (this._timeline) {
                      retryTimelineEntries = this._getAdditionalTimelineRetryEntries(retryEntries, [roomKey]);
                      retryEntries = retryEntries.concat(retryTimelineEntries);
                    }

                    if (!retryEntries.length) {
                      _context3.next = 19;
                      break;
                    }

                    decryptRequest = this._decryptEntries(DecryptionSource.Retry, retryEntries, txn, log); // this will close txn while awaiting decryption

                    _context3.next = 13;
                    return decryptRequest.complete();

                  case 13:
                    (_this$_timeline = this._timeline) === null || _this$_timeline === void 0 ? void 0 : _this$_timeline.replaceEntries(retryEntries); // we would ideally write the room summary in the same txn as the groupSessionDecryptions in the
                    // _decryptEntries entries and could even know which events have been decrypted for the first
                    // time from DecryptionChanges.write and only pass those to the summary. As timeline changes
                    // are not essential to the room summary, it's fine to write this in a separate txn for now.

                    changes = this._summary.data.applyTimelineEntries(retryEntries, false, false);
                    _context3.next = 17;
                    return this._summary.writeAndApplyData(changes, this._storage);

                  case 17:
                    if (!_context3.sent) {
                      _context3.next = 19;
                      break;
                    }

                    this._emitUpdate();

                  case 19:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function notifyRoomKey(_x4, _x5, _x6) {
            return _notifyRoomKey.apply(this, arguments);
          }

          return notifyRoomKey;
        }()
      }, {
        key: "_setEncryption",
        value: function _setEncryption(roomEncryption) {
          if (roomEncryption && !this._roomEncryption) {
            this._roomEncryption = roomEncryption;

            if (this._timeline) {
              this._timeline.enableEncryption(this._decryptEntries.bind(this, DecryptionSource.Timeline));
            }

            return true;
          }

          return false;
        }
        /**
         * Used for decrypting when loading/filling the timeline, and retrying decryption,
         * not during sync, where it is split up during the multiple phases.
         */

      }, {
        key: "_decryptEntries",
        value: function _decryptEntries(source, entries, inboundSessionTxn) {
          var _this3 = this;

          var log = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          var request = new DecryptionRequest( /*#__PURE__*/function () {
            var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(r, log) {
              var events, changes, stores, isTimelineOpen, writeTxn, decryption;
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      if (inboundSessionTxn) {
                        _context4.next = 4;
                        break;
                      }

                      _context4.next = 3;
                      return _this3._storage.readTxn([_this3._storage.storeNames.inboundGroupSessions]);

                    case 3:
                      inboundSessionTxn = _context4.sent;

                    case 4:
                      if (!r.cancelled) {
                        _context4.next = 6;
                        break;
                      }

                      return _context4.abrupt("return");

                    case 6:
                      events = entries.filter(function (entry) {
                        return entry.eventType === EVENT_ENCRYPTED_TYPE;
                      }).map(function (entry) {
                        return entry.event;
                      });
                      _context4.next = 9;
                      return _this3._roomEncryption.prepareDecryptAll(events, null, source, inboundSessionTxn);

                    case 9:
                      r.preparation = _context4.sent;

                      if (!r.cancelled) {
                        _context4.next = 12;
                        break;
                      }

                      return _context4.abrupt("return");

                    case 12:
                      _context4.next = 14;
                      return r.preparation.decrypt();

                    case 14:
                      changes = _context4.sent;
                      r.preparation = null;

                      if (!r.cancelled) {
                        _context4.next = 18;
                        break;
                      }

                      return _context4.abrupt("return");

                    case 18:
                      stores = [_this3._storage.storeNames.groupSessionDecryptions];
                      isTimelineOpen = _this3._isTimelineOpen;

                      if (isTimelineOpen) {
                        // read to fetch devices if timeline is open
                        stores.push(_this3._storage.storeNames.deviceIdentities);
                      }

                      _context4.next = 23;
                      return _this3._storage.readWriteTxn(stores);

                    case 23:
                      writeTxn = _context4.sent;
                      _context4.prev = 24;
                      _context4.next = 27;
                      return changes.write(writeTxn, log);

                    case 27:
                      decryption = _context4.sent;

                      if (!isTimelineOpen) {
                        _context4.next = 31;
                        break;
                      }

                      _context4.next = 31;
                      return decryption.verifySenders(writeTxn);

                    case 31:
                      _context4.next = 37;
                      break;

                    case 33:
                      _context4.prev = 33;
                      _context4.t0 = _context4["catch"](24);
                      writeTxn.abort();
                      throw _context4.t0;

                    case 37:
                      _context4.next = 39;
                      return writeTxn.complete();

                    case 39:
                      // TODO: log decryption errors here
                      decryption.applyToEntries(entries);

                      if (_this3._observedEvents) {
                        _this3._observedEvents.updateEvents(entries);
                      }

                    case 41:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, null, [[24, 33]]);
            }));

            return function (_x7, _x8) {
              return _ref3.apply(this, arguments);
            };
          }(), ensureLogItem(log));
          return request;
        } // TODO: move this to Room

      }, {
        key: "_getSyncRetryDecryptEntries",
        value: function () {
          var _getSyncRetryDecryptEntries2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(newKeys, roomEncryption, txn) {
            var _this4 = this;

            var entriesPerKey, retryEntries, retryTimelineEntries, retryTimelineEntriesCopies;
            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    _context6.next = 2;
                    return Promise.all(newKeys.map( /*#__PURE__*/function () {
                      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(key) {
                        var retryEventIds;
                        return regeneratorRuntime.wrap(function _callee5$(_context5) {
                          while (1) {
                            switch (_context5.prev = _context5.next) {
                              case 0:
                                _context5.next = 2;
                                return roomEncryption.getEventIdsForMissingKey(key, txn);

                              case 2:
                                retryEventIds = _context5.sent;

                                if (!retryEventIds) {
                                  _context5.next = 5;
                                  break;
                                }

                                return _context5.abrupt("return", _this4._eventIdsToEntries(retryEventIds, txn));

                              case 5:
                              case "end":
                                return _context5.stop();
                            }
                          }
                        }, _callee5);
                      }));

                      return function (_x12) {
                        return _ref4.apply(this, arguments);
                      };
                    }()));

                  case 2:
                    entriesPerKey = _context6.sent;
                    retryEntries = entriesPerKey.reduce(function (allEntries, entries) {
                      return entries ? allEntries.concat(entries) : allEntries;
                    }, []); // If we have the timeline open, see if there are more entries for the new keys
                    // as we only store missing session information for synced events, not backfilled.
                    // We want to decrypt all events we can though if the user is looking
                    // at them when the timeline is open

                    if (this._timeline) {
                      retryTimelineEntries = this._getAdditionalTimelineRetryEntries(retryEntries, newKeys); // make copies so we don't modify the original entry in writeSync, before the afterSync stage

                      retryTimelineEntriesCopies = retryTimelineEntries.map(function (e) {
                        return e.clone();
                      }); // add to other retry entries

                      retryEntries = retryEntries.concat(retryTimelineEntriesCopies);
                    }

                    return _context6.abrupt("return", retryEntries);

                  case 6:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));

          function _getSyncRetryDecryptEntries(_x9, _x10, _x11) {
            return _getSyncRetryDecryptEntries2.apply(this, arguments);
          }

          return _getSyncRetryDecryptEntries;
        }()
        /** @package */

      }, {
        key: "load",
        value: function () {
          var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(summary, txn, log) {
            var roomEncryption, changes;
            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    log.set("id", this.id);
                    _context7.prev = 1;

                    // if called from sync, there is no summary yet
                    if (summary) {
                      this._summary.load(summary);
                    }

                    if (this._summary.data.encryption) {
                      roomEncryption = this._createRoomEncryption(this, this._summary.data.encryption);

                      this._setEncryption(roomEncryption);
                    } // need to load members for name?


                    if (!this._summary.data.needsHeroes) {
                      _context7.next = 10;
                      break;
                    }

                    this._heroes = new Heroes(this._roomId);
                    _context7.next = 8;
                    return this._heroes.calculateChanges(this._summary.data.heroes, [], txn);

                  case 8:
                    changes = _context7.sent;

                    this._heroes.applyChanges(changes, this._summary.data, log);

                  case 10:
                    _context7.next = 15;
                    break;

                  case 12:
                    _context7.prev = 12;
                    _context7.t0 = _context7["catch"](1);
                    throw new WrappedError("Could not load room ".concat(this._roomId), _context7.t0);

                  case 15:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this, [[1, 12]]);
          }));

          function load(_x13, _x14, _x15) {
            return _load.apply(this, arguments);
          }

          return load;
        }()
      }, {
        key: "observeMember",
        value: function () {
          var _observeMember = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(userId) {
            var _this5 = this;

            var mapMember, member, observableMember;
            return regeneratorRuntime.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    if (!this._observedMembers) {
                      this._observedMembers = new Map();
                    }

                    mapMember = this._observedMembers.get(userId);

                    if (!mapMember) {
                      _context8.next = 4;
                      break;
                    }

                    return _context8.abrupt("return", mapMember);

                  case 4:
                    _context8.next = 6;
                    return fetchOrLoadMember({
                      summary: this._summary,
                      roomId: this._roomId,
                      userId: userId,
                      storage: this._storage,
                      hsApi: this._hsApi
                    }, this._platform.logger);

                  case 6:
                    member = _context8.sent;

                    if (member) {
                      _context8.next = 9;
                      break;
                    }

                    return _context8.abrupt("return", null);

                  case 9:
                    observableMember = new RetainedObservableValue(member, function () {
                      return _this5._observedMembers.delete(userId);
                    });

                    this._observedMembers.set(userId, observableMember);

                    return _context8.abrupt("return", observableMember);

                  case 12:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));

          function observeMember(_x16) {
            return _observeMember.apply(this, arguments);
          }

          return observeMember;
        }()
        /** @public */

      }, {
        key: "loadMemberList",
        value: function () {
          var _loadMemberList = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
            var _this6 = this;

            var log,
                members,
                _args9 = arguments;
            return regeneratorRuntime.wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    log = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : null;

                    if (!this._memberList) {
                      _context9.next = 6;
                      break;
                    }

                    // TODO: also await fetchOrLoadMembers promise here
                    this._memberList.retain();

                    return _context9.abrupt("return", this._memberList);

                  case 6:
                    _context9.next = 8;
                    return fetchOrLoadMembers({
                      summary: this._summary,
                      roomId: this._roomId,
                      hsApi: this._hsApi,
                      storage: this._storage,
                      syncToken: this._getSyncToken(),
                      // to handle race between /members and /sync
                      setChangedMembersMap: function setChangedMembersMap(map) {
                        return _this6._changedMembersDuringSync = map;
                      },
                      log: log
                    }, this._platform.logger);

                  case 8:
                    members = _context9.sent;
                    this._memberList = new MemberList({
                      members: members,
                      closeCallback: function closeCallback() {
                        _this6._memberList = null;
                      }
                    });
                    return _context9.abrupt("return", this._memberList);

                  case 11:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this);
          }));

          function loadMemberList() {
            return _loadMemberList.apply(this, arguments);
          }

          return loadMemberList;
        }()
        /** @public */

      }, {
        key: "fillGap",
        value: function fillGap(fragmentEntry, amount) {
          var _this7 = this;

          var log = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          // TODO move some/all of this out of BaseRoom
          return this._platform.logger.wrapOrRun(log, "fillGap", /*#__PURE__*/function () {
            var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(log) {
              var response, txn, extraGapFillChanges, gapResult, relationWriter, gapWriter, decryptRequest, _iterator, _step, fragment;

              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      log.set("id", _this7.id);
                      log.set("fragment", fragmentEntry.fragmentId);
                      log.set("dir", fragmentEntry.direction.asApiString());

                      if (!fragmentEntry.edgeReached) {
                        _context10.next = 6;
                        break;
                      }

                      log.set("edgeReached", true);
                      return _context10.abrupt("return");

                    case 6:
                      _context10.next = 8;
                      return _this7._hsApi.messages(_this7._roomId, {
                        from: fragmentEntry.token,
                        dir: fragmentEntry.direction.asApiString(),
                        limit: amount,
                        filter: {
                          lazy_load_members: true,
                          include_redundant_members: true
                        }
                      }, {
                        log: log
                      }).response();

                    case 8:
                      response = _context10.sent;
                      _context10.next = 11;
                      return _this7._storage.readWriteTxn([_this7._storage.storeNames.pendingEvents, _this7._storage.storeNames.timelineEvents, _this7._storage.storeNames.timelineRelations, _this7._storage.storeNames.timelineFragments]);

                    case 11:
                      txn = _context10.sent;
                      _context10.prev = 12;
                      _context10.next = 15;
                      return _this7._writeGapFill(response.chunk, txn, log);

                    case 15:
                      extraGapFillChanges = _context10.sent;
                      // write new events into gap
                      relationWriter = new RelationWriter({
                        roomId: _this7._roomId,
                        fragmentIdComparer: _this7._fragmentIdComparer,
                        ownUserId: _this7._user.id
                      });
                      gapWriter = new GapWriter({
                        roomId: _this7._roomId,
                        storage: _this7._storage,
                        fragmentIdComparer: _this7._fragmentIdComparer,
                        relationWriter: relationWriter
                      });
                      _context10.next = 20;
                      return gapWriter.writeFragmentFill(fragmentEntry, response, txn, log);

                    case 20:
                      gapResult = _context10.sent;
                      _context10.next = 27;
                      break;

                    case 23:
                      _context10.prev = 23;
                      _context10.t0 = _context10["catch"](12);
                      txn.abort();
                      throw _context10.t0;

                    case 27:
                      _context10.next = 29;
                      return txn.complete();

                    case 29:
                      if (!_this7._roomEncryption) {
                        _context10.next = 33;
                        break;
                      }

                      decryptRequest = _this7._decryptEntries(DecryptionSource.Timeline, gapResult.entries, null, log);
                      _context10.next = 33;
                      return decryptRequest.complete();

                    case 33:
                      // once txn is committed, update in-memory state & emit events
                      _iterator = _createForOfIteratorHelper(gapResult.fragments);

                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done;) {
                          fragment = _step.value;

                          _this7._fragmentIdComparer.add(fragment);
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }

                      if (extraGapFillChanges) {
                        _this7._applyGapFill(extraGapFillChanges);
                      }

                      if (_this7._timeline) {
                        // these should not be added if not already there
                        _this7._timeline.replaceEntries(gapResult.updatedEntries);

                        _this7._timeline.addEntries(gapResult.entries);
                      }

                    case 37:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10, null, [[12, 23]]);
            }));

            return function (_x17) {
              return _ref5.apply(this, arguments);
            };
          }());
        }
        /**
        allow sub classes to integrate in the gap fill lifecycle.
        JoinedRoom uses this update remote echos.
        */
        // eslint-disable-next-line no-unused-vars

      }, {
        key: "_writeGapFill",
        value: function () {
          var _writeGapFill2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(chunk, txn, log) {
            return regeneratorRuntime.wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11);
          }));

          function _writeGapFill(_x18, _x19, _x20) {
            return _writeGapFill2.apply(this, arguments);
          }

          return _writeGapFill;
        }()
      }, {
        key: "_applyGapFill",
        value: function _applyGapFill() {}
        /** @public */

      }, {
        key: "_loadPowerLevels",
        value: function () {
          var _loadPowerLevels2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
            var txn, powerLevelsState, createState, membership;
            return regeneratorRuntime.wrap(function _callee12$(_context12) {
              while (1) {
                switch (_context12.prev = _context12.next) {
                  case 0:
                    _context12.next = 2;
                    return this._storage.readTxn([this._storage.storeNames.roomState]);

                  case 2:
                    txn = _context12.sent;
                    _context12.next = 5;
                    return txn.roomState.get(this._roomId, "m.room.power_levels", "");

                  case 5:
                    powerLevelsState = _context12.sent;

                    if (!powerLevelsState) {
                      _context12.next = 8;
                      break;
                    }

                    return _context12.abrupt("return", new PowerLevels({
                      powerLevelEvent: powerLevelsState.event,
                      ownUserId: this._user.id,
                      membership: this.membership
                    }));

                  case 8:
                    _context12.next = 10;
                    return txn.roomState.get(this._roomId, "m.room.create", "");

                  case 10:
                    createState = _context12.sent;

                    if (!createState) {
                      _context12.next = 15;
                      break;
                    }

                    return _context12.abrupt("return", new PowerLevels({
                      createEvent: createState.event,
                      ownUserId: this._user.id,
                      membership: this.membership
                    }));

                  case 15:
                    membership = this.membership;
                    return _context12.abrupt("return", new PowerLevels({
                      ownUserId: this._user.id,
                      membership: membership
                    }));

                  case 17:
                  case "end":
                    return _context12.stop();
                }
              }
            }, _callee12, this);
          }));

          function _loadPowerLevels() {
            return _loadPowerLevels2.apply(this, arguments);
          }

          return _loadPowerLevels;
        }()
        /**
         * Get the PowerLevels of the room.
         * Always subscribe to the value returned by this method.
         * @returns {RetainedObservableValue} PowerLevels of the room
         */

      }, {
        key: "observePowerLevels",
        value: function () {
          var _observePowerLevels = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
            var _this8 = this;

            var observable, powerLevels;
            return regeneratorRuntime.wrap(function _callee13$(_context13) {
              while (1) {
                switch (_context13.prev = _context13.next) {
                  case 0:
                    if (!this._powerLevelLoading) {
                      _context13.next = 3;
                      break;
                    }

                    _context13.next = 3;
                    return this._powerLevelLoading;

                  case 3:
                    observable = this._powerLevels;

                    if (observable) {
                      _context13.next = 12;
                      break;
                    }

                    this._powerLevelLoading = this._loadPowerLevels();
                    _context13.next = 8;
                    return this._powerLevelLoading;

                  case 8:
                    powerLevels = _context13.sent;
                    observable = new RetainedObservableValue(powerLevels, function () {
                      _this8._powerLevels = null;
                    });
                    this._powerLevels = observable;
                    this._powerLevelLoading = null;

                  case 12:
                    return _context13.abrupt("return", observable);

                  case 13:
                  case "end":
                    return _context13.stop();
                }
              }
            }, _callee13, this);
          }));

          function observePowerLevels() {
            return _observePowerLevels.apply(this, arguments);
          }

          return observePowerLevels;
        }()
      }, {
        key: "enableSessionBackup",
        value: function enableSessionBackup(sessionBackup) {
          var _this$_roomEncryption,
              _this9 = this;

          (_this$_roomEncryption = this._roomEncryption) === null || _this$_roomEncryption === void 0 ? void 0 : _this$_roomEncryption.enableSessionBackup(sessionBackup); // TODO: do we really want to do this every time you open the app?

          if (this._timeline && sessionBackup) {
            this._platform.logger.run("enableSessionBackup", function (log) {
              return _this9._roomEncryption.restoreMissingSessionsFromBackup(_this9._timeline.remoteEntries, log);
            });
          }
        }
      }, {
        key: "_emitUpdate",
        value: function _emitUpdate() {
          // once for event emitter listeners
          this.emit("change"); // and once for collection listeners

          this._emitCollectionChange(this);
        }
        /** @public */

      }, {
        key: "openTimeline",
        value: function openTimeline() {
          var _this10 = this;

          var log = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          return this._platform.logger.wrapOrRun(log, "open timeline", /*#__PURE__*/function () {
            var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(log) {
              return regeneratorRuntime.wrap(function _callee14$(_context14) {
                while (1) {
                  switch (_context14.prev = _context14.next) {
                    case 0:
                      log.set("id", _this10.id);

                      if (!_this10._timeline) {
                        _context14.next = 3;
                        break;
                      }

                      throw new Error("not dealing with load race here for now");

                    case 3:
                      _context14.t0 = Timeline;
                      _context14.t1 = _this10.id;
                      _context14.t2 = _this10._storage;
                      _context14.t3 = _this10._fragmentIdComparer;
                      _context14.t4 = _this10._getPendingEvents();

                      _context14.t5 = function closeCallback() {
                        _this10._timeline = null;

                        if (_this10._roomEncryption) {
                          _this10._roomEncryption.notifyTimelineClosed();
                        }
                      };

                      _context14.t6 = _this10._platform.clock;
                      _context14.t7 = _this10._platform.logger;
                      _context14.next = 13;
                      return _this10.observePowerLevels();

                    case 13:
                      _context14.t8 = _context14.sent;
                      _context14.t9 = {
                        roomId: _context14.t1,
                        storage: _context14.t2,
                        fragmentIdComparer: _context14.t3,
                        pendingEvents: _context14.t4,
                        closeCallback: _context14.t5,
                        clock: _context14.t6,
                        logger: _context14.t7,
                        powerLevelsObservable: _context14.t8
                      };
                      _this10._timeline = new _context14.t0(_context14.t9);
                      _context14.prev = 16;

                      if (_this10._roomEncryption) {
                        _this10._timeline.enableEncryption(_this10._decryptEntries.bind(_this10, DecryptionSource.Timeline));
                      }

                      _context14.next = 20;
                      return _this10._timeline.load(_this10._user, _this10.membership, log);

                    case 20:
                      _context14.next = 26;
                      break;

                    case 22:
                      _context14.prev = 22;
                      _context14.t10 = _context14["catch"](16);

                      // this also clears this._timeline in the closeCallback
                      _this10._timeline.dispose();

                      throw _context14.t10;

                    case 26:
                      return _context14.abrupt("return", _this10._timeline);

                    case 27:
                    case "end":
                      return _context14.stop();
                  }
                }
              }, _callee14, null, [[16, 22]]);
            }));

            return function (_x21) {
              return _ref6.apply(this, arguments);
            };
          }());
        }
        /* allow subclasses to provide an observable list with pending events when opening the timeline */

      }, {
        key: "_getPendingEvents",
        value: function _getPendingEvents() {
          return null;
        }
      }, {
        key: "observeEvent",
        value: function observeEvent(eventId) {
          var _this11 = this;

          if (!this._observedEvents) {
            this._observedEvents = new ObservedEventMap(function () {
              _this11._observedEvents = null;
            });
          }

          var entry = null;

          if (this._timeline) {
            entry = this._timeline.getByEventId(eventId);
          }

          var observable = this._observedEvents.observe(eventId, entry);

          if (!entry) {
            // update in the background
            this._readEventById(eventId).then(function (entry) {
              observable.update(entry);
            }).catch(function (err) {
              console.warn("could not load event ".concat(eventId, " from storage"), err);
            });
          }

          return observable;
        }
      }, {
        key: "_readEventById",
        value: function () {
          var _readEventById2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(eventId) {
            var stores, txn, storageEntry, entry, request;
            return regeneratorRuntime.wrap(function _callee15$(_context15) {
              while (1) {
                switch (_context15.prev = _context15.next) {
                  case 0:
                    stores = [this._storage.storeNames.timelineEvents];

                    if (this.isEncrypted) {
                      stores.push(this._storage.storeNames.inboundGroupSessions);
                    }

                    _context15.next = 4;
                    return this._storage.readTxn(stores);

                  case 4:
                    txn = _context15.sent;
                    _context15.next = 7;
                    return txn.timelineEvents.getByEventId(this._roomId, eventId);

                  case 7:
                    storageEntry = _context15.sent;

                    if (!storageEntry) {
                      _context15.next = 15;
                      break;
                    }

                    entry = new EventEntry(storageEntry, this._fragmentIdComparer);

                    if (!(entry.eventType === EVENT_ENCRYPTED_TYPE)) {
                      _context15.next = 14;
                      break;
                    }

                    request = this._decryptEntries(DecryptionSource.Timeline, [entry], txn);
                    _context15.next = 14;
                    return request.complete();

                  case 14:
                    return _context15.abrupt("return", entry);

                  case 15:
                  case "end":
                    return _context15.stop();
                }
              }
            }, _callee15, this);
          }));

          function _readEventById(_x22) {
            return _readEventById2.apply(this, arguments);
          }

          return _readEventById;
        }()
      }, {
        key: "dispose",
        value: function dispose() {
          var _this$_roomEncryption2, _this$_timeline2;

          (_this$_roomEncryption2 = this._roomEncryption) === null || _this$_roomEncryption2 === void 0 ? void 0 : _this$_roomEncryption2.dispose();
          (_this$_timeline2 = this._timeline) === null || _this$_timeline2 === void 0 ? void 0 : _this$_timeline2.dispose();
        }
      }, {
        key: "name",
        get: function get() {
          if (this._heroes) {
            return this._heroes.roomName;
          }

          var summaryData = this._summary.data;

          if (summaryData.name) {
            return summaryData.name;
          }

          if (summaryData.canonicalAlias) {
            return summaryData.canonicalAlias;
          }

          return null;
        }
        /** @public */

      }, {
        key: "id",
        get: function get() {
          return this._roomId;
        }
      }, {
        key: "avatarUrl",
        get: function get() {
          if (this._summary.data.avatarUrl) {
            return this._summary.data.avatarUrl;
          } else if (this._heroes) {
            return this._heroes.roomAvatarUrl;
          }

          return null;
        }
        /**
         * Retrieve the identifier that should be used to color
         * this room's avatar. By default this is the room's
         * ID, but DM rooms should be the same color as their
         * user's avatar.
         */

      }, {
        key: "avatarColorId",
        get: function get() {
          return this._roomId;
        }
      }, {
        key: "lastMessageTimestamp",
        get: function get() {
          return this._summary.data.lastMessageTimestamp;
        }
      }, {
        key: "isLowPriority",
        get: function get() {
          var tags = this._summary.data.tags;
          return !!(tags && tags['m.lowpriority']);
        }
      }, {
        key: "isEncrypted",
        get: function get() {
          return !!this._summary.data.encryption;
        }
      }, {
        key: "isJoined",
        get: function get() {
          return this.membership === "join";
        }
      }, {
        key: "isLeft",
        get: function get() {
          return this.membership === "leave";
        }
      }, {
        key: "canonicalAlias",
        get: function get() {
          return this._summary.data.canonicalAlias;
        }
      }, {
        key: "joinedMemberCount",
        get: function get() {
          return this._summary.data.joinCount;
        }
      }, {
        key: "mediaRepository",
        get: function get() {
          return this._mediaRepository;
        }
      }, {
        key: "membership",
        get: function get() {
          return this._summary.data.membership;
        }
      }, {
        key: "_isTimelineOpen",
        get: function get() {
          return !!this._timeline;
        }
      }]);

      return BaseRoom;
    }(EventEmitter);

    var DecryptionRequest = /*#__PURE__*/function () {
      function DecryptionRequest(decryptFn, log) {
        var _this12 = this;

        _classCallCheck(this, DecryptionRequest);

        this._cancelled = false;
        this.preparation = null;
        this._promise = log.wrap("decryptEntries", function (log) {
          return decryptFn(_this12, log);
        });
      }

      _createClass(DecryptionRequest, [{
        key: "complete",
        value: function complete() {
          return this._promise;
        }
      }, {
        key: "dispose",
        value: function dispose() {
          this._cancelled = true;

          if (this.preparation) {
            this.preparation.dispose();
          }
        }
      }, {
        key: "cancelled",
        get: function get() {
          return this._cancelled;
        }
      }]);

      return DecryptionRequest;
    }();

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function makeTxnId() {
      var n = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
      var str = n.toString(16);
      return "t" + "0".repeat(14 - str.length) + str;
    }
    function isTxnId(txnId) {
      return txnId.startsWith("t") && txnId.length === 15;
    }

    var SendQueue = /*#__PURE__*/function () {
      function SendQueue(_ref) {
        var _this = this;

        var roomId = _ref.roomId,
            storage = _ref.storage,
            hsApi = _ref.hsApi,
            pendingEvents = _ref.pendingEvents;

        _classCallCheck(this, SendQueue);

        pendingEvents = pendingEvents || [];
        this._roomId = roomId;
        this._storage = storage;
        this._hsApi = hsApi;
        this._pendingEvents = new SortedArray(function (a, b) {
          return a.queueIndex - b.queueIndex;
        });

        this._pendingEvents.setManyUnsorted(pendingEvents.map(function (data) {
          return _this._createPendingEvent(data);
        }));

        this._isSending = false;
        this._offline = false;
        this._roomEncryption = null;
        this._currentQueueIndex = 0;
      }

      _createClass(SendQueue, [{
        key: "_createPendingEvent",
        value: function _createPendingEvent(data) {
          var _this2 = this;

          var attachments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var pendingEvent = new PendingEvent({
            data: data,
            remove: function remove() {
              return _this2._removeEvent(pendingEvent);
            },
            emitUpdate: function emitUpdate(params) {
              return _this2._pendingEvents.update(pendingEvent, params);
            },
            attachments: attachments
          });
          return pendingEvent;
        }
      }, {
        key: "enableEncryption",
        value: function enableEncryption(roomEncryption) {
          this._roomEncryption = roomEncryption;
        }
      }, {
        key: "_sendLoop",
        value: function _sendLoop(log) {
          var _this3 = this;

          this._isSending = true;
          this._sendLoopLogItem = log.runDetached("send queue flush", /*#__PURE__*/function () {
            var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(log) {
              var _iterator, _step, _loop;

              return regeneratorRuntime.wrap(function _callee2$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.prev = 0;
                      _iterator = _createForOfIteratorHelper(_this3._pendingEvents);
                      _context3.prev = 2;
                      _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop() {
                        var pendingEvent;
                        return regeneratorRuntime.wrap(function _loop$(_context2) {
                          while (1) {
                            switch (_context2.prev = _context2.next) {
                              case 0:
                                pendingEvent = _step.value;
                                _context2.next = 3;
                                return log.wrap("send event", /*#__PURE__*/function () {
                                  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(log) {
                                    var isPermanentError;
                                    return regeneratorRuntime.wrap(function _callee$(_context) {
                                      while (1) {
                                        switch (_context.prev = _context.next) {
                                          case 0:
                                            log.set("queueIndex", pendingEvent.queueIndex);
                                            _context.prev = 1;
                                            _this3._currentQueueIndex = pendingEvent.queueIndex;
                                            _context.next = 5;
                                            return _this3._sendEvent(pendingEvent, log);

                                          case 5:
                                            _context.next = 24;
                                            break;

                                          case 7:
                                            _context.prev = 7;
                                            _context.t0 = _context["catch"](1);

                                            if (!(_context.t0 instanceof ConnectionError)) {
                                              _context.next = 15;
                                              break;
                                            }

                                            _this3._offline = true;
                                            log.set("offline", true);
                                            pendingEvent.setWaiting();
                                            _context.next = 24;
                                            break;

                                          case 15:
                                            log.catch(_context.t0);
                                            isPermanentError = _context.t0.name === "HomeServerError" && (_context.t0.statusCode === 400 || // bad request, must be a bug on our end
                                            _context.t0.statusCode === 403 || // forbidden
                                            _context.t0.statusCode === 404 // not found
                                            );

                                            if (!isPermanentError) {
                                              _context.next = 23;
                                              break;
                                            }

                                            log.set("remove", true);
                                            _context.next = 21;
                                            return pendingEvent.abort();

                                          case 21:
                                            _context.next = 24;
                                            break;

                                          case 23:
                                            pendingEvent.setError(_context.t0);

                                          case 24:
                                            _context.prev = 24;
                                            _this3._currentQueueIndex = 0;
                                            return _context.finish(24);

                                          case 27:
                                          case "end":
                                            return _context.stop();
                                        }
                                      }
                                    }, _callee, null, [[1, 7, 24, 27]]);
                                  }));

                                  return function (_x2) {
                                    return _ref3.apply(this, arguments);
                                  };
                                }());

                              case 3:
                              case "end":
                                return _context2.stop();
                            }
                          }
                        }, _loop);
                      });

                      _iterator.s();

                    case 5:
                      if ((_step = _iterator.n()).done) {
                        _context3.next = 9;
                        break;
                      }

                      return _context3.delegateYield(_loop(), "t0", 7);

                    case 7:
                      _context3.next = 5;
                      break;

                    case 9:
                      _context3.next = 14;
                      break;

                    case 11:
                      _context3.prev = 11;
                      _context3.t1 = _context3["catch"](2);

                      _iterator.e(_context3.t1);

                    case 14:
                      _context3.prev = 14;

                      _iterator.f();

                      return _context3.finish(14);

                    case 17:
                      _context3.prev = 17;
                      _this3._isSending = false;
                      _this3._sendLoopLogItem = null;
                      return _context3.finish(17);

                    case 21:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee2, null, [[0,, 17, 21], [2, 11, 14, 17]]);
            }));

            return function (_x) {
              return _ref2.apply(this, arguments);
            };
          }());
        }
      }, {
        key: "_sendEvent",
        value: function () {
          var _sendEvent2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(pendingEvent, log) {
            var _this4 = this;

            var encryptionContent, _yield$log$wrap, type, content, txn;

            return regeneratorRuntime.wrap(function _callee3$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!pendingEvent.needsUpload) {
                      _context4.next = 5;
                      break;
                    }

                    _context4.next = 3;
                    return log.wrap("upload attachments", function (log) {
                      return pendingEvent.uploadAttachments(_this4._hsApi, log);
                    });

                  case 3:
                    _context4.next = 5;
                    return this._tryUpdateEvent(pendingEvent);

                  case 5:
                    if (!pendingEvent.needsEncryption) {
                      _context4.next = 16;
                      break;
                    }

                    pendingEvent.setEncrypting();
                    encryptionContent = pendingEvent.contentForEncryption;
                    _context4.next = 10;
                    return log.wrap("encrypt", function (log) {
                      return _this4._roomEncryption.encrypt(pendingEvent.eventType, encryptionContent, _this4._hsApi, log);
                    });

                  case 10:
                    _yield$log$wrap = _context4.sent;
                    type = _yield$log$wrap.type;
                    content = _yield$log$wrap.content;
                    pendingEvent.setEncrypted(type, content);
                    _context4.next = 16;
                    return this._tryUpdateEvent(pendingEvent);

                  case 16:
                    if (!pendingEvent.needsSending) {
                      _context4.next = 35;
                      break;
                    }

                    _context4.next = 19;
                    return pendingEvent.send(this._hsApi, log);

                  case 19:
                    _context4.next = 21;
                    return this._storage.readWriteTxn([this._storage.storeNames.pendingEvents]);

                  case 21:
                    txn = _context4.sent;
                    _context4.prev = 22;
                    _context4.next = 25;
                    return this._tryUpdateEventWithTxn(pendingEvent, txn);

                  case 25:
                    _context4.next = 27;
                    return this._resolveRemoteIdInPendingRelations(pendingEvent.txnId, pendingEvent.remoteId, txn);

                  case 27:
                    _context4.next = 33;
                    break;

                  case 29:
                    _context4.prev = 29;
                    _context4.t0 = _context4["catch"](22);
                    txn.abort();
                    throw _context4.t0;

                  case 33:
                    _context4.next = 35;
                    return txn.complete();

                  case 35:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee3, this, [[22, 29]]);
          }));

          function _sendEvent(_x3, _x4) {
            return _sendEvent2.apply(this, arguments);
          }

          return _sendEvent;
        }()
      }, {
        key: "_resolveRemoteIdInPendingRelations",
        value: function () {
          var _resolveRemoteIdInPendingRelations2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(txnId, remoteId, txn) {
            var relatedEventWithoutRemoteId, _iterator2, _step2, relatedPE;

            return regeneratorRuntime.wrap(function _callee4$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    relatedEventWithoutRemoteId = this._pendingEvents.array.filter(function (pe) {
                      return pe.relatedTxnId === txnId && pe.relatedEventId !== remoteId;
                    });
                    _iterator2 = _createForOfIteratorHelper(relatedEventWithoutRemoteId);
                    _context5.prev = 2;

                    _iterator2.s();

                  case 4:
                    if ((_step2 = _iterator2.n()).done) {
                      _context5.next = 11;
                      break;
                    }

                    relatedPE = _step2.value;
                    relatedPE.setRelatedEventId(remoteId);
                    _context5.next = 9;
                    return this._tryUpdateEventWithTxn(relatedPE, txn);

                  case 9:
                    _context5.next = 4;
                    break;

                  case 11:
                    _context5.next = 16;
                    break;

                  case 13:
                    _context5.prev = 13;
                    _context5.t0 = _context5["catch"](2);

                    _iterator2.e(_context5.t0);

                  case 16:
                    _context5.prev = 16;

                    _iterator2.f();

                    return _context5.finish(16);

                  case 19:
                    return _context5.abrupt("return", relatedEventWithoutRemoteId);

                  case 20:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee4, this, [[2, 13, 16, 19]]);
          }));

          function _resolveRemoteIdInPendingRelations(_x5, _x6, _x7) {
            return _resolveRemoteIdInPendingRelations2.apply(this, arguments);
          }

          return _resolveRemoteIdInPendingRelations;
        }()
      }, {
        key: "removeRemoteEchos",
        value: function () {
          var _removeRemoteEchos = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(events, txn, parentLog) {
            var _this5 = this;

            var removed, _iterator3, _step3, _loop2;

            return regeneratorRuntime.wrap(function _callee5$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    removed = [];
                    _iterator3 = _createForOfIteratorHelper(events);
                    _context7.prev = 2;
                    _loop2 = /*#__PURE__*/regeneratorRuntime.mark(function _loop2() {
                      var event, txnId, idx, pendingEvent, remoteId;
                      return regeneratorRuntime.wrap(function _loop2$(_context6) {
                        while (1) {
                          switch (_context6.prev = _context6.next) {
                            case 0:
                              event = _step3.value;
                              txnId = event.unsigned && event.unsigned.transaction_id;
                              idx = void 0;

                              if (txnId) {
                                idx = _this5._pendingEvents.array.findIndex(function (pe) {
                                  return pe.txnId === txnId;
                                });
                              } else {
                                idx = _this5._pendingEvents.array.findIndex(function (pe) {
                                  return pe.remoteId === event.event_id;
                                });
                              }

                              if (!(idx !== -1)) {
                                _context6.next = 12;
                                break;
                              }

                              pendingEvent = _this5._pendingEvents.get(idx);
                              remoteId = event.event_id;
                              parentLog.log({
                                l: "removeRemoteEcho",
                                queueIndex: pendingEvent.queueIndex,
                                remoteId: remoteId,
                                txnId: txnId
                              });
                              txn.pendingEvents.remove(pendingEvent.roomId, pendingEvent.queueIndex);
                              removed.push(pendingEvent);
                              _context6.next = 12;
                              return _this5._resolveRemoteIdInPendingRelations(txnId, remoteId, txn);

                            case 12:
                            case "end":
                              return _context6.stop();
                          }
                        }
                      }, _loop2);
                    });

                    _iterator3.s();

                  case 5:
                    if ((_step3 = _iterator3.n()).done) {
                      _context7.next = 9;
                      break;
                    }

                    return _context7.delegateYield(_loop2(), "t0", 7);

                  case 7:
                    _context7.next = 5;
                    break;

                  case 9:
                    _context7.next = 14;
                    break;

                  case 11:
                    _context7.prev = 11;
                    _context7.t1 = _context7["catch"](2);

                    _iterator3.e(_context7.t1);

                  case 14:
                    _context7.prev = 14;

                    _iterator3.f();

                    return _context7.finish(14);

                  case 17:
                    return _context7.abrupt("return", removed);

                  case 18:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee5, null, [[2, 11, 14, 17]]);
          }));

          function removeRemoteEchos(_x8, _x9, _x10) {
            return _removeRemoteEchos.apply(this, arguments);
          }

          return removeRemoteEchos;
        }()
      }, {
        key: "_removeEvent",
        value: function () {
          var _removeEvent2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(pendingEvent) {
            var hasEvent, txn, idx;
            return regeneratorRuntime.wrap(function _callee6$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    hasEvent = this._pendingEvents.array.indexOf(pendingEvent) !== -1;

                    if (!hasEvent) {
                      _context8.next = 10;
                      break;
                    }

                    _context8.next = 4;
                    return this._storage.readWriteTxn([this._storage.storeNames.pendingEvents]);

                  case 4:
                    txn = _context8.sent;

                    try {
                      txn.pendingEvents.remove(pendingEvent.roomId, pendingEvent.queueIndex);
                    } catch (err) {
                      txn.abort();
                    }

                    _context8.next = 8;
                    return txn.complete();

                  case 8:
                    // lookup index after async txn is complete,
                    // to make sure we're not racing with anything
                    idx = this._pendingEvents.array.indexOf(pendingEvent);

                    if (idx !== -1) {
                      this._pendingEvents.remove(idx);
                    }

                  case 10:
                    pendingEvent.dispose();

                  case 11:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee6, this);
          }));

          function _removeEvent(_x11) {
            return _removeEvent2.apply(this, arguments);
          }

          return _removeEvent;
        }()
      }, {
        key: "emitRemovals",
        value: function emitRemovals(pendingEvents) {
          var _iterator4 = _createForOfIteratorHelper(pendingEvents),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var pendingEvent = _step4.value;

              var idx = this._pendingEvents.array.indexOf(pendingEvent);

              if (idx !== -1) {
                this._pendingEvents.remove(idx);
              }

              pendingEvent.dispose();
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }
      }, {
        key: "resumeSending",
        value: function resumeSending(parentLog) {
          var _this6 = this;

          this._offline = false;

          if (this._pendingEvents.length) {
            parentLog.wrap("resumeSending", function (log) {
              log.set("id", _this6._roomId);
              log.set("pendingEvents", _this6._pendingEvents.length);

              if (!_this6._isSending) {
                _this6._sendLoop(log);
              }

              if (_this6._sendLoopLogItem) {
                log.refDetached(_this6._sendLoopLogItem);
              }
            });
          }
        }
      }, {
        key: "enqueueEvent",
        value: function () {
          var _enqueueEvent2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(eventType, content, attachments, log) {
            var relation, relatedTxnId, relationTarget, isAlreadyAnnotating;
            return regeneratorRuntime.wrap(function _callee7$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    relation = getRelationFromContent(content);
                    relatedTxnId = null;

                    if (!relation) {
                      _context9.next = 10;
                      break;
                    }

                    relationTarget = getRelationTarget(relation);

                    if (isTxnId(relationTarget)) {
                      relatedTxnId = relationTarget;
                      setRelationTarget(relation, null);
                    }

                    if (!(relation.rel_type === ANNOTATION_RELATION_TYPE)) {
                      _context9.next = 10;
                      break;
                    }

                    // Here we know the shape of the relation, and can use event_id safely
                    isAlreadyAnnotating = this._pendingEvents.array.some(function (pe) {
                      var r = getRelationFromContent(pe.content);
                      return pe.eventType === eventType && r && r.key === relation.key && (pe.relatedTxnId === relatedTxnId || r.event_id === relation.event_id);
                    });

                    if (!isAlreadyAnnotating) {
                      _context9.next = 10;
                      break;
                    }

                    log.set("already_annotating", true);
                    return _context9.abrupt("return");

                  case 10:
                    _context9.next = 12;
                    return this._enqueueEvent(eventType, content, attachments, relatedTxnId, null, log);

                  case 12:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee7, this);
          }));

          function enqueueEvent(_x12, _x13, _x14, _x15) {
            return _enqueueEvent2.apply(this, arguments);
          }

          return enqueueEvent;
        }()
      }, {
        key: "_enqueueEvent",
        value: function () {
          var _enqueueEvent3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(eventType, content, attachments, relatedTxnId, relatedEventId, log) {
            var pendingEvent;
            return regeneratorRuntime.wrap(function _callee8$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    _context10.next = 2;
                    return this._createAndStoreEvent(eventType, content, relatedTxnId, relatedEventId, attachments);

                  case 2:
                    pendingEvent = _context10.sent;

                    this._pendingEvents.set(pendingEvent);

                    log.set("queueIndex", pendingEvent.queueIndex);
                    log.set("pendingEvents", this._pendingEvents.length);

                    if (!this._isSending && !this._offline) {
                      this._sendLoop(log);
                    }

                    if (this._sendLoopLogItem) {
                      log.refDetached(this._sendLoopLogItem);
                    }

                  case 8:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee8, this);
          }));

          function _enqueueEvent(_x16, _x17, _x18, _x19, _x20, _x21) {
            return _enqueueEvent3.apply(this, arguments);
          }

          return _enqueueEvent;
        }()
      }, {
        key: "enqueueRedaction",
        value: function () {
          var _enqueueRedaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(eventIdOrTxnId, reason, log) {
            var isAlreadyRedacting, relatedTxnId, relatedEventId, txnId, pe, _pe;

            return regeneratorRuntime.wrap(function _callee9$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    isAlreadyRedacting = this._pendingEvents.array.some(function (pe) {
                      return pe.eventType === REDACTION_TYPE && (pe.relatedTxnId === eventIdOrTxnId || pe.relatedEventId === eventIdOrTxnId);
                    });

                    if (!isAlreadyRedacting) {
                      _context11.next = 4;
                      break;
                    }

                    log.set("already_redacting", true);
                    return _context11.abrupt("return");

                  case 4:
                    if (!isTxnId(eventIdOrTxnId)) {
                      _context11.next = 22;
                      break;
                    }

                    relatedTxnId = eventIdOrTxnId;
                    txnId = eventIdOrTxnId;
                    pe = this._pendingEvents.array.find(function (pe) {
                      return pe.txnId === txnId;
                    });

                    if (!(pe && !pe.remoteId && pe.status !== SendStatus.Sending)) {
                      _context11.next = 15;
                      break;
                    }

                    // haven't started sending this event yet,
                    // just remove it from the queue
                    log.set("remove", relatedTxnId);
                    _context11.next = 12;
                    return pe.abort();

                  case 12:
                    return _context11.abrupt("return");

                  case 15:
                    if (!pe) {
                      _context11.next = 19;
                      break;
                    }

                    relatedEventId = pe.remoteId;
                    _context11.next = 20;
                    break;

                  case 19:
                    return _context11.abrupt("return");

                  case 20:
                    _context11.next = 25;
                    break;

                  case 22:
                    relatedEventId = eventIdOrTxnId;
                    _pe = this._pendingEvents.array.find(function (pe) {
                      return pe.remoteId === relatedEventId;
                    });

                    if (_pe) {
                      // also set the txn id just in case that an event id was passed
                      // for relating to a pending event that is still waiting for the remote echo
                      relatedTxnId = _pe.txnId;
                    }

                  case 25:
                    log.set("relatedTxnId", relatedTxnId);
                    log.set("relatedEventId", relatedEventId);
                    _context11.next = 29;
                    return this._enqueueEvent(REDACTION_TYPE, {
                      reason: reason
                    }, null, relatedTxnId, relatedEventId, log);

                  case 29:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee9, this);
          }));

          function enqueueRedaction(_x22, _x23, _x24) {
            return _enqueueRedaction.apply(this, arguments);
          }

          return enqueueRedaction;
        }()
      }, {
        key: "_tryUpdateEvent",
        value: function () {
          var _tryUpdateEvent2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(pendingEvent) {
            var txn;
            return regeneratorRuntime.wrap(function _callee10$(_context12) {
              while (1) {
                switch (_context12.prev = _context12.next) {
                  case 0:
                    _context12.next = 2;
                    return this._storage.readWriteTxn([this._storage.storeNames.pendingEvents]);

                  case 2:
                    txn = _context12.sent;
                    _context12.prev = 3;

                    this._tryUpdateEventWithTxn(pendingEvent, txn);

                    _context12.next = 11;
                    break;

                  case 7:
                    _context12.prev = 7;
                    _context12.t0 = _context12["catch"](3);
                    txn.abort();
                    throw _context12.t0;

                  case 11:
                    _context12.next = 13;
                    return txn.complete();

                  case 13:
                  case "end":
                    return _context12.stop();
                }
              }
            }, _callee10, this, [[3, 7]]);
          }));

          function _tryUpdateEvent(_x25) {
            return _tryUpdateEvent2.apply(this, arguments);
          }

          return _tryUpdateEvent;
        }()
      }, {
        key: "_tryUpdateEventWithTxn",
        value: function () {
          var _tryUpdateEventWithTxn2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(pendingEvent, txn) {
            return regeneratorRuntime.wrap(function _callee11$(_context13) {
              while (1) {
                switch (_context13.prev = _context13.next) {
                  case 0:
                    _context13.next = 2;
                    return txn.pendingEvents.exists(pendingEvent.roomId, pendingEvent.queueIndex);

                  case 2:
                    if (!_context13.sent) {
                      _context13.next = 4;
                      break;
                    }

                    txn.pendingEvents.update(pendingEvent.data);

                  case 4:
                  case "end":
                    return _context13.stop();
                }
              }
            }, _callee11);
          }));

          function _tryUpdateEventWithTxn(_x26, _x27) {
            return _tryUpdateEventWithTxn2.apply(this, arguments);
          }

          return _tryUpdateEventWithTxn;
        }()
      }, {
        key: "_createAndStoreEvent",
        value: function () {
          var _createAndStoreEvent2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(eventType, content, relatedTxnId, relatedEventId, attachments) {
            var txn, pendingEvent, pendingEventsStore, maxStorageQueueIndex, maxQueueIndex, queueIndex, needsEncryption;
            return regeneratorRuntime.wrap(function _callee12$(_context14) {
              while (1) {
                switch (_context14.prev = _context14.next) {
                  case 0:
                    _context14.next = 2;
                    return this._storage.readWriteTxn([this._storage.storeNames.pendingEvents]);

                  case 2:
                    txn = _context14.sent;
                    _context14.prev = 3;
                    pendingEventsStore = txn.pendingEvents;
                    _context14.next = 7;
                    return pendingEventsStore.getMaxQueueIndex(this._roomId);

                  case 7:
                    _context14.t0 = _context14.sent;

                    if (_context14.t0) {
                      _context14.next = 10;
                      break;
                    }

                    _context14.t0 = 0;

                  case 10:
                    maxStorageQueueIndex = _context14.t0;
                    // don't use the queueIndex of the pendingEvent currently waiting for /send to return
                    // if the remote echo already removed the pendingEvent in storage, as the send loop
                    // wouldn't be able to detect the remote echo already arrived and end up overwriting the new event
                    maxQueueIndex = Math.max(maxStorageQueueIndex, this._currentQueueIndex);
                    queueIndex = maxQueueIndex + 1;
                    needsEncryption = eventType !== REDACTION_TYPE && eventType !== REACTION_TYPE && !!this._roomEncryption;
                    pendingEvent = this._createPendingEvent({
                      roomId: this._roomId,
                      queueIndex: queueIndex,
                      eventType: eventType,
                      content: content,
                      relatedTxnId: relatedTxnId,
                      relatedEventId: relatedEventId,
                      txnId: makeTxnId(),
                      needsEncryption: needsEncryption,
                      needsUpload: !!attachments
                    }, attachments);
                    pendingEventsStore.add(pendingEvent.data);
                    _context14.next = 22;
                    break;

                  case 18:
                    _context14.prev = 18;
                    _context14.t1 = _context14["catch"](3);
                    txn.abort();
                    throw _context14.t1;

                  case 22:
                    _context14.next = 24;
                    return txn.complete();

                  case 24:
                    return _context14.abrupt("return", pendingEvent);

                  case 25:
                  case "end":
                    return _context14.stop();
                }
              }
            }, _callee12, this, [[3, 18]]);
          }));

          function _createAndStoreEvent(_x28, _x29, _x30, _x31, _x32) {
            return _createAndStoreEvent2.apply(this, arguments);
          }

          return _createAndStoreEvent;
        }()
      }, {
        key: "dispose",
        value: function dispose() {
          var _iterator5 = _createForOfIteratorHelper(this._pendingEvents),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var pe = _step5.value;
              pe.dispose();
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      }, {
        key: "pendingEvents",
        get: function get() {
          return this._pendingEvents;
        }
      }]);

      return SendQueue;
    }();

    var AttachmentUpload = /*#__PURE__*/function () {
      function AttachmentUpload(_ref) {
        var filename = _ref.filename,
            blob = _ref.blob,
            platform = _ref.platform;

        _classCallCheck(this, AttachmentUpload);

        this._filename = filename; // need to keep around for local preview while uploading

        this._unencryptedBlob = blob;
        this._transferredBlob = this._unencryptedBlob;
        this._platform = platform;
        this._mxcUrl = null;
        this._encryptionInfo = null;
        this._uploadRequest = null;
        this._aborted = false;
        this._error = null;
        this._sentBytes = 0;
      }
      /** important to call after encrypt() if encryption is needed */


      _createClass(AttachmentUpload, [{
        key: "abort",

        /** @public */
        value: function abort() {
          var _this$_uploadRequest;

          (_this$_uploadRequest = this._uploadRequest) === null || _this$_uploadRequest === void 0 ? void 0 : _this$_uploadRequest.abort();
        }
        /** @public */

      }, {
        key: "encrypt",

        /** @package */
        value: function () {
          var _encrypt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var _yield$encryptAttachm, info, blob;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!this._encryptionInfo) {
                      _context.next = 2;
                      break;
                    }

                    throw new Error("already encrypted");

                  case 2:
                    _context.next = 4;
                    return encryptAttachment(this._platform, this._transferredBlob);

                  case 4:
                    _yield$encryptAttachm = _context.sent;
                    info = _yield$encryptAttachm.info;
                    blob = _yield$encryptAttachm.blob;
                    this._transferredBlob = blob;
                    this._encryptionInfo = info;

                  case 9:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function encrypt() {
            return _encrypt.apply(this, arguments);
          }

          return encrypt;
        }()
        /** @package */

      }, {
        key: "upload",
        value: function () {
          var _upload = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(hsApi, progressCallback, log) {
            var _this = this;

            var _yield$this$_uploadRe, content_uri;

            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    this._uploadRequest = hsApi.uploadAttachment(this._transferredBlob, this._filename, {
                      uploadProgress: function uploadProgress(sentBytes) {
                        _this._sentBytes = sentBytes;
                        progressCallback();
                      },
                      log: log
                    });
                    _context2.next = 3;
                    return this._uploadRequest.response();

                  case 3:
                    _yield$this$_uploadRe = _context2.sent;
                    content_uri = _yield$this$_uploadRe.content_uri;
                    this._mxcUrl = content_uri;

                  case 6:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function upload(_x, _x2, _x3) {
            return _upload.apply(this, arguments);
          }

          return upload;
        }()
        /** @package */

      }, {
        key: "applyToContent",
        value: function applyToContent(urlPath, content) {
          if (!this._mxcUrl) {
            throw new Error("upload has not finished");
          }

          var prefix = urlPath.substr(0, urlPath.lastIndexOf("url"));
          setPath("".concat(prefix, "info.size"), content, this._transferredBlob.size);
          setPath("".concat(prefix, "info.mimetype"), content, this._unencryptedBlob.mimeType);

          if (this._encryptionInfo) {
            setPath("".concat(prefix, "file"), content, Object.assign(this._encryptionInfo, {
              mimetype: this._unencryptedBlob.mimeType,
              url: this._mxcUrl
            }));
          } else {
            setPath("".concat(prefix, "url"), content, this._mxcUrl);
          }
        }
      }, {
        key: "dispose",
        value: function dispose() {
          this._unencryptedBlob.dispose();

          this._transferredBlob.dispose();
        }
      }, {
        key: "size",
        get: function get() {
          return this._transferredBlob.size;
        }
      }, {
        key: "sentBytes",
        get: function get() {
          return this._sentBytes;
        }
      }, {
        key: "localPreview",
        get: function get() {
          return this._unencryptedBlob;
        }
      }]);

      return AttachmentUpload;
    }();

    function setPath(path, content, value) {
      var parts = path.split(".");
      var obj = content;

      for (var i = 0; i < parts.length - 1; i += 1) {
        var key = parts[i];

        if (!obj[key]) {
          obj[key] = {};
        }

        obj = obj[key];
      }

      var propKey = parts[parts.length - 1];
      obj[propKey] = value;
    }

    var EVENT_ENCRYPTED_TYPE$1 = "m.room.encrypted";
    var Room = /*#__PURE__*/function (_BaseRoom) {
      _inherits(Room, _BaseRoom);

      var _super = _createSuper(Room);

      function Room(options) {
        var _this;

        _classCallCheck(this, Room);

        _this = _super.call(this, options); // TODO: pass pendingEvents to start like pendingOperations?

        var pendingEvents = options.pendingEvents;
        var relationWriter = new RelationWriter({
          roomId: _this.id,
          fragmentIdComparer: _this._fragmentIdComparer,
          ownUserId: _this._user.id
        });
        _this._syncWriter = new SyncWriter({
          roomId: _this.id,
          fragmentIdComparer: _this._fragmentIdComparer,
          relationWriter: relationWriter,
          memberWriter: new MemberWriter(_this.id)
        });
        _this._sendQueue = new SendQueue({
          roomId: _this.id,
          storage: _this._storage,
          hsApi: _this._hsApi,
          pendingEvents: pendingEvents
        });
        return _this;
      }

      _createClass(Room, [{
        key: "_setEncryption",
        value: function _setEncryption(roomEncryption) {
          if (_get(_getPrototypeOf(Room.prototype), "_setEncryption", this).call(this, roomEncryption)) {
            this._sendQueue.enableEncryption(this._roomEncryption);

            return true;
          }

          return false;
        }
      }, {
        key: "prepareSync",
        value: function () {
          var _prepareSync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(roomResponse, membership, invite, newKeys, txn, log) {
            var summaryChanges, roomEncryption, retryEntries, decryptPreparation, _roomResponse$timelin, eventsToDecrypt;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    log.set("id", this.id);

                    if (newKeys) {
                      log.set("newKeys", newKeys.length);
                    }

                    summaryChanges = this._summary.data.applySyncResponse(roomResponse, membership);

                    if (membership === "join" && invite) {
                      summaryChanges = summaryChanges.applyInvite(invite);
                    }

                    roomEncryption = this._roomEncryption; // encryption is enabled in this sync

                    if (!roomEncryption && summaryChanges.encryption) {
                      log.set("enableEncryption", true);
                      roomEncryption = this._createRoomEncryption(this, summaryChanges.encryption);
                    }

                    if (!roomEncryption) {
                      _context.next = 18;
                      break;
                    }

                    eventsToDecrypt = (roomResponse === null || roomResponse === void 0 ? void 0 : (_roomResponse$timelin = roomResponse.timeline) === null || _roomResponse$timelin === void 0 ? void 0 : _roomResponse$timelin.events) || []; // when new keys arrive, also see if any older events can now be retried to decrypt

                    if (!newKeys) {
                      _context.next = 13;
                      break;
                    }

                    _context.next = 11;
                    return this._getSyncRetryDecryptEntries(newKeys, roomEncryption, txn);

                  case 11:
                    retryEntries = _context.sent;

                    if (retryEntries.length) {
                      log.set("retry", retryEntries.length);
                      eventsToDecrypt = eventsToDecrypt.concat(retryEntries.map(function (entry) {
                        return entry.event;
                      }));
                    }

                  case 13:
                    eventsToDecrypt = eventsToDecrypt.filter(function (event) {
                      return (event === null || event === void 0 ? void 0 : event.type) === EVENT_ENCRYPTED_TYPE$1;
                    });

                    if (!eventsToDecrypt.length) {
                      _context.next = 18;
                      break;
                    }

                    _context.next = 17;
                    return roomEncryption.prepareDecryptAll(eventsToDecrypt, newKeys, DecryptionSource.Sync, txn);

                  case 17:
                    decryptPreparation = _context.sent;

                  case 18:
                    return _context.abrupt("return", {
                      roomEncryption: roomEncryption,
                      summaryChanges: summaryChanges,
                      decryptPreparation: decryptPreparation,
                      decryptChanges: null,
                      retryEntries: retryEntries
                    });

                  case 19:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function prepareSync(_x, _x2, _x3, _x4, _x5, _x6) {
            return _prepareSync.apply(this, arguments);
          }

          return prepareSync;
        }()
      }, {
        key: "afterPrepareSync",
        value: function () {
          var _afterPrepareSync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(preparation, parentLog) {
            var _this2 = this;

            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (!preparation.decryptPreparation) {
                      _context3.next = 3;
                      break;
                    }

                    _context3.next = 3;
                    return parentLog.wrap("decrypt", /*#__PURE__*/function () {
                      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(log) {
                        return regeneratorRuntime.wrap(function _callee2$(_context2) {
                          while (1) {
                            switch (_context2.prev = _context2.next) {
                              case 0:
                                log.set("id", _this2.id);
                                _context2.next = 3;
                                return preparation.decryptPreparation.decrypt();

                              case 3:
                                preparation.decryptChanges = _context2.sent;
                                preparation.decryptPreparation = null;

                              case 5:
                              case "end":
                                return _context2.stop();
                            }
                          }
                        }, _callee2);
                      }));

                      return function (_x9) {
                        return _ref.apply(this, arguments);
                      };
                    }(), parentLog.level.Detail);

                  case 3:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));

          function afterPrepareSync(_x7, _x8) {
            return _afterPrepareSync.apply(this, arguments);
          }

          return afterPrepareSync;
        }()
        /** @package */

      }, {
        key: "writeSync",
        value: function () {
          var _writeSync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(roomResponse, isInitialSync, _ref2, txn, log) {
            var _this3 = this,
                _summaryChanges,
                _roomResponse$timelin2;

            var summaryChanges, decryptChanges, roomEncryption, retryEntries, isRejoin, _yield$log$wrap, newEntries, updatedEntries, newLiveKey, memberChanges, decryption, shouldFlushKeyShares, allEntries, heroChanges, removedPendingEvents, powerLevelsEvent;

            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    summaryChanges = _ref2.summaryChanges, decryptChanges = _ref2.decryptChanges, roomEncryption = _ref2.roomEncryption, retryEntries = _ref2.retryEntries;
                    log.set("id", this.id);
                    isRejoin = summaryChanges.isNewJoin(this._summary.data);

                    if (isRejoin) {
                      // remove all room state before calling syncWriter,
                      // so no old state sticks around
                      txn.roomState.removeAllForRoom(this.id);
                      txn.roomMembers.removeAllForRoom(this.id);
                    }

                    _context4.next = 6;
                    return log.wrap("syncWriter", function (log) {
                      return _this3._syncWriter.writeSync(roomResponse, isRejoin, summaryChanges.hasFetchedMembers, txn, log);
                    }, log.level.Detail);

                  case 6:
                    _yield$log$wrap = _context4.sent;
                    newEntries = _yield$log$wrap.entries;
                    updatedEntries = _yield$log$wrap.updatedEntries;
                    newLiveKey = _yield$log$wrap.newLiveKey;
                    memberChanges = _yield$log$wrap.memberChanges;

                    if (!decryptChanges) {
                      _context4.next = 22;
                      break;
                    }

                    _context4.next = 14;
                    return log.wrap("decryptChanges", function (log) {
                      return decryptChanges.write(txn, log);
                    });

                  case 14:
                    decryption = _context4.sent;
                    log.set("decryptionResults", decryption.results.size);
                    log.set("decryptionErrors", decryption.errors.size);

                    if (!this._isTimelineOpen) {
                      _context4.next = 20;
                      break;
                    }

                    _context4.next = 20;
                    return decryption.verifySenders(txn);

                  case 20:
                    decryption.applyToEntries(newEntries);

                    if (retryEntries === null || retryEntries === void 0 ? void 0 : retryEntries.length) {
                      decryption.applyToEntries(retryEntries);
                      updatedEntries.push.apply(updatedEntries, _toConsumableArray(retryEntries));
                    }

                  case 22:
                    log.set("newEntries", newEntries.length);
                    log.set("updatedEntries", updatedEntries.length);
                    shouldFlushKeyShares = false; // pass member changes to device tracker

                    if (!(roomEncryption && this.isTrackingMembers && (memberChanges === null || memberChanges === void 0 ? void 0 : memberChanges.size))) {
                      _context4.next = 30;
                      break;
                    }

                    _context4.next = 28;
                    return roomEncryption.writeMemberChanges(memberChanges, txn, log);

                  case 28:
                    shouldFlushKeyShares = _context4.sent;
                    log.set("shouldFlushKeyShares", shouldFlushKeyShares);

                  case 30:
                    allEntries = newEntries.concat(updatedEntries); // also apply (decrypted) timeline entries to the summary changes

                    summaryChanges = summaryChanges.applyTimelineEntries(allEntries, isInitialSync, !this._isTimelineOpen, this._user.id); // if we've have left the room, remove the summary

                    if (summaryChanges.membership !== "join") {
                      txn.roomSummary.remove(this.id);
                    } else {
                      // write summary changes, and unset if nothing was actually changed
                      summaryChanges = this._summary.writeData(summaryChanges, txn);
                    }

                    if (summaryChanges) {
                      log.set("summaryChanges", summaryChanges.diff(this._summary.data));
                    } // fetch new members while we have txn open,
                    // but don't make any in-memory changes yet


                    if (!((_summaryChanges = summaryChanges) === null || _summaryChanges === void 0 ? void 0 : _summaryChanges.needsHeroes)) {
                      _context4.next = 39;
                      break;
                    }

                    // room name disappeared, open heroes
                    if (!this._heroes) {
                      this._heroes = new Heroes(this._roomId);
                    }

                    _context4.next = 38;
                    return this._heroes.calculateChanges(summaryChanges.heroes, memberChanges, txn);

                  case 38:
                    heroChanges = _context4.sent;

                  case 39:
                    if (!Array.isArray((_roomResponse$timelin2 = roomResponse.timeline) === null || _roomResponse$timelin2 === void 0 ? void 0 : _roomResponse$timelin2.events)) {
                      _context4.next = 43;
                      break;
                    }

                    _context4.next = 42;
                    return this._sendQueue.removeRemoteEchos(roomResponse.timeline.events, txn, log);

                  case 42:
                    removedPendingEvents = _context4.sent;

                  case 43:
                    powerLevelsEvent = this._getPowerLevelsEvent(roomResponse);
                    return _context4.abrupt("return", {
                      summaryChanges: summaryChanges,
                      roomEncryption: roomEncryption,
                      newEntries: newEntries,
                      updatedEntries: updatedEntries,
                      newLiveKey: newLiveKey,
                      removedPendingEvents: removedPendingEvents,
                      memberChanges: memberChanges,
                      heroChanges: heroChanges,
                      powerLevelsEvent: powerLevelsEvent,
                      shouldFlushKeyShares: shouldFlushKeyShares
                    });

                  case 45:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function writeSync(_x10, _x11, _x12, _x13, _x14) {
            return _writeSync.apply(this, arguments);
          }

          return writeSync;
        }()
        /**
         * @package
         * Called with the changes returned from `writeSync` to apply them and emit changes.
         * No storage or network operations should be done here.
         */

      }, {
        key: "afterSync",
        value: function afterSync(changes, log) {
          var summaryChanges = changes.summaryChanges,
              newEntries = changes.newEntries,
              updatedEntries = changes.updatedEntries,
              newLiveKey = changes.newLiveKey,
              removedPendingEvents = changes.removedPendingEvents,
              memberChanges = changes.memberChanges,
              powerLevelsEvent = changes.powerLevelsEvent,
              heroChanges = changes.heroChanges,
              roomEncryption = changes.roomEncryption;
          log.set("id", this.id);

          this._syncWriter.afterSync(newLiveKey);

          this._setEncryption(roomEncryption);

          if (memberChanges.size) {
            if (this._changedMembersDuringSync) {
              var _iterator = _createForOfIteratorHelper(memberChanges.entries()),
                  _step;

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var _step$value = _slicedToArray(_step.value, 2),
                      userId = _step$value[0],
                      memberChange = _step$value[1];

                  this._changedMembersDuringSync.set(userId, memberChange.member);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            }

            if (this._memberList) {
              this._memberList.afterSync(memberChanges);
            }

            if (this._observedMembers) {
              this._updateObservedMembers(memberChanges);
            }

            if (this._timeline) {
              var _iterator2 = _createForOfIteratorHelper(memberChanges.entries()),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var _step2$value = _slicedToArray(_step2.value, 2),
                      _userId = _step2$value[0],
                      _memberChange = _step2$value[1];

                  if (_userId === this._user.id) {
                    this._timeline.updateOwnMember(_memberChange.member);

                    break;
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
          }

          var emitChange = false;

          if (summaryChanges) {
            this._summary.applyChanges(summaryChanges);

            if (!this._summary.data.needsHeroes) {
              this._heroes = null;
            }

            emitChange = true;
          }

          if (this._heroes && heroChanges) {
            var oldName = this.name;

            this._heroes.applyChanges(heroChanges, this._summary.data, log);

            if (oldName !== this.name) {
              emitChange = true;
            }
          }

          if (powerLevelsEvent) {
            this._updatePowerLevels(powerLevelsEvent);
          }

          if (emitChange) {
            this._emitUpdate();
          }

          if (this._timeline) {
            // these should not be added if not already there
            this._timeline.replaceEntries(updatedEntries);

            this._timeline.addEntries(newEntries);
          }

          if (this._observedEvents) {
            this._observedEvents.updateEvents(updatedEntries);

            this._observedEvents.updateEvents(newEntries);
          }

          if (removedPendingEvents) {
            this._sendQueue.emitRemovals(removedPendingEvents);
          }
        }
      }, {
        key: "_updateObservedMembers",
        value: function _updateObservedMembers(memberChanges) {
          var _iterator3 = _createForOfIteratorHelper(memberChanges),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var _step3$value = _slicedToArray(_step3.value, 2),
                  userId = _step3$value[0],
                  memberChange = _step3$value[1];

              var observableMember = this._observedMembers.get(userId);

              if (observableMember) {
                observableMember.set(memberChange.member);
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      }, {
        key: "_getPowerLevelsEvent",
        value: function _getPowerLevelsEvent(roomResponse) {
          var _roomResponse$timelin3, _roomResponse$timelin4, _roomResponse$state;

          var isPowerlevelEvent = function isPowerlevelEvent(event) {
            return event.state_key === "" && event.type === EVENT_TYPE$1;
          };

          var powerLevelEvent = (_roomResponse$timelin3 = (_roomResponse$timelin4 = roomResponse.timeline) === null || _roomResponse$timelin4 === void 0 ? void 0 : _roomResponse$timelin4.events.find(isPowerlevelEvent)) !== null && _roomResponse$timelin3 !== void 0 ? _roomResponse$timelin3 : (_roomResponse$state = roomResponse.state) === null || _roomResponse$state === void 0 ? void 0 : _roomResponse$state.events.find(isPowerlevelEvent);
          return powerLevelEvent;
        }
      }, {
        key: "_updatePowerLevels",
        value: function _updatePowerLevels(powerLevelEvent) {
          if (this._powerLevels) {
            var newPowerLevels = new PowerLevels({
              powerLevelEvent: powerLevelEvent,
              ownUserId: this._user.id,
              membership: this.membership
            });

            this._powerLevels.set(newPowerLevels);
          }
        }
      }, {
        key: "needsAfterSyncCompleted",
        value: function needsAfterSyncCompleted(_ref3) {
          var shouldFlushKeyShares = _ref3.shouldFlushKeyShares;
          return shouldFlushKeyShares;
        }
        /**
         * Only called if the result of writeSync had `needsAfterSyncCompleted` set.
         * Can be used to do longer running operations that resulted from the last sync,
         * like network operations.
         */

      }, {
        key: "afterSyncCompleted",
        value: function () {
          var _afterSyncCompleted = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(changes, log) {
            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    log.set("id", this.id);

                    if (!this._roomEncryption) {
                      _context5.next = 4;
                      break;
                    }

                    _context5.next = 4;
                    return this._roomEncryption.flushPendingRoomKeyShares(this._hsApi, null, log);

                  case 4:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));

          function afterSyncCompleted(_x15, _x16) {
            return _afterSyncCompleted.apply(this, arguments);
          }

          return afterSyncCompleted;
        }()
        /** @package */

      }, {
        key: "start",
        value: function start(pendingOperations, parentLog) {
          var _this4 = this;

          if (this._roomEncryption) {
            var roomKeyShares = pendingOperations === null || pendingOperations === void 0 ? void 0 : pendingOperations.get("share_room_key");

            if (roomKeyShares) {
              // if we got interrupted last time sending keys to newly joined members
              parentLog.wrapDetached("flush room keys", function (log) {
                log.set("id", _this4.id);
                return _this4._roomEncryption.flushPendingRoomKeyShares(_this4._hsApi, roomKeyShares, log);
              });
            }
          }

          this._sendQueue.resumeSending(parentLog);
        }
        /** @package */

      }, {
        key: "load",
        value: function () {
          var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(summary, txn, log) {
            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    _context6.prev = 0;
                    _context6.next = 3;
                    return _get(_getPrototypeOf(Room.prototype), "load", this).call(this, summary, txn, log);

                  case 3:
                    _context6.next = 5;
                    return this._syncWriter.load(txn, log);

                  case 5:
                    _context6.next = 10;
                    break;

                  case 7:
                    _context6.prev = 7;
                    _context6.t0 = _context6["catch"](0);
                    throw new WrappedError("Could not load room ".concat(this._roomId), _context6.t0);

                  case 10:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this, [[0, 7]]);
          }));

          function load(_x17, _x18, _x19) {
            return _load.apply(this, arguments);
          }

          return load;
        }()
      }, {
        key: "_writeGapFill",
        value: function () {
          var _writeGapFill2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(gapChunk, txn, log) {
            var removedPendingEvents;
            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.next = 2;
                    return this._sendQueue.removeRemoteEchos(gapChunk, txn, log);

                  case 2:
                    removedPendingEvents = _context7.sent;
                    return _context7.abrupt("return", removedPendingEvents);

                  case 4:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));

          function _writeGapFill(_x20, _x21, _x22) {
            return _writeGapFill2.apply(this, arguments);
          }

          return _writeGapFill;
        }()
      }, {
        key: "_applyGapFill",
        value: function _applyGapFill(removedPendingEvents) {
          this._sendQueue.emitRemovals(removedPendingEvents);
        }
        /** @public */

      }, {
        key: "sendEvent",
        value: function sendEvent(eventType, content, attachments) {
          var _this5 = this;

          var log = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
          return this._platform.logger.wrapOrRun(log, "send", function (log) {
            log.set("id", _this5.id);
            return _this5._sendQueue.enqueueEvent(eventType, content, attachments, log);
          });
        }
        /** @public */

      }, {
        key: "sendRedaction",
        value: function sendRedaction(eventIdOrTxnId, reason) {
          var _this6 = this;

          var log = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          return this._platform.logger.wrapOrRun(log, "redact", function (log) {
            log.set("id", _this6.id);
            return _this6._sendQueue.enqueueRedaction(eventIdOrTxnId, reason, log);
          });
        }
        /** @public */

      }, {
        key: "ensureMessageKeyIsShared",
        value: function () {
          var _ensureMessageKeyIsShared = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
            var _this7 = this;

            var log,
                _args8 = arguments;
            return regeneratorRuntime.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    log = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : null;

                    if (this._roomEncryption) {
                      _context8.next = 3;
                      break;
                    }

                    return _context8.abrupt("return");

                  case 3:
                    return _context8.abrupt("return", this._platform.logger.wrapOrRun(log, "ensureMessageKeyIsShared", function (log) {
                      log.set("id", _this7.id);
                      return _this7._roomEncryption.ensureMessageKeyIsShared(_this7._hsApi, log);
                    }));

                  case 4:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this);
          }));

          function ensureMessageKeyIsShared() {
            return _ensureMessageKeyIsShared.apply(this, arguments);
          }

          return ensureMessageKeyIsShared;
        }()
      }, {
        key: "_getLastEventId",
        value: function () {
          var _getLastEventId2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
            var lastKey, _eventEntry$event, txn, eventEntry;

            return regeneratorRuntime.wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    lastKey = this._syncWriter.lastMessageKey;

                    if (!lastKey) {
                      _context9.next = 9;
                      break;
                    }

                    _context9.next = 4;
                    return this._storage.readTxn([this._storage.storeNames.timelineEvents]);

                  case 4:
                    txn = _context9.sent;
                    _context9.next = 7;
                    return txn.timelineEvents.get(this._roomId, lastKey);

                  case 7:
                    eventEntry = _context9.sent;
                    return _context9.abrupt("return", eventEntry === null || eventEntry === void 0 ? void 0 : (_eventEntry$event = eventEntry.event) === null || _eventEntry$event === void 0 ? void 0 : _eventEntry$event.event_id);

                  case 9:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this);
          }));

          function _getLastEventId() {
            return _getLastEventId2.apply(this, arguments);
          }

          return _getLastEventId;
        }()
      }, {
        key: "clearUnread",
        value: function () {
          var _clearUnread = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
            var _this8 = this;

            var log,
                _args11 = arguments;
            return regeneratorRuntime.wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    log = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : null;

                    if (!(this.isUnread || this.notificationCount)) {
                      _context11.next = 5;
                      break;
                    }

                    _context11.next = 4;
                    return this._platform.logger.wrapOrRun(log, "clearUnread", /*#__PURE__*/function () {
                      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(log) {
                        var txn, data, lastEventId;
                        return regeneratorRuntime.wrap(function _callee10$(_context10) {
                          while (1) {
                            switch (_context10.prev = _context10.next) {
                              case 0:
                                log.set("id", _this8.id);
                                _context10.next = 3;
                                return _this8._storage.readWriteTxn([_this8._storage.storeNames.roomSummary]);

                              case 3:
                                txn = _context10.sent;
                                _context10.prev = 4;
                                data = _this8._summary.writeClearUnread(txn);
                                _context10.next = 12;
                                break;

                              case 8:
                                _context10.prev = 8;
                                _context10.t0 = _context10["catch"](4);
                                txn.abort();
                                throw _context10.t0;

                              case 12:
                                _context10.next = 14;
                                return txn.complete();

                              case 14:
                                _this8._summary.applyChanges(data);

                                _this8._emitUpdate();

                                _context10.prev = 16;
                                _context10.next = 19;
                                return _this8._getLastEventId();

                              case 19:
                                lastEventId = _context10.sent;

                                if (!lastEventId) {
                                  _context10.next = 23;
                                  break;
                                }

                                _context10.next = 23;
                                return _this8._hsApi.receipt(_this8._roomId, "m.read", lastEventId);

                              case 23:
                                _context10.next = 29;
                                break;

                              case 25:
                                _context10.prev = 25;
                                _context10.t1 = _context10["catch"](16);

                                if (!(_context10.t1.name !== "ConnectionError")) {
                                  _context10.next = 29;
                                  break;
                                }

                                throw _context10.t1;

                              case 29:
                              case "end":
                                return _context10.stop();
                            }
                          }
                        }, _callee10, null, [[4, 8], [16, 25]]);
                      }));

                      return function (_x23) {
                        return _ref4.apply(this, arguments);
                      };
                    }());

                  case 4:
                    return _context11.abrupt("return", _context11.sent);

                  case 5:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this);
          }));

          function clearUnread() {
            return _clearUnread.apply(this, arguments);
          }

          return clearUnread;
        }()
      }, {
        key: "leave",
        value: function leave() {
          var _this9 = this;

          var log = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          return this._platform.logger.wrapOrRun(log, "leave room", /*#__PURE__*/function () {
            var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(log) {
              return regeneratorRuntime.wrap(function _callee12$(_context12) {
                while (1) {
                  switch (_context12.prev = _context12.next) {
                    case 0:
                      log.set("id", _this9.id);
                      _context12.next = 3;
                      return _this9._hsApi.leave(_this9.id, {
                        log: log
                      }).response();

                    case 3:
                    case "end":
                      return _context12.stop();
                  }
                }
              }, _callee12);
            }));

            return function (_x24) {
              return _ref5.apply(this, arguments);
            };
          }());
        }
        /* called by BaseRoom to pass pendingEvents when opening the timeline */

      }, {
        key: "_getPendingEvents",
        value: function _getPendingEvents() {
          return this._sendQueue.pendingEvents;
        }
        /** @package */

      }, {
        key: "writeIsTrackingMembers",
        value: function writeIsTrackingMembers(value, txn) {
          return this._summary.writeIsTrackingMembers(value, txn);
        }
        /** @package */

      }, {
        key: "applyIsTrackingMembersChanges",
        value: function applyIsTrackingMembersChanges(changes) {
          this._summary.applyChanges(changes);
        }
      }, {
        key: "createAttachment",
        value: function createAttachment(blob, filename) {
          return new AttachmentUpload({
            blob: blob,
            filename: filename,
            platform: this._platform
          });
        }
      }, {
        key: "dispose",
        value: function dispose() {
          _get(_getPrototypeOf(Room.prototype), "dispose", this).call(this);

          this._sendQueue.dispose();
        }
      }, {
        key: "avatarColorId",
        get: function get() {
          var _this$_heroes;

          return ((_this$_heroes = this._heroes) === null || _this$_heroes === void 0 ? void 0 : _this$_heroes.roomAvatarColorId) || this._roomId;
        }
      }, {
        key: "isUnread",
        get: function get() {
          return this._summary.data.isUnread;
        }
      }, {
        key: "notificationCount",
        get: function get() {
          return this._summary.data.notificationCount;
        }
      }, {
        key: "highlightCount",
        get: function get() {
          return this._summary.data.highlightCount;
        }
      }, {
        key: "isTrackingMembers",
        get: function get() {
          return this._summary.data.isTrackingMembers;
        }
      }]);

      return Room;
    }(BaseRoom);

    var ArchivedRoom = /*#__PURE__*/function (_BaseRoom) {
      _inherits(ArchivedRoom, _BaseRoom);

      var _super = _createSuper(ArchivedRoom);

      function ArchivedRoom(options) {
        var _this;

        _classCallCheck(this, ArchivedRoom);

        _this = _super.call(this, options); // archived rooms are reference counted,
        // as they are not kept in memory when not needed

        _this._releaseCallback = options.releaseCallback;
        _this._forgetCallback = options.forgetCallback;
        _this._retentionCount = 1;
        /**
        Some details from our own member event when being kicked or banned.
        We can't get this from the member store, because we don't store the reason field there.
        */

        _this._kickDetails = null;
        _this._kickedBy = null;
        return _this;
      }

      _createClass(ArchivedRoom, [{
        key: "retain",
        value: function retain() {
          this._retentionCount += 1;
        }
      }, {
        key: "release",
        value: function release() {
          this._retentionCount -= 1;

          if (this._retentionCount === 0) {
            this._releaseCallback();
          }
        }
      }, {
        key: "_getKickAuthor",
        value: function () {
          var _getKickAuthor2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(sender, txn) {
            var senderMember;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return txn.roomMembers.get(this.id, sender);

                  case 2:
                    senderMember = _context.sent;

                    if (!senderMember) {
                      _context.next = 7;
                      break;
                    }

                    return _context.abrupt("return", new RoomMember(senderMember));

                  case 7:
                    return _context.abrupt("return", RoomMember.fromUserId(this.id, sender, "join"));

                  case 8:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function _getKickAuthor(_x, _x2) {
            return _getKickAuthor2.apply(this, arguments);
          }

          return _getKickAuthor;
        }()
      }, {
        key: "load",
        value: function () {
          var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(archivedRoomSummary, txn, log) {
            var summary, kickDetails;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    summary = archivedRoomSummary.summary, kickDetails = archivedRoomSummary.kickDetails;
                    this._kickDetails = kickDetails;

                    if (!this._kickDetails) {
                      _context2.next = 6;
                      break;
                    }

                    _context2.next = 5;
                    return this._getKickAuthor(this._kickDetails.sender, txn);

                  case 5:
                    this._kickedBy = _context2.sent;

                  case 6:
                    return _context2.abrupt("return", _get(_getPrototypeOf(ArchivedRoom.prototype), "load", this).call(this, summary, txn, log));

                  case 7:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function load(_x3, _x4, _x5) {
            return _load.apply(this, arguments);
          }

          return load;
        }()
        /** @package */

      }, {
        key: "writeSync",
        value: function () {
          var _writeSync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(joinedSummaryData, roomResponse, membership, txn, log) {
            var newKickDetails, kickDetails, kickedBy, summaryData;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    log.set("id", this.id);

                    if (!(membership === "leave")) {
                      _context3.next = 14;
                      break;
                    }

                    newKickDetails = findKickDetails(roomResponse, this._user.id);

                    if (!(newKickDetails || joinedSummaryData)) {
                      _context3.next = 12;
                      break;
                    }

                    kickDetails = newKickDetails || this._kickDetails;

                    if (!newKickDetails) {
                      _context3.next = 9;
                      break;
                    }

                    _context3.next = 8;
                    return this._getKickAuthor(newKickDetails.sender, txn);

                  case 8:
                    kickedBy = _context3.sent;

                  case 9:
                    summaryData = joinedSummaryData || this._summary.data;
                    txn.archivedRoomSummary.set({
                      summary: summaryData.serialize(),
                      kickDetails: kickDetails
                    });
                    return _context3.abrupt("return", {
                      kickDetails: kickDetails,
                      kickedBy: kickedBy,
                      summaryData: summaryData
                    });

                  case 12:
                    _context3.next = 15;
                    break;

                  case 14:
                    if (membership === "join") {
                      txn.archivedRoomSummary.remove(this.id);
                    }

                  case 15:
                    return _context3.abrupt("return", {});

                  case 16:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function writeSync(_x6, _x7, _x8, _x9, _x10) {
            return _writeSync.apply(this, arguments);
          }

          return writeSync;
        }()
        /**
         * @package
         * Called with the changes returned from `writeSync` to apply them and emit changes.
         * No storage or network operations should be done here.
         */

      }, {
        key: "afterSync",
        value: function afterSync(_ref, log) {
          var summaryData = _ref.summaryData,
              kickDetails = _ref.kickDetails,
              kickedBy = _ref.kickedBy;
          log.set("id", this.id);

          if (summaryData) {
            this._summary.applyChanges(summaryData);
          }

          if (kickDetails) {
            this._kickDetails = kickDetails;
          }

          if (kickedBy) {
            this._kickedBy = kickedBy;
          }

          this._emitUpdate();
        }
      }, {
        key: "isArchived",
        value: function isArchived() {
          return true;
        }
      }, {
        key: "forget",
        value: function forget() {
          var _this2 = this;

          var log = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          return this._platform.logger.wrapOrRun(log, "forget room", /*#__PURE__*/function () {
            var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(log) {
              var storeNames, txn;
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      log.set("id", _this2.id);
                      _context4.next = 3;
                      return _this2._hsApi.forget(_this2.id, {
                        log: log
                      }).response();

                    case 3:
                      storeNames = _this2._storage.storeNames;
                      _context4.next = 6;
                      return _this2._storage.readWriteTxn([storeNames.roomState, storeNames.archivedRoomSummary, storeNames.roomMembers, storeNames.timelineEvents, storeNames.timelineFragments, storeNames.timelineRelations, storeNames.pendingEvents, storeNames.inboundGroupSessions, storeNames.groupSessionDecryptions, storeNames.operations]);

                    case 6:
                      txn = _context4.sent;
                      txn.roomState.removeAllForRoom(_this2.id);
                      txn.archivedRoomSummary.remove(_this2.id);
                      txn.roomMembers.removeAllForRoom(_this2.id);
                      txn.timelineEvents.removeAllForRoom(_this2.id);
                      txn.timelineFragments.removeAllForRoom(_this2.id);
                      txn.timelineRelations.removeAllForRoom(_this2.id);
                      txn.pendingEvents.removeAllForRoom(_this2.id);
                      txn.inboundGroupSessions.removeAllForRoom(_this2.id);
                      txn.groupSessionDecryptions.removeAllForRoom(_this2.id);
                      _context4.next = 18;
                      return txn.operations.removeAllForScope(_this2.id);

                    case 18:
                      _context4.next = 20;
                      return txn.complete();

                    case 20:
                      _this2._retentionCount = 0;

                      _this2._releaseCallback();

                      _this2._forgetCallback(_this2.id);

                    case 23:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4);
            }));

            return function (_x11) {
              return _ref2.apply(this, arguments);
            };
          }());
        }
      }, {
        key: "join",
        value: function join() {
          var _this3 = this;

          var log = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          return this._platform.logger.wrapOrRun(log, "rejoin archived room", /*#__PURE__*/function () {
            var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(log) {
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      _context5.next = 2;
                      return _this3._hsApi.join(_this3.id, {
                        log: log
                      }).response();

                    case 2:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5);
            }));

            return function (_x12) {
              return _ref3.apply(this, arguments);
            };
          }());
        }
      }, {
        key: "isKicked",
        get: function get() {
          var _this$_kickDetails;

          return ((_this$_kickDetails = this._kickDetails) === null || _this$_kickDetails === void 0 ? void 0 : _this$_kickDetails.membership) === "leave";
        }
      }, {
        key: "isBanned",
        get: function get() {
          var _this$_kickDetails2;

          return ((_this$_kickDetails2 = this._kickDetails) === null || _this$_kickDetails2 === void 0 ? void 0 : _this$_kickDetails2.membership) === "ban";
        }
      }, {
        key: "kickedBy",
        get: function get() {
          return this._kickedBy;
        }
      }, {
        key: "kickReason",
        get: function get() {
          var _this$_kickDetails3;

          return (_this$_kickDetails3 = this._kickDetails) === null || _this$_kickDetails3 === void 0 ? void 0 : _this$_kickDetails3.reason;
        }
      }]);

      return ArchivedRoom;
    }(BaseRoom);

    function findKickDetails(roomResponse, ownUserId) {
      var kickEvent = reduceStateEvents(roomResponse, function (kickEvent, event) {
        if (event.type === EVENT_TYPE) {
          // did we get kicked?
          if (event.state_key === ownUserId && event.sender !== event.state_key) {
            kickEvent = event;
          }
        }

        return kickEvent;
      }, null);

      if (kickEvent) {
        var _kickEvent$content, _kickEvent$content2;

        return {
          // this is different from the room membership in the sync section, which can only be leave
          membership: (_kickEvent$content = kickEvent.content) === null || _kickEvent$content === void 0 ? void 0 : _kickEvent$content.membership,
          // could be leave or ban
          reason: (_kickEvent$content2 = kickEvent.content) === null || _kickEvent$content2 === void 0 ? void 0 : _kickEvent$content2.reason,
          sender: kickEvent.sender
        };
      }
    }

    /*
    Copyright 2021 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var RoomStatus = /*#__PURE__*/function () {
      function RoomStatus(joined, invited, archived) {
        _classCallCheck(this, RoomStatus);

        this.joined = joined;
        this.invited = invited;
        this.archived = archived;
      }

      _createClass(RoomStatus, [{
        key: "withInvited",
        value: function withInvited() {
          if (this.invited) {
            return this;
          } else if (this.archived) {
            return RoomStatus.invitedAndArchived;
          } else {
            return RoomStatus.invited;
          }
        }
      }, {
        key: "withoutInvited",
        value: function withoutInvited() {
          if (!this.invited) {
            return this;
          } else if (this.joined) {
            return RoomStatus.joined;
          } else if (this.archived) {
            return RoomStatus.archived;
          } else {
            return RoomStatus.none;
          }
        }
      }, {
        key: "withoutArchived",
        value: function withoutArchived() {
          if (!this.archived) {
            return this;
          } else if (this.invited) {
            return RoomStatus.invited;
          } else {
            return RoomStatus.none;
          }
        }
      }]);

      return RoomStatus;
    }();
    RoomStatus.joined = new RoomStatus(true, false, false);
    RoomStatus.archived = new RoomStatus(false, false, true);
    RoomStatus.invited = new RoomStatus(false, true, false);
    RoomStatus.invitedAndArchived = new RoomStatus(false, true, true);
    RoomStatus.none = new RoomStatus(false, false, false);

    var Invite = /*#__PURE__*/function (_EventEmitter) {
      _inherits(Invite, _EventEmitter);

      var _super = _createSuper(Invite);

      function Invite(_ref) {
        var _this;

        var roomId = _ref.roomId,
            user = _ref.user,
            hsApi = _ref.hsApi,
            mediaRepository = _ref.mediaRepository,
            emitCollectionRemove = _ref.emitCollectionRemove,
            emitCollectionUpdate = _ref.emitCollectionUpdate,
            platform = _ref.platform;

        _classCallCheck(this, Invite);

        _this = _super.call(this);
        _this._roomId = roomId;
        _this._user = user;
        _this._hsApi = hsApi;
        _this._emitCollectionRemove = emitCollectionRemove;
        _this._emitCollectionUpdate = emitCollectionUpdate;
        _this._mediaRepository = mediaRepository;
        _this._platform = platform;
        _this._inviteData = null;
        _this._accepting = false;
        _this._rejecting = false;
        _this._accepted = false;
        _this._rejected = false;
        return _this;
      }

      _createClass(Invite, [{
        key: "accept",
        value: function () {
          var _accept = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            var _this2 = this;

            var log,
                _args2 = arguments;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    log = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : null;
                    _context2.next = 3;
                    return this._platform.logger.wrapOrRun(log, "acceptInvite", /*#__PURE__*/function () {
                      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(log) {
                        return regeneratorRuntime.wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                _this2._accepting = true;

                                _this2._emitChange("accepting");

                                _context.next = 4;
                                return _this2._hsApi.join(_this2._roomId, {
                                  log: log
                                }).response();

                              case 4:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee);
                      }));

                      return function (_x) {
                        return _ref2.apply(this, arguments);
                      };
                    }());

                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function accept() {
            return _accept.apply(this, arguments);
          }

          return accept;
        }()
      }, {
        key: "reject",
        value: function () {
          var _reject = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
            var _this3 = this;

            var log,
                _args4 = arguments;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    log = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : null;
                    _context4.next = 3;
                    return this._platform.logger.wrapOrRun(log, "rejectInvite", /*#__PURE__*/function () {
                      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(log) {
                        return regeneratorRuntime.wrap(function _callee3$(_context3) {
                          while (1) {
                            switch (_context3.prev = _context3.next) {
                              case 0:
                                _this3._rejecting = true;

                                _this3._emitChange("rejecting");

                                _context3.next = 4;
                                return _this3._hsApi.leave(_this3._roomId, {
                                  log: log
                                }).response();

                              case 4:
                              case "end":
                                return _context3.stop();
                            }
                          }
                        }, _callee3);
                      }));

                      return function (_x2) {
                        return _ref3.apply(this, arguments);
                      };
                    }());

                  case 3:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function reject() {
            return _reject.apply(this, arguments);
          }

          return reject;
        }()
      }, {
        key: "_emitChange",
        value: function _emitChange(params) {
          this.emit("change");

          this._emitCollectionUpdate(this, params);
        }
      }, {
        key: "load",
        value: function load(inviteData, log) {
          log.set("id", this.id);
          this._inviteData = inviteData;
          this._inviter = inviteData.inviter ? new RoomMember(inviteData.inviter) : null;
        }
      }, {
        key: "writeSync",
        value: function () {
          var _writeSync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(membership, roomResponse, txn, log) {
            var _roomResponse$invite_, inviteState, summaryData, heroes, myInvite, inviter, inviteData;

            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    if (!(membership === "invite")) {
                      _context5.next = 20;
                      break;
                    }

                    log.set("id", this.id);
                    log.set("add", true);
                    inviteState = (_roomResponse$invite_ = roomResponse["invite_state"]) === null || _roomResponse$invite_ === void 0 ? void 0 : _roomResponse$invite_.events;

                    if (Array.isArray(inviteState)) {
                      _context5.next = 6;
                      break;
                    }

                    return _context5.abrupt("return", null);

                  case 6:
                    summaryData = this._createSummaryData(inviteState);

                    if (!(!summaryData.name && !summaryData.canonicalAlias)) {
                      _context5.next = 11;
                      break;
                    }

                    _context5.next = 10;
                    return this._createHeroes(inviteState, log);

                  case 10:
                    heroes = _context5.sent;

                  case 11:
                    myInvite = this._getMyInvite(inviteState);

                    if (myInvite) {
                      _context5.next = 14;
                      break;
                    }

                    return _context5.abrupt("return", null);

                  case 14:
                    inviter = this._getInviter(myInvite, inviteState);
                    inviteData = this._createData(inviteState, myInvite, inviter, summaryData, heroes);
                    txn.invites.set(inviteData);
                    return _context5.abrupt("return", {
                      inviteData: inviteData,
                      inviter: inviter
                    });

                  case 20:
                    log.set("id", this.id);
                    log.set("membership", membership);
                    txn.invites.remove(this.id);
                    return _context5.abrupt("return", {
                      removed: true,
                      membership: membership
                    });

                  case 24:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));

          function writeSync(_x3, _x4, _x5, _x6) {
            return _writeSync.apply(this, arguments);
          }

          return writeSync;
        }()
      }, {
        key: "afterSync",
        value: function afterSync(changes, log) {
          log.set("id", this.id);

          if (changes) {
            if (changes.removed) {
              this._accepting = false;
              this._rejecting = false;

              if (changes.membership === "join") {
                this._accepted = true;
              } else {
                this._rejected = true;
              }

              this.emit("change");
            } else {
              // no emit change, adding to the collection is done by sync
              this._inviteData = changes.inviteData;
              this._inviter = changes.inviter;
            }
          }
        }
      }, {
        key: "_createData",
        value: function _createData(inviteState, myInvite, inviter, summaryData, heroes) {
          var name = heroes ? heroes.roomName : summaryData.name;
          var avatarUrl = heroes ? heroes.roomAvatarUrl : summaryData.avatarUrl;
          var avatarColorId = (heroes === null || heroes === void 0 ? void 0 : heroes.roomAvatarColorId) || this.id;
          return {
            roomId: this.id,
            isEncrypted: !!summaryData.encryption,
            isDirectMessage: this._isDirectMessage(myInvite),
            //            type: 
            name: name,
            avatarUrl: avatarUrl,
            avatarColorId: avatarColorId,
            canonicalAlias: summaryData.canonicalAlias,
            timestamp: this._platform.clock.now(),
            joinRule: this._getJoinRule(inviteState),
            inviter: inviter === null || inviter === void 0 ? void 0 : inviter.serialize()
          };
        }
      }, {
        key: "_isDirectMessage",
        value: function _isDirectMessage(myInvite) {
          var _myInvite$content;

          return !!(myInvite === null || myInvite === void 0 ? void 0 : (_myInvite$content = myInvite.content) === null || _myInvite$content === void 0 ? void 0 : _myInvite$content.is_direct);
        }
      }, {
        key: "_createSummaryData",
        value: function _createSummaryData(inviteState) {
          return inviteState.reduce(processStateEvent, new SummaryData(null, this.id));
        }
      }, {
        key: "_createHeroes",
        value: function () {
          var _createHeroes2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(inviteState, log) {
            var _this4 = this;

            var members, otherMembers, memberChanges, otherUserIds, heroes, changes, countSummary;
            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    members = inviteState.filter(function (e) {
                      return e.type === EVENT_TYPE;
                    });
                    otherMembers = members.filter(function (e) {
                      return e.state_key !== _this4._user.id;
                    });
                    memberChanges = otherMembers.reduce(function (map, e) {
                      var member = RoomMember.fromMemberEvent(_this4.id, e);
                      map.set(member.userId, new MemberChange(member, null));
                      return map;
                    }, new Map());
                    otherUserIds = otherMembers.map(function (e) {
                      return e.state_key;
                    });
                    heroes = new Heroes(this.id);
                    _context6.next = 7;
                    return heroes.calculateChanges(otherUserIds, memberChanges, null);

                  case 7:
                    changes = _context6.sent;
                    // we don't get an actual lazy-loading m.heroes summary on invites,
                    // so just count the members by hand
                    countSummary = new SummaryData(null, this.id);
                    countSummary.joinCount = members.reduce(function (sum, e) {
                      var _e$content;

                      return sum + (((_e$content = e.content) === null || _e$content === void 0 ? void 0 : _e$content.membership) === "join" ? 1 : 0);
                    }, 0);
                    countSummary.inviteCount = members.reduce(function (sum, e) {
                      var _e$content2;

                      return sum + (((_e$content2 = e.content) === null || _e$content2 === void 0 ? void 0 : _e$content2.membership) === "invite" ? 1 : 0);
                    }, 0);
                    heroes.applyChanges(changes, countSummary, log);
                    return _context6.abrupt("return", heroes);

                  case 13:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));

          function _createHeroes(_x7, _x8) {
            return _createHeroes2.apply(this, arguments);
          }

          return _createHeroes;
        }()
      }, {
        key: "_getMyInvite",
        value: function _getMyInvite(inviteState) {
          var _this5 = this;

          return inviteState.find(function (e) {
            return e.type === EVENT_TYPE && e.state_key === _this5._user.id;
          });
        }
      }, {
        key: "_getInviter",
        value: function _getInviter(myInvite, inviteState) {
          var inviterMemberEvent = inviteState.find(function (e) {
            return e.type === EVENT_TYPE && e.state_key === myInvite.sender;
          });

          if (inviterMemberEvent) {
            return RoomMember.fromMemberEvent(this.id, inviterMemberEvent);
          }
        }
      }, {
        key: "_getJoinRule",
        value: function _getJoinRule(inviteState) {
          var event = inviteState.find(function (e) {
            return e.type === "m.room.join_rules";
          });

          if (event) {
            var _event$content;

            return (_event$content = event.content) === null || _event$content === void 0 ? void 0 : _event$content.join_rule;
          }

          return null;
        }
      }, {
        key: "isInvite",
        get: function get() {
          return true;
        }
      }, {
        key: "id",
        get: function get() {
          return this._roomId;
        }
      }, {
        key: "name",
        get: function get() {
          return this._inviteData.name || this._inviteData.canonicalAlias;
        }
      }, {
        key: "isDirectMessage",
        get: function get() {
          return this._inviteData.isDirectMessage;
        }
      }, {
        key: "avatarUrl",
        get: function get() {
          return this._inviteData.avatarUrl;
        }
        /** @see BaseRoom.avatarColorId */

      }, {
        key: "avatarColorId",
        get: function get() {
          return this._inviteData.avatarColorId || this.id;
        }
      }, {
        key: "timestamp",
        get: function get() {
          return this._inviteData.timestamp;
        }
      }, {
        key: "isEncrypted",
        get: function get() {
          return this._inviteData.isEncrypted;
        }
      }, {
        key: "inviter",
        get: function get() {
          return this._inviter;
        }
      }, {
        key: "isPublic",
        get: function get() {
          return this._inviteData.joinRule === "public";
        }
      }, {
        key: "canonicalAlias",
        get: function get() {
          return this._inviteData.canonicalAlias;
        }
      }, {
        key: "accepting",
        get: function get() {
          return this._accepting;
        }
      }, {
        key: "accepted",
        get: function get() {
          return this._accepted;
        }
      }, {
        key: "rejecting",
        get: function get() {
          return this._rejecting;
        }
      }, {
        key: "rejected",
        get: function get() {
          return this._rejected;
        }
      }, {
        key: "mediaRepository",
        get: function get() {
          return this._mediaRepository;
        }
      }]);

      return Invite;
    }(EventEmitter);

    var Pusher = /*#__PURE__*/function () {
      function Pusher(description) {
        _classCallCheck(this, Pusher);

        this._description = description;
      }

      _createClass(Pusher, [{
        key: "enable",
        value: function () {
          var _enable = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(hsApi, log) {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    try {
                      log.set("endpoint", new URL(this._description.data.endpoint).host);
                    } catch (_unused) {
                      log.set("endpoint", null);
                    }

                    _context.next = 3;
                    return hsApi.setPusher(this._description, {
                      log: log
                    }).response();

                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function enable(_x, _x2) {
            return _enable.apply(this, arguments);
          }

          return enable;
        }()
      }, {
        key: "disable",
        value: function () {
          var _disable = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(hsApi, log) {
            var deleteDescription;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    deleteDescription = Object.assign({}, this._description, {
                      kind: null
                    });
                    _context2.next = 3;
                    return hsApi.setPusher(deleteDescription, {
                      log: log
                    }).response();

                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function disable(_x3, _x4) {
            return _disable.apply(this, arguments);
          }

          return disable;
        }()
      }, {
        key: "serialize",
        value: function serialize() {
          return this._description;
        }
      }, {
        key: "equals",
        value: function equals(pusher) {
          if (this._description.app_id !== pusher._description.app_id) {
            return false;
          }

          if (this._description.pushkey !== pusher._description.pushkey) {
            return false;
          }

          return JSON.stringify(this._description.data) === JSON.stringify(pusher._description.data);
        }
      }], [{
        key: "httpPusher",
        value: function httpPusher(host, appId, pushkey, data) {
          return new Pusher({
            kind: "http",
            append: true,
            // as pushkeys are shared between multiple users on one origin
            data: Object.assign({}, data, {
              url: host + "/_matrix/push/v1/notify"
            }),
            pushkey: pushkey,
            app_id: appId,
            app_display_name: "Hydrogen",
            device_display_name: "Hydrogen",
            lang: "en"
          });
        }
      }, {
        key: "createDefaultPayload",
        value: function createDefaultPayload(sessionId) {
          return {
            session_id: sessionId
          };
        }
      }]);

      return Pusher;
    }();

    function groupBy(array, groupFn) {
      return groupByWithCreator(array, groupFn, function () {
        return [];
      }, function (array2, value) {
        return array2.push(value);
      });
    }
    function groupByWithCreator(array, groupFn, createCollectionFn, addCollectionFn) {
      return array.reduce(function (map, value) {
        var key = groupFn(value);
        var collection = map.get(key);

        if (!collection) {
          collection = createCollectionFn();
          map.set(key, collection);
        }

        addCollectionFn(collection, value);
        return map;
      }, new Map());
    }

    function _countBy(events, mapper) {
      return events.reduce(function (counts, event) {
        var mappedValue = mapper(event);

        if (!counts[mappedValue]) {
          counts[mappedValue] = 1;
        } else {
          counts[mappedValue] += 1;
        }

        return counts;
      }, {});
    }

    var DeviceMessageHandler = /*#__PURE__*/function () {
      function DeviceMessageHandler(_ref) {
        var storage = _ref.storage;

        _classCallCheck(this, DeviceMessageHandler);

        this._storage = storage;
        this._olmDecryption = null;
        this._megolmDecryption = null;
      }

      _createClass(DeviceMessageHandler, [{
        key: "enableEncryption",
        value: function enableEncryption(_ref2) {
          var olmDecryption = _ref2.olmDecryption,
              megolmDecryption = _ref2.megolmDecryption;
          this._olmDecryption = olmDecryption;
          this._megolmDecryption = megolmDecryption;
        }
      }, {
        key: "obtainSyncLock",
        value: function obtainSyncLock(toDeviceEvents) {
          var _this$_olmDecryption;

          return (_this$_olmDecryption = this._olmDecryption) === null || _this$_olmDecryption === void 0 ? void 0 : _this$_olmDecryption.obtainDecryptionLock(toDeviceEvents);
        }
      }, {
        key: "prepareSync",
        value: function () {
          var _prepareSync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(toDeviceEvents, lock, txn, log) {
            var encryptedEvents, olmEvents, olmDecryptChanges, _iterator, _step, err, newRoomKeys;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    log.set("messageTypes", _countBy(toDeviceEvents, function (e) {
                      return e.type;
                    }));
                    encryptedEvents = toDeviceEvents.filter(function (e) {
                      return e.type === "m.room.encrypted";
                    });

                    if (this._olmDecryption) {
                      _context.next = 5;
                      break;
                    }

                    log.log("can't decrypt, encryption not enabled", log.level.Warn);
                    return _context.abrupt("return");

                  case 5:
                    // only know olm for now
                    olmEvents = encryptedEvents.filter(function (e) {
                      var _e$content;

                      return ((_e$content = e.content) === null || _e$content === void 0 ? void 0 : _e$content.algorithm) === OLM_ALGORITHM;
                    });

                    if (!olmEvents.length) {
                      _context.next = 15;
                      break;
                    }

                    _context.next = 9;
                    return this._olmDecryption.decryptAll(olmEvents, lock, txn);

                  case 9:
                    olmDecryptChanges = _context.sent;
                    log.set("decryptedTypes", _countBy(olmDecryptChanges.results, function (r) {
                      var _r$event;

                      return (_r$event = r.event) === null || _r$event === void 0 ? void 0 : _r$event.type;
                    }));
                    _iterator = _createForOfIteratorHelper(olmDecryptChanges.errors);

                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done;) {
                        err = _step.value;
                        log.child("decrypt_error").catch(err);
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }

                    newRoomKeys = this._megolmDecryption.roomKeysFromDeviceMessages(olmDecryptChanges.results, log);
                    return _context.abrupt("return", new SyncPreparation(olmDecryptChanges, newRoomKeys));

                  case 15:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function prepareSync(_x, _x2, _x3, _x4) {
            return _prepareSync.apply(this, arguments);
          }

          return prepareSync;
        }()
        /** check that prep is not undefined before calling this */

      }, {
        key: "writeSync",
        value: function () {
          var _writeSync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(prep, txn) {
            var _this = this;

            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    // write olm changes
                    prep.olmDecryptChanges.write(txn);
                    _context2.next = 3;
                    return Promise.all(prep.newRoomKeys.map(function (key) {
                      return _this._megolmDecryption.writeRoomKey(key, txn);
                    }));

                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          function writeSync(_x5, _x6) {
            return _writeSync.apply(this, arguments);
          }

          return writeSync;
        }()
      }]);

      return DeviceMessageHandler;
    }();

    var SyncPreparation = function SyncPreparation(olmDecryptChanges, newRoomKeys) {
      _classCallCheck(this, SyncPreparation);

      this.olmDecryptChanges = olmDecryptChanges;
      this.newRoomKeys = newRoomKeys;
      this.newKeysByRoom = groupBy(newRoomKeys, function (r) {
        return r.roomId;
      });
    };

    var ACCOUNT_SESSION_KEY = SESSION_E2EE_KEY_PREFIX + "olmAccount";
    var DEVICE_KEY_FLAG_SESSION_KEY = SESSION_E2EE_KEY_PREFIX + "areDeviceKeysUploaded";
    var SERVER_OTK_COUNT_SESSION_KEY = SESSION_E2EE_KEY_PREFIX + "serverOTKCount";

    function initiallyStoreAccount(_x, _x2, _x3, _x4, _x5) {
      return _initiallyStoreAccount.apply(this, arguments);
    }

    function _initiallyStoreAccount() {
      _initiallyStoreAccount = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(account, pickleKey, areDeviceKeysUploaded, serverOTKCount, storage) {
        var pickledAccount, txn;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                pickledAccount = account.pickle(pickleKey);
                _context8.next = 3;
                return storage.readWriteTxn([storage.storeNames.session]);

              case 3:
                txn = _context8.sent;
                _context8.prev = 4;
                // add will throw if the key already exists
                // we would not want to overwrite olmAccount here
                txn.session.add(ACCOUNT_SESSION_KEY, pickledAccount);
                txn.session.add(DEVICE_KEY_FLAG_SESSION_KEY, areDeviceKeysUploaded);
                txn.session.add(SERVER_OTK_COUNT_SESSION_KEY, serverOTKCount);
                _context8.next = 14;
                break;

              case 10:
                _context8.prev = 10;
                _context8.t0 = _context8["catch"](4);
                txn.abort();
                throw _context8.t0;

              case 14:
                _context8.next = 16;
                return txn.complete();

              case 16:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, null, [[4, 10]]);
      }));
      return _initiallyStoreAccount.apply(this, arguments);
    }

    var Account = /*#__PURE__*/function () {
      _createClass(Account, null, [{
        key: "load",
        value: function () {
          var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref) {
            var olm, pickleKey, hsApi, userId, deviceId, olmWorker, txn, pickledAccount, account, areDeviceKeysUploaded, serverOTKCount;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    olm = _ref.olm, pickleKey = _ref.pickleKey, hsApi = _ref.hsApi, userId = _ref.userId, deviceId = _ref.deviceId, olmWorker = _ref.olmWorker, txn = _ref.txn;
                    _context.next = 3;
                    return txn.session.get(ACCOUNT_SESSION_KEY);

                  case 3:
                    pickledAccount = _context.sent;

                    if (!pickledAccount) {
                      _context.next = 14;
                      break;
                    }

                    account = new olm.Account();
                    _context.next = 8;
                    return txn.session.get(DEVICE_KEY_FLAG_SESSION_KEY);

                  case 8:
                    areDeviceKeysUploaded = _context.sent;
                    account.unpickle(pickleKey, pickledAccount);
                    _context.next = 12;
                    return txn.session.get(SERVER_OTK_COUNT_SESSION_KEY);

                  case 12:
                    serverOTKCount = _context.sent;
                    return _context.abrupt("return", new Account({
                      pickleKey: pickleKey,
                      hsApi: hsApi,
                      account: account,
                      userId: userId,
                      deviceId: deviceId,
                      areDeviceKeysUploaded: areDeviceKeysUploaded,
                      serverOTKCount: serverOTKCount,
                      olm: olm,
                      olmWorker: olmWorker
                    }));

                  case 14:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function load(_x6) {
            return _load.apply(this, arguments);
          }

          return load;
        }()
      }, {
        key: "adoptDehydratedDevice",
        value: function () {
          var _adoptDehydratedDevice = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref2) {
            var olm, dehydratedDevice, pickleKey, hsApi, userId, olmWorker, storage, account, oneTimeKeys, oneTimeKeysEntries, serverOTKCount, areDeviceKeysUploaded;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    olm = _ref2.olm, dehydratedDevice = _ref2.dehydratedDevice, pickleKey = _ref2.pickleKey, hsApi = _ref2.hsApi, userId = _ref2.userId, olmWorker = _ref2.olmWorker, storage = _ref2.storage;
                    account = dehydratedDevice.adoptUnpickledOlmAccount();
                    oneTimeKeys = JSON.parse(account.one_time_keys()); // only one algorithm supported by olm atm, so hardcode its name

                    oneTimeKeysEntries = Object.entries(oneTimeKeys.curve25519);
                    serverOTKCount = oneTimeKeysEntries.length;
                    areDeviceKeysUploaded = true;
                    _context2.next = 8;
                    return initiallyStoreAccount(account, pickleKey, areDeviceKeysUploaded, serverOTKCount, storage);

                  case 8:
                    return _context2.abrupt("return", new Account({
                      pickleKey: pickleKey,
                      hsApi: hsApi,
                      account: account,
                      userId: userId,
                      deviceId: dehydratedDevice.deviceId,
                      areDeviceKeysUploaded: areDeviceKeysUploaded,
                      serverOTKCount: serverOTKCount,
                      olm: olm,
                      olmWorker: olmWorker
                    }));

                  case 9:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          function adoptDehydratedDevice(_x7) {
            return _adoptDehydratedDevice.apply(this, arguments);
          }

          return adoptDehydratedDevice;
        }()
      }, {
        key: "create",
        value: function () {
          var _create = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(_ref3) {
            var olm, pickleKey, hsApi, userId, deviceId, olmWorker, storage, account, areDeviceKeysUploaded, serverOTKCount;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    olm = _ref3.olm, pickleKey = _ref3.pickleKey, hsApi = _ref3.hsApi, userId = _ref3.userId, deviceId = _ref3.deviceId, olmWorker = _ref3.olmWorker, storage = _ref3.storage;
                    account = new olm.Account();

                    if (!olmWorker) {
                      _context3.next = 7;
                      break;
                    }

                    _context3.next = 5;
                    return olmWorker.createAccountAndOTKs(account, account.max_number_of_one_time_keys());

                  case 5:
                    _context3.next = 9;
                    break;

                  case 7:
                    account.create();
                    account.generate_one_time_keys(account.max_number_of_one_time_keys());

                  case 9:
                    areDeviceKeysUploaded = false;
                    serverOTKCount = 0;

                    if (!storage) {
                      _context3.next = 14;
                      break;
                    }

                    _context3.next = 14;
                    return initiallyStoreAccount(account, pickleKey, areDeviceKeysUploaded, serverOTKCount, storage);

                  case 14:
                    return _context3.abrupt("return", new Account({
                      pickleKey: pickleKey,
                      hsApi: hsApi,
                      account: account,
                      userId: userId,
                      deviceId: deviceId,
                      areDeviceKeysUploaded: areDeviceKeysUploaded,
                      serverOTKCount: serverOTKCount,
                      olm: olm,
                      olmWorker: olmWorker
                    }));

                  case 15:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));

          function create(_x8) {
            return _create.apply(this, arguments);
          }

          return create;
        }()
      }]);

      function Account(_ref4) {
        var pickleKey = _ref4.pickleKey,
            hsApi = _ref4.hsApi,
            account = _ref4.account,
            userId = _ref4.userId,
            deviceId = _ref4.deviceId,
            areDeviceKeysUploaded = _ref4.areDeviceKeysUploaded,
            serverOTKCount = _ref4.serverOTKCount,
            olm = _ref4.olm,
            olmWorker = _ref4.olmWorker;

        _classCallCheck(this, Account);

        this._olm = olm;
        this._pickleKey = pickleKey;
        this._hsApi = hsApi;
        this._account = account;
        this._userId = userId;
        this._deviceId = deviceId;
        this._areDeviceKeysUploaded = areDeviceKeysUploaded;
        this._serverOTKCount = serverOTKCount;
        this._olmWorker = olmWorker;
        this._identityKeys = JSON.parse(this._account.identity_keys());
      }

      _createClass(Account, [{
        key: "setDeviceId",
        value: function setDeviceId(deviceId) {
          this._deviceId = deviceId;
        }
      }, {
        key: "uploadKeys",
        value: function () {
          var _uploadKeys = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(storage, isDehydratedDevice, log) {
            var _this = this;

            var oneTimeKeys, oneTimeKeysEntries, _response$one_time_ke, payload, identityKeys, dehydratedDeviceId, response;

            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    oneTimeKeys = JSON.parse(this._account.one_time_keys()); // only one algorithm supported by olm atm, so hardcode its name

                    oneTimeKeysEntries = Object.entries(oneTimeKeys.curve25519);

                    if (!(oneTimeKeysEntries.length || !this._areDeviceKeysUploaded)) {
                      _context4.next = 14;
                      break;
                    }

                    payload = {};

                    if (!this._areDeviceKeysUploaded) {
                      log.set("identity", true);
                      identityKeys = JSON.parse(this._account.identity_keys());
                      payload.device_keys = this._deviceKeysPayload(identityKeys);
                    }

                    if (oneTimeKeysEntries.length) {
                      log.set("otks", true);
                      payload.one_time_keys = this._oneTimeKeysPayload(oneTimeKeysEntries);
                    }

                    dehydratedDeviceId = isDehydratedDevice ? this._deviceId : undefined;
                    _context4.next = 9;
                    return this._hsApi.uploadKeys(dehydratedDeviceId, payload, {
                      log: log
                    }).response();

                  case 9:
                    response = _context4.sent;
                    this._serverOTKCount = response === null || response === void 0 ? void 0 : (_response$one_time_ke = response.one_time_key_counts) === null || _response$one_time_ke === void 0 ? void 0 : _response$one_time_ke.signed_curve25519;
                    log.set("serverOTKCount", this._serverOTKCount); // TODO: should we not modify this in the txn like we do elsewhere?
                    // we'd have to pickle and unpickle the account to clone it though ...
                    // and the upload has succeed at this point, so in-memory would be correct
                    // but in-storage not if the txn fails. 

                    _context4.next = 14;
                    return this._updateSessionStorage(storage, function (sessionStore) {
                      if (oneTimeKeysEntries.length) {
                        _this._account.mark_keys_as_published();

                        sessionStore === null || sessionStore === void 0 ? void 0 : sessionStore.set(ACCOUNT_SESSION_KEY, _this._account.pickle(_this._pickleKey));
                        sessionStore === null || sessionStore === void 0 ? void 0 : sessionStore.set(SERVER_OTK_COUNT_SESSION_KEY, _this._serverOTKCount);
                      }

                      if (!_this._areDeviceKeysUploaded) {
                        _this._areDeviceKeysUploaded = true;
                        sessionStore === null || sessionStore === void 0 ? void 0 : sessionStore.set(DEVICE_KEY_FLAG_SESSION_KEY, _this._areDeviceKeysUploaded);
                      }
                    });

                  case 14:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function uploadKeys(_x9, _x10, _x11) {
            return _uploadKeys.apply(this, arguments);
          }

          return uploadKeys;
        }()
      }, {
        key: "generateOTKsIfNeeded",
        value: function () {
          var _generateOTKsIfNeeded = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(storage, log) {
            var _this2 = this;

            var maxOTKs, keyLimit, oneTimeKeys, oneTimeKeysEntries, unpublishedOTKCount, newKeyCount;
            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    // We need to keep a pool of one time public keys on the server so that
                    // other devices can start conversations with us. But we can only store
                    // a finite number of private keys in the olm Account object.
                    // To complicate things further then can be a delay between a device
                    // claiming a public one time key from the server and it sending us a
                    // message. We need to keep the corresponding private key locally until
                    // we receive the message.
                    // But that message might never arrive leaving us stuck with duff
                    // private keys clogging up our local storage.
                    // So we need some kind of engineering compromise to balance all of
                    // these factors.
                    // Check how many keys we can store in the Account object.
                    maxOTKs = this._account.max_number_of_one_time_keys(); // Try to keep at most half that number on the server. This leaves the
                    // rest of the slots free to hold keys that have been claimed from the
                    // server but we haven't recevied a message for.
                    // If we run out of slots when generating new keys then olm will
                    // discard the oldest private keys first. This will eventually clean
                    // out stale private keys that won't receive a message.

                    keyLimit = Math.floor(maxOTKs / 2); // does the server have insufficient OTKs?

                    if (!(this._serverOTKCount < keyLimit)) {
                      _context5.next = 11;
                      break;
                    }

                    oneTimeKeys = JSON.parse(this._account.one_time_keys());
                    oneTimeKeysEntries = Object.entries(oneTimeKeys.curve25519);
                    unpublishedOTKCount = oneTimeKeysEntries.length; // we want to end up with maxOTKs / 2 key on the server,
                    // so generate any on top of the remaining ones on the server and the unpublished ones
                    // (we have generated before but haven't uploaded yet for some reason)
                    // to get to that number.

                    newKeyCount = keyLimit - unpublishedOTKCount - this._serverOTKCount;

                    if (!(newKeyCount > 0)) {
                      _context5.next = 10;
                      break;
                    }

                    _context5.next = 10;
                    return log.wrap("generate otks", function (log) {
                      log.set("max", maxOTKs);
                      log.set("server", _this2._serverOTKCount);
                      log.set("unpublished", unpublishedOTKCount);
                      log.set("new", newKeyCount);
                      log.set("limit", keyLimit);

                      _this2._account.generate_one_time_keys(newKeyCount);

                      _this2._updateSessionStorage(storage, function (sessionStore) {
                        sessionStore.set(ACCOUNT_SESSION_KEY, _this2._account.pickle(_this2._pickleKey));
                      });
                    });

                  case 10:
                    return _context5.abrupt("return", true);

                  case 11:
                    return _context5.abrupt("return", false);

                  case 12:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));

          function generateOTKsIfNeeded(_x12, _x13) {
            return _generateOTKsIfNeeded.apply(this, arguments);
          }

          return generateOTKsIfNeeded;
        }()
      }, {
        key: "createInboundOlmSession",
        value: function createInboundOlmSession(senderKey, body) {
          var newSession = new this._olm.Session();

          try {
            newSession.create_inbound_from(this._account, senderKey, body);
            return newSession;
          } catch (err) {
            newSession.free();
            throw err;
          }
        }
      }, {
        key: "createOutboundOlmSession",
        value: function () {
          var _createOutboundOlmSession = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(theirIdentityKey, theirOneTimeKey) {
            var newSession;
            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    newSession = new this._olm.Session();
                    _context6.prev = 1;

                    if (!this._olmWorker) {
                      _context6.next = 7;
                      break;
                    }

                    _context6.next = 5;
                    return this._olmWorker.createOutboundOlmSession(this._account, newSession, theirIdentityKey, theirOneTimeKey);

                  case 5:
                    _context6.next = 8;
                    break;

                  case 7:
                    newSession.create_outbound(this._account, theirIdentityKey, theirOneTimeKey);

                  case 8:
                    return _context6.abrupt("return", newSession);

                  case 11:
                    _context6.prev = 11;
                    _context6.t0 = _context6["catch"](1);
                    newSession.free();
                    throw _context6.t0;

                  case 15:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this, [[1, 11]]);
          }));

          function createOutboundOlmSession(_x14, _x15) {
            return _createOutboundOlmSession.apply(this, arguments);
          }

          return createOutboundOlmSession;
        }()
      }, {
        key: "writeRemoveOneTimeKey",
        value: function writeRemoveOneTimeKey(session, txn) {
          // this is side-effecty and will have applied the change if the txn fails,
          // but don't want to clone the account for now
          // and it is not the worst thing to think we have used a OTK when
          // decrypting the message that actually used it threw for some reason.
          this._account.remove_one_time_keys(session);

          txn.session.set(ACCOUNT_SESSION_KEY, this._account.pickle(this._pickleKey));
        }
      }, {
        key: "writeSync",
        value: function writeSync(deviceOneTimeKeysCount, txn, log) {
          // we only upload signed_curve25519 otks
          var otkCount = deviceOneTimeKeysCount.signed_curve25519 || 0;

          if (Number.isSafeInteger(otkCount) && otkCount !== this._serverOTKCount) {
            txn.session.set(SERVER_OTK_COUNT_SESSION_KEY, otkCount);
            log.set("otkCount", otkCount);
            return otkCount;
          }
        }
      }, {
        key: "afterSync",
        value: function afterSync(otkCount) {
          // could also be undefined
          if (Number.isSafeInteger(otkCount)) {
            this._serverOTKCount = otkCount;
          }
        }
      }, {
        key: "_deviceKeysPayload",
        value: function _deviceKeysPayload(identityKeys) {
          var obj = {
            user_id: this._userId,
            device_id: this._deviceId,
            algorithms: [OLM_ALGORITHM, MEGOLM_ALGORITHM],
            keys: {}
          };

          for (var _i = 0, _Object$entries = Object.entries(identityKeys); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                algorithm = _Object$entries$_i[0],
                pubKey = _Object$entries$_i[1];

            obj.keys["".concat(algorithm, ":").concat(this._deviceId)] = pubKey;
          }

          this.signObject(obj);
          return obj;
        }
      }, {
        key: "_oneTimeKeysPayload",
        value: function _oneTimeKeysPayload(oneTimeKeysEntries) {
          var obj = {};

          var _iterator = _createForOfIteratorHelper(oneTimeKeysEntries),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _slicedToArray(_step.value, 2),
                  keyId = _step$value[0],
                  pubKey = _step$value[1];

              var keyObj = {
                key: pubKey
              };
              this.signObject(keyObj);
              obj["signed_curve25519:".concat(keyId)] = keyObj;
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          return obj;
        }
      }, {
        key: "_updateSessionStorage",
        value: function () {
          var _updateSessionStorage2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(storage, callback) {
            var txn;
            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    if (!storage) {
                      _context7.next = 17;
                      break;
                    }

                    _context7.next = 3;
                    return storage.readWriteTxn([storage.storeNames.session]);

                  case 3:
                    txn = _context7.sent;
                    _context7.prev = 4;
                    _context7.next = 7;
                    return callback(txn.session);

                  case 7:
                    _context7.next = 13;
                    break;

                  case 9:
                    _context7.prev = 9;
                    _context7.t0 = _context7["catch"](4);
                    txn.abort();
                    throw _context7.t0;

                  case 13:
                    _context7.next = 15;
                    return txn.complete();

                  case 15:
                    _context7.next = 19;
                    break;

                  case 17:
                    _context7.next = 19;
                    return callback(undefined);

                  case 19:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, null, [[4, 9]]);
          }));

          function _updateSessionStorage(_x16, _x17) {
            return _updateSessionStorage2.apply(this, arguments);
          }

          return _updateSessionStorage;
        }()
      }, {
        key: "signObject",
        value: function signObject(obj) {
          var sigs = obj.signatures || {};
          var unsigned = obj.unsigned;
          delete obj.signatures;
          delete obj.unsigned;
          sigs[this._userId] = sigs[this._userId] || {};
          sigs[this._userId]["ed25519:" + this._deviceId] = this._account.sign(anotherJson.stringify(obj));
          obj.signatures = sigs;

          if (unsigned !== undefined) {
            obj.unsigned = unsigned;
          }
        }
      }, {
        key: "pickleWithKey",
        value: function pickleWithKey(key) {
          return this._account.pickle(key);
        }
      }, {
        key: "dispose",
        value: function dispose() {
          this._account.free();

          this._account = undefined;
        }
      }, {
        key: "identityKeys",
        get: function get() {
          return this._identityKeys;
        }
      }]);

      return Account;
    }();

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var KeyDescription = /*#__PURE__*/function () {
      function KeyDescription(id, keyDescription) {
        _classCallCheck(this, KeyDescription);

        this._id = id;
        this._keyDescription = keyDescription;
      }

      _createClass(KeyDescription, [{
        key: "isCompatible",
        value: function () {
          var _isCompatible = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(key, platform) {
            var kd, otherMac, kdOther;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!(this.algorithm === "m.secret_storage.v1.aes-hmac-sha2")) {
                      _context.next = 14;
                      break;
                    }

                    kd = this._keyDescription;

                    if (!kd.mac) {
                      _context.next = 9;
                      break;
                    }

                    _context.next = 5;
                    return calculateKeyMac(key.binaryKey, kd.iv, platform);

                  case 5:
                    otherMac = _context.sent;
                    return _context.abrupt("return", kd.mac === otherMac);

                  case 9:
                    if (!kd.passphrase) {
                      _context.next = 14;
                      break;
                    }

                    kdOther = key.description._keyDescription;

                    if (kdOther.passphrase) {
                      _context.next = 13;
                      break;
                    }

                    return _context.abrupt("return", false);

                  case 13:
                    return _context.abrupt("return", kd.passphrase.algorithm === kdOther.passphrase.algorithm && kd.passphrase.iterations === kdOther.passphrase.iterations && kd.passphrase.salt === kdOther.passphrase.salt);

                  case 14:
                    return _context.abrupt("return", false);

                  case 15:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function isCompatible(_x, _x2) {
            return _isCompatible.apply(this, arguments);
          }

          return isCompatible;
        }()
      }, {
        key: "id",
        get: function get() {
          return this._id;
        }
      }, {
        key: "passphraseParams",
        get: function get() {
          var _this$_keyDescription;

          return (_this$_keyDescription = this._keyDescription) === null || _this$_keyDescription === void 0 ? void 0 : _this$_keyDescription.passphrase;
        }
      }, {
        key: "algorithm",
        get: function get() {
          var _this$_keyDescription2;

          return (_this$_keyDescription2 = this._keyDescription) === null || _this$_keyDescription2 === void 0 ? void 0 : _this$_keyDescription2.algorithm;
        }
      }]);

      return KeyDescription;
    }();
    var Key = /*#__PURE__*/function () {
      function Key(keyDescription, binaryKey) {
        _classCallCheck(this, Key);

        this._keyDescription = keyDescription;
        this._binaryKey = binaryKey;
      }

      _createClass(Key, [{
        key: "withDescription",
        value: function withDescription(description) {
          return new Key(description, this._binaryKey);
        }
      }, {
        key: "description",
        get: function get() {
          return this._keyDescription;
        }
      }, {
        key: "id",
        get: function get() {
          return this._keyDescription.id;
        }
      }, {
        key: "binaryKey",
        get: function get() {
          return this._binaryKey;
        }
      }, {
        key: "algorithm",
        get: function get() {
          return this._keyDescription.algorithm;
        }
      }]);

      return Key;
    }();

    function calculateKeyMac(_x3, _x4, _x5) {
      return _calculateKeyMac.apply(this, arguments);
    }

    function _calculateKeyMac() {
      _calculateKeyMac = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(key, ivStr, platform) {
        var crypto, encoding, utf8, base64, derive, aes, hmac, iv, zerosalt, ZERO_STR, info, keybits, aesKey, hmacKey, ciphertext, mac;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                crypto = platform.crypto, encoding = platform.encoding;
                utf8 = encoding.utf8, base64 = encoding.base64;
                derive = crypto.derive, aes = crypto.aes, hmac = crypto.hmac;
                iv = base64.decode(ivStr); // salt for HKDF, with 8 bytes of zeros

                zerosalt = new Uint8Array(8);
                ZERO_STR = "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
                info = utf8.encode("");
                _context2.next = 9;
                return derive.hkdf(key, zerosalt, info, "SHA-256", 512);

              case 9:
                keybits = _context2.sent;
                aesKey = keybits.slice(0, 32);
                hmacKey = keybits.slice(32);
                _context2.next = 14;
                return aes.encryptCTR({
                  key: aesKey,
                  iv: iv,
                  data: utf8.encode(ZERO_STR)
                });

              case 14:
                ciphertext = _context2.sent;
                _context2.next = 17;
                return hmac.compute(hmacKey, ciphertext, "SHA-256");

              case 17:
                mac = _context2.sent;
                return _context2.abrupt("return", base64.encode(mac));

              case 19:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      return _calculateKeyMac.apply(this, arguments);
    }

    var DEFAULT_ITERATIONS = 500000;
    var DEFAULT_BITSIZE = 256;
    /**
     * @param  {KeyDescription} keyDescription
     * @param  {string} passphrase
     * @param  {Platform} platform
     * @return {Key}
     */

    function keyFromPassphrase(_x, _x2, _x3) {
      return _keyFromPassphrase.apply(this, arguments);
    }

    function _keyFromPassphrase() {
      _keyFromPassphrase = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(keyDescription, passphrase, platform) {
        var passphraseParams, utf8, keyBits;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                passphraseParams = keyDescription.passphraseParams;

                if (passphraseParams) {
                  _context.next = 3;
                  break;
                }

                throw new Error("not a passphrase key");

              case 3:
                if (!(passphraseParams.algorithm !== "m.pbkdf2")) {
                  _context.next = 5;
                  break;
                }

                throw new Error("Unsupported passphrase algorithm: ".concat(passphraseParams.algorithm));

              case 5:
                utf8 = platform.encoding.utf8;
                _context.next = 8;
                return platform.crypto.derive.pbkdf2(utf8.encode(passphrase), passphraseParams.iterations || DEFAULT_ITERATIONS, // salt is just a random string, not encoded in any way
                utf8.encode(passphraseParams.salt), "SHA-512", passphraseParams.bits || DEFAULT_BITSIZE);

              case 8:
                keyBits = _context.sent;
                return _context.abrupt("return", new Key(keyDescription, keyBits));

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return _keyFromPassphrase.apply(this, arguments);
    }

    var OLM_RECOVERY_KEY_PREFIX = [0x8B, 0x01];
    /**
     * @param  {Olm} olm
     * @param  {KeyDescription} keyDescription
     * @param  {string} recoveryKey
     * @return {Key}
     */

    function keyFromRecoveryKey(keyDescription, recoveryKey, olm, platform) {
      var result = platform.encoding.base58.decode(recoveryKey.replace(/ /g, ''));
      var parity = 0;

      var _iterator = _createForOfIteratorHelper(result),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var b = _step.value;
          parity ^= b;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (parity !== 0) {
        throw new Error("Incorrect parity");
      }

      for (var i = 0; i < OLM_RECOVERY_KEY_PREFIX.length; ++i) {
        if (result[i] !== OLM_RECOVERY_KEY_PREFIX[i]) {
          throw new Error("Incorrect prefix");
        }
      }

      if (result.length !== OLM_RECOVERY_KEY_PREFIX.length + olm.PRIVATE_KEY_LENGTH + 1) {
        throw new Error("Incorrect length");
      }

      var keyBits = Uint8Array.from(result.slice(OLM_RECOVERY_KEY_PREFIX.length, OLM_RECOVERY_KEY_PREFIX.length + olm.PRIVATE_KEY_LENGTH));
      return new Key(keyDescription, keyBits);
    }

    var SSSS_KEY = "".concat(SESSION_E2EE_KEY_PREFIX, "ssssKey");
    var KeyType = createEnum("RecoveryKey", "Passphrase");

    function readDefaultKeyDescription(_x) {
      return _readDefaultKeyDescription.apply(this, arguments);
    }

    function _readDefaultKeyDescription() {
      _readDefaultKeyDescription = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(storage) {
        var _defaultKeyEvent$cont;

        var txn, defaultKeyEvent, id, keyAccountData;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return storage.readTxn([storage.storeNames.accountData]);

              case 2:
                txn = _context.sent;
                _context.next = 5;
                return txn.accountData.get("m.secret_storage.default_key");

              case 5:
                defaultKeyEvent = _context.sent;
                id = defaultKeyEvent === null || defaultKeyEvent === void 0 ? void 0 : (_defaultKeyEvent$cont = defaultKeyEvent.content) === null || _defaultKeyEvent$cont === void 0 ? void 0 : _defaultKeyEvent$cont.key;

                if (id) {
                  _context.next = 9;
                  break;
                }

                return _context.abrupt("return");

              case 9:
                _context.next = 11;
                return txn.accountData.get("m.secret_storage.key.".concat(id));

              case 11:
                keyAccountData = _context.sent;

                if (keyAccountData) {
                  _context.next = 14;
                  break;
                }

                return _context.abrupt("return");

              case 14:
                return _context.abrupt("return", new KeyDescription(id, keyAccountData.content));

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return _readDefaultKeyDescription.apply(this, arguments);
    }

    function writeKey(_x2, _x3) {
      return _writeKey.apply(this, arguments);
    }

    function _writeKey() {
      _writeKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(key, txn) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                txn.session.set(SSSS_KEY, {
                  id: key.id,
                  binaryKey: key.binaryKey
                });

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      return _writeKey.apply(this, arguments);
    }

    function readKey(_x4) {
      return _readKey.apply(this, arguments);
    }

    function _readKey() {
      _readKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(txn) {
        var keyData, keyAccountData;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return txn.session.get(SSSS_KEY);

              case 2:
                keyData = _context3.sent;

                if (keyData) {
                  _context3.next = 5;
                  break;
                }

                return _context3.abrupt("return");

              case 5:
                _context3.next = 7;
                return txn.accountData.get("m.secret_storage.key.".concat(keyData.id));

              case 7:
                keyAccountData = _context3.sent;

                if (!keyAccountData) {
                  _context3.next = 10;
                  break;
                }

                return _context3.abrupt("return", new Key(new KeyDescription(keyData.id, keyAccountData.content), keyData.binaryKey));

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      return _readKey.apply(this, arguments);
    }

    function removeKey(_x5) {
      return _removeKey.apply(this, arguments);
    }

    function _removeKey() {
      _removeKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(txn) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return txn.session.remove(SSSS_KEY);

              case 2:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      return _removeKey.apply(this, arguments);
    }

    function keyFromCredential(_x6, _x7, _x8, _x9, _x10) {
      return _keyFromCredential.apply(this, arguments);
    }

    function _keyFromCredential() {
      _keyFromCredential = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(type, credential, storage, platform, olm) {
        var keyDescription;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return readDefaultKeyDescription(storage);

              case 2:
                keyDescription = _context5.sent;

                if (keyDescription) {
                  _context5.next = 5;
                  break;
                }

                throw new Error("Could not find a default secret storage key in account data");

              case 5:
                _context5.next = 7;
                return keyFromCredentialAndDescription(type, credential, keyDescription, platform, olm);

              case 7:
                return _context5.abrupt("return", _context5.sent);

              case 8:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));
      return _keyFromCredential.apply(this, arguments);
    }

    function keyFromCredentialAndDescription(_x11, _x12, _x13, _x14, _x15) {
      return _keyFromCredentialAndDescription.apply(this, arguments);
    }

    function _keyFromCredentialAndDescription() {
      _keyFromCredentialAndDescription = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(type, credential, keyDescription, platform, olm) {
        var key;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!(type === KeyType.Passphrase)) {
                  _context6.next = 6;
                  break;
                }

                _context6.next = 3;
                return keyFromPassphrase(keyDescription, credential, platform);

              case 3:
                key = _context6.sent;
                _context6.next = 11;
                break;

              case 6:
                if (!(type === KeyType.RecoveryKey)) {
                  _context6.next = 10;
                  break;
                }

                key = keyFromRecoveryKey(keyDescription, credential, olm, platform);
                _context6.next = 11;
                break;

              case 10:
                throw new Error("Invalid type: ".concat(type));

              case 11:
                return _context6.abrupt("return", key);

              case 12:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));
      return _keyFromCredentialAndDescription.apply(this, arguments);
    }

    function keyFromDehydratedDeviceKey(_x16, _x17, _x18) {
      return _keyFromDehydratedDeviceKey.apply(this, arguments);
    }

    function _keyFromDehydratedDeviceKey() {
      _keyFromDehydratedDeviceKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(key, storage, platform) {
        var keyDescription;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return readDefaultKeyDescription(storage);

              case 2:
                keyDescription = _context7.sent;
                _context7.next = 5;
                return keyDescription.isCompatible(key, platform);

              case 5:
                if (!_context7.sent) {
                  _context7.next = 7;
                  break;
                }

                return _context7.abrupt("return", key.withDescription(keyDescription));

              case 7:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));
      return _keyFromDehydratedDeviceKey.apply(this, arguments);
    }

    /*
    Copyright 2021 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var DEHYDRATION_LIBOLM_PICKLE_ALGORITHM = "org.matrix.msc2697.v1.olm.libolm_pickle";
    function getDehydratedDevice(_x, _x2, _x3, _x4) {
      return _getDehydratedDevice.apply(this, arguments);
    }

    function _getDehydratedDevice() {
      _getDehydratedDevice = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(hsApi, olm, platform, log) {
        var response;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                _context3.next = 3;
                return hsApi.getDehydratedDevice({
                  log: log
                }).response();

              case 3:
                response = _context3.sent;

                if (!(response.device_data.algorithm === DEHYDRATION_LIBOLM_PICKLE_ALGORITHM)) {
                  _context3.next = 6;
                  break;
                }

                return _context3.abrupt("return", new EncryptedDehydratedDevice(response, olm, platform));

              case 6:
                _context3.next = 12;
                break;

              case 8:
                _context3.prev = 8;
                _context3.t0 = _context3["catch"](0);

                if (_context3.t0.name !== "HomeServerError") {
                  log.error = _context3.t0;
                }

                return _context3.abrupt("return", undefined);

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[0, 8]]);
      }));
      return _getDehydratedDevice.apply(this, arguments);
    }

    function uploadAccountAsDehydratedDevice(_x5, _x6, _x7, _x8, _x9) {
      return _uploadAccountAsDehydratedDevice.apply(this, arguments);
    }

    function _uploadAccountAsDehydratedDevice() {
      _uploadAccountAsDehydratedDevice = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(account, hsApi, key, deviceDisplayName, log) {
        var _key$description;

        var response, deviceId;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return hsApi.createDehydratedDevice({
                  device_data: {
                    algorithm: DEHYDRATION_LIBOLM_PICKLE_ALGORITHM,
                    account: account.pickleWithKey(key.binaryKey.slice()),
                    passphrase: ((_key$description = key.description) === null || _key$description === void 0 ? void 0 : _key$description.passphraseParams) || {}
                  },
                  initial_device_display_name: deviceDisplayName
                }).response();

              case 2:
                response = _context4.sent;
                deviceId = response.device_id;
                account.setDeviceId(deviceId);
                _context4.next = 7;
                return account.uploadKeys(undefined, true, log);

              case 7:
                return _context4.abrupt("return", deviceId);

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      return _uploadAccountAsDehydratedDevice.apply(this, arguments);
    }

    var EncryptedDehydratedDevice = /*#__PURE__*/function () {
      function EncryptedDehydratedDevice(dehydratedDevice, olm, platform) {
        _classCallCheck(this, EncryptedDehydratedDevice);

        this._dehydratedDevice = dehydratedDevice;
        this._olm = olm;
        this._platform = platform;
      }

      _createClass(EncryptedDehydratedDevice, [{
        key: "decrypt",
        value: function () {
          var _decrypt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(keyType, credential) {
            var keyDescription, key, account, pickledAccount;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    keyDescription = new KeyDescription("dehydrated_device", this._dehydratedDevice.device_data.passphrase);
                    _context.next = 3;
                    return keyFromCredentialAndDescription(keyType, credential, keyDescription, this._platform, this._olm);

                  case 3:
                    key = _context.sent;
                    account = new this._olm.Account();
                    _context.prev = 5;
                    pickledAccount = this._dehydratedDevice.device_data.account;
                    account.unpickle(key.binaryKey.slice(), pickledAccount);
                    return _context.abrupt("return", new DehydratedDevice(this._dehydratedDevice, account, key));

                  case 11:
                    _context.prev = 11;
                    _context.t0 = _context["catch"](5);
                    account.free();

                    if (!(_context.t0.message === "OLM.BAD_ACCOUNT_KEY")) {
                      _context.next = 18;
                      break;
                    }

                    return _context.abrupt("return", undefined);

                  case 18:
                    throw _context.t0;

                  case 19:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[5, 11]]);
          }));

          function decrypt(_x10, _x11) {
            return _decrypt.apply(this, arguments);
          }

          return decrypt;
        }()
      }, {
        key: "deviceId",
        get: function get() {
          return this._dehydratedDevice.device_id;
        }
      }]);

      return EncryptedDehydratedDevice;
    }();

    var DehydratedDevice = /*#__PURE__*/function () {
      function DehydratedDevice(dehydratedDevice, account, key) {
        _classCallCheck(this, DehydratedDevice);

        this._dehydratedDevice = dehydratedDevice;
        this._account = account;
        this._key = key;
      }

      _createClass(DehydratedDevice, [{
        key: "claim",
        value: function () {
          var _claim = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(hsApi, log) {
            var response;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.prev = 0;
                    _context2.next = 3;
                    return hsApi.claimDehydratedDevice(this.deviceId, {
                      log: log
                    }).response();

                  case 3:
                    response = _context2.sent;
                    return _context2.abrupt("return", response.success);

                  case 7:
                    _context2.prev = 7;
                    _context2.t0 = _context2["catch"](0);
                    return _context2.abrupt("return", false);

                  case 10:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[0, 7]]);
          }));

          function claim(_x12, _x13) {
            return _claim.apply(this, arguments);
          }

          return claim;
        }() // make it clear that ownership is transfered upon calling this

      }, {
        key: "adoptUnpickledOlmAccount",
        value: function adoptUnpickledOlmAccount() {
          var account = this._account;
          this._account = undefined;
          return account;
        }
      }, {
        key: "dispose",
        value: function dispose() {
          var _this$_account;

          (_this$_account = this._account) === null || _this$_account === void 0 ? void 0 : _this$_account.free();
          this._account = undefined;
        }
      }, {
        key: "deviceId",
        get: function get() {
          return this._dehydratedDevice.device_id;
        }
      }, {
        key: "key",
        get: function get() {
          return this._key;
        }
      }]);

      return DehydratedDevice;
    }();

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var Lock = /*#__PURE__*/function () {
      function Lock() {
        _classCallCheck(this, Lock);

        this._promise = null;
        this._resolve = null;
      }

      _createClass(Lock, [{
        key: "tryTake",
        value: function tryTake() {
          var _this = this;

          if (!this._promise) {
            this._promise = new Promise(function (resolve) {
              _this._resolve = resolve;
            });
            return true;
          }

          return false;
        }
      }, {
        key: "take",
        value: function () {
          var _take = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (this.tryTake()) {
                      _context.next = 5;
                      break;
                    }

                    _context.next = 3;
                    return this.released();

                  case 3:
                    _context.next = 0;
                    break;

                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function take() {
            return _take.apply(this, arguments);
          }

          return take;
        }()
      }, {
        key: "release",
        value: function release() {
          if (this._resolve) {
            this._promise = null;
            var resolve = this._resolve;
            this._resolve = null;
            resolve();
          }
        }
      }, {
        key: "released",
        value: function released() {
          return this._promise;
        }
      }, {
        key: "isTaken",
        get: function get() {
          return !!this._promise;
        }
      }]);

      return Lock;
    }();
    var MultiLock = /*#__PURE__*/function () {
      function MultiLock(locks) {
        _classCallCheck(this, MultiLock);

        this.locks = locks;
      }

      _createClass(MultiLock, [{
        key: "release",
        value: function release() {
          var _iterator = _createForOfIteratorHelper(this.locks),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var lock = _step.value;
              lock.release();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }]);

      return MultiLock;
    }();

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function createSessionEntry(olmSession, senderKey, timestamp, pickleKey) {
      return {
        session: olmSession.pickle(pickleKey),
        sessionId: olmSession.session_id(),
        senderKey: senderKey,
        lastUsed: timestamp
      };
    }
    var Session = /*#__PURE__*/function () {
      function Session(data, pickleKey, olm) {
        var isNew = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        _classCallCheck(this, Session);

        this.data = data;
        this._olm = olm;
        this._pickleKey = pickleKey;
        this.isNew = isNew;
        this.isModified = isNew;
      }

      _createClass(Session, [{
        key: "load",
        value: function load() {
          var session = new this._olm.Session();
          session.unpickle(this._pickleKey, this.data.session);
          return session;
        }
      }, {
        key: "unload",
        value: function unload(olmSession) {
          olmSession.free();
        }
      }, {
        key: "save",
        value: function save(olmSession) {
          this.data.session = olmSession.pickle(this._pickleKey);
          this.isModified = true;
        }
      }, {
        key: "id",
        get: function get() {
          return this.data.sessionId;
        }
      }], [{
        key: "create",
        value: function create(senderKey, olmSession, olm, pickleKey, timestamp) {
          var data = createSessionEntry(olmSession, senderKey, timestamp, pickleKey);
          return new Session(data, pickleKey, olm, true);
        }
      }]);

      return Session;
    }();

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */

    /**
     * @property {object} event the plaintext event (type and content property)
     * @property {string} senderCurve25519Key the curve25519 sender key of the olm event
     * @property {string} claimedEd25519Key The ed25519 fingerprint key retrieved from the decryption payload.
     *                                      The sender of the olm event claims this is the ed25519 fingerprint key
     *                                      that matches the curve25519 sender key.
     *                                      The caller needs to check if this key does indeed match the senderKey
     *                                      for a device with a valid signature returned from /keys/query,
     *                                      see DeviceTracker
     */
    var DecryptionResult = /*#__PURE__*/function () {
      function DecryptionResult(event, senderCurve25519Key, claimedEd25519Key) {
        _classCallCheck(this, DecryptionResult);

        this.event = event;
        this.senderCurve25519Key = senderCurve25519Key;
        this.claimedEd25519Key = claimedEd25519Key;
        this._device = null;
        this._roomTracked = true;
      }

      _createClass(DecryptionResult, [{
        key: "setDevice",
        value: function setDevice(device) {
          this._device = device;
        }
      }, {
        key: "setRoomNotTrackedYet",
        value: function setRoomNotTrackedYet() {
          this._roomTracked = false;
        }
      }, {
        key: "isVerified",
        get: function get() {
          if (this._device) {
            var comesFromDevice = this._device.ed25519Key === this.claimedEd25519Key;
            return comesFromDevice;
          }

          return false;
        }
      }, {
        key: "isUnverified",
        get: function get() {
          if (this._device) {
            return !this.isVerified;
          } else if (this.isVerificationUnknown) {
            return false;
          } else {
            return true;
          }
        }
      }, {
        key: "isVerificationUnknown",
        get: function get() {
          // verification is unknown if we haven't yet fetched the devices for the room
          return !this._device && !this._roomTracked;
        }
      }]);

      return DecryptionResult;
    }();

    var SESSION_LIMIT_PER_SENDER_KEY = 4;

    function isPreKeyMessage(message) {
      return message.type === 0;
    }

    function sortSessions(sessions) {
      sessions.sort(function (a, b) {
        return b.data.lastUsed - a.data.lastUsed;
      });
    }

    var Decryption = /*#__PURE__*/function () {
      function Decryption(_ref) {
        var account = _ref.account,
            pickleKey = _ref.pickleKey,
            now = _ref.now,
            ownUserId = _ref.ownUserId,
            storage = _ref.storage,
            olm = _ref.olm,
            senderKeyLock = _ref.senderKeyLock;

        _classCallCheck(this, Decryption);

        this._account = account;
        this._pickleKey = pickleKey;
        this._now = now;
        this._ownUserId = ownUserId;
        this._storage = storage;
        this._olm = olm;
        this._senderKeyLock = senderKeyLock;
      } // we need to lock because both encryption and decryption can't be done in one txn,
      // so for them not to step on each other toes, we need to lock.
      // 
      // the lock is release from 1 of 3 places, whichever comes first:
      //  - decryptAll below fails (to release the lock as early as we can)
      //  - DecryptionChanges.write succeeds
      //  - Sync finishes the writeSync phase (or an error was thrown, in case we never get to DecryptionChanges.write) 


      _createClass(Decryption, [{
        key: "obtainDecryptionLock",
        value: function () {
          var _obtainDecryptionLock = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(events) {
            var _this = this;

            var senderKeys, _iterator, _step, _event$content, event, senderKey, locks;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    senderKeys = new Set();
                    _iterator = _createForOfIteratorHelper(events);

                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done;) {
                        event = _step.value;
                        senderKey = (_event$content = event.content) === null || _event$content === void 0 ? void 0 : _event$content["sender_key"];

                        if (senderKey) {
                          senderKeys.add(senderKey);
                        }
                      } // take a lock on all senderKeys so encryption or other calls to decryptAll (should not happen)
                      // don't modify the sessions at the same time

                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }

                    _context.next = 5;
                    return Promise.all(Array.from(senderKeys).map(function (senderKey) {
                      return _this._senderKeyLock.takeLock(senderKey);
                    }));

                  case 5:
                    locks = _context.sent;
                    return _context.abrupt("return", new MultiLock(locks));

                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function obtainDecryptionLock(_x) {
            return _obtainDecryptionLock.apply(this, arguments);
          }

          return obtainDecryptionLock;
        }() // we need decryptAll because there is some parallelization we can do for decrypting different sender keys at once
        // but for the same sender key we need to do one by one
        // 
        // also we want to store the room key, etc ... in the same txn as we remove the pending encrypted event
        // 
        // so we need to decrypt events in a batch (so we can decide which ones can run in parallel and which one one by one)
        // and also can avoid side-effects before all can be stored this way
        // 
        // doing it one by one would be possible, but we would lose the opportunity for parallelization
        // 

        /**
         * It is importants the lock obtained from obtainDecryptionLock is for the same set of events as passed in here.
         * [decryptAll description]
         * @param  {[type]} events
         * @return {Promise<DecryptionChanges>}        [description]
         */

      }, {
        key: "decryptAll",
        value: function () {
          var _decryptAll = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(events, lock, txn) {
            var _this2 = this;

            var eventsPerSenderKey, timestamp, senderKeyOperations, results, errors, senderKeyDecryptions;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.prev = 0;
                    eventsPerSenderKey = groupBy(events, function (event) {
                      var _event$content2;

                      return (_event$content2 = event.content) === null || _event$content2 === void 0 ? void 0 : _event$content2["sender_key"];
                    });
                    timestamp = this._now(); // decrypt events for different sender keys in parallel

                    _context2.next = 5;
                    return Promise.all(Array.from(eventsPerSenderKey.entries()).map(function (_ref2) {
                      var _ref3 = _slicedToArray(_ref2, 2),
                          senderKey = _ref3[0],
                          events = _ref3[1];

                      return _this2._decryptAllForSenderKey(senderKey, events, timestamp, txn);
                    }));

                  case 5:
                    senderKeyOperations = _context2.sent;
                    results = senderKeyOperations.reduce(function (all, r) {
                      return all.concat(r.results);
                    }, []);
                    errors = senderKeyOperations.reduce(function (all, r) {
                      return all.concat(r.errors);
                    }, []);
                    senderKeyDecryptions = senderKeyOperations.map(function (r) {
                      return r.senderKeyDecryption;
                    });
                    return _context2.abrupt("return", new DecryptionChanges(senderKeyDecryptions, results, errors, this._account, lock));

                  case 12:
                    _context2.prev = 12;
                    _context2.t0 = _context2["catch"](0);
                    // make sure the locks are release if something throws
                    // otherwise they will be released in DecryptionChanges after having written
                    // or after the writeSync phase in Sync
                    lock.release();
                    throw _context2.t0;

                  case 16:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[0, 12]]);
          }));

          function decryptAll(_x2, _x3, _x4) {
            return _decryptAll.apply(this, arguments);
          }

          return decryptAll;
        }()
      }, {
        key: "_decryptAllForSenderKey",
        value: function () {
          var _decryptAllForSenderKey2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(senderKey, events, timestamp, readSessionsTxn) {
            var sessions, senderKeyDecryption, results, errors, _iterator2, _step2, event, result;

            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this._getSessions(senderKey, readSessionsTxn);

                  case 2:
                    sessions = _context3.sent;
                    senderKeyDecryption = new SenderKeyDecryption(senderKey, sessions, this._olm, timestamp);
                    results = [];
                    errors = []; // events for a single senderKey need to be decrypted one by one

                    _iterator2 = _createForOfIteratorHelper(events);

                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                        event = _step2.value;

                        try {
                          result = this._decryptForSenderKey(senderKeyDecryption, event, timestamp);
                          results.push(result);
                        } catch (err) {
                          errors.push(err);
                        }
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }

                    return _context3.abrupt("return", {
                      results: results,
                      errors: errors,
                      senderKeyDecryption: senderKeyDecryption
                    });

                  case 9:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function _decryptAllForSenderKey(_x5, _x6, _x7, _x8) {
            return _decryptAllForSenderKey2.apply(this, arguments);
          }

          return _decryptAllForSenderKey;
        }()
      }, {
        key: "_decryptForSenderKey",
        value: function _decryptForSenderKey(senderKeyDecryption, event, timestamp) {
          var senderKey = senderKeyDecryption.senderKey;

          var message = this._getMessageAndValidateEvent(event);

          var plaintext;

          try {
            plaintext = senderKeyDecryption.decrypt(message);
          } catch (err) {
            // TODO: is it ok that an error on one session prevents other sessions from being attempted?
            throw new DecryptionError("OLM_BAD_ENCRYPTED_MESSAGE", event, {
              senderKey: senderKey,
              error: err.message
            });
          } // could not decrypt with any existing session


          if (typeof plaintext !== "string" && isPreKeyMessage(message)) {
            var createResult;

            try {
              createResult = this._createSessionAndDecrypt(senderKey, message, timestamp);
            } catch (error) {
              throw new DecryptionError("Could not create inbound olm session: ".concat(error.message), event, {
                senderKey: senderKey,
                error: error
              });
            }

            senderKeyDecryption.addNewSession(createResult.session);
            plaintext = createResult.plaintext;
          }

          if (typeof plaintext === "string") {
            var payload;

            try {
              payload = JSON.parse(plaintext);
            } catch (error) {
              throw new DecryptionError("PLAINTEXT_NOT_JSON", event, {
                plaintext: plaintext,
                error: error
              });
            }

            this._validatePayload(payload, event);

            return new DecryptionResult(payload, senderKey, payload.keys.ed25519);
          } else {
            throw new DecryptionError("OLM_NO_MATCHING_SESSION", event, {
              knownSessionIds: senderKeyDecryption.sessions.map(function (s) {
                return s.id;
              })
            });
          }
        } // only for pre-key messages after having attempted decryption with existing sessions

      }, {
        key: "_createSessionAndDecrypt",
        value: function _createSessionAndDecrypt(senderKey, message, timestamp) {
          var plaintext; // if we have multiple messages encrypted with the same new session,
          // this could create multiple sessions as the OTK isn't removed yet
          // (this only happens in DecryptionChanges.write)
          // This should be ok though as we'll first try to decrypt with the new session

          var olmSession = this._account.createInboundOlmSession(senderKey, message.body);

          try {
            plaintext = olmSession.decrypt(message.type, message.body);
            var session = Session.create(senderKey, olmSession, this._olm, this._pickleKey, timestamp);
            session.unload(olmSession);
            return {
              session: session,
              plaintext: plaintext
            };
          } catch (err) {
            olmSession.free();
            throw err;
          }
        }
      }, {
        key: "_getMessageAndValidateEvent",
        value: function _getMessageAndValidateEvent(event) {
          var _event$content3;

          var ciphertext = (_event$content3 = event.content) === null || _event$content3 === void 0 ? void 0 : _event$content3.ciphertext;

          if (!ciphertext) {
            throw new DecryptionError("OLM_MISSING_CIPHERTEXT", event);
          }

          var message = ciphertext === null || ciphertext === void 0 ? void 0 : ciphertext[this._account.identityKeys.curve25519];

          if (!message) {
            throw new DecryptionError("OLM_NOT_INCLUDED_IN_RECIPIENTS", event);
          }

          return message;
        }
      }, {
        key: "_getSessions",
        value: function () {
          var _getSessions2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(senderKey, txn) {
            var _this3 = this;

            var sessionEntries, sessions;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return txn.olmSessions.getAll(senderKey);

                  case 2:
                    sessionEntries = _context4.sent;
                    // sort most recent used sessions first
                    sessions = sessionEntries.map(function (s) {
                      return new Session(s, _this3._pickleKey, _this3._olm);
                    });
                    sortSessions(sessions);
                    return _context4.abrupt("return", sessions);

                  case 6:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4);
          }));

          function _getSessions(_x9, _x10) {
            return _getSessions2.apply(this, arguments);
          }

          return _getSessions;
        }()
      }, {
        key: "_validatePayload",
        value: function _validatePayload(payload, event) {
          var _payload$recipient_ke, _payload$keys;

          if (payload.sender !== event.sender) {
            throw new DecryptionError("OLM_FORWARDED_MESSAGE", event, {
              sentBy: event.sender,
              encryptedBy: payload.sender
            });
          }

          if (payload.recipient !== this._ownUserId) {
            throw new DecryptionError("OLM_BAD_RECIPIENT", event, {
              recipient: payload.recipient
            });
          }

          if (((_payload$recipient_ke = payload.recipient_keys) === null || _payload$recipient_ke === void 0 ? void 0 : _payload$recipient_ke.ed25519) !== this._account.identityKeys.ed25519) {
            var _payload$recipient_ke2;

            throw new DecryptionError("OLM_BAD_RECIPIENT_KEY", event, {
              key: (_payload$recipient_ke2 = payload.recipient_keys) === null || _payload$recipient_ke2 === void 0 ? void 0 : _payload$recipient_ke2.ed25519
            });
          } // TODO: check room_id


          if (!payload.type) {
            throw new DecryptionError("missing type on payload", event, {
              payload: payload
            });
          }

          if (typeof ((_payload$keys = payload.keys) === null || _payload$keys === void 0 ? void 0 : _payload$keys.ed25519) !== "string") {
            throw new DecryptionError("Missing or invalid claimed ed25519 key on payload", event, {
              payload: payload
            });
          }
        }
      }]);

      return Decryption;
    }(); // decryption helper for a single senderKey

    var SenderKeyDecryption = /*#__PURE__*/function () {
      function SenderKeyDecryption(senderKey, sessions, olm, timestamp) {
        _classCallCheck(this, SenderKeyDecryption);

        this.senderKey = senderKey;
        this.sessions = sessions;
        this._olm = olm;
        this._timestamp = timestamp;
      }

      _createClass(SenderKeyDecryption, [{
        key: "addNewSession",
        value: function addNewSession(session) {
          // add at top as it is most recent
          this.sessions.unshift(session);
        }
      }, {
        key: "decrypt",
        value: function decrypt(message) {
          var _iterator3 = _createForOfIteratorHelper(this.sessions),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var session = _step3.value;

              var plaintext = this._decryptWithSession(session, message);

              if (typeof plaintext === "string") {
                // keep them sorted so will try the same session first for other messages
                // and so we can assume the excess ones are at the end
                // if they grow too large
                sortSessions(this.sessions);
                return plaintext;
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      }, {
        key: "getModifiedSessions",
        value: function getModifiedSessions() {
          return this.sessions.filter(function (session) {
            return session.isModified;
          });
        }
      }, {
        key: "_decryptWithSession",
        // this could internally dispatch to a web-worker
        // and is why we unpickle/pickle on each iteration
        // if this turns out to be a real cost for IE11,
        // we could look into adding a less expensive serialization mechanism
        // for olm sessions to libolm
        value: function _decryptWithSession(session, message) {
          var olmSession = session.load();

          try {
            if (isPreKeyMessage(message) && !olmSession.matches_inbound(message.body)) {
              return;
            }

            try {
              var plaintext = olmSession.decrypt(message.type, message.body);
              session.save(olmSession);
              session.lastUsed = this._timestamp;
              return plaintext;
            } catch (err) {
              if (isPreKeyMessage(message)) {
                throw new Error("Error decrypting prekey message with existing session id ".concat(session.id, ": ").concat(err.message));
              } // decryption failed, bail out


              return;
            }
          } finally {
            session.unload(olmSession);
          }
        }
      }, {
        key: "hasNewSessions",
        get: function get() {
          return this.sessions.some(function (session) {
            return session.isNew;
          });
        }
      }]);

      return SenderKeyDecryption;
    }();
    /**
     * @property {Array<DecryptionResult>} results
     * @property {Array<DecryptionError>} errors  see DecryptionError.event to retrieve the event that failed to decrypt.
     */


    var DecryptionChanges = /*#__PURE__*/function () {
      function DecryptionChanges(senderKeyDecryptions, results, errors, account, lock) {
        _classCallCheck(this, DecryptionChanges);

        this._senderKeyDecryptions = senderKeyDecryptions;
        this._account = account;
        this.results = results;
        this.errors = errors;
        this._lock = lock;
      }

      _createClass(DecryptionChanges, [{
        key: "write",
        value: function write(txn) {
          try {
            var _iterator4 = _createForOfIteratorHelper(this._senderKeyDecryptions),
                _step4;

            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var senderKeyDecryption = _step4.value;

                var _iterator5 = _createForOfIteratorHelper(senderKeyDecryption.getModifiedSessions()),
                    _step5;

                try {
                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                    var _session = _step5.value;
                    txn.olmSessions.set(_session.data);

                    if (_session.isNew) {
                      var olmSession = _session.load();

                      try {
                        this._account.writeRemoveOneTimeKey(olmSession, txn);
                      } finally {
                        _session.unload(olmSession);
                      }
                    }
                  }
                } catch (err) {
                  _iterator5.e(err);
                } finally {
                  _iterator5.f();
                }

                if (senderKeyDecryption.sessions.length > SESSION_LIMIT_PER_SENDER_KEY) {
                  var senderKey = senderKeyDecryption.senderKey,
                      sessions = senderKeyDecryption.sessions; // >= because index is zero-based

                  for (var i = sessions.length - 1; i >= SESSION_LIMIT_PER_SENDER_KEY; i -= 1) {
                    var session = sessions[i];
                    txn.olmSessions.remove(senderKey, session.id);
                  }
                }
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          } finally {
            this._lock.release();
          }
        }
      }, {
        key: "hasNewSessions",
        get: function get() {
          return this._senderKeyDecryptions.some(function (skd) {
            return skd.hasNewSessions;
          });
        }
      }]);

      return DecryptionChanges;
    }();

    function findFirstSessionId(sessionIds) {
      return sessionIds.reduce(function (first, sessionId) {
        if (!first || sessionId < first) {
          return sessionId;
        } else {
          return first;
        }
      }, null);
    }

    var OTK_ALGORITHM = "signed_curve25519"; // only encrypt this amount of olm messages at once otherwise we run out of wasm memory
    // with all the sessions loaded at the same time
    // See https://github.com/vector-im/hydrogen-web/issues/150 as well, which indicates the limit is 44,
    // but let's take a conservative limit as the megolm session cache also takes space

    var MAX_BATCH_SIZE = 20;
    var Encryption = /*#__PURE__*/function () {
      function Encryption(_ref) {
        var account = _ref.account,
            olm = _ref.olm,
            olmUtil = _ref.olmUtil,
            ownUserId = _ref.ownUserId,
            storage = _ref.storage,
            now = _ref.now,
            pickleKey = _ref.pickleKey,
            senderKeyLock = _ref.senderKeyLock;

        _classCallCheck(this, Encryption);

        this._account = account;
        this._olm = olm;
        this._olmUtil = olmUtil;
        this._ownUserId = ownUserId;
        this._storage = storage;
        this._now = now;
        this._pickleKey = pickleKey;
        this._senderKeyLock = senderKeyLock;
      }

      _createClass(Encryption, [{
        key: "encrypt",
        value: function () {
          var _encrypt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(type, content, devices, hsApi, log) {
            var messages, i, batchDevices, batchMessages;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    messages = [];
                    i = 0;

                  case 2:
                    if (!(i < devices.length)) {
                      _context.next = 11;
                      break;
                    }

                    batchDevices = devices.slice(i, i + MAX_BATCH_SIZE);
                    _context.next = 6;
                    return this._encryptForMaxDevices(type, content, batchDevices, hsApi, log);

                  case 6:
                    batchMessages = _context.sent;
                    messages = messages.concat(batchMessages);

                  case 8:
                    i += MAX_BATCH_SIZE;
                    _context.next = 2;
                    break;

                  case 11:
                    return _context.abrupt("return", messages);

                  case 12:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function encrypt(_x, _x2, _x3, _x4, _x5) {
            return _encrypt.apply(this, arguments);
          }

          return encrypt;
        }()
      }, {
        key: "_encryptForMaxDevices",
        value: function () {
          var _encryptForMaxDevices2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(type, content, devices, hsApi, log) {
            var _this = this;

            var locks, _yield$this$_findExis, devicesWithoutSession, existingEncryptionTargets, timestamp, encryptionTargets, newEncryptionTargets, encryptLog, messages, _iterator, _step, target, _iterator2, _step2, lock;

            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return Promise.all(devices.map(function (device) {
                      return _this._senderKeyLock.takeLock(device.curve25519Key);
                    }));

                  case 2:
                    locks = _context2.sent;
                    _context2.prev = 3;
                    _context2.next = 6;
                    return this._findExistingSessions(devices);

                  case 6:
                    _yield$this$_findExis = _context2.sent;
                    devicesWithoutSession = _yield$this$_findExis.devicesWithoutSession;
                    existingEncryptionTargets = _yield$this$_findExis.existingEncryptionTargets;
                    timestamp = this._now();
                    encryptionTargets = [];
                    _context2.prev = 11;

                    if (!devicesWithoutSession.length) {
                      _context2.next = 17;
                      break;
                    }

                    _context2.next = 15;
                    return log.wrap("create sessions", function (log) {
                      return _this._createNewSessions(devicesWithoutSession, hsApi, timestamp, log);
                    });

                  case 15:
                    newEncryptionTargets = _context2.sent;
                    encryptionTargets = encryptionTargets.concat(newEncryptionTargets);

                  case 17:
                    _context2.next = 19;
                    return this._loadSessions(existingEncryptionTargets);

                  case 19:
                    encryptionTargets = encryptionTargets.concat(existingEncryptionTargets);
                    encryptLog = {
                      l: "encrypt",
                      targets: encryptionTargets.length
                    };
                    messages = log.wrap(encryptLog, function () {
                      return encryptionTargets.map(function (target) {
                        var encryptedContent = _this._encryptForDevice(type, content, target);

                        return new EncryptedMessage(encryptedContent, target.device);
                      });
                    });
                    _context2.next = 24;
                    return this._storeSessions(encryptionTargets, timestamp);

                  case 24:
                    return _context2.abrupt("return", messages);

                  case 25:
                    _context2.prev = 25;
                    _iterator = _createForOfIteratorHelper(encryptionTargets);

                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done;) {
                        target = _step.value;
                        target.dispose();
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }

                    return _context2.finish(25);

                  case 29:
                    _context2.prev = 29;
                    _iterator2 = _createForOfIteratorHelper(locks);

                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                        lock = _step2.value;
                        lock.release();
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }

                    return _context2.finish(29);

                  case 33:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[3,, 29, 33], [11,, 25, 29]]);
          }));

          function _encryptForMaxDevices(_x6, _x7, _x8, _x9, _x10) {
            return _encryptForMaxDevices2.apply(this, arguments);
          }

          return _encryptForMaxDevices;
        }()
      }, {
        key: "_findExistingSessions",
        value: function () {
          var _findExistingSessions2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(devices) {
            var txn, sessionIdsForDevice, devicesWithoutSession, existingEncryptionTargets;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return this._storage.readTxn([this._storage.storeNames.olmSessions]);

                  case 2:
                    txn = _context4.sent;
                    _context4.next = 5;
                    return Promise.all(devices.map( /*#__PURE__*/function () {
                      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(device) {
                        return regeneratorRuntime.wrap(function _callee3$(_context3) {
                          while (1) {
                            switch (_context3.prev = _context3.next) {
                              case 0:
                                _context3.next = 2;
                                return txn.olmSessions.getSessionIds(device.curve25519Key);

                              case 2:
                                return _context3.abrupt("return", _context3.sent);

                              case 3:
                              case "end":
                                return _context3.stop();
                            }
                          }
                        }, _callee3);
                      }));

                      return function (_x12) {
                        return _ref2.apply(this, arguments);
                      };
                    }()));

                  case 5:
                    sessionIdsForDevice = _context4.sent;
                    devicesWithoutSession = devices.filter(function (_, i) {
                      var sessionIds = sessionIdsForDevice[i];
                      return !(sessionIds === null || sessionIds === void 0 ? void 0 : sessionIds.length);
                    });
                    existingEncryptionTargets = devices.map(function (device, i) {
                      var sessionIds = sessionIdsForDevice[i];

                      if ((sessionIds === null || sessionIds === void 0 ? void 0 : sessionIds.length) > 0) {
                        var sessionId = findFirstSessionId(sessionIds);
                        return EncryptionTarget.fromSessionId(device, sessionId);
                      }
                    }).filter(function (target) {
                      return !!target;
                    });
                    return _context4.abrupt("return", {
                      devicesWithoutSession: devicesWithoutSession,
                      existingEncryptionTargets: existingEncryptionTargets
                    });

                  case 9:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function _findExistingSessions(_x11) {
            return _findExistingSessions2.apply(this, arguments);
          }

          return _findExistingSessions;
        }()
      }, {
        key: "_encryptForDevice",
        value: function _encryptForDevice(type, content, target) {
          var session = target.session,
              device = target.device;
          var plaintext = JSON.stringify(this._buildPlainTextMessageForDevice(type, content, device));
          var message = session.encrypt(plaintext);
          var encryptedContent = {
            algorithm: OLM_ALGORITHM,
            sender_key: this._account.identityKeys.curve25519,
            ciphertext: _defineProperty({}, device.curve25519Key, message)
          };
          return encryptedContent;
        }
      }, {
        key: "_buildPlainTextMessageForDevice",
        value: function _buildPlainTextMessageForDevice(type, content, device) {
          return {
            keys: {
              "ed25519": this._account.identityKeys.ed25519
            },
            recipient_keys: {
              "ed25519": device.ed25519Key
            },
            recipient: device.userId,
            sender: this._ownUserId,
            content: content,
            type: type
          };
        }
      }, {
        key: "_createNewSessions",
        value: function () {
          var _createNewSessions2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(devicesWithoutSession, hsApi, timestamp, log) {
            var _this2 = this;

            var newEncryptionTargets, _iterator3, _step3, target, device, oneTimeKey, _iterator4, _step4, _target;

            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return log.wrap("claim", function (log) {
                      return _this2._claimOneTimeKeys(hsApi, devicesWithoutSession, log);
                    });

                  case 2:
                    newEncryptionTargets = _context5.sent;
                    _context5.prev = 3;
                    _iterator3 = _createForOfIteratorHelper(newEncryptionTargets);
                    _context5.prev = 5;

                    _iterator3.s();

                  case 7:
                    if ((_step3 = _iterator3.n()).done) {
                      _context5.next = 15;
                      break;
                    }

                    target = _step3.value;
                    device = target.device, oneTimeKey = target.oneTimeKey;
                    _context5.next = 12;
                    return this._account.createOutboundOlmSession(device.curve25519Key, oneTimeKey);

                  case 12:
                    target.session = _context5.sent;

                  case 13:
                    _context5.next = 7;
                    break;

                  case 15:
                    _context5.next = 20;
                    break;

                  case 17:
                    _context5.prev = 17;
                    _context5.t0 = _context5["catch"](5);

                    _iterator3.e(_context5.t0);

                  case 20:
                    _context5.prev = 20;

                    _iterator3.f();

                    return _context5.finish(20);

                  case 23:
                    _context5.next = 25;
                    return this._storeSessions(newEncryptionTargets, timestamp);

                  case 25:
                    _context5.next = 32;
                    break;

                  case 27:
                    _context5.prev = 27;
                    _context5.t1 = _context5["catch"](3);
                    _iterator4 = _createForOfIteratorHelper(newEncryptionTargets);

                    try {
                      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                        _target = _step4.value;

                        _target.dispose();
                      }
                    } catch (err) {
                      _iterator4.e(_context5.t1);
                    } finally {
                      _iterator4.f();
                    }

                    throw _context5.t1;

                  case 32:
                    return _context5.abrupt("return", newEncryptionTargets);

                  case 33:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this, [[3, 27], [5, 17, 20, 23]]);
          }));

          function _createNewSessions(_x13, _x14, _x15, _x16) {
            return _createNewSessions2.apply(this, arguments);
          }

          return _createNewSessions;
        }()
      }, {
        key: "_claimOneTimeKeys",
        value: function () {
          var _claimOneTimeKeys2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(hsApi, deviceIdentities, log) {
            var devicesByUser, oneTimeKeys, claimResponse, userKeyMap;
            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    // create a Map<userId, Map<deviceId, deviceIdentity>>
                    devicesByUser = groupByWithCreator(deviceIdentities, function (device) {
                      return device.userId;
                    }, function () {
                      return new Map();
                    }, function (deviceMap, device) {
                      return deviceMap.set(device.deviceId, device);
                    });
                    oneTimeKeys = Array.from(devicesByUser.entries()).reduce(function (usersObj, _ref3) {
                      var _ref4 = _slicedToArray(_ref3, 2),
                          userId = _ref4[0],
                          deviceMap = _ref4[1];

                      usersObj[userId] = Array.from(deviceMap.values()).reduce(function (devicesObj, device) {
                        devicesObj[device.deviceId] = OTK_ALGORITHM;
                        return devicesObj;
                      }, {});
                      return usersObj;
                    }, {});
                    _context6.next = 4;
                    return hsApi.claimKeys({
                      timeout: 10000,
                      one_time_keys: oneTimeKeys
                    }, {
                      log: log
                    }).response();

                  case 4:
                    claimResponse = _context6.sent;

                    if (Object.keys(claimResponse.failures).length) {
                      log.log({
                        l: "failures",
                        servers: Object.keys(claimResponse.failures)
                      }, log.level.Warn);
                    }

                    userKeyMap = claimResponse === null || claimResponse === void 0 ? void 0 : claimResponse["one_time_keys"];
                    return _context6.abrupt("return", this._verifyAndCreateOTKTargets(userKeyMap, devicesByUser));

                  case 8:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));

          function _claimOneTimeKeys(_x17, _x18, _x19) {
            return _claimOneTimeKeys2.apply(this, arguments);
          }

          return _claimOneTimeKeys;
        }()
      }, {
        key: "_verifyAndCreateOTKTargets",
        value: function _verifyAndCreateOTKTargets(userKeyMap, devicesByUser) {
          var verifiedEncryptionTargets = [];

          for (var _i = 0, _Object$entries = Object.entries(userKeyMap); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                userId = _Object$entries$_i[0],
                userSection = _Object$entries$_i[1];

            for (var _i2 = 0, _Object$entries2 = Object.entries(userSection); _i2 < _Object$entries2.length; _i2++) {
              var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
                  deviceId = _Object$entries2$_i[0],
                  deviceSection = _Object$entries2$_i[1];

              var _Object$entries$ = _slicedToArray(Object.entries(deviceSection)[0], 2),
                  firstPropName = _Object$entries$[0],
                  keySection = _Object$entries$[1];

              var _firstPropName$split = firstPropName.split(":"),
                  _firstPropName$split2 = _slicedToArray(_firstPropName$split, 1),
                  keyAlgorithm = _firstPropName$split2[0];

              if (keyAlgorithm === OTK_ALGORITHM) {
                var _devicesByUser$get;

                var device = (_devicesByUser$get = devicesByUser.get(userId)) === null || _devicesByUser$get === void 0 ? void 0 : _devicesByUser$get.get(deviceId);

                if (device) {
                  var isValidSignature = verifyEd25519Signature(this._olmUtil, userId, deviceId, device.ed25519Key, keySection);

                  if (isValidSignature) {
                    var target = EncryptionTarget.fromOTK(device, keySection.key);
                    verifiedEncryptionTargets.push(target);
                  }
                }
              }
            }
          }

          return verifiedEncryptionTargets;
        }
      }, {
        key: "_loadSessions",
        value: function () {
          var _loadSessions2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(encryptionTargets) {
            var _this3 = this;

            var txn, failed, _iterator5, _step5, target;

            return regeneratorRuntime.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    _context8.next = 2;
                    return this._storage.readTxn([this._storage.storeNames.olmSessions]);

                  case 2:
                    txn = _context8.sent;
                    // given we run loading in parallel, there might still be some
                    // storage requests that will finish later once one has failed.
                    // those should not allocate a session anymore.
                    failed = false;
                    _context8.prev = 4;
                    _context8.next = 7;
                    return Promise.all(encryptionTargets.map( /*#__PURE__*/function () {
                      var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(encryptionTarget) {
                        var sessionEntry, olmSession;
                        return regeneratorRuntime.wrap(function _callee7$(_context7) {
                          while (1) {
                            switch (_context7.prev = _context7.next) {
                              case 0:
                                _context7.next = 2;
                                return txn.olmSessions.get(encryptionTarget.device.curve25519Key, encryptionTarget.sessionId);

                              case 2:
                                sessionEntry = _context7.sent;

                                if (sessionEntry && !failed) {
                                  olmSession = new _this3._olm.Session();
                                  olmSession.unpickle(_this3._pickleKey, sessionEntry.session);
                                  encryptionTarget.session = olmSession;
                                }

                              case 4:
                              case "end":
                                return _context7.stop();
                            }
                          }
                        }, _callee7);
                      }));

                      return function (_x21) {
                        return _ref5.apply(this, arguments);
                      };
                    }()));

                  case 7:
                    _context8.next = 15;
                    break;

                  case 9:
                    _context8.prev = 9;
                    _context8.t0 = _context8["catch"](4);
                    failed = true; // clean up the sessions that did load

                    _iterator5 = _createForOfIteratorHelper(encryptionTargets);

                    try {
                      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                        target = _step5.value;
                        target.dispose();
                      }
                    } catch (err) {
                      _iterator5.e(_context8.t0);
                    } finally {
                      _iterator5.f();
                    }

                    throw _context8.t0;

                  case 15:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this, [[4, 9]]);
          }));

          function _loadSessions(_x20) {
            return _loadSessions2.apply(this, arguments);
          }

          return _loadSessions;
        }()
      }, {
        key: "_storeSessions",
        value: function () {
          var _storeSessions2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(encryptionTargets, timestamp) {
            var txn, _iterator6, _step6, target, sessionEntry;

            return regeneratorRuntime.wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    _context9.next = 2;
                    return this._storage.readWriteTxn([this._storage.storeNames.olmSessions]);

                  case 2:
                    txn = _context9.sent;
                    _context9.prev = 3;
                    _iterator6 = _createForOfIteratorHelper(encryptionTargets);

                    try {
                      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                        target = _step6.value;
                        sessionEntry = createSessionEntry(target.session, target.device.curve25519Key, timestamp, this._pickleKey);
                        txn.olmSessions.set(sessionEntry);
                      }
                    } catch (err) {
                      _iterator6.e(err);
                    } finally {
                      _iterator6.f();
                    }

                    _context9.next = 12;
                    break;

                  case 8:
                    _context9.prev = 8;
                    _context9.t0 = _context9["catch"](3);
                    txn.abort();
                    throw _context9.t0;

                  case 12:
                    _context9.next = 14;
                    return txn.complete();

                  case 14:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, this, [[3, 8]]);
          }));

          function _storeSessions(_x22, _x23) {
            return _storeSessions2.apply(this, arguments);
          }

          return _storeSessions;
        }()
      }]);

      return Encryption;
    }(); // just a container needed to encrypt a message for a recipient device
    // it is constructed with either a oneTimeKey
    // (and later converted to a session) in case of a new session
    // or an existing session

    var EncryptionTarget = /*#__PURE__*/function () {
      function EncryptionTarget(device, oneTimeKey, sessionId) {
        _classCallCheck(this, EncryptionTarget);

        this.device = device;
        this.oneTimeKey = oneTimeKey;
        this.sessionId = sessionId; // an olmSession, should probably be called olmSession

        this.session = null;
      }

      _createClass(EncryptionTarget, [{
        key: "dispose",
        value: function dispose() {
          if (this.session) {
            this.session.free();
          }
        }
      }], [{
        key: "fromOTK",
        value: function fromOTK(device, oneTimeKey) {
          return new EncryptionTarget(device, oneTimeKey, null);
        }
      }, {
        key: "fromSessionId",
        value: function fromSessionId(device, sessionId) {
          return new EncryptionTarget(device, null, sessionId);
        }
      }]);

      return EncryptionTarget;
    }();

    var EncryptedMessage = function EncryptedMessage(content, device) {
      _classCallCheck(this, EncryptedMessage);

      this.content = content;
      this.device = device;
    };

    var DecryptionChanges$1 = /*#__PURE__*/function () {
      function DecryptionChanges(roomId, results, errors, replayEntries) {
        _classCallCheck(this, DecryptionChanges);

        this._roomId = roomId;
        this._results = results;
        this._errors = errors;
        this._replayEntries = replayEntries;
      }
      /**
       * @type MegolmBatchDecryptionResult
       * @property {Map<string, DecryptionResult>} results a map of event id to decryption result
       * @property {Map<string, Error>} errors event id -> errors
       * 
       * Handle replay attack detection, and return result
       * @param  {[type]} txn [description]
       * @return {MegolmBatchDecryptionResult}
       */


      _createClass(DecryptionChanges, [{
        key: "write",
        value: function () {
          var _write = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(txn) {
            var _this = this;

            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return Promise.all(this._replayEntries.map( /*#__PURE__*/function () {
                      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(replayEntry) {
                        return regeneratorRuntime.wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                try {
                                  _this._handleReplayAttack(_this._roomId, replayEntry, txn);
                                } catch (err) {
                                  _this._errors.set(replayEntry.eventId, err);
                                }

                              case 1:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee);
                      }));

                      return function (_x2) {
                        return _ref.apply(this, arguments);
                      };
                    }()));

                  case 2:
                    return _context2.abrupt("return", {
                      results: this._results,
                      errors: this._errors
                    });

                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function write(_x) {
            return _write.apply(this, arguments);
          }

          return write;
        }() // need to handle replay attack because
        // if we redecrypted the same message twice and showed it again
        // then it could be a malicious server admin replaying the word “yes”
        // to make you respond to a msg you didn’t say “yes” to, or something

      }, {
        key: "_handleReplayAttack",
        value: function () {
          var _handleReplayAttack2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(roomId, replayEntry, txn) {
            var messageIndex, sessionId, eventId, timestamp, decryption, decryptedEventIsBad, badEventId;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    messageIndex = replayEntry.messageIndex, sessionId = replayEntry.sessionId, eventId = replayEntry.eventId, timestamp = replayEntry.timestamp;
                    _context3.next = 3;
                    return txn.groupSessionDecryptions.get(roomId, sessionId, messageIndex);

                  case 3:
                    decryption = _context3.sent;

                    if (!(decryption && decryption.eventId !== eventId)) {
                      _context3.next = 9;
                      break;
                    }

                    // the one with the newest timestamp should be the attack
                    decryptedEventIsBad = decryption.timestamp < timestamp;
                    badEventId = decryptedEventIsBad ? eventId : decryption.eventId; // discard result

                    this._results.delete(eventId);

                    throw new DecryptionError("MEGOLM_REPLAYED_INDEX", event, {
                      messageIndex: messageIndex,
                      badEventId: badEventId,
                      otherEventId: decryption.eventId
                    });

                  case 9:
                    if (!decryption) {
                      txn.groupSessionDecryptions.set(roomId, sessionId, messageIndex, {
                        eventId: eventId,
                        timestamp: timestamp
                      });
                    }

                  case 10:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function _handleReplayAttack(_x3, _x4, _x5) {
            return _handleReplayAttack2.apply(this, arguments);
          }

          return _handleReplayAttack;
        }()
      }]);

      return DecryptionChanges;
    }();

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function mergeMap(src, dst) {
      if (src) {
        var _iterator = _createForOfIteratorHelper(src.entries()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
                key = _step$value[0],
                value = _step$value[1];

            dst.set(key, value);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }

    /**
     * Class that contains all the state loaded from storage to decrypt the given events
     */

    var DecryptionPreparation = /*#__PURE__*/function () {
      function DecryptionPreparation(roomId, sessionDecryptions, errors) {
        _classCallCheck(this, DecryptionPreparation);

        this._roomId = roomId;
        this._sessionDecryptions = sessionDecryptions;
        this._initialErrors = errors;
      }

      _createClass(DecryptionPreparation, [{
        key: "decrypt",
        value: function () {
          var _decrypt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            var errors, results, replayEntries;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.prev = 0;
                    errors = this._initialErrors;
                    results = new Map();
                    replayEntries = [];
                    _context2.next = 6;
                    return Promise.all(this._sessionDecryptions.map( /*#__PURE__*/function () {
                      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(sessionDecryption) {
                        var sessionResult;
                        return regeneratorRuntime.wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                _context.next = 2;
                                return sessionDecryption.decryptAll();

                              case 2:
                                sessionResult = _context.sent;
                                mergeMap(sessionResult.errors, errors);
                                mergeMap(sessionResult.results, results);
                                replayEntries.push.apply(replayEntries, _toConsumableArray(sessionResult.replayEntries));

                              case 6:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee);
                      }));

                      return function (_x) {
                        return _ref.apply(this, arguments);
                      };
                    }()));

                  case 6:
                    return _context2.abrupt("return", new DecryptionChanges$1(this._roomId, results, errors, replayEntries));

                  case 7:
                    _context2.prev = 7;
                    this.dispose();
                    return _context2.finish(7);

                  case 10:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[0,, 7, 10]]);
          }));

          function decrypt() {
            return _decrypt.apply(this, arguments);
          }

          return decrypt;
        }()
      }, {
        key: "dispose",
        value: function dispose() {
          var _iterator = _createForOfIteratorHelper(this._sessionDecryptions),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var sd = _step.value;
              sd.dispose();
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }]);

      return DecryptionPreparation;
    }();

    var ReplayDetectionEntry = /*#__PURE__*/function () {
      function ReplayDetectionEntry(sessionId, messageIndex, event) {
        _classCallCheck(this, ReplayDetectionEntry);

        this.sessionId = sessionId;
        this.messageIndex = messageIndex;
        this.event = event;
      }

      _createClass(ReplayDetectionEntry, [{
        key: "eventId",
        get: function get() {
          return this.event.event_id;
        }
      }, {
        key: "timestamp",
        get: function get() {
          return this.event.origin_server_ts;
        }
      }]);

      return ReplayDetectionEntry;
    }();

    var SessionDecryption = /*#__PURE__*/function () {
      function SessionDecryption(key, events, olmWorker, keyLoader) {
        _classCallCheck(this, SessionDecryption);

        this.key = key;
        this.events = events;
        this.olmWorker = olmWorker;
        this.keyLoader = keyLoader;
        this.decryptionRequests = olmWorker ? [] : void 0;
      }

      _createClass(SessionDecryption, [{
        key: "decryptAll",
        value: function () {
          var _decryptAll = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            var _this = this;

            var replayEntries, results, errors;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    replayEntries = [];
                    results = new Map();
                    _context2.next = 4;
                    return this.keyLoader.useKey(this.key, /*#__PURE__*/function () {
                      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(session) {
                        var _iterator, _step, event, ciphertext, decryptionResult, request, _decryptionResult, plaintext, payload, result;

                        return regeneratorRuntime.wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                _iterator = _createForOfIteratorHelper(_this.events);
                                _context.prev = 1;

                                _iterator.s();

                              case 3:
                                if ((_step = _iterator.n()).done) {
                                  _context.next = 41;
                                  break;
                                }

                                event = _step.value;
                                _context.prev = 5;
                                ciphertext = event.content.ciphertext;
                                decryptionResult = void 0;

                                if (!_this.olmWorker) {
                                  _context.next = 16;
                                  break;
                                }

                                request = _this.olmWorker.megolmDecrypt(session, ciphertext);

                                _this.decryptionRequests.push(request);

                                _context.next = 13;
                                return request.response();

                              case 13:
                                decryptionResult = _context.sent;
                                _context.next = 17;
                                break;

                              case 16:
                                decryptionResult = session.decrypt(ciphertext);

                              case 17:
                                _decryptionResult = decryptionResult, plaintext = _decryptionResult.plaintext;
                                payload = void 0;
                                _context.prev = 19;
                                payload = JSON.parse(plaintext);
                                _context.next = 26;
                                break;

                              case 23:
                                _context.prev = 23;
                                _context.t0 = _context["catch"](19);
                                throw new DecryptionError("PLAINTEXT_NOT_JSON", event, {
                                  plaintext: plaintext,
                                  err: _context.t0
                                });

                              case 26:
                                if (!(payload.room_id !== _this.key.roomId)) {
                                  _context.next = 28;
                                  break;
                                }

                                throw new DecryptionError("MEGOLM_WRONG_ROOM", event, {
                                  encryptedRoomId: payload.room_id,
                                  eventRoomId: _this.key.roomId
                                });

                              case 28:
                                replayEntries.push(new ReplayDetectionEntry(_this.key.sessionId, decryptionResult.message_index, event));
                                result = new DecryptionResult(payload, _this.key.senderKey, _this.key.claimedEd25519Key);
                                results.set(event.event_id, result);
                                _context.next = 39;
                                break;

                              case 33:
                                _context.prev = 33;
                                _context.t1 = _context["catch"](5);

                                if (!(_context.t1.name === "AbortError")) {
                                  _context.next = 37;
                                  break;
                                }

                                return _context.abrupt("return");

                              case 37:
                                if (!errors) {
                                  errors = new Map();
                                }

                                errors.set(event.event_id, _context.t1);

                              case 39:
                                _context.next = 3;
                                break;

                              case 41:
                                _context.next = 46;
                                break;

                              case 43:
                                _context.prev = 43;
                                _context.t2 = _context["catch"](1);

                                _iterator.e(_context.t2);

                              case 46:
                                _context.prev = 46;

                                _iterator.f();

                                return _context.finish(46);

                              case 49:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee, null, [[1, 43, 46, 49], [5, 33], [19, 23]]);
                      }));

                      return function (_x) {
                        return _ref.apply(this, arguments);
                      };
                    }());

                  case 4:
                    return _context2.abrupt("return", {
                      results: results,
                      errors: errors,
                      replayEntries: replayEntries
                    });

                  case 5:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function decryptAll() {
            return _decryptAll.apply(this, arguments);
          }

          return decryptAll;
        }()
      }, {
        key: "dispose",
        value: function dispose() {
          if (this.decryptionRequests) {
            var _iterator2 = _createForOfIteratorHelper(this.decryptionRequests),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var r = _step2.value;
                r.abort();
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        }
      }]);

      return SessionDecryption;
    }();

    function getSenderKey(event) {
      var _event$content;

      return (_event$content = event.content) === null || _event$content === void 0 ? void 0 : _event$content["sender_key"];
    }

    function getSessionId(event) {
      var _event$content2;

      return (_event$content2 = event.content) === null || _event$content2 === void 0 ? void 0 : _event$content2["session_id"];
    }

    function getCiphertext(event) {
      var _event$content3;

      return (_event$content3 = event.content) === null || _event$content3 === void 0 ? void 0 : _event$content3.ciphertext;
    }

    function validateEvent(event) {
      return typeof getSenderKey(event) === "string" && typeof getSessionId(event) === "string" && typeof getCiphertext(event) === "string";
    }
    var SessionKeyGroup = /*#__PURE__*/function () {
      function SessionKeyGroup() {
        _classCallCheck(this, SessionKeyGroup);

        this.events = [];
      }

      _createClass(SessionKeyGroup, [{
        key: "senderKey",
        get: function get() {
          return getSenderKey(this.events[0]);
        }
      }, {
        key: "sessionId",
        get: function get() {
          return getSessionId(this.events[0]);
        }
      }]);

      return SessionKeyGroup;
    }();
    function groupEventsBySession(events) {
      return groupByWithCreator(events, function (event) {
        return "".concat(getSenderKey(event), "|").concat(getSessionId(event));
      }, function () {
        return new SessionKeyGroup();
      }, function (group, event) {
        return group.events.push(event);
      });
    }

    var RoomKey = /*#__PURE__*/function () {
      function RoomKey() {
        _classCallCheck(this, RoomKey);
      }

      _createClass(RoomKey, [{
        key: "isForSession",
        value: function isForSession(roomId, senderKey, sessionId) {
          return this.roomId === roomId && this.senderKey === senderKey && this.sessionId === sessionId;
        }
      }, {
        key: "isBetter",
        get: function get() {
          return this._isBetter;
        },
        set: function set(value) {
          this._isBetter = value;
        }
      }]);

      return RoomKey;
    }();
    function isBetterThan(newSession, existingSession) {
      return newSession.first_known_index() < existingSession.first_known_index();
    }
    var IncomingRoomKey = /*#__PURE__*/function (_RoomKey) {
      _inherits(IncomingRoomKey, _RoomKey);

      var _super = _createSuper(IncomingRoomKey);

      function IncomingRoomKey() {
        _classCallCheck(this, IncomingRoomKey);

        return _super.apply(this, arguments);
      }

      _createClass(IncomingRoomKey, [{
        key: "checkBetterThanKeyInStorage",
        value: function checkBetterThanKeyInStorage(loader, txn) {
          return this._checkBetterThanKeyInStorage(loader, void 0, txn);
        }
      }, {
        key: "write",
        value: function () {
          var _write = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(loader, txn) {
            var pickledSession, sessionEntry;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!(this.isBetter === void 0)) {
                      _context.next = 3;
                      break;
                    }

                    _context.next = 3;
                    return this._checkBetterThanKeyInStorage(loader, function (session, pickleKey) {
                      pickledSession = session.pickle(pickleKey);
                    }, txn);

                  case 3:
                    if (!(this.isBetter === false)) {
                      _context.next = 5;
                      break;
                    }

                    return _context.abrupt("return", false);

                  case 5:
                    if (pickledSession) {
                      _context.next = 9;
                      break;
                    }

                    _context.next = 8;
                    return loader.useKey(this, function (session, pickleKey) {
                      return session.pickle(pickleKey);
                    });

                  case 8:
                    pickledSession = _context.sent;

                  case 9:
                    sessionEntry = {
                      roomId: this.roomId,
                      senderKey: this.senderKey,
                      sessionId: this.sessionId,
                      session: pickledSession,
                      claimedKeys: {
                        ed25519: this.claimedEd25519Key
                      }
                    };
                    txn.inboundGroupSessions.set(sessionEntry);
                    return _context.abrupt("return", true);

                  case 12:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function write(_x, _x2) {
            return _write.apply(this, arguments);
          }

          return write;
        }()
      }, {
        key: "_checkBetterThanKeyInStorage",
        value: function () {
          var _checkBetterThanKeyInStorage2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(loader, callback, txn) {
            var _this = this;

            var existingKey, storageKey, key;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (!(this.isBetter !== void 0)) {
                      _context3.next = 2;
                      break;
                    }

                    return _context3.abrupt("return", this.isBetter);

                  case 2:
                    existingKey = loader.getCachedKey(this.roomId, this.senderKey, this.sessionId);

                    if (existingKey) {
                      _context3.next = 8;
                      break;
                    }

                    _context3.next = 6;
                    return keyFromStorage(this.roomId, this.senderKey, this.sessionId, txn);

                  case 6:
                    storageKey = _context3.sent;

                    if (storageKey) {
                      if (storageKey.hasSession) {
                        existingKey = storageKey;
                      } else if (storageKey.eventIds) {
                        this._eventIds = storageKey.eventIds;
                      }
                    }

                  case 8:
                    if (!existingKey) {
                      _context3.next = 14;
                      break;
                    }

                    key = existingKey;
                    _context3.next = 12;
                    return loader.useKey(this, /*#__PURE__*/function () {
                      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(newSession) {
                        return regeneratorRuntime.wrap(function _callee2$(_context2) {
                          while (1) {
                            switch (_context2.prev = _context2.next) {
                              case 0:
                                _context2.next = 2;
                                return loader.useKey(key, function (existingSession, pickleKey) {
                                  _this.isBetter = isBetterThan(newSession, existingSession);
                                  key.isBetter = !_this.isBetter;

                                  if (_this.isBetter && callback) {
                                    callback(newSession, pickleKey);
                                  }
                                });

                              case 2:
                              case "end":
                                return _context2.stop();
                            }
                          }
                        }, _callee2);
                      }));

                      return function (_x6) {
                        return _ref.apply(this, arguments);
                      };
                    }());

                  case 12:
                    _context3.next = 15;
                    break;

                  case 14:
                    this.isBetter = true;

                  case 15:
                    return _context3.abrupt("return", this.isBetter);

                  case 16:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function _checkBetterThanKeyInStorage(_x3, _x4, _x5) {
            return _checkBetterThanKeyInStorage2.apply(this, arguments);
          }

          return _checkBetterThanKeyInStorage;
        }()
      }, {
        key: "eventIds",
        get: function get() {
          return this._eventIds;
        }
      }]);

      return IncomingRoomKey;
    }(RoomKey);

    var DeviceMessageRoomKey = /*#__PURE__*/function (_IncomingRoomKey) {
      _inherits(DeviceMessageRoomKey, _IncomingRoomKey);

      var _super2 = _createSuper(DeviceMessageRoomKey);

      function DeviceMessageRoomKey(decryptionResult) {
        var _this2;

        _classCallCheck(this, DeviceMessageRoomKey);

        _this2 = _super2.call(this);
        _this2._decryptionResult = decryptionResult;
        return _this2;
      }

      _createClass(DeviceMessageRoomKey, [{
        key: "loadInto",
        value: function loadInto(session) {
          session.create(this.serializationKey);
        }
      }, {
        key: "roomId",
        get: function get() {
          var _this$_decryptionResu;

          return (_this$_decryptionResu = this._decryptionResult.event.content) === null || _this$_decryptionResu === void 0 ? void 0 : _this$_decryptionResu["room_id"];
        }
      }, {
        key: "senderKey",
        get: function get() {
          return this._decryptionResult.senderCurve25519Key;
        }
      }, {
        key: "sessionId",
        get: function get() {
          var _this$_decryptionResu2;

          return (_this$_decryptionResu2 = this._decryptionResult.event.content) === null || _this$_decryptionResu2 === void 0 ? void 0 : _this$_decryptionResu2["session_id"];
        }
      }, {
        key: "claimedEd25519Key",
        get: function get() {
          return this._decryptionResult.claimedEd25519Key;
        }
      }, {
        key: "serializationKey",
        get: function get() {
          var _this$_decryptionResu3;

          return (_this$_decryptionResu3 = this._decryptionResult.event.content) === null || _this$_decryptionResu3 === void 0 ? void 0 : _this$_decryptionResu3["session_key"];
        }
      }, {
        key: "serializationType",
        get: function get() {
          return "create";
        }
      }]);

      return DeviceMessageRoomKey;
    }(IncomingRoomKey);

    var BackupRoomKey = /*#__PURE__*/function (_IncomingRoomKey2) {
      _inherits(BackupRoomKey, _IncomingRoomKey2);

      var _super3 = _createSuper(BackupRoomKey);

      function BackupRoomKey(roomId, sessionId, backupInfo) {
        var _this3;

        _classCallCheck(this, BackupRoomKey);

        _this3 = _super3.call(this);
        _this3._roomId = roomId;
        _this3._sessionId = sessionId;
        _this3._backupInfo = backupInfo;
        return _this3;
      }

      _createClass(BackupRoomKey, [{
        key: "loadInto",
        value: function loadInto(session) {
          session.import_session(this.serializationKey);
        }
      }, {
        key: "roomId",
        get: function get() {
          return this._roomId;
        }
      }, {
        key: "senderKey",
        get: function get() {
          return this._backupInfo["sender_key"];
        }
      }, {
        key: "sessionId",
        get: function get() {
          return this._sessionId;
        }
      }, {
        key: "claimedEd25519Key",
        get: function get() {
          var _this$_backupInfo$sen;

          return (_this$_backupInfo$sen = this._backupInfo["sender_claimed_keys"]) === null || _this$_backupInfo$sen === void 0 ? void 0 : _this$_backupInfo$sen["ed25519"];
        }
      }, {
        key: "serializationKey",
        get: function get() {
          return this._backupInfo["session_key"];
        }
      }, {
        key: "serializationType",
        get: function get() {
          return "import_session";
        }
      }]);

      return BackupRoomKey;
    }(IncomingRoomKey);

    var StoredRoomKey = /*#__PURE__*/function (_RoomKey2) {
      _inherits(StoredRoomKey, _RoomKey2);

      var _super4 = _createSuper(StoredRoomKey);

      function StoredRoomKey(storageEntry) {
        var _this4;

        _classCallCheck(this, StoredRoomKey);

        _this4 = _super4.call(this);
        _this4.isBetter = true;
        _this4.storageEntry = storageEntry;
        return _this4;
      }

      _createClass(StoredRoomKey, [{
        key: "loadInto",
        value: function loadInto(session, pickleKey) {
          session.unpickle(pickleKey, this.serializationKey);
        }
      }, {
        key: "roomId",
        get: function get() {
          return this.storageEntry.roomId;
        }
      }, {
        key: "senderKey",
        get: function get() {
          return this.storageEntry.senderKey;
        }
      }, {
        key: "sessionId",
        get: function get() {
          return this.storageEntry.sessionId;
        }
      }, {
        key: "claimedEd25519Key",
        get: function get() {
          return this.storageEntry.claimedKeys["ed25519"];
        }
      }, {
        key: "eventIds",
        get: function get() {
          return this.storageEntry.eventIds;
        }
      }, {
        key: "serializationKey",
        get: function get() {
          return this.storageEntry.session || "";
        }
      }, {
        key: "serializationType",
        get: function get() {
          return "unpickle";
        }
      }, {
        key: "hasSession",
        get: function get() {
          return !!this.serializationKey;
        }
      }]);

      return StoredRoomKey;
    }(RoomKey);

    function keyFromDeviceMessage(dr) {
      var _dr$event$content;

      var sessionKey = (_dr$event$content = dr.event.content) === null || _dr$event$content === void 0 ? void 0 : _dr$event$content["session_key"];
      var key = new DeviceMessageRoomKey(dr);

      if (typeof key.roomId === "string" && typeof key.sessionId === "string" && typeof key.senderKey === "string" && typeof sessionKey === "string") {
        return key;
      }
    }
    function keyFromBackup(roomId, sessionId, backupInfo) {
      var _backupInfo$sender_cl;

      var sessionKey = backupInfo["session_key"];
      var senderKey = backupInfo["sender_key"];
      var claimedEd25519Key = (_backupInfo$sender_cl = backupInfo["sender_claimed_keys"]) === null || _backupInfo$sender_cl === void 0 ? void 0 : _backupInfo$sender_cl["ed25519"];

      if (typeof roomId === "string" && typeof sessionId === "string" && typeof senderKey === "string" && typeof sessionKey === "string" && typeof claimedEd25519Key === "string") {
        return new BackupRoomKey(roomId, sessionId, backupInfo);
      }
    }
    function keyFromStorage(_x7, _x8, _x9, _x10) {
      return _keyFromStorage.apply(this, arguments);
    }

    function _keyFromStorage() {
      _keyFromStorage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(roomId, senderKey, sessionId, txn) {
        var existingSessionEntry;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return txn.inboundGroupSessions.get(roomId, senderKey, sessionId);

              case 2:
                existingSessionEntry = _context4.sent;

                if (!existingSessionEntry) {
                  _context4.next = 5;
                  break;
                }

                return _context4.abrupt("return", new StoredRoomKey(existingSessionEntry));

              case 5:
                return _context4.abrupt("return");

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));
      return _keyFromStorage.apply(this, arguments);
    }

    var Decryption$1 = /*#__PURE__*/function () {
      function Decryption(keyLoader, olmWorker) {
        _classCallCheck(this, Decryption);

        this.keyLoader = keyLoader;
        this.olmWorker = olmWorker;
      }

      _createClass(Decryption, [{
        key: "addMissingKeyEventIds",
        value: function () {
          var _addMissingKeyEventIds = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(roomId, senderKey, sessionId, eventIds, txn) {
            var _sessionEntry;

            var sessionEntry, uniqueEventIds, _iterator, _step, id;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return txn.inboundGroupSessions.get(roomId, senderKey, sessionId);

                  case 2:
                    sessionEntry = _context.sent;

                    if (!((_sessionEntry = sessionEntry) === null || _sessionEntry === void 0 ? void 0 : _sessionEntry.session)) {
                      _context.next = 5;
                      break;
                    }

                    return _context.abrupt("return");

                  case 5:
                    if (sessionEntry) {
                      uniqueEventIds = new Set(sessionEntry.eventIds);
                      _iterator = _createForOfIteratorHelper(eventIds);

                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done;) {
                          id = _step.value;
                          uniqueEventIds.add(id);
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }

                      sessionEntry.eventIds = Array.from(uniqueEventIds);
                    } else {
                      sessionEntry = {
                        roomId: roomId,
                        senderKey: senderKey,
                        sessionId: sessionId,
                        eventIds: eventIds
                      };
                    }

                    txn.inboundGroupSessions.set(sessionEntry);

                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function addMissingKeyEventIds(_x, _x2, _x3, _x4, _x5) {
            return _addMissingKeyEventIds.apply(this, arguments);
          }

          return addMissingKeyEventIds;
        }()
      }, {
        key: "getEventIdsForMissingKey",
        value: function () {
          var _getEventIdsForMissingKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(roomId, senderKey, sessionId, txn) {
            var sessionEntry;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return txn.inboundGroupSessions.get(roomId, senderKey, sessionId);

                  case 2:
                    sessionEntry = _context2.sent;

                    if (!(sessionEntry && !sessionEntry.session)) {
                      _context2.next = 5;
                      break;
                    }

                    return _context2.abrupt("return", sessionEntry.eventIds);

                  case 5:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          function getEventIdsForMissingKey(_x6, _x7, _x8, _x9) {
            return _getEventIdsForMissingKey.apply(this, arguments);
          }

          return getEventIdsForMissingKey;
        }()
      }, {
        key: "hasSession",
        value: function () {
          var _hasSession = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(roomId, senderKey, sessionId, txn) {
            var sessionEntry, isValidSession;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return txn.inboundGroupSessions.get(roomId, senderKey, sessionId);

                  case 2:
                    sessionEntry = _context3.sent;
                    isValidSession = typeof (sessionEntry === null || sessionEntry === void 0 ? void 0 : sessionEntry.session) === "string";
                    return _context3.abrupt("return", isValidSession);

                  case 5:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));

          function hasSession(_x10, _x11, _x12, _x13) {
            return _hasSession.apply(this, arguments);
          }

          return hasSession;
        }()
      }, {
        key: "prepareDecryptAll",
        value: function () {
          var _prepareDecryptAll = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(roomId, events, newKeys, txn) {
            var _this = this;

            var errors, validEvents, _iterator2, _step2, event, eventsBySession, sessionDecryptions;

            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    errors = new Map();
                    validEvents = [];
                    _iterator2 = _createForOfIteratorHelper(events);

                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                        event = _step2.value;

                        if (validateEvent(event)) {
                          validEvents.push(event);
                        } else {
                          errors.set(event.event_id, new DecryptionError("MEGOLM_INVALID_EVENT", event));
                        }
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }

                    eventsBySession = groupEventsBySession(validEvents);
                    sessionDecryptions = [];
                    _context5.next = 8;
                    return Promise.all(Array.from(eventsBySession.values()).map( /*#__PURE__*/function () {
                      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(group) {
                        var key, _iterator3, _step3, event;

                        return regeneratorRuntime.wrap(function _callee4$(_context4) {
                          while (1) {
                            switch (_context4.prev = _context4.next) {
                              case 0:
                                _context4.next = 2;
                                return _this.getRoomKey(roomId, group.senderKey, group.sessionId, newKeys, txn);

                              case 2:
                                key = _context4.sent;

                                if (key) {
                                  sessionDecryptions.push(new SessionDecryption(key, group.events, _this.olmWorker, _this.keyLoader));
                                } else {
                                  _iterator3 = _createForOfIteratorHelper(group.events);

                                  try {
                                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                                      event = _step3.value;
                                      errors.set(event.event_id, new DecryptionError("MEGOLM_NO_SESSION", event));
                                    }
                                  } catch (err) {
                                    _iterator3.e(err);
                                  } finally {
                                    _iterator3.f();
                                  }
                                }

                              case 4:
                              case "end":
                                return _context4.stop();
                            }
                          }
                        }, _callee4);
                      }));

                      return function (_x18) {
                        return _ref.apply(this, arguments);
                      };
                    }()));

                  case 8:
                    return _context5.abrupt("return", new DecryptionPreparation(roomId, sessionDecryptions, errors));

                  case 9:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5);
          }));

          function prepareDecryptAll(_x14, _x15, _x16, _x17) {
            return _prepareDecryptAll.apply(this, arguments);
          }

          return prepareDecryptAll;
        }()
      }, {
        key: "getRoomKey",
        value: function () {
          var _getRoomKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(roomId, senderKey, sessionId, newKeys, txn) {
            var key, cachedKey, storageKey;
            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    if (!newKeys) {
                      _context6.next = 9;
                      break;
                    }

                    key = newKeys.find(function (k) {
                      return k.isForSession(roomId, senderKey, sessionId);
                    });
                    _context6.t0 = key;

                    if (!_context6.t0) {
                      _context6.next = 7;
                      break;
                    }

                    _context6.next = 6;
                    return key.checkBetterThanKeyInStorage(this.keyLoader, txn);

                  case 6:
                    _context6.t0 = _context6.sent;

                  case 7:
                    if (!_context6.t0) {
                      _context6.next = 9;
                      break;
                    }

                    return _context6.abrupt("return", key);

                  case 9:
                    cachedKey = this.keyLoader.getCachedKey(roomId, senderKey, sessionId);

                    if (!cachedKey) {
                      _context6.next = 12;
                      break;
                    }

                    return _context6.abrupt("return", cachedKey);

                  case 12:
                    _context6.next = 14;
                    return keyFromStorage(roomId, senderKey, sessionId, txn);

                  case 14:
                    storageKey = _context6.sent;

                    if (!(storageKey && storageKey.serializationKey)) {
                      _context6.next = 17;
                      break;
                    }

                    return _context6.abrupt("return", storageKey);

                  case 17:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));

          function getRoomKey(_x19, _x20, _x21, _x22, _x23) {
            return _getRoomKey.apply(this, arguments);
          }

          return getRoomKey;
        }()
      }, {
        key: "writeRoomKey",
        value: function writeRoomKey(key, txn) {
          return key.write(this.keyLoader, txn);
        }
      }, {
        key: "roomKeysFromDeviceMessages",
        value: function roomKeysFromDeviceMessages(decryptionResults, log) {
          var keys = [];

          var _iterator4 = _createForOfIteratorHelper(decryptionResults),
              _step4;

          try {
            var _loop = function _loop() {
              var _dr$event, _dr$event$content;

              var dr = _step4.value;

              if (((_dr$event = dr.event) === null || _dr$event === void 0 ? void 0 : _dr$event.type) !== "m.room_key" || ((_dr$event$content = dr.event.content) === null || _dr$event$content === void 0 ? void 0 : _dr$event$content.algorithm) !== MEGOLM_ALGORITHM) {
                return "continue";
              }

              log.wrap("room_key", function (log2) {
                var key = keyFromDeviceMessage(dr);

                if (key) {
                  log2.set("roomId", key.roomId);
                  log2.set("id", key.sessionId);
                  keys.push(key);
                } else {
                  log2.logLevel = log2.level.Warn;
                  log2.set("invalid", true);
                }
              }, log.level.Detail);
            };

            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _ret = _loop();

              if (_ret === "continue") continue;
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          return keys;
        }
      }, {
        key: "roomKeyFromBackup",
        value: function roomKeyFromBackup(roomId, sessionId, sessionInfo) {
          return keyFromBackup(roomId, sessionId, sessionInfo);
        }
      }, {
        key: "dispose",
        value: function dispose() {
          this.keyLoader.dispose();
        }
      }]);

      return Decryption;
    }();

    var KeyLoader = /*#__PURE__*/function (_BaseLRUCache) {
      _inherits(KeyLoader, _BaseLRUCache);

      var _super = _createSuper(KeyLoader);

      function KeyLoader(olm, pickleKey, limit) {
        var _this;

        _classCallCheck(this, KeyLoader);

        _this = _super.call(this, limit);
        _this.pickleKey = pickleKey;
        _this.olm = olm;
        return _this;
      }

      _createClass(KeyLoader, [{
        key: "getCachedKey",
        value: function getCachedKey(roomId, senderKey, sessionId) {
          var idx = this.findCachedKeyIndex(roomId, senderKey, sessionId);

          if (idx !== -1) {
            return this._getByIndexAndMoveUp(idx).key;
          }
        }
      }, {
        key: "useKey",
        value: function () {
          var _useKey = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(key, callback) {
            var keyOp;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this.allocateOperation(key);

                  case 2:
                    keyOp = _context.sent;
                    _context.prev = 3;
                    _context.next = 6;
                    return callback(keyOp.session, this.pickleKey);

                  case 6:
                    return _context.abrupt("return", _context.sent);

                  case 7:
                    _context.prev = 7;
                    this.releaseOperation(keyOp);
                    return _context.finish(7);

                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[3,, 7, 10]]);
          }));

          function useKey(_x, _x2) {
            return _useKey.apply(this, arguments);
          }

          return useKey;
        }()
      }, {
        key: "dispose",
        value: function dispose() {
          for (var i = 0; i < this._entries.length; i += 1) {
            this._entries[i].dispose();
          }

          this._entries.splice(0, this._entries.length);
        }
      }, {
        key: "allocateOperation",
        value: function () {
          var _allocateOperation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(key) {
            var idx, op, session, _op;

            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (!((idx = this.findIndexForAllocation(key)) === -1)) {
                      _context2.next = 5;
                      break;
                    }

                    _context2.next = 3;
                    return this.operationBecomesUnused();

                  case 3:
                    _context2.next = 0;
                    break;

                  case 5:
                    if (!(idx < this.size)) {
                      _context2.next = 18;
                      break;
                    }

                    op = this._getByIndexAndMoveUp(idx);

                    if (!op.isForKey(key)) {
                      _context2.next = 12;
                      break;
                    }

                    op.refCount += 1;
                    return _context2.abrupt("return", op);

                  case 12:
                    op.refCount = 1;
                    op.key = key;
                    key.loadInto(op.session, this.pickleKey);

                  case 15:
                    return _context2.abrupt("return", op);

                  case 18:
                    session = new this.olm.InboundGroupSession();
                    key.loadInto(session, this.pickleKey);
                    _op = new KeyOperation(key, session);

                    this._set(_op);

                    return _context2.abrupt("return", _op);

                  case 23:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function allocateOperation(_x3) {
            return _allocateOperation.apply(this, arguments);
          }

          return allocateOperation;
        }()
      }, {
        key: "releaseOperation",
        value: function releaseOperation(op) {
          op.refCount -= 1;

          if (op.refCount <= 0 && this.resolveUnusedOperation) {
            this.resolveUnusedOperation();
            this.operationBecomesUnusedPromise = this.resolveUnusedOperation = void 0;
          }
        }
      }, {
        key: "operationBecomesUnused",
        value: function operationBecomesUnused() {
          var _this2 = this;

          if (!this.operationBecomesUnusedPromise) {
            this.operationBecomesUnusedPromise = new Promise(function (resolve) {
              _this2.resolveUnusedOperation = resolve;
            });
          }

          return this.operationBecomesUnusedPromise;
        }
      }, {
        key: "findIndexForAllocation",
        value: function findIndexForAllocation(key) {
          var idx = this.findIndexSameKey(key);

          if (idx === -1) {
            if (this.size < this.limit) {
              idx = this.size;
            } else {
              idx = this.findIndexSameSessionUnused(key);

              if (idx === -1) {
                idx = this.findIndexOldestUnused();
              }
            }
          }

          return idx;
        }
      }, {
        key: "findCachedKeyIndex",
        value: function findCachedKeyIndex(roomId, senderKey, sessionId) {
          return this._entries.reduce(function (bestIdx, op, i, arr) {
            var bestOp = bestIdx === -1 ? void 0 : arr[bestIdx];

            if (op.isBest === true && op.isForSameSession(roomId, senderKey, sessionId)) {
              if (!bestOp || op.isBetter(bestOp)) {
                return i;
              }
            }

            return bestIdx;
          }, -1);
        }
      }, {
        key: "findIndexSameKey",
        value: function findIndexSameKey(key) {
          return this._entries.findIndex(function (op) {
            return op.isForSameSession(key.roomId, key.senderKey, key.sessionId) && op.isForKey(key);
          });
        }
      }, {
        key: "findIndexSameSessionUnused",
        value: function findIndexSameSessionUnused(key) {
          return this._entries.reduce(function (worstIdx, op, i, arr) {
            var worst = worstIdx === -1 ? void 0 : arr[worstIdx];

            if (op.refCount === 0 && op.isForSameSession(key.roomId, key.senderKey, key.sessionId)) {
              if (!worst || !op.isBetter(worst)) {
                return i;
              }
            }

            return worstIdx;
          }, -1);
        }
      }, {
        key: "findIndexOldestUnused",
        value: function findIndexOldestUnused() {
          for (var i = this._entries.length - 1; i >= 0; i -= 1) {
            var op = this._entries[i];

            if (op.refCount === 0) {
              return i;
            }
          }

          return -1;
        }
      }, {
        key: "running",
        get: function get() {
          return this._entries.some(function (op) {
            return op.refCount !== 0;
          });
        }
      }]);

      return KeyLoader;
    }(BaseLRUCache);

    var KeyOperation = /*#__PURE__*/function () {
      function KeyOperation(key, session) {
        _classCallCheck(this, KeyOperation);

        this.key = key;
        this.session = session;
        this.refCount = 1;
      }

      _createClass(KeyOperation, [{
        key: "isForSameSession",
        value: function isForSameSession(roomId, senderKey, sessionId) {
          return this.key.roomId === roomId && this.key.senderKey === senderKey && this.key.sessionId === sessionId;
        }
      }, {
        key: "isBetter",
        value: function isBetter(other) {
          return isBetterThan(this.session, other.session);
        }
      }, {
        key: "isForKey",
        value: function isForKey(key) {
          return this.key.serializationKey === key.serializationKey && this.key.serializationType === key.serializationType;
        }
      }, {
        key: "dispose",
        value: function dispose() {
          this.session.free();
          this.session = void 0;
        }
      }, {
        key: "isBest",
        get: function get() {
          return this.key.isBetter;
        }
      }]);

      return KeyOperation;
    }();

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var SessionBackup = /*#__PURE__*/function () {
      function SessionBackup(_ref) {
        var backupInfo = _ref.backupInfo,
            decryption = _ref.decryption,
            hsApi = _ref.hsApi;

        _classCallCheck(this, SessionBackup);

        this._backupInfo = backupInfo;
        this._decryption = decryption;
        this._hsApi = hsApi;
      }

      _createClass(SessionBackup, [{
        key: "getSession",
        value: function () {
          var _getSession = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(roomId, sessionId, log) {
            var sessionResponse, sessionInfo;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this._hsApi.roomKeyForRoomAndSession(this._backupInfo.version, roomId, sessionId, {
                      log: log
                    }).response();

                  case 2:
                    sessionResponse = _context.sent;
                    sessionInfo = this._decryption.decrypt(sessionResponse.session_data.ephemeral, sessionResponse.session_data.mac, sessionResponse.session_data.ciphertext);
                    return _context.abrupt("return", JSON.parse(sessionInfo));

                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function getSession(_x, _x2, _x3) {
            return _getSession.apply(this, arguments);
          }

          return getSession;
        }()
      }, {
        key: "dispose",
        value: function dispose() {
          this._decryption.free();
        }
      }, {
        key: "version",
        get: function get() {
          return this._backupInfo.version;
        }
      }], [{
        key: "fromSecretStorage",
        value: function () {
          var _fromSecretStorage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref2) {
            var platform, olm, secretStorage, hsApi, txn, base64PrivateKey, privateKey, backupInfo, expectedPubKey, decryption, pubKey;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    platform = _ref2.platform, olm = _ref2.olm, secretStorage = _ref2.secretStorage, hsApi = _ref2.hsApi, txn = _ref2.txn;
                    _context2.next = 3;
                    return secretStorage.readSecret("m.megolm_backup.v1", txn);

                  case 3:
                    base64PrivateKey = _context2.sent;

                    if (!base64PrivateKey) {
                      _context2.next = 22;
                      break;
                    }

                    privateKey = new Uint8Array(platform.encoding.base64.decode(base64PrivateKey));
                    _context2.next = 8;
                    return hsApi.roomKeysVersion().response();

                  case 8:
                    backupInfo = _context2.sent;
                    expectedPubKey = backupInfo.auth_data.public_key;
                    decryption = new olm.PkDecryption();
                    _context2.prev = 11;
                    pubKey = decryption.init_with_private_key(privateKey);

                    if (!(pubKey !== expectedPubKey)) {
                      _context2.next = 15;
                      break;
                    }

                    throw new Error("Bad backup key, public key does not match. Calculated ".concat(pubKey, " but expected ").concat(expectedPubKey));

                  case 15:
                    _context2.next = 21;
                    break;

                  case 17:
                    _context2.prev = 17;
                    _context2.t0 = _context2["catch"](11);
                    decryption.free();
                    throw _context2.t0;

                  case 21:
                    return _context2.abrupt("return", new SessionBackup({
                      backupInfo: backupInfo,
                      decryption: decryption,
                      hsApi: hsApi
                    }));

                  case 22:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, null, [[11, 17]]);
          }));

          function fromSecretStorage(_x4) {
            return _fromSecretStorage.apply(this, arguments);
          }

          return fromSecretStorage;
        }()
      }]);

      return SessionBackup;
    }();

    var Encryption$1 = /*#__PURE__*/function () {
      function Encryption(_ref) {
        var pickleKey = _ref.pickleKey,
            olm = _ref.olm,
            account = _ref.account,
            storage = _ref.storage,
            now = _ref.now,
            ownDeviceId = _ref.ownDeviceId;

        _classCallCheck(this, Encryption);

        this._pickleKey = pickleKey;
        this._olm = olm;
        this._account = account;
        this._storage = storage;
        this._now = now;
        this._ownDeviceId = ownDeviceId;
      }

      _createClass(Encryption, [{
        key: "discardOutboundSession",
        value: function discardOutboundSession(roomId, txn) {
          txn.outboundGroupSessions.remove(roomId);
        }
      }, {
        key: "createRoomKeyMessage",
        value: function () {
          var _createRoomKeyMessage2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(roomId, txn) {
            var sessionEntry, session;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return txn.outboundGroupSessions.get(roomId);

                  case 2:
                    sessionEntry = _context.sent;

                    if (!sessionEntry) {
                      _context.next = 11;
                      break;
                    }

                    session = new this._olm.OutboundGroupSession();
                    _context.prev = 5;
                    session.unpickle(this._pickleKey, sessionEntry.session);
                    return _context.abrupt("return", this._createRoomKeyMessage(session, roomId));

                  case 8:
                    _context.prev = 8;
                    session.free();
                    return _context.finish(8);

                  case 11:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[5,, 8, 11]]);
          }));

          function createRoomKeyMessage(_x, _x2) {
            return _createRoomKeyMessage2.apply(this, arguments);
          }

          return createRoomKeyMessage;
        }()
      }, {
        key: "createWithheldMessage",
        value: function createWithheldMessage(roomMessage, code, reason) {
          return {
            algorithm: roomMessage.algorithm,
            code: code,
            reason: reason,
            room_id: roomMessage.room_id,
            sender_key: this._account.identityKeys.curve25519,
            session_id: roomMessage.session_id
          };
        }
      }, {
        key: "ensureOutboundSession",
        value: function () {
          var _ensureOutboundSession = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(roomId, encryptionParams) {
            var session, txn, roomKeyMessage, sessionEntry;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    session = new this._olm.OutboundGroupSession();
                    _context2.prev = 1;
                    _context2.next = 4;
                    return this._storage.readWriteTxn([this._storage.storeNames.inboundGroupSessions, this._storage.storeNames.outboundGroupSessions]);

                  case 4:
                    txn = _context2.sent;
                    _context2.prev = 5;
                    _context2.next = 8;
                    return txn.outboundGroupSessions.get(roomId);

                  case 8:
                    sessionEntry = _context2.sent;
                    roomKeyMessage = this._readOrCreateSession(session, sessionEntry, roomId, encryptionParams, txn);

                    if (roomKeyMessage) {
                      this._writeSession(this._now(), session, roomId, txn);
                    }

                    _context2.next = 17;
                    break;

                  case 13:
                    _context2.prev = 13;
                    _context2.t0 = _context2["catch"](5);
                    txn.abort();
                    throw _context2.t0;

                  case 17:
                    _context2.next = 19;
                    return txn.complete();

                  case 19:
                    return _context2.abrupt("return", roomKeyMessage);

                  case 20:
                    _context2.prev = 20;
                    session.free();
                    return _context2.finish(20);

                  case 23:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[1,, 20, 23], [5, 13]]);
          }));

          function ensureOutboundSession(_x3, _x4) {
            return _ensureOutboundSession.apply(this, arguments);
          }

          return ensureOutboundSession;
        }()
      }, {
        key: "_readOrCreateSession",
        value: function _readOrCreateSession(session, sessionEntry, roomId, encryptionParams, txn) {
          if (sessionEntry) {
            session.unpickle(this._pickleKey, sessionEntry.session);
          }

          if (!sessionEntry || this._needsToRotate(session, sessionEntry.createdAt, encryptionParams)) {
            // in the case of rotating, recreate a session as we already unpickled into it
            if (sessionEntry) {
              session.free();
              session = new this._olm.OutboundGroupSession();
            }

            session.create();

            var roomKeyMessage = this._createRoomKeyMessage(session, roomId);

            this._storeAsInboundSession(session, roomId, txn);

            return roomKeyMessage;
          }
        }
      }, {
        key: "_writeSession",
        value: function _writeSession(createdAt, session, roomId, txn) {
          txn.outboundGroupSessions.set({
            roomId: roomId,
            session: session.pickle(this._pickleKey),
            createdAt: createdAt
          });
        }
        /**
         * Encrypts a message with megolm
         * @param  {string} roomId           
         * @param  {string} type             event type to encrypt
         * @param  {string} content          content to encrypt
         * @param  {object} encryptionParams the content of the m.room.encryption event
         * @return {Promise<EncryptionResult>}
         */

      }, {
        key: "encrypt",
        value: function () {
          var _encrypt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(roomId, type, content, encryptionParams) {
            var session, txn, roomKeyMessage, encryptedContent, sessionEntry, createdAt;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    session = new this._olm.OutboundGroupSession();
                    _context3.prev = 1;
                    _context3.next = 4;
                    return this._storage.readWriteTxn([this._storage.storeNames.inboundGroupSessions, this._storage.storeNames.outboundGroupSessions]);

                  case 4:
                    txn = _context3.sent;
                    _context3.prev = 5;
                    _context3.next = 8;
                    return txn.outboundGroupSessions.get(roomId);

                  case 8:
                    sessionEntry = _context3.sent;
                    roomKeyMessage = this._readOrCreateSession(session, sessionEntry, roomId, encryptionParams, txn);
                    encryptedContent = this._encryptContent(roomId, session, type, content); // update timestamp when a new session is created

                    createdAt = roomKeyMessage ? this._now() : sessionEntry.createdAt;

                    this._writeSession(createdAt, session, roomId, txn);

                    _context3.next = 19;
                    break;

                  case 15:
                    _context3.prev = 15;
                    _context3.t0 = _context3["catch"](5);
                    txn.abort();
                    throw _context3.t0;

                  case 19:
                    _context3.next = 21;
                    return txn.complete();

                  case 21:
                    return _context3.abrupt("return", new EncryptionResult(encryptedContent, roomKeyMessage));

                  case 22:
                    _context3.prev = 22;

                    if (session) {
                      session.free();
                    }

                    return _context3.finish(22);

                  case 25:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[1,, 22, 25], [5, 15]]);
          }));

          function encrypt(_x5, _x6, _x7, _x8) {
            return _encrypt.apply(this, arguments);
          }

          return encrypt;
        }()
      }, {
        key: "_needsToRotate",
        value: function _needsToRotate(session, createdAt, encryptionParams) {
          var rotationPeriodMs = 604800000; // default

          if (Number.isSafeInteger(encryptionParams === null || encryptionParams === void 0 ? void 0 : encryptionParams.rotation_period_ms)) {
            rotationPeriodMs = encryptionParams === null || encryptionParams === void 0 ? void 0 : encryptionParams.rotation_period_ms;
          }

          var rotationPeriodMsgs = 100; // default

          if (Number.isSafeInteger(encryptionParams === null || encryptionParams === void 0 ? void 0 : encryptionParams.rotation_period_msgs)) {
            rotationPeriodMsgs = encryptionParams === null || encryptionParams === void 0 ? void 0 : encryptionParams.rotation_period_msgs;
          }

          if (this._now() > createdAt + rotationPeriodMs) {
            return true;
          }

          if (session.message_index() >= rotationPeriodMsgs) {
            return true;
          }
        }
      }, {
        key: "_encryptContent",
        value: function _encryptContent(roomId, session, type, content) {
          var plaintext = JSON.stringify({
            room_id: roomId,
            type: type,
            content: content
          });
          var ciphertext = session.encrypt(plaintext);
          var encryptedContent = {
            algorithm: MEGOLM_ALGORITHM,
            sender_key: this._account.identityKeys.curve25519,
            ciphertext: ciphertext,
            session_id: session.session_id(),
            device_id: this._ownDeviceId
          };
          return encryptedContent;
        }
      }, {
        key: "_createRoomKeyMessage",
        value: function _createRoomKeyMessage(session, roomId) {
          return {
            room_id: roomId,
            session_id: session.session_id(),
            session_key: session.session_key(),
            algorithm: MEGOLM_ALGORITHM,
            // chain_index is ignored by element-web if not all clients
            // but let's send it anyway, as element-web does so
            chain_index: session.message_index()
          };
        }
      }, {
        key: "_storeAsInboundSession",
        value: function _storeAsInboundSession(outboundSession, roomId, txn) {
          var identityKeys = this._account.identityKeys;
          var claimedKeys = {
            ed25519: identityKeys.ed25519
          };
          var session = new this._olm.InboundGroupSession();

          try {
            session.create(outboundSession.session_key());
            var sessionEntry = {
              roomId: roomId,
              senderKey: identityKeys.curve25519,
              sessionId: session.session_id(),
              session: session.pickle(this._pickleKey),
              claimedKeys: claimedKeys
            };
            txn.inboundGroupSessions.set(sessionEntry);
            return sessionEntry;
          } finally {
            session.free();
          }
        }
      }]);

      return Encryption;
    }();
    /**
     * @property {object?} roomKeyMessage  if encrypting this message
     *                                     created a new outbound session,
     *                                     this contains the content of the m.room_key message
     *                                     that should be sent out over olm.
     * @property {object} content  the encrypted message as the content of
     *                             the m.room.encrypted event that should be sent out   
     */

    var EncryptionResult = function EncryptionResult(content, roomKeyMessage) {
      _classCallCheck(this, EncryptionResult);

      this.content = content;
      this.roomKeyMessage = roomKeyMessage;
    };

    var ENCRYPTED_TYPE = "m.room.encrypted"; // how often ensureMessageKeyIsShared can check if it needs to
    // create a new outbound session
    // note that encrypt could still create a new session

    var MIN_PRESHARE_INTERVAL = 60 * 1000; // 1min
    // TODO: this class is a good candidate for splitting up into encryption and decryption, there doesn't seem to be much overlap

    var RoomEncryption = /*#__PURE__*/function () {
      function RoomEncryption(_ref) {
        var room = _ref.room,
            deviceTracker = _ref.deviceTracker,
            olmEncryption = _ref.olmEncryption,
            megolmEncryption = _ref.megolmEncryption,
            megolmDecryption = _ref.megolmDecryption,
            encryptionParams = _ref.encryptionParams,
            storage = _ref.storage,
            sessionBackup = _ref.sessionBackup,
            notifyMissingMegolmSession = _ref.notifyMissingMegolmSession,
            clock = _ref.clock;

        _classCallCheck(this, RoomEncryption);

        this._room = room;
        this._deviceTracker = deviceTracker;
        this._olmEncryption = olmEncryption;
        this._megolmEncryption = megolmEncryption;
        this._megolmDecryption = megolmDecryption; // content of the m.room.encryption event

        this._encryptionParams = encryptionParams; // caches devices to verify events

        this._senderDeviceCache = new Map();
        this._storage = storage;
        this._sessionBackup = sessionBackup;
        this._notifyMissingMegolmSession = notifyMissingMegolmSession;
        this._clock = clock;
        this._isFlushingRoomKeyShares = false;
        this._lastKeyPreShareTime = null;
        this._keySharePromise = null;
        this._disposed = false;
      }

      _createClass(RoomEncryption, [{
        key: "enableSessionBackup",
        value: function enableSessionBackup(sessionBackup) {
          if (this._sessionBackup && !!sessionBackup) {
            return;
          }

          this._sessionBackup = sessionBackup;
        }
      }, {
        key: "restoreMissingSessionsFromBackup",
        value: function () {
          var _restoreMissingSessionsFromBackup = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(entries, log) {
            var _this = this;

            var events, eventsBySession, groups, txn, hasSessions, missingSessions, _loop, i;

            return regeneratorRuntime.wrap(function _callee2$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    events = entries.filter(function (e) {
                      return e.isEncrypted && !e.isDecrypted && e.event;
                    }).map(function (e) {
                      return e.event;
                    });
                    eventsBySession = groupEventsBySession(events);
                    groups = Array.from(eventsBySession.values());
                    _context3.next = 5;
                    return this._storage.readTxn([this._storage.storeNames.inboundGroupSessions]);

                  case 5:
                    txn = _context3.sent;
                    _context3.next = 8;
                    return Promise.all(groups.map( /*#__PURE__*/function () {
                      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(group) {
                        return regeneratorRuntime.wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                return _context.abrupt("return", _this._megolmDecryption.hasSession(_this._room.id, group.senderKey, group.sessionId, txn));

                              case 1:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee);
                      }));

                      return function (_x3) {
                        return _ref2.apply(this, arguments);
                      };
                    }()));

                  case 8:
                    hasSessions = _context3.sent;
                    missingSessions = groups.filter(function (_, i) {
                      return !hasSessions[i];
                    });

                    if (!missingSessions.length) {
                      _context3.next = 18;
                      break;
                    }

                    _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop() {
                      var session;
                      return regeneratorRuntime.wrap(function _loop$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              session = missingSessions[i];
                              _context2.next = 3;
                              return log.wrap("session", function (log) {
                                return _this._requestMissingSessionFromBackup(session.senderKey, session.sessionId, log);
                              });

                            case 3:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _loop);
                    });
                    i = missingSessions.length - 1;

                  case 13:
                    if (!(i >= 0)) {
                      _context3.next = 18;
                      break;
                    }

                    return _context3.delegateYield(_loop(), "t0", 15);

                  case 15:
                    i--;
                    _context3.next = 13;
                    break;

                  case 18:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee2, this);
          }));

          function restoreMissingSessionsFromBackup(_x, _x2) {
            return _restoreMissingSessionsFromBackup.apply(this, arguments);
          }

          return restoreMissingSessionsFromBackup;
        }()
      }, {
        key: "notifyTimelineClosed",
        value: function notifyTimelineClosed() {
          this._senderDeviceCache = new Map(); // purge the sender device cache
        }
      }, {
        key: "writeMemberChanges",
        value: function () {
          var _writeMemberChanges = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(memberChanges, txn, log) {
            var shouldFlush, memberChangesArray;
            return regeneratorRuntime.wrap(function _callee3$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    shouldFlush = false;
                    memberChangesArray = Array.from(memberChanges.values()); // this also clears our session if we leave the room ourselves

                    if (memberChangesArray.some(function (m) {
                      return m.hasLeft;
                    })) {
                      log.log({
                        l: "discardOutboundSession",
                        leftUsers: memberChangesArray.filter(function (m) {
                          return m.hasLeft;
                        }).map(function (m) {
                          return m.userId;
                        })
                      });

                      this._megolmEncryption.discardOutboundSession(this._room.id, txn);
                    }

                    if (!memberChangesArray.some(function (m) {
                      return m.hasJoined;
                    })) {
                      _context4.next = 7;
                      break;
                    }

                    _context4.next = 6;
                    return this._addShareRoomKeyOperationForNewMembers(memberChangesArray, txn, log);

                  case 6:
                    shouldFlush = _context4.sent;

                  case 7:
                    _context4.next = 9;
                    return this._deviceTracker.writeMemberChanges(this._room, memberChanges, txn);

                  case 9:
                    return _context4.abrupt("return", shouldFlush);

                  case 10:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee3, this);
          }));

          function writeMemberChanges(_x4, _x5, _x6) {
            return _writeMemberChanges.apply(this, arguments);
          }

          return writeMemberChanges;
        }()
      }, {
        key: "prepareDecryptAll",
        value: function () {
          var _prepareDecryptAll = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(events, newKeys, source, txn) {
            var errors, validEvents, _iterator, _step, _event$unsigned, _event$content, event, _event$content2, preparation;

            return regeneratorRuntime.wrap(function _callee4$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    errors = new Map();
                    validEvents = [];
                    _iterator = _createForOfIteratorHelper(events);
                    _context5.prev = 3;

                    _iterator.s();

                  case 5:
                    if ((_step = _iterator.n()).done) {
                      _context5.next = 13;
                      break;
                    }

                    event = _step.value;

                    if (!(event.redacted_because || ((_event$unsigned = event.unsigned) === null || _event$unsigned === void 0 ? void 0 : _event$unsigned.redacted_because))) {
                      _context5.next = 9;
                      break;
                    }

                    return _context5.abrupt("continue", 11);

                  case 9:
                    if (((_event$content = event.content) === null || _event$content === void 0 ? void 0 : _event$content.algorithm) !== MEGOLM_ALGORITHM) {
                      errors.set(event.event_id, new Error("Unsupported algorithm: " + ((_event$content2 = event.content) === null || _event$content2 === void 0 ? void 0 : _event$content2.algorithm)));
                    }

                    validEvents.push(event);

                  case 11:
                    _context5.next = 5;
                    break;

                  case 13:
                    _context5.next = 18;
                    break;

                  case 15:
                    _context5.prev = 15;
                    _context5.t0 = _context5["catch"](3);

                    _iterator.e(_context5.t0);

                  case 18:
                    _context5.prev = 18;

                    _iterator.f();

                    return _context5.finish(18);

                  case 21:
                    _context5.next = 23;
                    return this._megolmDecryption.prepareDecryptAll(this._room.id, validEvents, newKeys, txn);

                  case 23:
                    preparation = _context5.sent;
                    return _context5.abrupt("return", new DecryptionPreparation$1(preparation, errors, source, this, events));

                  case 25:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee4, this, [[3, 15, 18, 21]]);
          }));

          function prepareDecryptAll(_x7, _x8, _x9, _x10) {
            return _prepareDecryptAll.apply(this, arguments);
          }

          return prepareDecryptAll;
        }()
      }, {
        key: "_processDecryptionResults",
        value: function () {
          var _processDecryptionResults2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(events, results, errors, source, txn, log) {
            var _this2 = this;

            var missingSessionEvents, missingEventsBySession;
            return regeneratorRuntime.wrap(function _callee8$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    missingSessionEvents = events.filter(function (event) {
                      var error = errors.get(event.event_id);
                      return (error === null || error === void 0 ? void 0 : error.code) === "MEGOLM_NO_SESSION";
                    });

                    if (missingSessionEvents.length) {
                      _context9.next = 3;
                      break;
                    }

                    return _context9.abrupt("return");

                  case 3:
                    // store missing event ids if received from sync
                    missingEventsBySession = groupEventsBySession(missingSessionEvents);

                    if (!(source === DecryptionSource.Sync)) {
                      _context9.next = 7;
                      break;
                    }

                    _context9.next = 7;
                    return Promise.all(Array.from(missingEventsBySession.values()).map( /*#__PURE__*/function () {
                      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(group) {
                        var eventIds;
                        return regeneratorRuntime.wrap(function _callee5$(_context6) {
                          while (1) {
                            switch (_context6.prev = _context6.next) {
                              case 0:
                                eventIds = group.events.map(function (e) {
                                  return e.event_id;
                                });
                                return _context6.abrupt("return", _this2._megolmDecryption.addMissingKeyEventIds(_this2._room.id, group.senderKey, group.sessionId, eventIds, txn));

                              case 2:
                              case "end":
                                return _context6.stop();
                            }
                          }
                        }, _callee5);
                      }));

                      return function (_x17) {
                        return _ref3.apply(this, arguments);
                      };
                    }()));

                  case 7:
                    if (this._sessionBackup) {
                      _context9.next = 9;
                      break;
                    }

                    return _context9.abrupt("return");

                  case 9:
                    log.wrapDetached("check key backup", /*#__PURE__*/function () {
                      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(log) {
                        var _txn;

                        return regeneratorRuntime.wrap(function _callee7$(_context8) {
                          while (1) {
                            switch (_context8.prev = _context8.next) {
                              case 0:
                                // if the message came from sync, wait 10s to see if the room key arrives late,
                                // and only after that proceed to request from backup
                                log.set("source", source);
                                log.set("events", missingSessionEvents.length);
                                log.set("sessions", missingEventsBySession.size);

                                if (!(source === DecryptionSource.Sync)) {
                                  _context8.next = 13;
                                  break;
                                }

                                _context8.next = 6;
                                return _this2._clock.createTimeout(10000).elapsed();

                              case 6:
                                if (!_this2._disposed) {
                                  _context8.next = 8;
                                  break;
                                }

                                return _context8.abrupt("return");

                              case 8:
                                _context8.next = 10;
                                return _this2._storage.readTxn([_this2._storage.storeNames.inboundGroupSessions]);

                              case 10:
                                _txn = _context8.sent;
                                _context8.next = 13;
                                return Promise.all(Array.from(missingEventsBySession).map( /*#__PURE__*/function () {
                                  var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref5) {
                                    var _ref7, key, group;

                                    return regeneratorRuntime.wrap(function _callee6$(_context7) {
                                      while (1) {
                                        switch (_context7.prev = _context7.next) {
                                          case 0:
                                            _ref7 = _slicedToArray(_ref5, 2), key = _ref7[0], group = _ref7[1];
                                            _context7.next = 3;
                                            return _this2._megolmDecryption.hasSession(_this2._room.id, group.senderKey, group.sessionId, _txn);

                                          case 3:
                                            if (!_context7.sent) {
                                              _context7.next = 5;
                                              break;
                                            }

                                            missingEventsBySession.delete(key);

                                          case 5:
                                          case "end":
                                            return _context7.stop();
                                        }
                                      }
                                    }, _callee6);
                                  }));

                                  return function (_x19) {
                                    return _ref6.apply(this, arguments);
                                  };
                                }()));

                              case 13:
                                _context8.next = 15;
                                return Promise.all(Array.from(missingEventsBySession.values()).map(function (group) {
                                  return log.wrap("session", function (log) {
                                    return _this2._requestMissingSessionFromBackup(group.senderKey, group.sessionId, log);
                                  });
                                }));

                              case 15:
                              case "end":
                                return _context8.stop();
                            }
                          }
                        }, _callee7);
                      }));

                      return function (_x18) {
                        return _ref4.apply(this, arguments);
                      };
                    }());

                  case 10:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee8, this);
          }));

          function _processDecryptionResults(_x11, _x12, _x13, _x14, _x15, _x16) {
            return _processDecryptionResults2.apply(this, arguments);
          }

          return _processDecryptionResults;
        }()
      }, {
        key: "_verifyDecryptionResult",
        value: function () {
          var _verifyDecryptionResult2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(result, txn) {
            var device;
            return regeneratorRuntime.wrap(function _callee9$(_context10) {
              while (1) {
                switch (_context10.prev = _context10.next) {
                  case 0:
                    device = this._senderDeviceCache.get(result.senderCurve25519Key);

                    if (device) {
                      _context10.next = 6;
                      break;
                    }

                    _context10.next = 4;
                    return this._deviceTracker.getDeviceByCurve25519Key(result.senderCurve25519Key, txn);

                  case 4:
                    device = _context10.sent;

                    this._senderDeviceCache.set(result.senderCurve25519Key, device);

                  case 6:
                    if (device) {
                      result.setDevice(device);
                    } else if (!this._room.isTrackingMembers) {
                      result.setRoomNotTrackedYet();
                    }

                  case 7:
                  case "end":
                    return _context10.stop();
                }
              }
            }, _callee9, this);
          }));

          function _verifyDecryptionResult(_x20, _x21) {
            return _verifyDecryptionResult2.apply(this, arguments);
          }

          return _verifyDecryptionResult;
        }()
      }, {
        key: "_requestMissingSessionFromBackup",
        value: function () {
          var _requestMissingSessionFromBackup2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(senderKey, sessionId, log) {
            var _this3 = this;

            var session, roomKey, keyIsBestOne, retryEventIds, txn;
            return regeneratorRuntime.wrap(function _callee10$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    if (this._sessionBackup) {
                      _context11.next = 4;
                      break;
                    }

                    log.set("enabled", false);

                    this._notifyMissingMegolmSession();

                    return _context11.abrupt("return");

                  case 4:
                    log.set("id", sessionId);
                    log.set("senderKey", senderKey);
                    _context11.prev = 6;
                    _context11.next = 9;
                    return this._sessionBackup.getSession(this._room.id, sessionId, log);

                  case 9:
                    session = _context11.sent;

                    if (!((session === null || session === void 0 ? void 0 : session.algorithm) === MEGOLM_ALGORITHM)) {
                      _context11.next = 40;
                      break;
                    }

                    roomKey = this._megolmDecryption.roomKeyFromBackup(this._room.id, sessionId, session);

                    if (!roomKey) {
                      _context11.next = 38;
                      break;
                    }

                    if (!(roomKey.senderKey !== senderKey)) {
                      _context11.next = 17;
                      break;
                    }

                    log.set("wrong_sender_key", roomKey.senderKey);
                    log.logLevel = log.level.Warn;
                    return _context11.abrupt("return");

                  case 17:
                    keyIsBestOne = false;
                    _context11.next = 20;
                    return this._storage.readWriteTxn([this._storage.storeNames.inboundGroupSessions]);

                  case 20:
                    txn = _context11.sent;
                    _context11.prev = 21;
                    _context11.next = 24;
                    return this._megolmDecryption.writeRoomKey(roomKey, txn);

                  case 24:
                    keyIsBestOne = _context11.sent;
                    log.set("isBetter", keyIsBestOne);

                    if (keyIsBestOne) {
                      retryEventIds = roomKey.eventIds;
                    }

                    _context11.next = 33;
                    break;

                  case 29:
                    _context11.prev = 29;
                    _context11.t0 = _context11["catch"](21);
                    txn.abort();
                    throw _context11.t0;

                  case 33:
                    _context11.next = 35;
                    return txn.complete();

                  case 35:
                    if (!keyIsBestOne) {
                      _context11.next = 38;
                      break;
                    }

                    _context11.next = 38;
                    return log.wrap("retryDecryption", function (log) {
                      return _this3._room.notifyRoomKey(roomKey, retryEventIds || [], log);
                    });

                  case 38:
                    _context11.next = 41;
                    break;

                  case 40:
                    if (session === null || session === void 0 ? void 0 : session.algorithm) {
                      log.set("unknown algorithm", session.algorithm);
                    }

                  case 41:
                    _context11.next = 46;
                    break;

                  case 43:
                    _context11.prev = 43;
                    _context11.t1 = _context11["catch"](6);

                    if (!(_context11.t1.name === "HomeServerError" && _context11.t1.errcode === "M_NOT_FOUND")) {
                      log.set("not_found", true);
                    } else {
                      log.error = _context11.t1;
                      log.logLevel = log.level.Error;
                    }

                  case 46:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee10, this, [[6, 43], [21, 29]]);
          }));

          function _requestMissingSessionFromBackup(_x22, _x23, _x24) {
            return _requestMissingSessionFromBackup2.apply(this, arguments);
          }

          return _requestMissingSessionFromBackup;
        }()
        /**
         * @param  {RoomKey} roomKeys
         * @param {Transaction} txn
         * @return {Promise<Array<string>>} the event ids that should be retried to decrypt
         */

      }, {
        key: "getEventIdsForMissingKey",
        value: function getEventIdsForMissingKey(roomKey, txn) {
          return this._megolmDecryption.getEventIdsForMissingKey(this._room.id, roomKey.senderKey, roomKey.sessionId, txn);
        }
        /** shares the encryption key for the next message if needed */

      }, {
        key: "ensureMessageKeyIsShared",
        value: function () {
          var _ensureMessageKeyIsShared = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(hsApi, log) {
            var _this$_lastKeyPreShar,
                _this4 = this;

            return regeneratorRuntime.wrap(function _callee12$(_context13) {
              while (1) {
                switch (_context13.prev = _context13.next) {
                  case 0:
                    if (!(((_this$_lastKeyPreShar = this._lastKeyPreShareTime) === null || _this$_lastKeyPreShar === void 0 ? void 0 : _this$_lastKeyPreShar.measure()) < MIN_PRESHARE_INTERVAL)) {
                      _context13.next = 2;
                      break;
                    }

                    return _context13.abrupt("return");

                  case 2:
                    this._lastKeyPreShareTime = this._clock.createMeasure();
                    _context13.prev = 3;
                    this._keySharePromise = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
                      var roomKeyMessage;
                      return regeneratorRuntime.wrap(function _callee11$(_context12) {
                        while (1) {
                          switch (_context12.prev = _context12.next) {
                            case 0:
                              _context12.next = 2;
                              return _this4._megolmEncryption.ensureOutboundSession(_this4._room.id, _this4._encryptionParams);

                            case 2:
                              roomKeyMessage = _context12.sent;

                              if (!roomKeyMessage) {
                                _context12.next = 6;
                                break;
                              }

                              _context12.next = 6;
                              return log.wrap("share key", function (log) {
                                return _this4._shareNewRoomKey(roomKeyMessage, hsApi, log);
                              });

                            case 6:
                            case "end":
                              return _context12.stop();
                          }
                        }
                      }, _callee11);
                    }))();
                    _context13.next = 7;
                    return this._keySharePromise;

                  case 7:
                    _context13.prev = 7;
                    this._keySharePromise = null;
                    return _context13.finish(7);

                  case 10:
                  case "end":
                    return _context13.stop();
                }
              }
            }, _callee12, this, [[3,, 7, 10]]);
          }));

          function ensureMessageKeyIsShared(_x25, _x26) {
            return _ensureMessageKeyIsShared.apply(this, arguments);
          }

          return ensureMessageKeyIsShared;
        }()
      }, {
        key: "encrypt",
        value: function () {
          var _encrypt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(type, content, hsApi, log) {
            var _this5 = this;

            var megolmResult;
            return regeneratorRuntime.wrap(function _callee13$(_context14) {
              while (1) {
                switch (_context14.prev = _context14.next) {
                  case 0:
                    if (!this._keySharePromise) {
                      _context14.next = 4;
                      break;
                    }

                    log.set("waitForRunningKeyShare", true);
                    _context14.next = 4;
                    return this._keySharePromise;

                  case 4:
                    _context14.next = 6;
                    return log.wrap("megolm encrypt", function () {
                      return _this5._megolmEncryption.encrypt(_this5._room.id, type, content, _this5._encryptionParams);
                    });

                  case 6:
                    megolmResult = _context14.sent;

                    if (!megolmResult.roomKeyMessage) {
                      _context14.next = 10;
                      break;
                    }

                    _context14.next = 10;
                    return log.wrap("share key", function (log) {
                      return _this5._shareNewRoomKey(megolmResult.roomKeyMessage, hsApi, log);
                    });

                  case 10:
                    return _context14.abrupt("return", {
                      type: ENCRYPTED_TYPE,
                      content: megolmResult.content
                    });

                  case 11:
                  case "end":
                    return _context14.stop();
                }
              }
            }, _callee13, this);
          }));

          function encrypt(_x27, _x28, _x29, _x30) {
            return _encrypt.apply(this, arguments);
          }

          return encrypt;
        }()
      }, {
        key: "needsToShareKeys",
        value: function needsToShareKeys(memberChanges) {
          var _iterator2 = _createForOfIteratorHelper(memberChanges.values()),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var m = _step2.value;

              if (m.hasJoined) {
                return true;
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          return false;
        }
      }, {
        key: "_shareNewRoomKey",
        value: function () {
          var _shareNewRoomKey2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(roomKeyMessage, hsApi, log) {
            var writeOpTxn, operation;
            return regeneratorRuntime.wrap(function _callee14$(_context15) {
              while (1) {
                switch (_context15.prev = _context15.next) {
                  case 0:
                    _context15.next = 2;
                    return this._storage.readWriteTxn([this._storage.storeNames.operations]);

                  case 2:
                    writeOpTxn = _context15.sent;
                    _context15.prev = 3;
                    operation = this._writeRoomKeyShareOperation(roomKeyMessage, null, writeOpTxn);
                    _context15.next = 11;
                    break;

                  case 7:
                    _context15.prev = 7;
                    _context15.t0 = _context15["catch"](3);
                    writeOpTxn.abort();
                    throw _context15.t0;

                  case 11:
                    _context15.next = 13;
                    return this._processShareRoomKeyOperation(operation, hsApi, log);

                  case 13:
                  case "end":
                    return _context15.stop();
                }
              }
            }, _callee14, this, [[3, 7]]);
          }));

          function _shareNewRoomKey(_x31, _x32, _x33) {
            return _shareNewRoomKey2.apply(this, arguments);
          }

          return _shareNewRoomKey;
        }()
      }, {
        key: "_addShareRoomKeyOperationForNewMembers",
        value: function () {
          var _addShareRoomKeyOperationForNewMembers2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(memberChangesArray, txn, log) {
            var userIds, roomKeyMessage;
            return regeneratorRuntime.wrap(function _callee15$(_context16) {
              while (1) {
                switch (_context16.prev = _context16.next) {
                  case 0:
                    userIds = memberChangesArray.filter(function (m) {
                      return m.hasJoined;
                    }).map(function (m) {
                      return m.userId;
                    });
                    _context16.next = 3;
                    return this._megolmEncryption.createRoomKeyMessage(this._room.id, txn);

                  case 3:
                    roomKeyMessage = _context16.sent;

                    if (!roomKeyMessage) {
                      _context16.next = 8;
                      break;
                    }

                    log.log({
                      l: "share key for new members",
                      userIds: userIds,
                      id: roomKeyMessage.session_id,
                      chain_index: roomKeyMessage.chain_index
                    });

                    this._writeRoomKeyShareOperation(roomKeyMessage, userIds, txn);

                    return _context16.abrupt("return", true);

                  case 8:
                    return _context16.abrupt("return", false);

                  case 9:
                  case "end":
                    return _context16.stop();
                }
              }
            }, _callee15, this);
          }));

          function _addShareRoomKeyOperationForNewMembers(_x34, _x35, _x36) {
            return _addShareRoomKeyOperationForNewMembers2.apply(this, arguments);
          }

          return _addShareRoomKeyOperationForNewMembers;
        }()
      }, {
        key: "flushPendingRoomKeyShares",
        value: function () {
          var _flushPendingRoomKeyShares = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(hsApi, operations, log) {
            var _this6 = this;

            var txn, _iterator3, _step3, _loop2, _ret;

            return regeneratorRuntime.wrap(function _callee16$(_context18) {
              while (1) {
                switch (_context18.prev = _context18.next) {
                  case 0:
                    if (!this._isFlushingRoomKeyShares) {
                      _context18.next = 2;
                      break;
                    }

                    return _context18.abrupt("return");

                  case 2:
                    this._isFlushingRoomKeyShares = true;
                    _context18.prev = 3;

                    if (operations) {
                      _context18.next = 11;
                      break;
                    }

                    _context18.next = 7;
                    return this._storage.readTxn([this._storage.storeNames.operations]);

                  case 7:
                    txn = _context18.sent;
                    _context18.next = 10;
                    return txn.operations.getAllByTypeAndScope("share_room_key", this._room.id);

                  case 10:
                    operations = _context18.sent;

                  case 11:
                    _iterator3 = _createForOfIteratorHelper(operations);
                    _context18.prev = 12;
                    _loop2 = /*#__PURE__*/regeneratorRuntime.mark(function _loop2() {
                      var operation;
                      return regeneratorRuntime.wrap(function _loop2$(_context17) {
                        while (1) {
                          switch (_context17.prev = _context17.next) {
                            case 0:
                              operation = _step3.value;

                              if (!(operation.type !== "share_room_key")) {
                                _context17.next = 3;
                                break;
                              }

                              return _context17.abrupt("return", "continue");

                            case 3:
                              _context17.next = 5;
                              return log.wrap("operation", function (log) {
                                return _this6._processShareRoomKeyOperation(operation, hsApi, log);
                              });

                            case 5:
                            case "end":
                              return _context17.stop();
                          }
                        }
                      }, _loop2);
                    });

                    _iterator3.s();

                  case 15:
                    if ((_step3 = _iterator3.n()).done) {
                      _context18.next = 22;
                      break;
                    }

                    return _context18.delegateYield(_loop2(), "t0", 17);

                  case 17:
                    _ret = _context18.t0;

                    if (!(_ret === "continue")) {
                      _context18.next = 20;
                      break;
                    }

                    return _context18.abrupt("continue", 20);

                  case 20:
                    _context18.next = 15;
                    break;

                  case 22:
                    _context18.next = 27;
                    break;

                  case 24:
                    _context18.prev = 24;
                    _context18.t1 = _context18["catch"](12);

                    _iterator3.e(_context18.t1);

                  case 27:
                    _context18.prev = 27;

                    _iterator3.f();

                    return _context18.finish(27);

                  case 30:
                    _context18.prev = 30;
                    this._isFlushingRoomKeyShares = false;
                    return _context18.finish(30);

                  case 33:
                  case "end":
                    return _context18.stop();
                }
              }
            }, _callee16, this, [[3,, 30, 33], [12, 24, 27, 30]]);
          }));

          function flushPendingRoomKeyShares(_x37, _x38, _x39) {
            return _flushPendingRoomKeyShares.apply(this, arguments);
          }

          return flushPendingRoomKeyShares;
        }()
      }, {
        key: "_writeRoomKeyShareOperation",
        value: function _writeRoomKeyShareOperation(roomKeyMessage, userIds, txn) {
          var id = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString();
          var operation = {
            id: id,
            type: "share_room_key",
            scope: this._room.id,
            userIds: userIds,
            roomKeyMessage: roomKeyMessage
          };
          txn.operations.add(operation);
          return operation;
        }
      }, {
        key: "_processShareRoomKeyOperation",
        value: function () {
          var _processShareRoomKeyOperation2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(operation, hsApi, log) {
            var _this7 = this;

            var devices, userIds, messages, missingDevices;
            return regeneratorRuntime.wrap(function _callee18$(_context20) {
              while (1) {
                switch (_context20.prev = _context20.next) {
                  case 0:
                    log.set("id", operation.id);
                    _context20.next = 3;
                    return this._deviceTracker.trackRoom(this._room, log);

                  case 3:
                    if (!(operation.userIds === null)) {
                      _context20.next = 13;
                      break;
                    }

                    _context20.next = 6;
                    return this._deviceTracker.devicesForTrackedRoom(this._room.id, hsApi, log);

                  case 6:
                    devices = _context20.sent;
                    userIds = Array.from(devices.reduce(function (set, device) {
                      return set.add(device.userId);
                    }, new Set()));
                    operation.userIds = userIds;
                    _context20.next = 11;
                    return this._updateOperationsStore(function (operations) {
                      return operations.update(operation);
                    });

                  case 11:
                    _context20.next = 16;
                    break;

                  case 13:
                    _context20.next = 15;
                    return this._deviceTracker.devicesForRoomMembers(this._room.id, operation.userIds, hsApi, log);

                  case 15:
                    devices = _context20.sent;

                  case 16:
                    _context20.next = 18;
                    return log.wrap("olm encrypt", function (log) {
                      return _this7._olmEncryption.encrypt("m.room_key", operation.roomKeyMessage, devices, hsApi, log);
                    });

                  case 18:
                    messages = _context20.sent;
                    missingDevices = devices.filter(function (d) {
                      return !messages.some(function (m) {
                        return m.device === d;
                      });
                    });
                    _context20.next = 22;
                    return log.wrap("send", function (log) {
                      return _this7._sendMessagesToDevices(ENCRYPTED_TYPE, messages, hsApi, log);
                    });

                  case 22:
                    if (!missingDevices.length) {
                      _context20.next = 25;
                      break;
                    }

                    _context20.next = 25;
                    return log.wrap("missingDevices", /*#__PURE__*/function () {
                      var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(log) {
                        var unsentUserIds, withheldMessage;
                        return regeneratorRuntime.wrap(function _callee17$(_context19) {
                          while (1) {
                            switch (_context19.prev = _context19.next) {
                              case 0:
                                log.set("devices", missingDevices.map(function (d) {
                                  return d.deviceId;
                                }));
                                unsentUserIds = operation.userIds.filter(function (userId) {
                                  return missingDevices.some(function (d) {
                                    return d.userId === userId;
                                  });
                                });
                                log.set("unsentUserIds", unsentUserIds);
                                operation.userIds = unsentUserIds; // first remove the users that we've sent the keys already from the operation,
                                // so if anything fails, we don't send them again

                                _context19.next = 6;
                                return _this7._updateOperationsStore(function (operations) {
                                  return operations.update(operation);
                                });

                              case 6:
                                // now, let the devices we could not claim their key
                                withheldMessage = _this7._megolmEncryption.createWithheldMessage(operation.roomKeyMessage, "m.no_olm", "OTKs exhausted");
                                _context19.next = 9;
                                return _this7._sendSharedMessageToDevices("org.matrix.room_key.withheld", withheldMessage, missingDevices, hsApi, log);

                              case 9:
                              case "end":
                                return _context19.stop();
                            }
                          }
                        }, _callee17);
                      }));

                      return function (_x43) {
                        return _ref9.apply(this, arguments);
                      };
                    }());

                  case 25:
                    _context20.next = 27;
                    return this._updateOperationsStore(function (operations) {
                      return operations.remove(operation.id);
                    });

                  case 27:
                  case "end":
                    return _context20.stop();
                }
              }
            }, _callee18, this);
          }));

          function _processShareRoomKeyOperation(_x40, _x41, _x42) {
            return _processShareRoomKeyOperation2.apply(this, arguments);
          }

          return _processShareRoomKeyOperation;
        }()
      }, {
        key: "_updateOperationsStore",
        value: function () {
          var _updateOperationsStore2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(callback) {
            var writeTxn;
            return regeneratorRuntime.wrap(function _callee19$(_context21) {
              while (1) {
                switch (_context21.prev = _context21.next) {
                  case 0:
                    _context21.next = 2;
                    return this._storage.readWriteTxn([this._storage.storeNames.operations]);

                  case 2:
                    writeTxn = _context21.sent;
                    _context21.prev = 3;
                    callback(writeTxn.operations);
                    _context21.next = 11;
                    break;

                  case 7:
                    _context21.prev = 7;
                    _context21.t0 = _context21["catch"](3);
                    writeTxn.abort();
                    throw _context21.t0;

                  case 11:
                    _context21.next = 13;
                    return writeTxn.complete();

                  case 13:
                  case "end":
                    return _context21.stop();
                }
              }
            }, _callee19, this, [[3, 7]]);
          }));

          function _updateOperationsStore(_x44) {
            return _updateOperationsStore2.apply(this, arguments);
          }

          return _updateOperationsStore;
        }()
      }, {
        key: "_sendSharedMessageToDevices",
        value: function () {
          var _sendSharedMessageToDevices2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(type, message, devices, hsApi, log) {
            var devicesByUser, payload, txnId;
            return regeneratorRuntime.wrap(function _callee20$(_context22) {
              while (1) {
                switch (_context22.prev = _context22.next) {
                  case 0:
                    devicesByUser = groupBy(devices, function (device) {
                      return device.userId;
                    });
                    payload = {
                      messages: Array.from(devicesByUser.entries()).reduce(function (userMap, _ref10) {
                        var _ref11 = _slicedToArray(_ref10, 2),
                            userId = _ref11[0],
                            devices = _ref11[1];

                        userMap[userId] = devices.reduce(function (deviceMap, device) {
                          deviceMap[device.deviceId] = message;
                          return deviceMap;
                        }, {});
                        return userMap;
                      }, {})
                    };
                    txnId = makeTxnId();
                    _context22.next = 5;
                    return hsApi.sendToDevice(type, payload, txnId, {
                      log: log
                    }).response();

                  case 5:
                  case "end":
                    return _context22.stop();
                }
              }
            }, _callee20);
          }));

          function _sendSharedMessageToDevices(_x45, _x46, _x47, _x48, _x49) {
            return _sendSharedMessageToDevices2.apply(this, arguments);
          }

          return _sendSharedMessageToDevices;
        }()
      }, {
        key: "_sendMessagesToDevices",
        value: function () {
          var _sendMessagesToDevices2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(type, messages, hsApi, log) {
            var messagesByUser, payload, txnId;
            return regeneratorRuntime.wrap(function _callee21$(_context23) {
              while (1) {
                switch (_context23.prev = _context23.next) {
                  case 0:
                    log.set("messages", messages.length);
                    messagesByUser = groupBy(messages, function (message) {
                      return message.device.userId;
                    });
                    payload = {
                      messages: Array.from(messagesByUser.entries()).reduce(function (userMap, _ref12) {
                        var _ref13 = _slicedToArray(_ref12, 2),
                            userId = _ref13[0],
                            messages = _ref13[1];

                        userMap[userId] = messages.reduce(function (deviceMap, message) {
                          deviceMap[message.device.deviceId] = message.content;
                          return deviceMap;
                        }, {});
                        return userMap;
                      }, {})
                    };
                    txnId = makeTxnId();
                    _context23.next = 6;
                    return hsApi.sendToDevice(type, payload, txnId, {
                      log: log
                    }).response();

                  case 6:
                  case "end":
                    return _context23.stop();
                }
              }
            }, _callee21);
          }));

          function _sendMessagesToDevices(_x50, _x51, _x52, _x53) {
            return _sendMessagesToDevices2.apply(this, arguments);
          }

          return _sendMessagesToDevices;
        }()
      }, {
        key: "filterUndecryptedEventEntriesForKeys",
        value: function filterUndecryptedEventEntriesForKeys(entries, keys) {
          return entries.filter(function (entry) {
            if (entry.isEncrypted && !entry.isDecrypted) {
              var event = entry.event;

              if (event) {
                var _event$content3, _event$content4;

                var senderKey = (_event$content3 = event.content) === null || _event$content3 === void 0 ? void 0 : _event$content3["sender_key"];
                var sessionId = (_event$content4 = event.content) === null || _event$content4 === void 0 ? void 0 : _event$content4["session_id"];
                return keys.some(function (key) {
                  return senderKey === key.senderKey && sessionId === key.sessionId;
                });
              }
            }

            return false;
          });
        }
      }, {
        key: "dispose",
        value: function dispose() {
          this._disposed = true;
        }
      }]);

      return RoomEncryption;
    }();
    /**
     * wrappers around megolm decryption classes to be able to post-process
     * the decryption results before turning them
     */

    var DecryptionPreparation$1 = /*#__PURE__*/function () {
      function DecryptionPreparation(megolmDecryptionPreparation, extraErrors, source, roomEncryption, events) {
        _classCallCheck(this, DecryptionPreparation);

        this._megolmDecryptionPreparation = megolmDecryptionPreparation;
        this._extraErrors = extraErrors;
        this._source = source;
        this._roomEncryption = roomEncryption;
        this._events = events;
      }

      _createClass(DecryptionPreparation, [{
        key: "decrypt",
        value: function () {
          var _decrypt = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22() {
            return regeneratorRuntime.wrap(function _callee22$(_context24) {
              while (1) {
                switch (_context24.prev = _context24.next) {
                  case 0:
                    _context24.t0 = DecryptionChanges$2;
                    _context24.next = 3;
                    return this._megolmDecryptionPreparation.decrypt();

                  case 3:
                    _context24.t1 = _context24.sent;
                    _context24.t2 = this._extraErrors;
                    _context24.t3 = this._source;
                    _context24.t4 = this._roomEncryption;
                    _context24.t5 = this._events;
                    return _context24.abrupt("return", new _context24.t0(_context24.t1, _context24.t2, _context24.t3, _context24.t4, _context24.t5));

                  case 9:
                  case "end":
                    return _context24.stop();
                }
              }
            }, _callee22, this);
          }));

          function decrypt() {
            return _decrypt.apply(this, arguments);
          }

          return decrypt;
        }()
      }, {
        key: "dispose",
        value: function dispose() {
          this._megolmDecryptionPreparation.dispose();
        }
      }]);

      return DecryptionPreparation;
    }();

    var DecryptionChanges$2 = /*#__PURE__*/function () {
      function DecryptionChanges(megolmDecryptionChanges, extraErrors, source, roomEncryption, events) {
        _classCallCheck(this, DecryptionChanges);

        this._megolmDecryptionChanges = megolmDecryptionChanges;
        this._extraErrors = extraErrors;
        this._source = source;
        this._roomEncryption = roomEncryption;
        this._events = events;
      }

      _createClass(DecryptionChanges, [{
        key: "write",
        value: function () {
          var _write = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(txn, log) {
            var _yield$this$_megolmDe, results, errors;

            return regeneratorRuntime.wrap(function _callee23$(_context25) {
              while (1) {
                switch (_context25.prev = _context25.next) {
                  case 0:
                    _context25.next = 2;
                    return this._megolmDecryptionChanges.write(txn);

                  case 2:
                    _yield$this$_megolmDe = _context25.sent;
                    results = _yield$this$_megolmDe.results;
                    errors = _yield$this$_megolmDe.errors;
                    mergeMap(this._extraErrors, errors);
                    _context25.next = 8;
                    return this._roomEncryption._processDecryptionResults(this._events, results, errors, this._source, txn, log);

                  case 8:
                    return _context25.abrupt("return", new BatchDecryptionResult(results, errors, this._roomEncryption));

                  case 9:
                  case "end":
                    return _context25.stop();
                }
              }
            }, _callee23, this);
          }));

          function write(_x54, _x55) {
            return _write.apply(this, arguments);
          }

          return write;
        }()
      }]);

      return DecryptionChanges;
    }();

    var BatchDecryptionResult = /*#__PURE__*/function () {
      function BatchDecryptionResult(results, errors, roomEncryption) {
        _classCallCheck(this, BatchDecryptionResult);

        this.results = results;
        this.errors = errors;
        this._roomEncryption = roomEncryption;
      }

      _createClass(BatchDecryptionResult, [{
        key: "applyToEntries",
        value: function applyToEntries(entries) {
          var _iterator4 = _createForOfIteratorHelper(entries),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var entry = _step4.value;
              var result = this.results.get(entry.id);

              if (result) {
                entry.setDecryptionResult(result);
              } else {
                var error = this.errors.get(entry.id);

                if (error) {
                  entry.setDecryptionError(error);
                }
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }
      }, {
        key: "verifySenders",
        value: function verifySenders(txn) {
          var _this8 = this;

          return Promise.all(Array.from(this.results.values()).map(function (result) {
            return _this8._roomEncryption._verifyDecryptionResult(result, txn);
          }));
        }
      }]);

      return BatchDecryptionResult;
    }();

    var LockMap = /*#__PURE__*/function () {
      function LockMap() {
        _classCallCheck(this, LockMap);

        this._map = new Map();
      }

      _createClass(LockMap, [{
        key: "takeLock",
        value: function () {
          var _takeLock = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(key) {
            var _this = this;

            var lock;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    lock = this._map.get(key);

                    if (!lock) {
                      _context.next = 6;
                      break;
                    }

                    _context.next = 4;
                    return lock.take();

                  case 4:
                    _context.next = 9;
                    break;

                  case 6:
                    lock = new Lock();
                    lock.tryTake();

                    this._map.set(key, lock);

                  case 9:
                    // don't leave old locks lying around
                    lock.released().then(function () {
                      // give others a chance to take the lock first
                      Promise.resolve().then(function () {
                        if (!lock.isTaken) {
                          _this._map.delete(key);
                        }
                      });
                    });
                    return _context.abrupt("return", lock);

                  case 11:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function takeLock(_x) {
            return _takeLock.apply(this, arguments);
          }

          return takeLock;
        }()
      }]);

      return LockMap;
    }();

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var SecretStorage = /*#__PURE__*/function () {
      function SecretStorage(_ref) {
        var key = _ref.key,
            platform = _ref.platform;

        _classCallCheck(this, SecretStorage);

        this._key = key;
        this._platform = platform;
      }

      _createClass(SecretStorage, [{
        key: "readSecret",
        value: function () {
          var _readSecret = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(name, txn) {
            var _accountData$content, _accountData$content$;

            var accountData, encryptedData;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return txn.accountData.get(name);

                  case 2:
                    accountData = _context.sent;

                    if (accountData) {
                      _context.next = 5;
                      break;
                    }

                    return _context.abrupt("return");

                  case 5:
                    encryptedData = accountData === null || accountData === void 0 ? void 0 : (_accountData$content = accountData.content) === null || _accountData$content === void 0 ? void 0 : (_accountData$content$ = _accountData$content.encrypted) === null || _accountData$content$ === void 0 ? void 0 : _accountData$content$[this._key.id];

                    if (encryptedData) {
                      _context.next = 8;
                      break;
                    }

                    throw new Error("Secret ".concat(accountData.type, " is not encrypted for key ").concat(this._key.id));

                  case 8:
                    if (!(this._key.algorithm === "m.secret_storage.v1.aes-hmac-sha2")) {
                      _context.next = 14;
                      break;
                    }

                    _context.next = 11;
                    return this._decryptAESSecret(accountData.type, encryptedData);

                  case 11:
                    return _context.abrupt("return", _context.sent);

                  case 14:
                    throw new Error("Unsupported algorithm for key ".concat(this._key.id, ": ").concat(this._key.algorithm));

                  case 15:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function readSecret(_x, _x2) {
            return _readSecret.apply(this, arguments);
          }

          return readSecret;
        }()
      }, {
        key: "_decryptAESSecret",
        value: function () {
          var _decryptAESSecret2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(type, encryptedData) {
            var _this$_platform$encod, base64, utf8, hkdfKey, aesKey, hmacKey, ciphertextBytes, isVerified, plaintextBytes;

            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _this$_platform$encod = this._platform.encoding, base64 = _this$_platform$encod.base64, utf8 = _this$_platform$encod.utf8; // now derive the aes and mac key from the 4s key

                    _context2.next = 3;
                    return this._platform.crypto.derive.hkdf(this._key.binaryKey, new Uint8Array(8).buffer, //zero salt
                    utf8.encode(type), // info
                    "SHA-256", 512 // 512 bits or 64 bytes
                    );

                  case 3:
                    hkdfKey = _context2.sent;
                    aesKey = hkdfKey.slice(0, 32);
                    hmacKey = hkdfKey.slice(32);
                    ciphertextBytes = base64.decode(encryptedData.ciphertext);
                    _context2.next = 9;
                    return this._platform.crypto.hmac.verify(hmacKey, base64.decode(encryptedData.mac), ciphertextBytes, "SHA-256");

                  case 9:
                    isVerified = _context2.sent;

                    if (isVerified) {
                      _context2.next = 12;
                      break;
                    }

                    throw new Error("Bad MAC");

                  case 12:
                    _context2.next = 14;
                    return this._platform.crypto.aes.decryptCTR({
                      key: aesKey,
                      iv: base64.decode(encryptedData.iv),
                      data: ciphertextBytes
                    });

                  case 14:
                    plaintextBytes = _context2.sent;
                    return _context2.abrupt("return", utf8.decode(plaintextBytes));

                  case 16:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function _decryptAESSecret(_x3, _x4) {
            return _decryptAESSecret2.apply(this, arguments);
          }

          return _decryptAESSecret;
        }()
      }]);

      return SecretStorage;
    }();

    var PICKLE_KEY = "DEFAULT_KEY";
    var PUSHER_KEY = "pusher";
    var Session$1 = /*#__PURE__*/function () {
      // sessionInfo contains deviceId, userId and homeserver
      function Session(_ref) {
        var _this = this;

        var storage = _ref.storage,
            hsApi = _ref.hsApi,
            sessionInfo = _ref.sessionInfo,
            olm = _ref.olm,
            olmWorker = _ref.olmWorker,
            platform = _ref.platform,
            mediaRepository = _ref.mediaRepository;

        _classCallCheck(this, Session);

        this._platform = platform;
        this._storage = storage;
        this._hsApi = hsApi;
        this._mediaRepository = mediaRepository;
        this._syncInfo = null;
        this._sessionInfo = sessionInfo;
        this._rooms = new ObservableMap();

        this._roomUpdateCallback = function (room, params) {
          return _this._rooms.update(room.id, params);
        };

        this._activeArchivedRooms = new Map();
        this._invites = new ObservableMap();

        this._inviteUpdateCallback = function (invite, params) {
          return _this._invites.update(invite.id, params);
        };

        this._user = new User(sessionInfo.userId);
        this._deviceMessageHandler = new DeviceMessageHandler({
          storage: storage
        });
        this._olm = olm;
        this._olmUtil = null;
        this._e2eeAccount = null;
        this._deviceTracker = null;
        this._olmEncryption = null;
        this._megolmEncryption = null;
        this._megolmDecryption = null;

        this._getSyncToken = function () {
          return _this.syncToken;
        };

        this._olmWorker = olmWorker;
        this._sessionBackup = null;
        this._hasSecretStorageKey = new ObservableValue(null);
        this._observedRoomStatus = new Map();

        if (olm) {
          this._olmUtil = new olm.Utility();
          this._deviceTracker = new DeviceTracker({
            storage: storage,
            getSyncToken: this._getSyncToken,
            olmUtil: this._olmUtil,
            ownUserId: sessionInfo.userId,
            ownDeviceId: sessionInfo.deviceId
          });
        }

        this._createRoomEncryption = this._createRoomEncryption.bind(this);
        this._forgetArchivedRoom = this._forgetArchivedRoom.bind(this);
        this.needsSessionBackup = new ObservableValue(false);
      }

      _createClass(Session, [{
        key: "logout",

        /** @internal call SessionContainer.logout instead */
        value: function () {
          var _logout = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var log,
                _args = arguments;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    log = _args.length > 0 && _args[0] !== undefined ? _args[0] : undefined;
                    _context.next = 3;
                    return this._hsApi.logout({
                      log: log
                    }).response();

                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function logout() {
            return _logout.apply(this, arguments);
          }

          return logout;
        }() // called once this._e2eeAccount is assigned

      }, {
        key: "_setupEncryption",
        value: function _setupEncryption() {
          // TODO: this should all go in a wrapper in e2ee/ that is bootstrapped by passing in the account
          // and can create RoomEncryption objects and handle encrypted to_device messages and device list changes.
          var senderKeyLock = new LockMap();
          var olmDecryption = new Decryption({
            account: this._e2eeAccount,
            pickleKey: PICKLE_KEY,
            olm: this._olm,
            storage: this._storage,
            now: this._platform.clock.now,
            ownUserId: this._user.id,
            senderKeyLock: senderKeyLock
          });
          this._olmEncryption = new Encryption({
            account: this._e2eeAccount,
            pickleKey: PICKLE_KEY,
            olm: this._olm,
            storage: this._storage,
            now: this._platform.clock.now,
            ownUserId: this._user.id,
            olmUtil: this._olmUtil,
            senderKeyLock: senderKeyLock
          });
          this._megolmEncryption = new Encryption$1({
            account: this._e2eeAccount,
            pickleKey: PICKLE_KEY,
            olm: this._olm,
            storage: this._storage,
            now: this._platform.clock.now,
            ownDeviceId: this._sessionInfo.deviceId
          });
          var keyLoader = new KeyLoader(this._olm, PICKLE_KEY, 20);
          this._megolmDecryption = new Decryption$1(keyLoader, this._olmWorker);

          this._deviceMessageHandler.enableEncryption({
            olmDecryption: olmDecryption,
            megolmDecryption: this._megolmDecryption
          });
        }
      }, {
        key: "_createRoomEncryption",
        value: function _createRoomEncryption(room, encryptionParams) {
          var _this2 = this;

          // TODO: this will actually happen when users start using the e2ee version for the first time
          // this should never happen because either a session was already synced once
          // and thus an e2ee account was created as well and _setupEncryption is called from load
          // OR
          // this is a new session and loading it will load zero rooms, thus not calling this method.
          // in this case _setupEncryption is called from beforeFirstSync, right after load,
          // so any incoming synced rooms won't be there yet
          if (!this._olmEncryption) {
            throw new Error("creating room encryption before encryption got globally enabled");
          } // only support megolm


          if (encryptionParams.algorithm !== MEGOLM_ALGORITHM) {
            return null;
          }

          return new RoomEncryption({
            room: room,
            deviceTracker: this._deviceTracker,
            olmEncryption: this._olmEncryption,
            megolmEncryption: this._megolmEncryption,
            megolmDecryption: this._megolmDecryption,
            storage: this._storage,
            sessionBackup: this._sessionBackup,
            encryptionParams: encryptionParams,
            notifyMissingMegolmSession: function notifyMissingMegolmSession() {
              if (!_this2._sessionBackup) {
                _this2.needsSessionBackup.set(true);
              }
            },
            clock: this._platform.clock
          });
        }
        /**
         * Enable secret storage by providing the secret storage credential.
         * This will also see if there is a megolm session backup and try to enable that if so.
         * 
         * @param  {string} type       either "passphrase" or "recoverykey"
         * @param  {string} credential either the passphrase or the recovery key, depending on the type
         * @return {Promise} resolves or rejects after having tried to enable secret storage
         */

      }, {
        key: "enableSecretStorage",
        value: function () {
          var _enableSecretStorage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(type, credential) {
            var key, readTxn;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (this._olm) {
                      _context2.next = 2;
                      break;
                    }

                    throw new Error("olm required");

                  case 2:
                    if (!this._sessionBackup) {
                      _context2.next = 4;
                      break;
                    }

                    return _context2.abrupt("return", false);

                  case 4:
                    _context2.next = 6;
                    return keyFromCredential(type, credential, this._storage, this._platform, this._olm);

                  case 6:
                    key = _context2.sent;
                    _context2.next = 9;
                    return this._storage.readTxn([this._storage.storeNames.accountData]);

                  case 9:
                    readTxn = _context2.sent;
                    _context2.next = 12;
                    return this._createSessionBackup(key, readTxn);

                  case 12:
                    _context2.next = 14;
                    return this._writeSSSSKey(key);

                  case 14:
                    this._hasSecretStorageKey.set(true);

                    return _context2.abrupt("return", key);

                  case 16:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function enableSecretStorage(_x, _x2) {
            return _enableSecretStorage.apply(this, arguments);
          }

          return enableSecretStorage;
        }()
      }, {
        key: "_writeSSSSKey",
        value: function () {
          var _writeSSSSKey2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(key) {
            var writeTxn;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this._storage.readWriteTxn([this._storage.storeNames.session]);

                  case 2:
                    writeTxn = _context3.sent;
                    _context3.prev = 3;
                    writeKey(key, writeTxn);
                    _context3.next = 11;
                    break;

                  case 7:
                    _context3.prev = 7;
                    _context3.t0 = _context3["catch"](3);
                    writeTxn.abort();
                    throw _context3.t0;

                  case 11:
                    _context3.next = 13;
                    return writeTxn.complete();

                  case 13:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[3, 7]]);
          }));

          function _writeSSSSKey(_x3) {
            return _writeSSSSKey2.apply(this, arguments);
          }

          return _writeSSSSKey;
        }()
      }, {
        key: "disableSecretStorage",
        value: function () {
          var _disableSecretStorage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
            var writeTxn, _this$_sessionBackup, _iterator, _step, room;

            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return this._storage.readWriteTxn([this._storage.storeNames.session]);

                  case 2:
                    writeTxn = _context4.sent;
                    _context4.prev = 3;
                    removeKey(writeTxn);
                    _context4.next = 11;
                    break;

                  case 7:
                    _context4.prev = 7;
                    _context4.t0 = _context4["catch"](3);
                    writeTxn.abort();
                    throw _context4.t0;

                  case 11:
                    _context4.next = 13;
                    return writeTxn.complete();

                  case 13:
                    if (this._sessionBackup) {
                      _iterator = _createForOfIteratorHelper(this._rooms.values());

                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done;) {
                          room = _step.value;

                          if (room.isEncrypted) {
                            room.enableSessionBackup(undefined);
                          }
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }

                      (_this$_sessionBackup = this._sessionBackup) === null || _this$_sessionBackup === void 0 ? void 0 : _this$_sessionBackup.dispose();
                      this._sessionBackup = undefined;
                    }

                    this._hasSecretStorageKey.set(false);

                  case 15:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this, [[3, 7]]);
          }));

          function disableSecretStorage() {
            return _disableSecretStorage.apply(this, arguments);
          }

          return disableSecretStorage;
        }()
      }, {
        key: "_createSessionBackup",
        value: function () {
          var _createSessionBackup2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(ssssKey, txn) {
            var secretStorage, _iterator2, _step2, room;

            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    secretStorage = new SecretStorage({
                      key: ssssKey,
                      platform: this._platform
                    });
                    _context5.next = 3;
                    return SessionBackup.fromSecretStorage({
                      platform: this._platform,
                      olm: this._olm,
                      secretStorage: secretStorage,
                      hsApi: this._hsApi,
                      txn: txn
                    });

                  case 3:
                    this._sessionBackup = _context5.sent;

                    if (this._sessionBackup) {
                      _iterator2 = _createForOfIteratorHelper(this._rooms.values());

                      try {
                        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                          room = _step2.value;

                          if (room.isEncrypted) {
                            room.enableSessionBackup(this._sessionBackup);
                          }
                        }
                      } catch (err) {
                        _iterator2.e(err);
                      } finally {
                        _iterator2.f();
                      }
                    }

                    this.needsSessionBackup.set(false);

                  case 6:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));

          function _createSessionBackup(_x4, _x5) {
            return _createSessionBackup2.apply(this, arguments);
          }

          return _createSessionBackup;
        }()
      }, {
        key: "createIdentity",

        /** @internal */
        value: function () {
          var _createIdentity = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(log) {
            var _this3 = this;

            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    if (!this._olm) {
                      _context6.next = 11;
                      break;
                    }

                    if (this._e2eeAccount) {
                      _context6.next = 7;
                      break;
                    }

                    _context6.next = 4;
                    return this._createNewAccount(this._sessionInfo.deviceId, this._storage);

                  case 4:
                    this._e2eeAccount = _context6.sent;
                    log.set("keys", this._e2eeAccount.identityKeys);

                    this._setupEncryption();

                  case 7:
                    _context6.next = 9;
                    return this._e2eeAccount.generateOTKsIfNeeded(this._storage, log);

                  case 9:
                    _context6.next = 11;
                    return log.wrap("uploadKeys", function (log) {
                      return _this3._e2eeAccount.uploadKeys(_this3._storage, false, log);
                    });

                  case 11:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this);
          }));

          function createIdentity(_x6) {
            return _createIdentity.apply(this, arguments);
          }

          return createIdentity;
        }()
        /** @internal */

      }, {
        key: "dehydrateIdentity",
        value: function () {
          var _dehydrateIdentity = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(dehydratedDevice, log) {
            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    log.set("deviceId", dehydratedDevice.deviceId);

                    if (this._olm) {
                      _context7.next = 4;
                      break;
                    }

                    log.set("no_olm", true);
                    return _context7.abrupt("return", false);

                  case 4:
                    if (!(dehydratedDevice.deviceId !== this.deviceId)) {
                      _context7.next = 7;
                      break;
                    }

                    log.set("wrong_device", true);
                    return _context7.abrupt("return", false);

                  case 7:
                    if (!this._e2eeAccount) {
                      _context7.next = 10;
                      break;
                    }

                    log.set("account_already_setup", true);
                    return _context7.abrupt("return", false);

                  case 10:
                    _context7.next = 12;
                    return dehydratedDevice.claim(this._hsApi, log);

                  case 12:
                    if (_context7.sent) {
                      _context7.next = 15;
                      break;
                    }

                    log.set("already_claimed", true);
                    return _context7.abrupt("return", false);

                  case 15:
                    _context7.next = 17;
                    return Account.adoptDehydratedDevice({
                      dehydratedDevice: dehydratedDevice,
                      hsApi: this._hsApi,
                      olm: this._olm,
                      pickleKey: PICKLE_KEY,
                      userId: this._sessionInfo.userId,
                      olmWorker: this._olmWorker,
                      deviceId: this.deviceId,
                      storage: this._storage
                    });

                  case 17:
                    this._e2eeAccount = _context7.sent;
                    log.set("keys", this._e2eeAccount.identityKeys);

                    this._setupEncryption();

                    return _context7.abrupt("return", true);

                  case 21:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));

          function dehydrateIdentity(_x7, _x8) {
            return _dehydrateIdentity.apply(this, arguments);
          }

          return dehydrateIdentity;
        }()
      }, {
        key: "_createNewAccount",
        value: function _createNewAccount(deviceId) {
          var storage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
          // storage is optional and if omitted the account won't be persisted (useful for dehydrating devices)
          return Account.create({
            hsApi: this._hsApi,
            olm: this._olm,
            pickleKey: PICKLE_KEY,
            userId: this._sessionInfo.userId,
            olmWorker: this._olmWorker,
            deviceId: deviceId,
            storage: storage
          });
        }
      }, {
        key: "setupDehydratedDevice",
        value: function setupDehydratedDevice(key) {
          var _this4 = this;

          var log = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return this._platform.logger.wrapOrRun(log, "setupDehydratedDevice", /*#__PURE__*/function () {
            var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(log) {
              var dehydrationAccount, deviceId;
              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      _context8.next = 2;
                      return _this4._createNewAccount("temp-device-id");

                    case 2:
                      dehydrationAccount = _context8.sent;
                      _context8.prev = 3;
                      _context8.next = 6;
                      return uploadAccountAsDehydratedDevice(dehydrationAccount, _this4._hsApi, key, "Dehydrated device", log);

                    case 6:
                      deviceId = _context8.sent;
                      log.set("deviceId", deviceId);
                      return _context8.abrupt("return", deviceId);

                    case 9:
                      _context8.prev = 9;
                      dehydrationAccount.dispose();
                      return _context8.finish(9);

                    case 12:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8, null, [[3,, 9, 12]]);
            }));

            return function (_x9) {
              return _ref2.apply(this, arguments);
            };
          }());
        }
        /** @internal */

      }, {
        key: "load",
        value: function () {
          var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(log) {
            var _this5 = this;

            var txn, pendingEventsByRoomId, invites, inviteLoadPromise, rooms, roomLoadPromise, _iterator3, _step3, _step3$value, roomId, invite, room;

            return regeneratorRuntime.wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    _context11.next = 2;
                    return this._storage.readTxn([this._storage.storeNames.session, this._storage.storeNames.roomSummary, this._storage.storeNames.invites, this._storage.storeNames.roomMembers, this._storage.storeNames.timelineEvents, this._storage.storeNames.timelineFragments, this._storage.storeNames.pendingEvents]);

                  case 2:
                    txn = _context11.sent;
                    _context11.next = 5;
                    return txn.session.get("sync");

                  case 5:
                    this._syncInfo = _context11.sent;

                    if (!this._olm) {
                      _context11.next = 11;
                      break;
                    }

                    _context11.next = 9;
                    return Account.load({
                      hsApi: this._hsApi,
                      olm: this._olm,
                      pickleKey: PICKLE_KEY,
                      userId: this._sessionInfo.userId,
                      deviceId: this._sessionInfo.deviceId,
                      olmWorker: this._olmWorker,
                      txn: txn
                    });

                  case 9:
                    this._e2eeAccount = _context11.sent;

                    if (this._e2eeAccount) {
                      log.set("keys", this._e2eeAccount.identityKeys);

                      this._setupEncryption();
                    }

                  case 11:
                    _context11.next = 13;
                    return this._getPendingEventsByRoom(txn);

                  case 13:
                    pendingEventsByRoomId = _context11.sent;
                    _context11.next = 16;
                    return txn.invites.getAll();

                  case 16:
                    invites = _context11.sent;
                    inviteLoadPromise = Promise.all(invites.map( /*#__PURE__*/function () {
                      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(inviteData) {
                        var invite;
                        return regeneratorRuntime.wrap(function _callee9$(_context9) {
                          while (1) {
                            switch (_context9.prev = _context9.next) {
                              case 0:
                                invite = _this5.createInvite(inviteData.roomId);
                                log.wrap("invite", function (log) {
                                  return invite.load(inviteData, log);
                                });

                                _this5._invites.add(invite.id, invite);

                              case 3:
                              case "end":
                                return _context9.stop();
                            }
                          }
                        }, _callee9);
                      }));

                      return function (_x11) {
                        return _ref3.apply(this, arguments);
                      };
                    }())); // load rooms

                    _context11.next = 20;
                    return txn.roomSummary.getAll();

                  case 20:
                    rooms = _context11.sent;
                    roomLoadPromise = Promise.all(rooms.map( /*#__PURE__*/function () {
                      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(summary) {
                        var room;
                        return regeneratorRuntime.wrap(function _callee10$(_context10) {
                          while (1) {
                            switch (_context10.prev = _context10.next) {
                              case 0:
                                room = _this5.createRoom(summary.roomId, pendingEventsByRoomId.get(summary.roomId));
                                _context10.next = 3;
                                return log.wrap("room", function (log) {
                                  return room.load(summary, txn, log);
                                });

                              case 3:
                                _this5._rooms.add(room.id, room);

                              case 4:
                              case "end":
                                return _context10.stop();
                            }
                          }
                        }, _callee10);
                      }));

                      return function (_x12) {
                        return _ref4.apply(this, arguments);
                      };
                    }())); // load invites and rooms in parallel

                    _context11.next = 24;
                    return Promise.all([inviteLoadPromise, roomLoadPromise]);

                  case 24:
                    _iterator3 = _createForOfIteratorHelper(this.invites);

                    try {
                      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                        _step3$value = _slicedToArray(_step3.value, 2), roomId = _step3$value[0], invite = _step3$value[1];
                        room = this.rooms.get(roomId);

                        if (room) {
                          room.setInvite(invite);
                        }
                      }
                    } catch (err) {
                      _iterator3.e(err);
                    } finally {
                      _iterator3.f();
                    }

                  case 26:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this);
          }));

          function load(_x10) {
            return _load.apply(this, arguments);
          }

          return load;
        }()
      }, {
        key: "dispose",
        value: function dispose() {
          var _this$_olmWorker, _this$_sessionBackup2, _this$_megolmDecrypti, _this$_e2eeAccount;

          (_this$_olmWorker = this._olmWorker) === null || _this$_olmWorker === void 0 ? void 0 : _this$_olmWorker.dispose();
          this._olmWorker = undefined;
          (_this$_sessionBackup2 = this._sessionBackup) === null || _this$_sessionBackup2 === void 0 ? void 0 : _this$_sessionBackup2.dispose();
          this._sessionBackup = undefined;
          (_this$_megolmDecrypti = this._megolmDecryption) === null || _this$_megolmDecrypti === void 0 ? void 0 : _this$_megolmDecrypti.dispose();
          this._megolmDecryption = undefined;
          (_this$_e2eeAccount = this._e2eeAccount) === null || _this$_e2eeAccount === void 0 ? void 0 : _this$_e2eeAccount.dispose();
          this._e2eeAccount = undefined;

          var _iterator4 = _createForOfIteratorHelper(this._rooms.values()),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var room = _step4.value;
              room.dispose();
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          this._rooms = undefined;
        }
        /**
         * @internal called from session container when coming back online and catchup syncs have finished.
         * @param  {Object} lastVersionResponse a response from /versions, which is polled while offline,
         *                                      and useful to store so we can later tell what capabilities
         *                                      our homeserver has.
         */

      }, {
        key: "start",
        value: function () {
          var _start = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(lastVersionResponse, dehydratedDevice, log) {
            var _this6 = this;

            var txn, _txn, ssssKey, opsTxn, operations, operationsByScope, _iterator5, _step5, room, roomOperationsByType, roomOperations;

            return regeneratorRuntime.wrap(function _callee13$(_context13) {
              while (1) {
                switch (_context13.prev = _context13.next) {
                  case 0:
                    if (!lastVersionResponse) {
                      _context13.next = 7;
                      break;
                    }

                    _context13.next = 3;
                    return this._storage.readWriteTxn([this._storage.storeNames.session]);

                  case 3:
                    txn = _context13.sent;
                    txn.session.set("serverVersions", lastVersionResponse); // TODO: what can we do if this throws?

                    _context13.next = 7;
                    return txn.complete();

                  case 7:
                    if (this._sessionBackup) {
                      _context13.next = 21;
                      break;
                    }

                    if (!dehydratedDevice) {
                      _context13.next = 11;
                      break;
                    }

                    _context13.next = 11;
                    return log.wrap("SSSSKeyFromDehydratedDeviceKey", /*#__PURE__*/function () {
                      var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(log) {
                        var ssssKey;
                        return regeneratorRuntime.wrap(function _callee12$(_context12) {
                          while (1) {
                            switch (_context12.prev = _context12.next) {
                              case 0:
                                _context12.next = 2;
                                return keyFromDehydratedDeviceKey(dehydratedDevice.key, _this6._storage, _this6._platform);

                              case 2:
                                ssssKey = _context12.sent;

                                if (!ssssKey) {
                                  _context12.next = 7;
                                  break;
                                }

                                log.set("success", true);
                                _context12.next = 7;
                                return _this6._writeSSSSKey(ssssKey);

                              case 7:
                              case "end":
                                return _context12.stop();
                            }
                          }
                        }, _callee12);
                      }));

                      return function (_x16) {
                        return _ref5.apply(this, arguments);
                      };
                    }());

                  case 11:
                    _context13.next = 13;
                    return this._storage.readTxn([this._storage.storeNames.session, this._storage.storeNames.accountData]);

                  case 13:
                    _txn = _context13.sent;
                    _context13.next = 16;
                    return readKey(_txn);

                  case 16:
                    ssssKey = _context13.sent;

                    if (!ssssKey) {
                      _context13.next = 20;
                      break;
                    }

                    _context13.next = 20;
                    return this._createSessionBackup(ssssKey, _txn);

                  case 20:
                    this._hasSecretStorageKey.set(!!ssssKey);

                  case 21:
                    _context13.next = 23;
                    return this._storage.readWriteTxn([this._storage.storeNames.operations]);

                  case 23:
                    opsTxn = _context13.sent;
                    _context13.next = 26;
                    return opsTxn.operations.getAll();

                  case 26:
                    operations = _context13.sent;
                    operationsByScope = groupBy(operations, function (o) {
                      return o.scope;
                    });
                    _iterator5 = _createForOfIteratorHelper(this._rooms.values());

                    try {
                      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                        room = _step5.value;
                        roomOperationsByType = void 0;
                        roomOperations = operationsByScope.get(room.id);

                        if (roomOperations) {
                          roomOperationsByType = groupBy(roomOperations, function (r) {
                            return r.type;
                          });
                        }

                        room.start(roomOperationsByType, log);
                      }
                    } catch (err) {
                      _iterator5.e(err);
                    } finally {
                      _iterator5.f();
                    }

                  case 30:
                  case "end":
                    return _context13.stop();
                }
              }
            }, _callee13, this);
          }));

          function start(_x13, _x14, _x15) {
            return _start.apply(this, arguments);
          }

          return start;
        }()
      }, {
        key: "_getPendingEventsByRoom",
        value: function () {
          var _getPendingEventsByRoom2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(txn) {
            var pendingEvents;
            return regeneratorRuntime.wrap(function _callee14$(_context14) {
              while (1) {
                switch (_context14.prev = _context14.next) {
                  case 0:
                    _context14.next = 2;
                    return txn.pendingEvents.getAll();

                  case 2:
                    pendingEvents = _context14.sent;
                    return _context14.abrupt("return", pendingEvents.reduce(function (groups, pe) {
                      var group = groups.get(pe.roomId);

                      if (group) {
                        group.push(pe);
                      } else {
                        groups.set(pe.roomId, [pe]);
                      }

                      return groups;
                    }, new Map()));

                  case 4:
                  case "end":
                    return _context14.stop();
                }
              }
            }, _callee14);
          }));

          function _getPendingEventsByRoom(_x17) {
            return _getPendingEventsByRoom2.apply(this, arguments);
          }

          return _getPendingEventsByRoom;
        }()
      }, {
        key: "createRoom",

        /** @internal */
        value: function createRoom(roomId, pendingEvents) {
          return new Room({
            roomId: roomId,
            getSyncToken: this._getSyncToken,
            storage: this._storage,
            emitCollectionChange: this._roomUpdateCallback,
            hsApi: this._hsApi,
            mediaRepository: this._mediaRepository,
            pendingEvents: pendingEvents,
            user: this._user,
            createRoomEncryption: this._createRoomEncryption,
            platform: this._platform
          });
        }
        /** @internal */

      }, {
        key: "_createArchivedRoom",
        value: function _createArchivedRoom(roomId) {
          var _this7 = this;

          var room = new ArchivedRoom({
            roomId: roomId,
            getSyncToken: this._getSyncToken,
            storage: this._storage,
            emitCollectionChange: function emitCollectionChange() {},
            releaseCallback: function releaseCallback() {
              return _this7._activeArchivedRooms.delete(roomId);
            },
            forgetCallback: this._forgetArchivedRoom,
            hsApi: this._hsApi,
            mediaRepository: this._mediaRepository,
            user: this._user,
            createRoomEncryption: this._createRoomEncryption,
            platform: this._platform
          });

          this._activeArchivedRooms.set(roomId, room);

          return room;
        }
      }, {
        key: "createInvite",

        /** @internal */
        value: function createInvite(roomId) {
          return new Invite({
            roomId: roomId,
            hsApi: this._hsApi,
            emitCollectionUpdate: this._inviteUpdateCallback,
            mediaRepository: this._mediaRepository,
            user: this._user,
            platform: this._platform
          });
        }
      }, {
        key: "obtainSyncLock",
        value: function () {
          var _obtainSyncLock = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(syncResponse) {
            var _syncResponse$to_devi;

            var toDeviceEvents;
            return regeneratorRuntime.wrap(function _callee15$(_context15) {
              while (1) {
                switch (_context15.prev = _context15.next) {
                  case 0:
                    toDeviceEvents = (_syncResponse$to_devi = syncResponse.to_device) === null || _syncResponse$to_devi === void 0 ? void 0 : _syncResponse$to_devi.events;

                    if (!(Array.isArray(toDeviceEvents) && toDeviceEvents.length)) {
                      _context15.next = 5;
                      break;
                    }

                    _context15.next = 4;
                    return this._deviceMessageHandler.obtainSyncLock(toDeviceEvents);

                  case 4:
                    return _context15.abrupt("return", _context15.sent);

                  case 5:
                  case "end":
                    return _context15.stop();
                }
              }
            }, _callee15, this);
          }));

          function obtainSyncLock(_x18) {
            return _obtainSyncLock.apply(this, arguments);
          }

          return obtainSyncLock;
        }()
      }, {
        key: "prepareSync",
        value: function () {
          var _prepareSync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(syncResponse, lock, txn, log) {
            var _syncResponse$to_devi2,
                _this8 = this;

            var toDeviceEvents;
            return regeneratorRuntime.wrap(function _callee16$(_context16) {
              while (1) {
                switch (_context16.prev = _context16.next) {
                  case 0:
                    toDeviceEvents = (_syncResponse$to_devi2 = syncResponse.to_device) === null || _syncResponse$to_devi2 === void 0 ? void 0 : _syncResponse$to_devi2.events;

                    if (!(Array.isArray(toDeviceEvents) && toDeviceEvents.length)) {
                      _context16.next = 5;
                      break;
                    }

                    _context16.next = 4;
                    return log.wrap("deviceMsgs", function (log) {
                      return _this8._deviceMessageHandler.prepareSync(toDeviceEvents, lock, txn, log);
                    });

                  case 4:
                    return _context16.abrupt("return", _context16.sent);

                  case 5:
                  case "end":
                    return _context16.stop();
                }
              }
            }, _callee16);
          }));

          function prepareSync(_x19, _x20, _x21, _x22) {
            return _prepareSync.apply(this, arguments);
          }

          return prepareSync;
        }()
        /** @internal */

      }, {
        key: "writeSync",
        value: function () {
          var _writeSync = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(syncResponse, syncFilterId, preparation, txn, log) {
            var _this9 = this;

            var changes, syncToken, syncInfo, deviceOneTimeKeysCount, deviceLists, accountData, _iterator6, _step6, event;

            return regeneratorRuntime.wrap(function _callee17$(_context17) {
              while (1) {
                switch (_context17.prev = _context17.next) {
                  case 0:
                    changes = {
                      syncInfo: null,
                      e2eeAccountChanges: null
                    };
                    syncToken = syncResponse.next_batch;

                    if (syncToken !== this.syncToken) {
                      syncInfo = {
                        token: syncToken,
                        filterId: syncFilterId
                      }; // don't modify `this` because transaction might still fail

                      txn.session.set("sync", syncInfo);
                      changes.syncInfo = syncInfo;
                    }

                    deviceOneTimeKeysCount = syncResponse.device_one_time_keys_count;

                    if (this._e2eeAccount && deviceOneTimeKeysCount) {
                      changes.e2eeAccountChanges = this._e2eeAccount.writeSync(deviceOneTimeKeysCount, txn, log);
                    }

                    deviceLists = syncResponse.device_lists;

                    if (!(this._deviceTracker && Array.isArray(deviceLists === null || deviceLists === void 0 ? void 0 : deviceLists.changed) && deviceLists.changed.length)) {
                      _context17.next = 9;
                      break;
                    }

                    _context17.next = 9;
                    return log.wrap("deviceLists", function (log) {
                      return _this9._deviceTracker.writeDeviceChanges(deviceLists.changed, txn, log);
                    });

                  case 9:
                    if (!preparation) {
                      _context17.next = 12;
                      break;
                    }

                    _context17.next = 12;
                    return log.wrap("deviceMsgs", function (log) {
                      return _this9._deviceMessageHandler.writeSync(preparation, txn, log);
                    });

                  case 12:
                    // store account data
                    accountData = syncResponse["account_data"];

                    if (Array.isArray(accountData === null || accountData === void 0 ? void 0 : accountData.events)) {
                      _iterator6 = _createForOfIteratorHelper(accountData.events);

                      try {
                        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                          event = _step6.value;

                          if (typeof event.type === "string") {
                            txn.accountData.set(event);
                          }
                        }
                      } catch (err) {
                        _iterator6.e(err);
                      } finally {
                        _iterator6.f();
                      }
                    }

                    return _context17.abrupt("return", changes);

                  case 15:
                  case "end":
                    return _context17.stop();
                }
              }
            }, _callee17, this);
          }));

          function writeSync(_x23, _x24, _x25, _x26, _x27) {
            return _writeSync.apply(this, arguments);
          }

          return writeSync;
        }()
        /** @internal */

      }, {
        key: "afterSync",
        value: function afterSync(_ref6) {
          var syncInfo = _ref6.syncInfo,
              e2eeAccountChanges = _ref6.e2eeAccountChanges;

          if (syncInfo) {
            // sync transaction succeeded, modify object state now
            this._syncInfo = syncInfo;
          }

          if (this._e2eeAccount) {
            this._e2eeAccount.afterSync(e2eeAccountChanges);
          }
        }
        /** @internal */

      }, {
        key: "afterSyncCompleted",
        value: function () {
          var _afterSyncCompleted = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(changes, isCatchupSync, log) {
            var _this10 = this;

            var needsToUploadOTKs;
            return regeneratorRuntime.wrap(function _callee18$(_context18) {
              while (1) {
                switch (_context18.prev = _context18.next) {
                  case 0:
                    if (isCatchupSync) {
                      _context18.next = 7;
                      break;
                    }

                    _context18.next = 3;
                    return this._e2eeAccount.generateOTKsIfNeeded(this._storage, log);

                  case 3:
                    needsToUploadOTKs = _context18.sent;

                    if (!needsToUploadOTKs) {
                      _context18.next = 7;
                      break;
                    }

                    _context18.next = 7;
                    return log.wrap("uploadKeys", function (log) {
                      return _this10._e2eeAccount.uploadKeys(_this10._storage, false, log);
                    });

                  case 7:
                  case "end":
                    return _context18.stop();
                }
              }
            }, _callee18, this);
          }));

          function afterSyncCompleted(_x28, _x29, _x30) {
            return _afterSyncCompleted.apply(this, arguments);
          }

          return afterSyncCompleted;
        }()
      }, {
        key: "applyRoomCollectionChangesAfterSync",
        value: function applyRoomCollectionChangesAfterSync(inviteStates, roomStates, archivedRoomStates) {
          // update the collections after sync
          var _iterator7 = _createForOfIteratorHelper(roomStates),
              _step7;

          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var _rs = _step7.value;

              if (_rs.shouldAdd) {
                this._rooms.add(_rs.id, _rs.room);
              } else if (_rs.shouldRemove) {
                this._rooms.remove(_rs.id);
              }
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }

          var _iterator8 = _createForOfIteratorHelper(inviteStates),
              _step8;

          try {
            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
              var _is = _step8.value;

              if (_is.shouldAdd) {
                this._invites.add(_is.id, _is.invite);
              } else if (_is.shouldRemove) {
                this._invites.remove(_is.id);
              }
            } // now all the collections are updated, update the room status
            // so any listeners to the status will find the collections
            // completely up to date

          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }

          if (this._observedRoomStatus.size !== 0) {
            var _iterator9 = _createForOfIteratorHelper(archivedRoomStates),
                _step9;

            try {
              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                var ars = _step9.value;

                if (ars.shouldAdd) {
                  var _this$_observedRoomSt;

                  (_this$_observedRoomSt = this._observedRoomStatus.get(ars.id)) === null || _this$_observedRoomSt === void 0 ? void 0 : _this$_observedRoomSt.set(RoomStatus.archived);
                }
              }
            } catch (err) {
              _iterator9.e(err);
            } finally {
              _iterator9.f();
            }

            var _iterator10 = _createForOfIteratorHelper(roomStates),
                _step10;

            try {
              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                var rs = _step10.value;

                if (rs.shouldAdd) {
                  var _this$_observedRoomSt2;

                  (_this$_observedRoomSt2 = this._observedRoomStatus.get(rs.id)) === null || _this$_observedRoomSt2 === void 0 ? void 0 : _this$_observedRoomSt2.set(RoomStatus.joined);
                }
              }
            } catch (err) {
              _iterator10.e(err);
            } finally {
              _iterator10.f();
            }

            var _iterator11 = _createForOfIteratorHelper(inviteStates),
                _step11;

            try {
              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                var is = _step11.value;

                var statusObservable = this._observedRoomStatus.get(is.id);

                if (statusObservable) {
                  if (is.shouldAdd) {
                    statusObservable.set(statusObservable.get().withInvited());
                  } else if (is.shouldRemove) {
                    statusObservable.set(statusObservable.get().withoutInvited());
                  }
                }
              }
            } catch (err) {
              _iterator11.e(err);
            } finally {
              _iterator11.f();
            }
          }
        }
      }, {
        key: "_forgetArchivedRoom",
        value: function _forgetArchivedRoom(roomId) {
          var statusObservable = this._observedRoomStatus.get(roomId);

          if (statusObservable) {
            statusObservable.set(statusObservable.get().withoutArchived());
          }
        }
        /** @internal */

      }, {
        key: "enablePushNotifications",
        value: function enablePushNotifications(enable) {
          if (enable) {
            return this._enablePush();
          } else {
            return this._disablePush();
          }
        }
      }, {
        key: "_enablePush",
        value: function () {
          var _enablePush2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20() {
            var _this11 = this;

            return regeneratorRuntime.wrap(function _callee20$(_context20) {
              while (1) {
                switch (_context20.prev = _context20.next) {
                  case 0:
                    return _context20.abrupt("return", this._platform.logger.run("enablePush", /*#__PURE__*/function () {
                      var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(log) {
                        var defaultPayload, pusher, txn;
                        return regeneratorRuntime.wrap(function _callee19$(_context19) {
                          while (1) {
                            switch (_context19.prev = _context19.next) {
                              case 0:
                                defaultPayload = Pusher.createDefaultPayload(_this11._sessionInfo.id);
                                _context19.next = 3;
                                return _this11._platform.notificationService.enablePush(Pusher, defaultPayload);

                              case 3:
                                pusher = _context19.sent;

                                if (pusher) {
                                  _context19.next = 7;
                                  break;
                                }

                                log.set("no_pusher", true);
                                return _context19.abrupt("return", false);

                              case 7:
                                _context19.next = 9;
                                return pusher.enable(_this11._hsApi, log);

                              case 9:
                                _context19.next = 11;
                                return _this11._storage.readWriteTxn([_this11._storage.storeNames.session]);

                              case 11:
                                txn = _context19.sent;
                                txn.session.set(PUSHER_KEY, pusher.serialize());
                                _context19.next = 15;
                                return txn.complete();

                              case 15:
                                return _context19.abrupt("return", true);

                              case 16:
                              case "end":
                                return _context19.stop();
                            }
                          }
                        }, _callee19);
                      }));

                      return function (_x31) {
                        return _ref7.apply(this, arguments);
                      };
                    }()));

                  case 1:
                  case "end":
                    return _context20.stop();
                }
              }
            }, _callee20, this);
          }));

          function _enablePush() {
            return _enablePush2.apply(this, arguments);
          }

          return _enablePush;
        }()
      }, {
        key: "_disablePush",
        value: function () {
          var _disablePush2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22() {
            var _this12 = this;

            return regeneratorRuntime.wrap(function _callee22$(_context22) {
              while (1) {
                switch (_context22.prev = _context22.next) {
                  case 0:
                    return _context22.abrupt("return", this._platform.logger.run("disablePush", /*#__PURE__*/function () {
                      var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(log) {
                        var readTxn, pusherData, pusher, txn;
                        return regeneratorRuntime.wrap(function _callee21$(_context21) {
                          while (1) {
                            switch (_context21.prev = _context21.next) {
                              case 0:
                                _context21.next = 2;
                                return _this12._platform.notificationService.disablePush();

                              case 2:
                                _context21.next = 4;
                                return _this12._storage.readTxn([_this12._storage.storeNames.session]);

                              case 4:
                                readTxn = _context21.sent;
                                _context21.next = 7;
                                return readTxn.session.get(PUSHER_KEY);

                              case 7:
                                pusherData = _context21.sent;

                                if (pusherData) {
                                  _context21.next = 10;
                                  break;
                                }

                                return _context21.abrupt("return", true);

                              case 10:
                                pusher = new Pusher(pusherData);
                                _context21.next = 13;
                                return pusher.disable(_this12._hsApi, log);

                              case 13:
                                _context21.next = 15;
                                return _this12._storage.readWriteTxn([_this12._storage.storeNames.session]);

                              case 15:
                                txn = _context21.sent;
                                txn.session.remove(PUSHER_KEY);
                                _context21.next = 19;
                                return txn.complete();

                              case 19:
                                return _context21.abrupt("return", true);

                              case 20:
                              case "end":
                                return _context21.stop();
                            }
                          }
                        }, _callee21);
                      }));

                      return function (_x32) {
                        return _ref8.apply(this, arguments);
                      };
                    }()));

                  case 1:
                  case "end":
                    return _context22.stop();
                }
              }
            }, _callee22, this);
          }));

          function _disablePush() {
            return _disablePush2.apply(this, arguments);
          }

          return _disablePush;
        }()
      }, {
        key: "arePushNotificationsEnabled",
        value: function () {
          var _arePushNotificationsEnabled = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23() {
            var readTxn, pusherData;
            return regeneratorRuntime.wrap(function _callee23$(_context23) {
              while (1) {
                switch (_context23.prev = _context23.next) {
                  case 0:
                    _context23.next = 2;
                    return this._platform.notificationService.isPushEnabled();

                  case 2:
                    if (_context23.sent) {
                      _context23.next = 4;
                      break;
                    }

                    return _context23.abrupt("return", false);

                  case 4:
                    _context23.next = 6;
                    return this._storage.readTxn([this._storage.storeNames.session]);

                  case 6:
                    readTxn = _context23.sent;
                    _context23.next = 9;
                    return readTxn.session.get(PUSHER_KEY);

                  case 9:
                    pusherData = _context23.sent;
                    return _context23.abrupt("return", !!pusherData);

                  case 11:
                  case "end":
                    return _context23.stop();
                }
              }
            }, _callee23, this);
          }));

          function arePushNotificationsEnabled() {
            return _arePushNotificationsEnabled.apply(this, arguments);
          }

          return arePushNotificationsEnabled;
        }()
      }, {
        key: "checkPusherEnabledOnHomeserver",
        value: function () {
          var _checkPusherEnabledOnHomeserver = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee24() {
            var readTxn, pusherData, myPusher, serverPushersData, serverPushers;
            return regeneratorRuntime.wrap(function _callee24$(_context24) {
              while (1) {
                switch (_context24.prev = _context24.next) {
                  case 0:
                    _context24.next = 2;
                    return this._storage.readTxn([this._storage.storeNames.session]);

                  case 2:
                    readTxn = _context24.sent;
                    _context24.next = 5;
                    return readTxn.session.get(PUSHER_KEY);

                  case 5:
                    pusherData = _context24.sent;

                    if (pusherData) {
                      _context24.next = 8;
                      break;
                    }

                    return _context24.abrupt("return", false);

                  case 8:
                    myPusher = new Pusher(pusherData);
                    _context24.next = 11;
                    return this._hsApi.getPushers().response();

                  case 11:
                    serverPushersData = _context24.sent;
                    serverPushers = ((serverPushersData === null || serverPushersData === void 0 ? void 0 : serverPushersData.pushers) || []).map(function (data) {
                      return new Pusher(data);
                    });
                    return _context24.abrupt("return", serverPushers.some(function (p) {
                      return p.equals(myPusher);
                    }));

                  case 14:
                  case "end":
                    return _context24.stop();
                }
              }
            }, _callee24, this);
          }));

          function checkPusherEnabledOnHomeserver() {
            return _checkPusherEnabledOnHomeserver.apply(this, arguments);
          }

          return checkPusherEnabledOnHomeserver;
        }()
      }, {
        key: "getRoomStatus",
        value: function () {
          var _getRoomStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee25(roomId) {
            var isJoined, isInvited, txn, isArchived;
            return regeneratorRuntime.wrap(function _callee25$(_context25) {
              while (1) {
                switch (_context25.prev = _context25.next) {
                  case 0:
                    isJoined = !!this._rooms.get(roomId);

                    if (!isJoined) {
                      _context25.next = 5;
                      break;
                    }

                    return _context25.abrupt("return", RoomStatus.joined);

                  case 5:
                    isInvited = !!this._invites.get(roomId);
                    _context25.next = 8;
                    return this._storage.readTxn([this._storage.storeNames.archivedRoomSummary]);

                  case 8:
                    txn = _context25.sent;
                    _context25.next = 11;
                    return txn.archivedRoomSummary.has(roomId);

                  case 11:
                    isArchived = _context25.sent;

                    if (!(isInvited && isArchived)) {
                      _context25.next = 16;
                      break;
                    }

                    return _context25.abrupt("return", RoomStatus.invitedAndArchived);

                  case 16:
                    if (!isInvited) {
                      _context25.next = 20;
                      break;
                    }

                    return _context25.abrupt("return", RoomStatus.invited);

                  case 20:
                    if (!isArchived) {
                      _context25.next = 24;
                      break;
                    }

                    return _context25.abrupt("return", RoomStatus.archived);

                  case 24:
                    return _context25.abrupt("return", RoomStatus.none);

                  case 25:
                  case "end":
                    return _context25.stop();
                }
              }
            }, _callee25, this);
          }));

          function getRoomStatus(_x33) {
            return _getRoomStatus.apply(this, arguments);
          }

          return getRoomStatus;
        }()
      }, {
        key: "observeRoomStatus",
        value: function () {
          var _observeRoomStatus = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee26(roomId) {
            var _this13 = this;

            var observable, status;
            return regeneratorRuntime.wrap(function _callee26$(_context26) {
              while (1) {
                switch (_context26.prev = _context26.next) {
                  case 0:
                    observable = this._observedRoomStatus.get(roomId);

                    if (observable) {
                      _context26.next = 7;
                      break;
                    }

                    _context26.next = 4;
                    return this.getRoomStatus(roomId);

                  case 4:
                    status = _context26.sent;
                    observable = new RetainedObservableValue(status, function () {
                      _this13._observedRoomStatus.delete(roomId);
                    });

                    this._observedRoomStatus.set(roomId, observable);

                  case 7:
                    return _context26.abrupt("return", observable);

                  case 8:
                  case "end":
                    return _context26.stop();
                }
              }
            }, _callee26, this);
          }));

          function observeRoomStatus(_x34) {
            return _observeRoomStatus.apply(this, arguments);
          }

          return observeRoomStatus;
        }()
        /**
        Creates an empty (summary isn't loaded) the archived room if it isn't
        loaded already, assuming sync will either remove it (when rejoining) or
        write a full summary adopting it from the joined room when leaving
        
        @internal
        */

      }, {
        key: "createOrGetArchivedRoomForSync",
        value: function createOrGetArchivedRoomForSync(roomId) {
          var archivedRoom = this._activeArchivedRooms.get(roomId);

          if (archivedRoom) {
            archivedRoom.retain();
          } else {
            archivedRoom = this._createArchivedRoom(roomId);
          }

          return archivedRoom;
        }
      }, {
        key: "loadArchivedRoom",
        value: function loadArchivedRoom(roomId) {
          var _this14 = this;

          var log = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return this._platform.logger.wrapOrRun(log, "loadArchivedRoom", /*#__PURE__*/function () {
            var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee27(log) {
              var activeArchivedRoom, txn, summary, room;
              return regeneratorRuntime.wrap(function _callee27$(_context27) {
                while (1) {
                  switch (_context27.prev = _context27.next) {
                    case 0:
                      log.set("id", roomId);
                      activeArchivedRoom = _this14._activeArchivedRooms.get(roomId);

                      if (!activeArchivedRoom) {
                        _context27.next = 5;
                        break;
                      }

                      activeArchivedRoom.retain();
                      return _context27.abrupt("return", activeArchivedRoom);

                    case 5:
                      _context27.next = 7;
                      return _this14._storage.readTxn([_this14._storage.storeNames.archivedRoomSummary, _this14._storage.storeNames.roomMembers]);

                    case 7:
                      txn = _context27.sent;
                      _context27.next = 10;
                      return txn.archivedRoomSummary.get(roomId);

                    case 10:
                      summary = _context27.sent;

                      if (!summary) {
                        _context27.next = 16;
                        break;
                      }

                      room = _this14._createArchivedRoom(roomId);
                      _context27.next = 15;
                      return room.load(summary, txn, log);

                    case 15:
                      return _context27.abrupt("return", room);

                    case 16:
                    case "end":
                      return _context27.stop();
                  }
                }
              }, _callee27);
            }));

            return function (_x35) {
              return _ref9.apply(this, arguments);
            };
          }());
        }
      }, {
        key: "joinRoom",
        value: function joinRoom(roomIdOrAlias) {
          var _this15 = this;

          var log = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return this._platform.logger.wrapOrRun(log, "joinRoom", /*#__PURE__*/function () {
            var _ref10 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee28(log) {
              var body;
              return regeneratorRuntime.wrap(function _callee28$(_context28) {
                while (1) {
                  switch (_context28.prev = _context28.next) {
                    case 0:
                      _context28.next = 2;
                      return _this15._hsApi.joinIdOrAlias(roomIdOrAlias, {
                        log: log
                      }).response();

                    case 2:
                      body = _context28.sent;
                      return _context28.abrupt("return", body.room_id);

                    case 4:
                    case "end":
                      return _context28.stop();
                  }
                }
              }, _callee28);
            }));

            return function (_x36) {
              return _ref10.apply(this, arguments);
            };
          }());
        }
      }, {
        key: "fingerprintKey",
        get: function get() {
          var _this$_e2eeAccount2;

          return (_this$_e2eeAccount2 = this._e2eeAccount) === null || _this$_e2eeAccount2 === void 0 ? void 0 : _this$_e2eeAccount2.identityKeys.ed25519;
        }
      }, {
        key: "hasSecretStorageKey",
        get: function get() {
          return this._hasSecretStorageKey;
        }
      }, {
        key: "deviceId",
        get: function get() {
          return this._sessionInfo.deviceId;
        }
      }, {
        key: "userId",
        get: function get() {
          return this._sessionInfo.userId;
        }
      }, {
        key: "sessionBackup",
        get: function get() {
          return this._sessionBackup;
        }
      }, {
        key: "hasIdentity",
        get: function get() {
          return !!this._e2eeAccount;
        }
      }, {
        key: "rooms",
        get: function get() {
          return this._rooms;
        }
      }, {
        key: "invites",
        get: function get() {
          return this._invites;
        }
      }, {
        key: "syncToken",
        get: function get() {
          var _this$_syncInfo;

          return (_this$_syncInfo = this._syncInfo) === null || _this$_syncInfo === void 0 ? void 0 : _this$_syncInfo.token;
        }
        /** @internal */

      }, {
        key: "syncFilterId",
        get: function get() {
          var _this$_syncInfo2;

          return (_this$_syncInfo2 = this._syncInfo) === null || _this$_syncInfo2 === void 0 ? void 0 : _this$_syncInfo2.filterId;
        }
      }, {
        key: "user",
        get: function get() {
          return this._user;
        }
      }, {
        key: "mediaRepository",
        get: function get() {
          return this._mediaRepository;
        }
      }]);

      return Session;
    }();

    /*
    Copyright 2021 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var LoginMethod = /*#__PURE__*/function () {
      function LoginMethod(_ref) {
        var homeserver = _ref.homeserver;

        _classCallCheck(this, LoginMethod);

        this.homeserver = homeserver;
      } // eslint-disable-next-line no-unused-vars


      _createClass(LoginMethod, [{
        key: "login",
        value: function () {
          var _login = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(hsApi, deviceName, log) {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    throw "Not Implemented";

                  case 1:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function login(_x, _x2, _x3) {
            return _login.apply(this, arguments);
          }

          return login;
        }()
      }]);

      return LoginMethod;
    }();

    var PasswordLoginMethod = /*#__PURE__*/function (_LoginMethod) {
      _inherits(PasswordLoginMethod, _LoginMethod);

      var _super = _createSuper(PasswordLoginMethod);

      function PasswordLoginMethod(options) {
        var _this;

        _classCallCheck(this, PasswordLoginMethod);

        _this = _super.call(this, options);
        _this.username = options.username;
        _this.password = options.password;
        return _this;
      }

      _createClass(PasswordLoginMethod, [{
        key: "login",
        value: function () {
          var _login = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(hsApi, deviceName, log) {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return hsApi.passwordLogin(this.username, this.password, deviceName, {
                      log: log
                    }).response();

                  case 2:
                    return _context.abrupt("return", _context.sent);

                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function login(_x, _x2, _x3) {
            return _login.apply(this, arguments);
          }

          return login;
        }()
      }]);

      return PasswordLoginMethod;
    }(LoginMethod);

    var TokenLoginMethod = /*#__PURE__*/function (_LoginMethod) {
      _inherits(TokenLoginMethod, _LoginMethod);

      var _super = _createSuper(TokenLoginMethod);

      function TokenLoginMethod(options) {
        var _this;

        _classCallCheck(this, TokenLoginMethod);

        _this = _super.call(this, options);
        _this._loginToken = options.loginToken;
        return _this;
      }

      _createClass(TokenLoginMethod, [{
        key: "login",
        value: function () {
          var _login = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(hsApi, deviceName, log) {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return hsApi.tokenLogin(this._loginToken, makeTxnId(), deviceName, {
                      log: log
                    }).response();

                  case 2:
                    return _context.abrupt("return", _context.sent);

                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function login(_x, _x2, _x3) {
            return _login.apply(this, arguments);
          }

          return login;
        }()
      }]);

      return TokenLoginMethod;
    }(LoginMethod);

    /*
    Copyright 2021 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var SSOLoginHelper = /*#__PURE__*/function () {
      function SSOLoginHelper(homeserver) {
        _classCallCheck(this, SSOLoginHelper);

        this._homeserver = homeserver;
      }

      _createClass(SSOLoginHelper, [{
        key: "createSSORedirectURL",
        value: function createSSORedirectURL(returnURL) {
          return "".concat(this._homeserver, "/_matrix/client/r0/login/sso/redirect?redirectUrl=").concat(returnURL);
        }
      }, {
        key: "homeserver",
        get: function get() {
          return this._homeserver;
        }
      }]);

      return SSOLoginHelper;
    }();

    var LoadStatus = createEnum("NotLoading", "Login", "LoginFailed", "QueryAccount", // check for dehydrated device after login
    "AccountSetup", // asked to restore from dehydrated device if present, call sc.accountSetup.finish() to progress to the next stage
    "Loading", "SessionSetup", // upload e2ee keys, ...
    "Migrating", // not used atm, but would fit here
    "FirstSync", "Error", "Ready");
    var LoginFailure = createEnum("Connection", "Credentials", "Unknown");
    var SessionContainer = /*#__PURE__*/function () {
      function SessionContainer(_ref) {
        var platform = _ref.platform,
            olmPromise = _ref.olmPromise,
            workerPromise = _ref.workerPromise;

        _classCallCheck(this, SessionContainer);

        this._platform = platform;
        this._sessionStartedByReconnector = false;
        this._status = new ObservableValue(LoadStatus.NotLoading);
        this._error = null;
        this._loginFailure = null;
        this._reconnector = null;
        this._session = null;
        this._sync = null;
        this._sessionId = null;
        this._storage = null;
        this._requestScheduler = null;
        this._olmPromise = olmPromise;
        this._workerPromise = workerPromise;
        this._accountSetup = undefined;
      }

      _createClass(SessionContainer, [{
        key: "createNewSessionId",
        value: function createNewSessionId() {
          return Math.floor(this._platform.random() * Number.MAX_SAFE_INTEGER).toString();
        }
      }, {
        key: "startWithExistingSession",
        value: function () {
          var _startWithExistingSession = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(sessionId) {
            var _this = this;

            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (!(this._status.get() !== LoadStatus.NotLoading)) {
                      _context2.next = 2;
                      break;
                    }

                    return _context2.abrupt("return");

                  case 2:
                    this._status.set(LoadStatus.Loading);

                    _context2.next = 5;
                    return this._platform.logger.run("load session", /*#__PURE__*/function () {
                      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(log) {
                        var sessionInfo;
                        return regeneratorRuntime.wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                log.set("id", sessionId);
                                _context.prev = 1;
                                _context.next = 4;
                                return _this._platform.sessionInfoStorage.get(sessionId);

                              case 4:
                                sessionInfo = _context.sent;

                                if (sessionInfo) {
                                  _context.next = 7;
                                  break;
                                }

                                throw new Error("Invalid session id: " + sessionId);

                              case 7:
                                _context.next = 9;
                                return _this._loadSessionInfo(sessionInfo, null, log);

                              case 9:
                                log.set("status", _this._status.get());
                                _context.next = 17;
                                break;

                              case 12:
                                _context.prev = 12;
                                _context.t0 = _context["catch"](1);
                                log.catch(_context.t0);
                                _this._error = _context.t0;

                                _this._status.set(LoadStatus.Error);

                              case 17:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee, null, [[1, 12]]);
                      }));

                      return function (_x2) {
                        return _ref2.apply(this, arguments);
                      };
                    }());

                  case 5:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function startWithExistingSession(_x) {
            return _startWithExistingSession.apply(this, arguments);
          }

          return startWithExistingSession;
        }()
      }, {
        key: "_parseLoginOptions",
        value: function _parseLoginOptions(options, homeserver) {
          /*
          Take server response and return new object which has two props password and sso which
          implements LoginMethod
          */
          var flows = options.flows;
          var result = {
            homeserver: homeserver
          };

          var _iterator = _createForOfIteratorHelper(flows),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var flow = _step.value;

              if (flow.type === "m.login.password") {
                result.password = function (username, password) {
                  return new PasswordLoginMethod({
                    homeserver: homeserver,
                    username: username,
                    password: password
                  });
                };
              } else if (flow.type === "m.login.sso" && flows.find(function (flow) {
                return flow.type === "m.login.token";
              })) {
                result.sso = new SSOLoginHelper(homeserver);
              } else if (flow.type === "m.login.token") {
                result.token = function (loginToken) {
                  return new TokenLoginMethod({
                    homeserver: homeserver,
                    loginToken: loginToken
                  });
                };
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          return result;
        }
      }, {
        key: "queryLogin",
        value: function queryLogin(homeserver) {
          var _this2 = this;

          return new AbortableOperation( /*#__PURE__*/function () {
            var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(setAbortable) {
              var hsApi, response;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.next = 2;
                      return lookupHomeserver(homeserver, function (url, options) {
                        return setAbortable(_this2._platform.request(url, options));
                      });

                    case 2:
                      homeserver = _context3.sent;
                      hsApi = new HomeServerApi({
                        homeserver: homeserver,
                        request: _this2._platform.request
                      });
                      _context3.next = 6;
                      return setAbortable(hsApi.getLoginFlows()).response();

                    case 6:
                      response = _context3.sent;
                      return _context3.abrupt("return", _this2._parseLoginOptions(response, homeserver));

                    case 8:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3);
            }));

            return function (_x3) {
              return _ref3.apply(this, arguments);
            };
          }());
        }
      }, {
        key: "startWithLogin",
        value: function () {
          var _startWithLogin = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(loginMethod) {
            var _this3 = this;

            var _ref4,
                inspectAccountSetup,
                currentStatus,
                _args5 = arguments;

            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _ref4 = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {}, inspectAccountSetup = _ref4.inspectAccountSetup;
                    currentStatus = this._status.get();

                    if (!(currentStatus !== LoadStatus.LoginFailed && currentStatus !== LoadStatus.NotLoading && currentStatus !== LoadStatus.Error)) {
                      _context5.next = 4;
                      break;
                    }

                    return _context5.abrupt("return");

                  case 4:
                    this._resetStatus();

                    _context5.next = 7;
                    return this._platform.logger.run("login", /*#__PURE__*/function () {
                      var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(log) {
                        var clock, sessionInfo, request, hsApi, loginData, sessionId, dehydratedDevice, _dehydratedDevice;

                        return regeneratorRuntime.wrap(function _callee4$(_context4) {
                          while (1) {
                            switch (_context4.prev = _context4.next) {
                              case 0:
                                _this3._status.set(LoadStatus.Login);

                                clock = _this3._platform.clock;
                                _context4.prev = 2;
                                request = _this3._platform.request;
                                hsApi = new HomeServerApi({
                                  homeserver: loginMethod.homeserver,
                                  request: request
                                });
                                _context4.next = 7;
                                return loginMethod.login(hsApi, "Hydrogen", log);

                              case 7:
                                loginData = _context4.sent;
                                sessionId = _this3.createNewSessionId();
                                sessionInfo = {
                                  id: sessionId,
                                  deviceId: loginData.device_id,
                                  userId: loginData.user_id,
                                  homeServer: loginMethod.homeserver,
                                  // deprecate this over time
                                  homeserver: loginMethod.homeserver,
                                  accessToken: loginData.access_token,
                                  lastUsed: clock.now()
                                };
                                log.set("id", sessionId);
                                _context4.next = 18;
                                break;

                              case 13:
                                _context4.prev = 13;
                                _context4.t0 = _context4["catch"](2);
                                _this3._error = _context4.t0;

                                if (_context4.t0.name === "HomeServerError") {
                                  if (_context4.t0.errcode === "M_FORBIDDEN") {
                                    _this3._loginFailure = LoginFailure.Credentials;
                                  } else {
                                    _this3._loginFailure = LoginFailure.Unknown;
                                  }

                                  log.set("loginFailure", _this3._loginFailure);

                                  _this3._status.set(LoadStatus.LoginFailed);
                                } else if (_context4.t0.name === "ConnectionError") {
                                  _this3._loginFailure = LoginFailure.Connection;

                                  _this3._status.set(LoadStatus.LoginFailed);
                                } else {
                                  _this3._status.set(LoadStatus.Error);
                                }

                                return _context4.abrupt("return");

                              case 18:
                                if (!inspectAccountSetup) {
                                  _context4.next = 23;
                                  break;
                                }

                                _context4.next = 21;
                                return _this3._inspectAccountAfterLogin(sessionInfo, log);

                              case 21:
                                dehydratedDevice = _context4.sent;

                                if (dehydratedDevice) {
                                  sessionInfo.deviceId = dehydratedDevice.deviceId;
                                }

                              case 23:
                                _context4.next = 25;
                                return _this3._platform.sessionInfoStorage.add(sessionInfo);

                              case 25:
                                _context4.prev = 25;
                                _context4.next = 28;
                                return _this3._loadSessionInfo(sessionInfo, dehydratedDevice, log);

                              case 28:
                                log.set("status", _this3._status.get());
                                _context4.next = 37;
                                break;

                              case 31:
                                _context4.prev = 31;
                                _context4.t1 = _context4["catch"](25);
                                log.catch(_context4.t1); // free olm Account that might be contained

                                (_dehydratedDevice = dehydratedDevice) === null || _dehydratedDevice === void 0 ? void 0 : _dehydratedDevice.dispose();
                                _this3._error = _context4.t1;

                                _this3._status.set(LoadStatus.Error);

                              case 37:
                              case "end":
                                return _context4.stop();
                            }
                          }
                        }, _callee4, null, [[2, 13], [25, 31]]);
                      }));

                      return function (_x5) {
                        return _ref5.apply(this, arguments);
                      };
                    }());

                  case 7:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));

          function startWithLogin(_x4) {
            return _startWithLogin.apply(this, arguments);
          }

          return startWithLogin;
        }()
      }, {
        key: "_loadSessionInfo",
        value: function () {
          var _loadSessionInfo2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(sessionInfo, dehydratedDevice, log) {
            var _this4 = this;

            var clock, hsApi, filteredSessionInfo, olm, olmWorker, mediaRepository, lastVersionsResponse, d;
            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    log.set("appVersion", this._platform.version);
                    clock = this._platform.clock;
                    this._sessionStartedByReconnector = false;

                    this._status.set(LoadStatus.Loading);

                    this._reconnector = new Reconnector({
                      onlineStatus: this._platform.onlineStatus,
                      retryDelay: new ExponentialRetryDelay(clock.createTimeout),
                      createMeasure: clock.createMeasure
                    });
                    hsApi = new HomeServerApi({
                      homeserver: sessionInfo.homeServer,
                      accessToken: sessionInfo.accessToken,
                      request: this._platform.request,
                      reconnector: this._reconnector
                    });
                    this._sessionId = sessionInfo.id;
                    _context7.next = 9;
                    return this._platform.storageFactory.create(sessionInfo.id, log);

                  case 9:
                    this._storage = _context7.sent;
                    // no need to pass access token to session
                    filteredSessionInfo = {
                      id: sessionInfo.id,
                      deviceId: sessionInfo.deviceId,
                      userId: sessionInfo.userId,
                      homeserver: sessionInfo.homeServer
                    };
                    _context7.next = 13;
                    return this._olmPromise;

                  case 13:
                    olm = _context7.sent;
                    olmWorker = null;

                    if (!this._workerPromise) {
                      _context7.next = 19;
                      break;
                    }

                    _context7.next = 18;
                    return this._workerPromise;

                  case 18:
                    olmWorker = _context7.sent;

                  case 19:
                    this._requestScheduler = new RequestScheduler({
                      hsApi: hsApi,
                      clock: clock
                    });

                    this._requestScheduler.start();

                    mediaRepository = new MediaRepository({
                      homeserver: sessionInfo.homeServer,
                      platform: this._platform
                    });
                    this._session = new Session$1({
                      storage: this._storage,
                      sessionInfo: filteredSessionInfo,
                      hsApi: this._requestScheduler.hsApi,
                      olm: olm,
                      olmWorker: olmWorker,
                      mediaRepository: mediaRepository,
                      platform: this._platform
                    });
                    _context7.next = 25;
                    return this._session.load(log);

                  case 25:
                    if (!dehydratedDevice) {
                      _context7.next = 32;
                      break;
                    }

                    _context7.next = 28;
                    return log.wrap("dehydrateIdentity", function (log) {
                      return _this4._session.dehydrateIdentity(dehydratedDevice, log);
                    });

                  case 28:
                    _context7.next = 30;
                    return this._session.setupDehydratedDevice(dehydratedDevice.key, log);

                  case 30:
                    _context7.next = 36;
                    break;

                  case 32:
                    if (this._session.hasIdentity) {
                      _context7.next = 36;
                      break;
                    }

                    this._status.set(LoadStatus.SessionSetup);

                    _context7.next = 36;
                    return log.wrap("createIdentity", function (log) {
                      return _this4._session.createIdentity(log);
                    });

                  case 36:
                    this._sync = new Sync({
                      hsApi: this._requestScheduler.hsApi,
                      storage: this._storage,
                      session: this._session,
                      logger: this._platform.logger
                    }); // notify sync and session when back online

                    this._reconnectSubscription = this._reconnector.connectionStatus.subscribe(function (state) {
                      if (state === ConnectionStatus.Online) {
                        _this4._platform.logger.runDetached("reconnect", /*#__PURE__*/function () {
                          var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(log) {
                            var d;
                            return regeneratorRuntime.wrap(function _callee6$(_context6) {
                              while (1) {
                                switch (_context6.prev = _context6.next) {
                                  case 0:
                                    // needs to happen before sync and session or it would abort all requests
                                    _this4._requestScheduler.start();

                                    _this4._sync.start();

                                    _this4._sessionStartedByReconnector = true;
                                    d = dehydratedDevice;
                                    dehydratedDevice = undefined;
                                    _context6.next = 7;
                                    return log.wrap("session start", function (log) {
                                      return _this4._session.start(_this4._reconnector.lastVersionsResponse, d, log);
                                    });

                                  case 7:
                                  case "end":
                                    return _context6.stop();
                                }
                              }
                            }, _callee6);
                          }));

                          return function (_x9) {
                            return _ref6.apply(this, arguments);
                          };
                        }());
                      }
                    });
                    _context7.next = 40;
                    return log.wrap("wait first sync", function () {
                      return _this4._waitForFirstSync();
                    });

                  case 40:
                    if (!this._isDisposed) {
                      _context7.next = 42;
                      break;
                    }

                    return _context7.abrupt("return");

                  case 42:
                    this._status.set(LoadStatus.Ready); // if the sync failed, and then the reconnector
                    // restored the connection, it would have already
                    // started to session, so check first
                    // to prevent an extra /versions request


                    if (this._sessionStartedByReconnector) {
                      _context7.next = 53;
                      break;
                    }

                    _context7.next = 46;
                    return hsApi.versions({
                      timeout: 10000,
                      log: log
                    }).response();

                  case 46:
                    lastVersionsResponse = _context7.sent;

                    if (!this._isDisposed) {
                      _context7.next = 49;
                      break;
                    }

                    return _context7.abrupt("return");

                  case 49:
                    d = dehydratedDevice;
                    dehydratedDevice = undefined; // log as ref as we don't want to await it

                    _context7.next = 53;
                    return log.wrap("session start", function (log) {
                      return _this4._session.start(lastVersionsResponse, d, log);
                    });

                  case 53:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this);
          }));

          function _loadSessionInfo(_x6, _x7, _x8) {
            return _loadSessionInfo2.apply(this, arguments);
          }

          return _loadSessionInfo;
        }()
      }, {
        key: "_waitForFirstSync",
        value: function () {
          var _waitForFirstSync2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
            var _this5 = this;

            return regeneratorRuntime.wrap(function _callee8$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    this._sync.start();

                    this._status.set(LoadStatus.FirstSync); // only transition into Ready once the first sync has succeeded


                    this._waitForFirstSyncHandle = this._sync.status.waitFor(function (s) {
                      if (s === SyncStatus.Stopped) {
                        var _this5$_sync$error;

                        // keep waiting if there is a ConnectionError
                        // as the reconnector above will call 
                        // sync.start again to retry in this case
                        return ((_this5$_sync$error = _this5._sync.error) === null || _this5$_sync$error === void 0 ? void 0 : _this5$_sync$error.name) !== "ConnectionError";
                      }

                      return s === SyncStatus.Syncing;
                    });
                    _context8.prev = 3;
                    _context8.next = 6;
                    return this._waitForFirstSyncHandle.promise;

                  case 6:
                    if (!(this._sync.status.get() === SyncStatus.Stopped && this._sync.error)) {
                      _context8.next = 8;
                      break;
                    }

                    throw this._sync.error;

                  case 8:
                    _context8.next = 15;
                    break;

                  case 10:
                    _context8.prev = 10;
                    _context8.t0 = _context8["catch"](3);

                    if (!(_context8.t0.name === "AbortError")) {
                      _context8.next = 14;
                      break;
                    }

                    return _context8.abrupt("return");

                  case 14:
                    throw _context8.t0;

                  case 15:
                    _context8.prev = 15;
                    this._waitForFirstSyncHandle = null;
                    return _context8.finish(15);

                  case 18:
                  case "end":
                    return _context8.stop();
                }
              }
            }, _callee8, this, [[3, 10, 15, 18]]);
          }));

          function _waitForFirstSync() {
            return _waitForFirstSync2.apply(this, arguments);
          }

          return _waitForFirstSync;
        }()
      }, {
        key: "_inspectAccountAfterLogin",
        value: function _inspectAccountAfterLogin(sessionInfo, log) {
          var _this6 = this;

          return log.wrap("inspectAccount", /*#__PURE__*/function () {
            var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(log) {
              var hsApi, olm, encryptedDehydratedDevice, _this6$_accountSetup, resolveStageFinish, promiseStageFinish, dehydratedDevice;

              return regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      _this6._status.set(LoadStatus.QueryAccount);

                      hsApi = new HomeServerApi({
                        homeserver: sessionInfo.homeServer,
                        accessToken: sessionInfo.accessToken,
                        request: _this6._platform.request
                      });
                      _context9.next = 4;
                      return _this6._olmPromise;

                    case 4:
                      olm = _context9.sent;
                      _context9.prev = 5;
                      _context9.next = 8;
                      return getDehydratedDevice(hsApi, olm, _this6._platform, log);

                    case 8:
                      encryptedDehydratedDevice = _context9.sent;
                      _context9.next = 18;
                      break;

                    case 11:
                      _context9.prev = 11;
                      _context9.t0 = _context9["catch"](5);

                      if (!(_context9.t0.name === "HomeServerError")) {
                        _context9.next = 17;
                        break;
                      }

                      log.set("not_supported", true);
                      _context9.next = 18;
                      break;

                    case 17:
                      throw _context9.t0;

                    case 18:
                      if (!encryptedDehydratedDevice) {
                        _context9.next = 27;
                        break;
                      }

                      promiseStageFinish = new Promise(function (r) {
                        return resolveStageFinish = r;
                      });
                      _this6._accountSetup = new AccountSetup(encryptedDehydratedDevice, resolveStageFinish);

                      _this6._status.set(LoadStatus.AccountSetup);

                      _context9.next = 24;
                      return promiseStageFinish;

                    case 24:
                      dehydratedDevice = (_this6$_accountSetup = _this6._accountSetup) === null || _this6$_accountSetup === void 0 ? void 0 : _this6$_accountSetup._dehydratedDevice;
                      _this6._accountSetup = null;
                      return _context9.abrupt("return", dehydratedDevice);

                    case 27:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9, null, [[5, 11]]);
            }));

            return function (_x10) {
              return _ref7.apply(this, arguments);
            };
          }());
        }
      }, {
        key: "logout",
        value: function logout() {
          var _this7 = this;

          return this._platform.logger.run("logout", /*#__PURE__*/function () {
            var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(log) {
              var _this7$_session;

              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      _context10.prev = 0;
                      _context10.next = 3;
                      return (_this7$_session = _this7._session) === null || _this7$_session === void 0 ? void 0 : _this7$_session.logout(log);

                    case 3:
                      _context10.next = 7;
                      break;

                    case 5:
                      _context10.prev = 5;
                      _context10.t0 = _context10["catch"](0);

                    case 7:
                      _context10.next = 9;
                      return _this7.deleteSession(log);

                    case 9:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10, null, [[0, 5]]);
            }));

            return function (_x11) {
              return _ref8.apply(this, arguments);
            };
          }());
        }
      }, {
        key: "dispose",
        value: function dispose() {
          if (this._reconnectSubscription) {
            this._reconnectSubscription();

            this._reconnectSubscription = null;
          }

          this._reconnector = null;

          if (this._requestScheduler) {
            this._requestScheduler.stop();

            this._requestScheduler = null;
          }

          if (this._sync) {
            this._sync.stop();

            this._sync = null;
          }

          if (this._session) {
            this._session.dispose();

            this._session = null;
          }

          if (this._waitForFirstSyncHandle) {
            this._waitForFirstSyncHandle.dispose();

            this._waitForFirstSyncHandle = null;
          }

          if (this._storage) {
            this._storage.close();

            this._storage = null;
          }
        }
      }, {
        key: "deleteSession",
        value: function () {
          var _deleteSession = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(log) {
            var _this8 = this;

            return regeneratorRuntime.wrap(function _callee11$(_context11) {
              while (1) {
                switch (_context11.prev = _context11.next) {
                  case 0:
                    if (!this._sessionId) {
                      _context11.next = 5;
                      break;
                    }

                    // need to dispose first, so the storage is closed,
                    // and also first sync finishing won't call Session.start anymore,
                    // which assumes that the storage works.
                    this.dispose(); // if one fails, don't block the other from trying
                    // also, run in parallel

                    _context11.next = 4;
                    return Promise.all([log.wrap("storageFactory", function () {
                      return _this8._platform.storageFactory.delete(_this8._sessionId);
                    }), log.wrap("sessionInfoStorage", function () {
                      return _this8._platform.sessionInfoStorage.delete(_this8._sessionId);
                    })]);

                  case 4:
                    this._sessionId = null;

                  case 5:
                  case "end":
                    return _context11.stop();
                }
              }
            }, _callee11, this);
          }));

          function deleteSession(_x12) {
            return _deleteSession.apply(this, arguments);
          }

          return deleteSession;
        }()
      }, {
        key: "_resetStatus",
        value: function _resetStatus() {
          this._status.set(LoadStatus.NotLoading);

          this._error = null;
          this._loginFailure = null;
        }
      }, {
        key: "sessionId",
        get: function get() {
          return this._sessionId;
        }
      }, {
        key: "accountSetup",
        get: function get() {
          return this._accountSetup;
        }
      }, {
        key: "loadStatus",
        get: function get() {
          return this._status;
        }
      }, {
        key: "loadError",
        get: function get() {
          return this._error;
        }
      }, {
        key: "loginFailure",
        get: function get() {
          return this._loginFailure;
        }
        /** only set at loadStatus InitialSync, CatchupSync or Ready */

      }, {
        key: "sync",
        get: function get() {
          return this._sync;
        }
        /** only set at loadStatus InitialSync, CatchupSync or Ready */

      }, {
        key: "session",
        get: function get() {
          return this._session;
        }
      }, {
        key: "reconnector",
        get: function get() {
          return this._reconnector;
        }
      }, {
        key: "_isDisposed",
        get: function get() {
          return !this._reconnector;
        }
      }]);

      return SessionContainer;
    }();

    var AccountSetup = /*#__PURE__*/function () {
      function AccountSetup(encryptedDehydratedDevice, finishStage) {
        _classCallCheck(this, AccountSetup);

        this._encryptedDehydratedDevice = encryptedDehydratedDevice;
        this._dehydratedDevice = undefined;
        this._finishStage = finishStage;
      }

      _createClass(AccountSetup, [{
        key: "finish",
        value: function finish(dehydratedDevice) {
          this._dehydratedDevice = dehydratedDevice;

          this._finishStage();
        }
      }, {
        key: "encryptedDehydratedDevice",
        get: function get() {
          return this._encryptedDehydratedDevice;
        }
      }]);

      return AccountSetup;
    }();

    var ViewModel = /*#__PURE__*/function (_EventEmitter) {
      _inherits(ViewModel, _EventEmitter);

      var _super = _createSuper(ViewModel);

      function ViewModel() {
        var _this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, ViewModel);

        _this = _super.call(this);
        _this.disposables = null;
        _this._isDisposed = false;
        _this._options = options;
        return _this;
      }

      _createClass(ViewModel, [{
        key: "childOptions",
        value: function childOptions(explicitOptions) {
          var _this$_options = this._options,
              navigation = _this$_options.navigation,
              urlCreator = _this$_options.urlCreator,
              platform = _this$_options.platform;
          return Object.assign({
            navigation: navigation,
            urlCreator: urlCreator,
            platform: platform
          }, explicitOptions);
        } // makes it easier to pass through dependencies of a sub-view model

      }, {
        key: "getOption",
        value: function getOption(name) {
          return this._options[name];
        }
      }, {
        key: "track",
        value: function track(disposable) {
          if (!this.disposables) {
            this.disposables = new Disposables();
          }

          return this.disposables.track(disposable);
        }
      }, {
        key: "untrack",
        value: function untrack(disposable) {
          if (this.disposables) {
            return this.disposables.untrack(disposable);
          }

          return null;
        }
      }, {
        key: "dispose",
        value: function dispose() {
          if (this.disposables) {
            this.disposables.dispose();
          }

          this._isDisposed = true;
        }
      }, {
        key: "disposeTracked",
        value: function disposeTracked(disposable) {
          if (this.disposables) {
            return this.disposables.disposeTracked(disposable);
          }

          return null;
        } // TODO: this will need to support binding
        // if any of the expr is a function, assume the function is a binding, and return a binding function ourselves
        // 
        // translated string should probably always be bindings, unless we're fine with a refresh when changing the language?
        // we probably are, if we're using routing with a url, we could just refresh.

      }, {
        key: "i18n",
        value: function i18n(parts) {
          // just concat for now
          var result = "";

          for (var i = 0; i < parts.length; ++i) {
            result = result + parts[i];

            if (i < (arguments.length <= 1 ? 0 : arguments.length - 1)) {
              result = result + (i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1]);
            }
          }

          return result;
        }
      }, {
        key: "updateOptions",
        value: function updateOptions(options) {
          this._options = Object.assign(this._options, options);
        }
      }, {
        key: "emitChange",
        value: function emitChange(changedProps) {
          if (this._options.emitChange) {
            this._options.emitChange(changedProps);
          } else {
            this.emit("change", changedProps);
          }
        }
      }, {
        key: "isDisposed",
        get: function get() {
          return this._isDisposed;
        }
      }, {
        key: "platform",
        get: function get() {
          return this._options.platform;
        }
      }, {
        key: "clock",
        get: function get() {
          return this._options.platform.clock;
        }
      }, {
        key: "logger",
        get: function get() {
          return this.platform.logger;
        }
        /**
         * The url router, only meant to be used to create urls with from view models.
         * @return {URLRouter}
         */

      }, {
        key: "urlCreator",
        get: function get() {
          return this._options.urlCreator;
        }
      }, {
        key: "navigation",
        get: function get() {
          return this._options.navigation;
        }
      }]);

      return ViewModel;
    }(EventEmitter);

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function avatarInitials(name) {
      var firstChar = name.charAt(0);

      if (firstChar === "!" || firstChar === "@" || firstChar === "#") {
        firstChar = name.charAt(1);
      }

      return firstChar.toUpperCase();
    }
    /**
     * calculates a numeric hash for a given string
     *
     * @param {string} str string to hash
     *
     * @return {number}
     */

    function hashCode(str) {
      var hash = 0;
      var i;
      var chr;

      if (str.length === 0) {
        return hash;
      }

      for (i = 0; i < str.length; i++) {
        chr = str.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash |= 0;
      }

      return Math.abs(hash);
    }

    function getIdentifierColorNumber(id) {
      return hashCode(id) % 8 + 1;
    }
    function getAvatarHttpUrl(avatarUrl, cssSize, platform, mediaRepository) {
      if (avatarUrl) {
        var imageSize = cssSize * platform.devicePixelRatio;
        return mediaRepository.mxcUrlThumbnail(avatarUrl, imageSize, imageSize, "crop");
      }

      return null;
    }

    var KIND_ORDER = ["invite", "room"];
    var BaseTileViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(BaseTileViewModel, _ViewModel);

      var _super = _createSuper(BaseTileViewModel);

      function BaseTileViewModel(options) {
        var _this;

        _classCallCheck(this, BaseTileViewModel);

        _this = _super.call(this, options);
        _this._isOpen = false;
        _this._hidden = false;
        return _this;
      }

      _createClass(BaseTileViewModel, [{
        key: "close",
        value: function close() {
          if (this._isOpen) {
            this._isOpen = false;
            this.emitChange("isOpen");
          }
        }
      }, {
        key: "open",
        value: function open() {
          if (!this._isOpen) {
            this._isOpen = true;
            this.emitChange("isOpen");
          }
        }
      }, {
        key: "compare",
        value: function compare(other) {
          if (other.kind !== this.kind) {
            return KIND_ORDER.indexOf(this.kind) - KIND_ORDER.indexOf(other.kind);
          }

          return 0;
        } // Avatar view model contract

      }, {
        key: "avatarUrl",
        value: function avatarUrl(size) {
          return getAvatarHttpUrl(this._avatarSource.avatarUrl, size, this.platform, this._avatarSource.mediaRepository);
        }
      }, {
        key: "hidden",
        get: function get() {
          return this._hidden;
        },
        set: function set(value) {
          if (value !== this._hidden) {
            this._hidden = value;
            this.emitChange("hidden");
          }
        }
      }, {
        key: "isOpen",
        get: function get() {
          return this._isOpen;
        }
      }, {
        key: "avatarLetter",
        get: function get() {
          return avatarInitials(this.name);
        }
      }, {
        key: "avatarColorNumber",
        get: function get() {
          return getIdentifierColorNumber(this._avatarSource.avatarColorId);
        }
      }, {
        key: "avatarTitle",
        get: function get() {
          return this.name;
        }
      }]);

      return BaseTileViewModel;
    }(ViewModel);

    function _templateObject$m() {
      var data = _taggedTemplateLiteral(["Empty Room"]);

      _templateObject$m = function _templateObject() {
        return data;
      };

      return data;
    }
    var RoomTileViewModel = /*#__PURE__*/function (_BaseTileViewModel) {
      _inherits(RoomTileViewModel, _BaseTileViewModel);

      var _super = _createSuper(RoomTileViewModel);

      function RoomTileViewModel(options) {
        var _this;

        _classCallCheck(this, RoomTileViewModel);

        _this = _super.call(this, options);
        var room = options.room;
        _this._room = room;
        _this._url = _this.urlCreator.openRoomActionUrl(_this._room.id);
        return _this;
      }

      _createClass(RoomTileViewModel, [{
        key: "compare",
        value: function compare(other) {
          var parentComparison = _get(_getPrototypeOf(RoomTileViewModel.prototype), "compare", this).call(this, other);

          if (parentComparison !== 0) {
            return parentComparison;
          }
          /*
          put unread rooms first
          then put rooms with a timestamp first, and sort by name
          then sort by name for rooms without a timestamp
           */


          var myRoom = this._room;
          var theirRoom = other._room;

          if (myRoom.isLowPriority !== theirRoom.isLowPriority) {
            if (myRoom.isLowPriority) {
              return 1;
            }

            return -1;
          }

          var myTimestamp = myRoom.lastMessageTimestamp;
          var theirTimestamp = theirRoom.lastMessageTimestamp;
          var myTimestampValid = Number.isSafeInteger(myTimestamp);
          var theirTimestampValid = Number.isSafeInteger(theirTimestamp); // if either does not have a timestamp, put the one with a timestamp first

          if (myTimestampValid !== theirTimestampValid) {
            if (!theirTimestampValid) {
              return -1;
            }

            return 1;
          }

          var timeDiff = theirTimestamp - myTimestamp;

          if (timeDiff === 0 || !theirTimestampValid || !myTimestampValid) {
            // sort alphabetically
            var nameCmp = this.name.localeCompare(other.name);

            if (nameCmp === 0) {
              return this._room.id.localeCompare(other._room.id);
            }

            return nameCmp;
          }

          return timeDiff;
        }
      }, {
        key: "kind",
        get: function get() {
          return "room";
        }
      }, {
        key: "url",
        get: function get() {
          return this._url;
        }
      }, {
        key: "isUnread",
        get: function get() {
          return this._room.isUnread;
        }
      }, {
        key: "name",
        get: function get() {
          return this._room.name || this.i18n(_templateObject$m());
        }
      }, {
        key: "badgeCount",
        get: function get() {
          return this._room.notificationCount;
        }
      }, {
        key: "isHighlighted",
        get: function get() {
          return this._room.highlightCount !== 0;
        }
      }, {
        key: "_avatarSource",
        get: function get() {
          return this._room;
        }
      }]);

      return RoomTileViewModel;
    }(BaseTileViewModel);

    var InviteTileViewModel = /*#__PURE__*/function (_BaseTileViewModel) {
      _inherits(InviteTileViewModel, _BaseTileViewModel);

      var _super = _createSuper(InviteTileViewModel);

      function InviteTileViewModel(options) {
        var _this;

        _classCallCheck(this, InviteTileViewModel);

        _this = _super.call(this, options);
        var invite = options.invite;
        _this._invite = invite;
        _this._url = _this.urlCreator.openRoomActionUrl(_this._invite.id);
        return _this;
      }

      _createClass(InviteTileViewModel, [{
        key: "compare",
        value: function compare(other) {
          var parentComparison = _get(_getPrototypeOf(InviteTileViewModel.prototype), "compare", this).call(this, other);

          if (parentComparison !== 0) {
            return parentComparison;
          }

          return other._invite.timestamp - this._invite.timestamp;
        }
      }, {
        key: "busy",
        get: function get() {
          return this._invite.accepting || this._invite.rejecting;
        }
      }, {
        key: "kind",
        get: function get() {
          return "invite";
        }
      }, {
        key: "url",
        get: function get() {
          return this._url;
        }
      }, {
        key: "name",
        get: function get() {
          return this._invite.name;
        }
      }, {
        key: "_avatarSource",
        get: function get() {
          return this._invite;
        }
      }]);

      return InviteTileViewModel;
    }(BaseTileViewModel);

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var RoomFilter = /*#__PURE__*/function () {
      function RoomFilter(query) {
        _classCallCheck(this, RoomFilter);

        this._parts = query.split(" ").map(function (s) {
          return s.toLowerCase().trim();
        });
      }

      _createClass(RoomFilter, [{
        key: "matches",
        value: function matches(roomTileVM) {
          var name = roomTileVM.name.toLowerCase();
          return this._parts.every(function (p) {
            return name.includes(p);
          });
        }
      }]);

      return RoomFilter;
    }();

    var ApplyMap = /*#__PURE__*/function (_BaseObservableMap) {
      _inherits(ApplyMap, _BaseObservableMap);

      var _super = _createSuper(ApplyMap);

      function ApplyMap(source, apply) {
        var _this;

        _classCallCheck(this, ApplyMap);

        _this = _super.call(this);
        _this._source = source;
        _this._apply = apply;
        _this._subscription = null;
        return _this;
      }

      _createClass(ApplyMap, [{
        key: "hasApply",
        value: function hasApply() {
          return !!this._apply;
        }
      }, {
        key: "setApply",
        value: function setApply(apply) {
          this._apply = apply;

          if (apply) {
            this.applyOnce(this._apply);
          }
        }
      }, {
        key: "applyOnce",
        value: function applyOnce(apply) {
          var _iterator = _createForOfIteratorHelper(this._source),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _slicedToArray(_step.value, 2),
                  key = _step$value[0],
                  value = _step$value[1];

              apply(key, value);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }, {
        key: "onAdd",
        value: function onAdd(key, value) {
          if (this._apply) {
            this._apply(key, value);
          }

          this.emitAdd(key, value);
        }
      }, {
        key: "onRemove",
        value: function onRemove(key, value) {
          this.emitRemove(key, value);
        }
      }, {
        key: "onUpdate",
        value: function onUpdate(key, value, params) {
          if (this._apply) {
            this._apply(key, value, params);
          }

          this.emitUpdate(key, value, params);
        }
      }, {
        key: "onSubscribeFirst",
        value: function onSubscribeFirst() {
          this._subscription = this._source.subscribe(this);

          if (this._apply) {
            this.applyOnce(this._apply);
          }

          _get(_getPrototypeOf(ApplyMap.prototype), "onSubscribeFirst", this).call(this);
        }
      }, {
        key: "onUnsubscribeLast",
        value: function onUnsubscribeLast() {
          _get(_getPrototypeOf(ApplyMap.prototype), "onUnsubscribeLast", this).call(this);

          this._subscription = this._subscription();
        }
      }, {
        key: "onReset",
        value: function onReset() {
          if (this._apply) {
            this.applyOnce(this._apply);
          }

          this.emitReset();
        }
      }, {
        key: Symbol.iterator,
        value: function value() {
          return this._source[Symbol.iterator]();
        }
      }, {
        key: "get",
        value: function get(key) {
          return this._source.get(key);
        }
      }, {
        key: "size",
        get: function get() {
          return this._source.size;
        }
      }]);

      return ApplyMap;
    }(BaseObservableMap);

    var Navigation = /*#__PURE__*/function () {
      function Navigation(allowsChild) {
        _classCallCheck(this, Navigation);

        this._allowsChild = allowsChild;
        this._path = new Path([], allowsChild);
        this._observables = new Map();
        this._pathObservable = new ObservableValue(this._path);
      }

      _createClass(Navigation, [{
        key: "push",
        value: function push(type) {
          var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
          return this.applyPath(this.path.with(new Segment(type, value)));
        }
      }, {
        key: "applyPath",
        value: function applyPath(path) {
          // Path is not exported, so you can only create a Path through Navigation,
          // so we assume it respects the allowsChild rules
          var oldPath = this._path;
          this._path = path; // clear values not in the new path in reverse order of path

          for (var i = oldPath.segments.length - 1; i >= 0; i -= 1) {
            var segment = oldPath.segments[i];

            if (!this._path.get(segment.type)) {
              var observable = this._observables.get(segment.type);

              observable === null || observable === void 0 ? void 0 : observable.emitIfChanged();
            }
          } // change values in order of path


          var _iterator = _createForOfIteratorHelper(this._path.segments),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _segment = _step.value;

              var _observable = this._observables.get(_segment.type);

              _observable === null || _observable === void 0 ? void 0 : _observable.emitIfChanged();
            } // to observe the whole path having changed
            // Since paths are immutable,
            // we can just use set here which will compare the references

          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          this._pathObservable.set(this._path);
        }
      }, {
        key: "observe",
        value: function observe(type) {
          var observable = this._observables.get(type);

          if (!observable) {
            observable = new SegmentObservable(this, type);

            this._observables.set(type, observable);
          }

          return observable;
        }
      }, {
        key: "pathFrom",
        value: function pathFrom(segments) {
          var parent;
          var i;

          for (i = 0; i < segments.length; i += 1) {
            if (!this._allowsChild(parent, segments[i])) {
              return new Path(segments.slice(0, i), this._allowsChild);
            }

            parent = segments[i];
          }

          return new Path(segments, this._allowsChild);
        }
      }, {
        key: "segment",
        value: function segment(type, value) {
          return new Segment(type, value);
        }
      }, {
        key: "pathObservable",
        get: function get() {
          return this._pathObservable;
        }
      }, {
        key: "path",
        get: function get() {
          return this._path;
        }
      }]);

      return Navigation;
    }();

    function segmentValueEqual(a, b) {
      if (a === b) {
        return true;
      } // allow (sparse) arrays


      if (Array.isArray(a) && Array.isArray(b)) {
        var len = Math.max(a.length, b.length);

        for (var i = 0; i < len; i += 1) {
          if (a[i] !== b[i]) {
            return false;
          }
        }

        return true;
      }

      return false;
    }

    var Segment = function Segment(type, value) {
      _classCallCheck(this, Segment);

      this.type = type;
      this.value = value === undefined ? true : value;
    };

    var Path = /*#__PURE__*/function () {
      function Path() {
        var segments = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var allowsChild = arguments.length > 1 ? arguments[1] : undefined;

        _classCallCheck(this, Path);

        this._segments = segments;
        this._allowsChild = allowsChild;
      }

      _createClass(Path, [{
        key: "clone",
        value: function clone() {
          return new Path(this._segments.slice(), this._allowsChild);
        }
      }, {
        key: "with",
        value: function _with(segment) {
          var index = this._segments.length - 1;

          do {
            if (this._allowsChild(this._segments[index], segment)) {
              // pop the elements that didn't allow the new segment as a child
              var newSegments = this._segments.slice(0, index + 1);

              newSegments.push(segment);
              return new Path(newSegments, this._allowsChild);
            }

            index -= 1;
          } while (index >= -1); // allow -1 as well so we check if the segment is allowed as root


          return null;
        }
      }, {
        key: "until",
        value: function until(type) {
          var index = this._segments.findIndex(function (s) {
            return s.type === type;
          });

          if (index !== -1) {
            return new Path(this._segments.slice(0, index + 1), this._allowsChild);
          }

          return new Path([], this._allowsChild);
        }
      }, {
        key: "get",
        value: function get(type) {
          return this._segments.find(function (s) {
            return s.type === type;
          });
        }
      }, {
        key: "replace",
        value: function replace(segment) {
          var index = this._segments.findIndex(function (s) {
            return s.type === segment.type;
          });

          if (index !== -1) {
            var parent = this._segments[index - 1];

            if (this._allowsChild(parent, segment)) {
              var child = this._segments[index + 1];

              if (!child || this._allowsChild(segment, child)) {
                var newSegments = this._segments.slice();

                newSegments[index] = segment;
                return new Path(newSegments, this._allowsChild);
              }
            }
          }

          return null;
        }
      }, {
        key: "segments",
        get: function get() {
          return this._segments;
        }
      }]);

      return Path;
    }();
    /**
     * custom observable so it always returns what is in navigation.path, even if we haven't emitted the change yet.
     * This ensures that observers of a segment can also read the most recent value of other segments.
     */


    var SegmentObservable = /*#__PURE__*/function (_BaseObservableValue) {
      _inherits(SegmentObservable, _BaseObservableValue);

      var _super = _createSuper(SegmentObservable);

      function SegmentObservable(navigation, type) {
        var _navigation$path$get;

        var _this;

        _classCallCheck(this, SegmentObservable);

        _this = _super.call(this);
        _this._navigation = navigation;
        _this._type = type;
        _this._lastSetValue = (_navigation$path$get = navigation.path.get(type)) === null || _navigation$path$get === void 0 ? void 0 : _navigation$path$get.value;
        return _this;
      }

      _createClass(SegmentObservable, [{
        key: "get",
        value: function get() {
          var path = this._navigation.path;
          var segment = path.get(this._type);
          var value = segment === null || segment === void 0 ? void 0 : segment.value;
          return value;
        }
      }, {
        key: "emitIfChanged",
        value: function emitIfChanged() {
          var newValue = this.get();

          if (!segmentValueEqual(newValue, this._lastSetValue)) {
            this._lastSetValue = newValue;
            this.emit(newValue);
          }
        }
      }]);

      return SegmentObservable;
    }(BaseObservableValue);

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var URLRouter = /*#__PURE__*/function () {
      function URLRouter(_ref) {
        var history = _ref.history,
            navigation = _ref.navigation,
            parseUrlPath = _ref.parseUrlPath,
            stringifyPath = _ref.stringifyPath;

        _classCallCheck(this, URLRouter);

        this._history = history;
        this._navigation = navigation;
        this._parseUrlPath = parseUrlPath;
        this._stringifyPath = stringifyPath;
        this._subscription = null;
        this._pathSubscription = null;
        this._isApplyingUrl = false;
        this._defaultSessionId = this._getLastSessionId();
      }

      _createClass(URLRouter, [{
        key: "_getLastSessionId",
        value: function _getLastSessionId() {
          var _navPath$get;

          var navPath = this._urlAsNavPath(this._history.getLastUrl() || "");

          var sessionId = (_navPath$get = navPath.get("session")) === null || _navPath$get === void 0 ? void 0 : _navPath$get.value;

          if (typeof sessionId === "string") {
            return sessionId;
          }

          return null;
        }
      }, {
        key: "attach",
        value: function attach() {
          var _this = this;

          this._subscription = this._history.subscribe(function (url) {
            return _this._applyUrl(url);
          }); // subscribe to path before applying initial url
          // so redirects in _applyNavPathToHistory are reflected in url bar

          this._pathSubscription = this._navigation.pathObservable.subscribe(function (path) {
            return _this._applyNavPathToHistory(path);
          });

          this._applyUrl(this._history.get());
        }
      }, {
        key: "dispose",
        value: function dispose() {
          this._subscription = this._subscription();
          this._pathSubscription = this._pathSubscription();
        }
      }, {
        key: "_applyNavPathToHistory",
        value: function _applyNavPathToHistory(path) {
          var url = this.urlForPath(path);

          if (url !== this._history.get()) {
            if (this._isApplyingUrl) {
              // redirect
              this._history.replaceUrlSilently(url);
            } else {
              this._history.pushUrlSilently(url);
            }
          }
        }
      }, {
        key: "_applyNavPathToNavigation",
        value: function _applyNavPathToNavigation(navPath) {
          // this will cause _applyNavPathToHistory to be called,
          // so set a flag whether this request came from ourselves
          // (in which case it is a redirect if the url does not match the current one)
          this._isApplyingUrl = true;

          this._navigation.applyPath(navPath);

          this._isApplyingUrl = false;
        }
      }, {
        key: "_urlAsNavPath",
        value: function _urlAsNavPath(url) {
          var urlPath = this._history.urlAsPath(url);

          return this._navigation.pathFrom(this._parseUrlPath(urlPath, this._navigation.path, this._defaultSessionId));
        }
      }, {
        key: "_applyUrl",
        value: function _applyUrl(url) {
          var navPath = this._urlAsNavPath(url);

          this._applyNavPathToNavigation(navPath);
        }
      }, {
        key: "pushUrl",
        value: function pushUrl(url) {
          this._history.pushUrl(url);
        }
      }, {
        key: "tryRestoreLastUrl",
        value: function tryRestoreLastUrl() {
          var lastNavPath = this._urlAsNavPath(this._history.getLastUrl() || "");

          if (lastNavPath.segments.length !== 0) {
            this._applyNavPathToNavigation(lastNavPath);

            return true;
          }

          return false;
        }
      }, {
        key: "urlForSegments",
        value: function urlForSegments(segments) {
          var path = this._navigation.path;

          var _iterator = _createForOfIteratorHelper(segments),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var segment = _step.value;
              path = path.with(segment);

              if (!path) {
                return;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          return this.urlForPath(path);
        }
      }, {
        key: "urlForSegment",
        value: function urlForSegment(type, value) {
          return this.urlForSegments([this._navigation.segment(type, value)]);
        }
      }, {
        key: "urlUntilSegment",
        value: function urlUntilSegment(type) {
          return this.urlForPath(this._navigation.path.until(type));
        }
      }, {
        key: "urlForPath",
        value: function urlForPath(path) {
          return this._history.pathAsUrl(this._stringifyPath(path));
        }
      }, {
        key: "openRoomActionUrl",
        value: function openRoomActionUrl(roomId) {
          // not a segment to navigation knowns about, so append it manually
          var urlPath = "".concat(this._stringifyPath(this._navigation.path.until("session")), "/open-room/").concat(roomId);
          return this._history.pathAsUrl(urlPath);
        }
      }, {
        key: "createSSOCallbackURL",
        value: function createSSOCallbackURL() {
          return window.location.origin;
        }
      }, {
        key: "normalizeUrl",
        value: function normalizeUrl() {
          // Remove any queryParameters from the URL
          // Gets rid of the loginToken after SSO
          this._history.replaceUrlSilently("".concat(window.location.origin, "/").concat(window.location.hash));
        }
      }]);

      return URLRouter;
    }();

    function createNavigation() {
      return new Navigation(allowsChild);
    }
    function createRouter(_ref) {
      var history = _ref.history,
          navigation = _ref.navigation;
      return new URLRouter({
        history: history,
        navigation: navigation,
        stringifyPath: stringifyPath,
        parseUrlPath: parseUrlPath
      });
    }

    function allowsChild(parent, child) {
      var type = child.type;

      switch (parent === null || parent === void 0 ? void 0 : parent.type) {
        case undefined:
          // allowed root segments
          return type === "login" || type === "session" || type === "sso";

        case "session":
          return type === "room" || type === "rooms" || type === "settings";

        case "rooms":
          // downside of the approach: both of these will control which tile is selected
          return type === "room" || type === "empty-grid-tile";

        case "room":
          return type === "lightbox" || type === "right-panel";

        case "right-panel":
          return type === "details" || type === "members" || type === "member";

        default:
          return false;
      }
    }

    function roomsSegmentWithRoom(rooms, roomId, path) {
      if (!rooms.value.includes(roomId)) {
        var emptyGridTile = path.get("empty-grid-tile");
        var oldRoom = path.get("room");
        var index = 0;

        if (emptyGridTile) {
          index = emptyGridTile.value;
        } else if (oldRoom) {
          index = rooms.value.indexOf(oldRoom.value);
        }

        var roomIds = rooms.value.slice();
        roomIds[index] = roomId;
        return new Segment("rooms", roomIds);
      } else {
        return rooms;
      }
    }

    function pushRightPanelSegment(array, segment) {
      var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      array.push(new Segment("right-panel"));
      array.push(new Segment(segment, value));
    }

    function addPanelIfNeeded(navigation, path) {
      var segments = navigation.path.segments;
      var i = segments.findIndex(function (segment) {
        return segment.type === "right-panel";
      });
      var _path = path;

      if (i !== -1) {
        _path = path.until("room");
        _path = _path.with(segments[i]);
        _path = _path.with(segments[i + 1]);
      }

      return _path;
    }
    function parseUrlPath(urlPath, currentNavPath, defaultSessionId) {
      // substr(1) to take of initial /
      var parts = urlPath.substr(1).split("/");
      var iterator = parts[Symbol.iterator]();
      var segments = [];
      var next;

      while (!(next = iterator.next()).done) {
        var type = next.value;

        if (type === "rooms") {
          var roomsValue = iterator.next().value;

          if (roomsValue === undefined) {
            break;
          }

          var roomIds = roomsValue.split(",");
          segments.push(new Segment(type, roomIds));
          var selectedIndex = parseInt(iterator.next().value || "0", 10);
          var roomId = roomIds[selectedIndex];

          if (roomId) {
            segments.push(new Segment("room", roomId));
          } else {
            segments.push(new Segment("empty-grid-tile", selectedIndex));
          }
        } else if (type === "open-room") {
          var _roomId = iterator.next().value;

          if (!_roomId) {
            break;
          }

          var rooms = currentNavPath.get("rooms");

          if (rooms) {
            segments.push(roomsSegmentWithRoom(rooms, _roomId, currentNavPath));
          }

          segments.push(new Segment("room", _roomId));
          var openRoomPartIndex = parts.findIndex(function (part) {
            return part === "open-room";
          });
          var hasOnlyRoomIdAfterPart = openRoomPartIndex >= parts.length - 2;

          if (hasOnlyRoomIdAfterPart) {
            // Copy right-panel segments from previous path only if there are no other parts after open-room
            // fixes memberlist -> member details closing/opening grid view
            var previousSegments = currentNavPath.segments;
            var i = previousSegments.findIndex(function (s) {
              return s.type === "right-panel";
            });

            if (i !== -1) {
              segments.push.apply(segments, _toConsumableArray(previousSegments.slice(i)));
            }
          }
        } else if (type === "last-session") {
          var _sessionSegment;

          var sessionSegment = currentNavPath.get("session");

          if (typeof ((_sessionSegment = sessionSegment) === null || _sessionSegment === void 0 ? void 0 : _sessionSegment.value) !== "string" && defaultSessionId) {
            sessionSegment = new Segment("session", defaultSessionId);
          }

          if (sessionSegment) {
            segments.push(sessionSegment);
          }
        } else if (type === "details" || type === "members") {
          pushRightPanelSegment(segments, type);
        } else if (type === "member") {
          var userId = iterator.next().value;

          if (!userId) {
            break;
          }

          pushRightPanelSegment(segments, type, userId);
        } else if (type.includes("loginToken")) {
          // Special case for SSO-login with query parameter loginToken=<token>
          var loginToken = type.split("=").pop();
          segments.push(new Segment("sso", loginToken));
        } else {
          // might be undefined, which will be turned into true by Segment 
          var value = iterator.next().value;
          segments.push(new Segment(type, value));
        }
      }

      return segments;
    }
    function stringifyPath(path) {
      var _prevSegment;

      var urlPath = "";
      var prevSegment;

      var _iterator = _createForOfIteratorHelper(path.segments),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var segment = _step.value;

          switch (segment.type) {
            case "rooms":
              urlPath += "/rooms/".concat(segment.value.join(","));
              break;

            case "empty-grid-tile":
              urlPath += "/".concat(segment.value);
              break;

            case "room":
              if (((_prevSegment = prevSegment) === null || _prevSegment === void 0 ? void 0 : _prevSegment.type) === "rooms") {
                var index = prevSegment.value.indexOf(segment.value);
                urlPath += "/".concat(index);
              } else {
                urlPath += "/".concat(segment.type, "/").concat(segment.value);
              }

              break;

            case "right-panel":
            case "sso":
              // Do not put these segments in URL
              continue;

            default:
              urlPath += "/".concat(segment.type);

              if (segment.value && segment.value !== true) {
                urlPath += "/".concat(segment.value);
              }

          }

          prevSegment = segment;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return urlPath;
    }

    var LeftPanelViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(LeftPanelViewModel, _ViewModel);

      var _super = _createSuper(LeftPanelViewModel);

      function LeftPanelViewModel(options) {
        var _this;

        _classCallCheck(this, LeftPanelViewModel);

        _this = _super.call(this, options);
        var rooms = options.rooms,
            invites = options.invites;
        _this._tileViewModelsMap = _this._mapTileViewModels(rooms, invites);
        _this._tileViewModelsFilterMap = new ApplyMap(_this._tileViewModelsMap);
        _this._tileViewModels = _this._tileViewModelsFilterMap.sortValues(function (a, b) {
          return a.compare(b);
        });
        _this._currentTileVM = null;

        _this._setupNavigation();

        _this._closeUrl = _this.urlCreator.urlForSegment("session");
        _this._settingsUrl = _this.urlCreator.urlForSegment("settings");
        return _this;
      }

      _createClass(LeftPanelViewModel, [{
        key: "_mapTileViewModels",
        value: function _mapTileViewModels(rooms, invites) {
          var _this2 = this;

          // join is not commutative, invites will take precedence over rooms
          return invites.join(rooms).mapValues(function (roomOrInvite, emitChange) {
            var _this2$navigation$pat;

            var vm;

            if (roomOrInvite.isInvite) {
              vm = new InviteTileViewModel(_this2.childOptions({
                invite: roomOrInvite,
                emitChange: emitChange
              }));
            } else {
              vm = new RoomTileViewModel(_this2.childOptions({
                room: roomOrInvite,
                emitChange: emitChange
              }));
            }

            var isOpen = ((_this2$navigation$pat = _this2.navigation.path.get("room")) === null || _this2$navigation$pat === void 0 ? void 0 : _this2$navigation$pat.value) === roomOrInvite.id;

            if (isOpen) {
              vm.open();

              _this2._updateCurrentVM(vm);
            }

            return vm;
          });
        }
      }, {
        key: "_updateCurrentVM",
        value: function _updateCurrentVM(vm) {
          var _this$_currentTileVM;

          // need to also update the current vm here as
          // we can't call `_open` from the ctor as the map
          // is only populated when the view subscribes.
          (_this$_currentTileVM = this._currentTileVM) === null || _this$_currentTileVM === void 0 ? void 0 : _this$_currentTileVM.close();
          this._currentTileVM = vm;
        }
      }, {
        key: "_setupNavigation",
        value: function _setupNavigation() {
          var _this3 = this;

          var roomObservable = this.navigation.observe("room");
          this.track(roomObservable.subscribe(function (roomId) {
            return _this3._open(roomId);
          }));
          var gridObservable = this.navigation.observe("rooms");
          this.gridEnabled = !!gridObservable.get();
          this.track(gridObservable.subscribe(function (roomIds) {
            var changed = _this3.gridEnabled ^ !!roomIds;
            _this3.gridEnabled = !!roomIds;

            if (changed) {
              _this3.emitChange("gridEnabled");
            }
          }));
        }
      }, {
        key: "_open",
        value: function _open(roomId) {
          var _this$_currentTileVM2;

          (_this$_currentTileVM2 = this._currentTileVM) === null || _this$_currentTileVM2 === void 0 ? void 0 : _this$_currentTileVM2.close();
          this._currentTileVM = null;

          if (roomId) {
            var _this$_currentTileVM3;

            this._currentTileVM = this._tileViewModelsMap.get(roomId);
            (_this$_currentTileVM3 = this._currentTileVM) === null || _this$_currentTileVM3 === void 0 ? void 0 : _this$_currentTileVM3.open();
          }
        }
      }, {
        key: "toggleGrid",
        value: function toggleGrid() {
          var room = this.navigation.path.get("room");
          var path = this.navigation.path.until("session");

          if (this.gridEnabled) {
            if (room) {
              path = path.with(room);
              path = addPanelIfNeeded(this.navigation, path);
            }
          } else {
            if (room) {
              path = path.with(this.navigation.segment("rooms", [room.value]));
              path = path.with(room);
              path = addPanelIfNeeded(this.navigation, path);
            } else {
              path = path.with(this.navigation.segment("rooms", []));
              path = path.with(this.navigation.segment("empty-grid-tile", 0));
            }
          }

          this.navigation.applyPath(path);
        }
      }, {
        key: "clearFilter",
        value: function clearFilter() {
          this._tileViewModelsFilterMap.setApply(null);

          this._tileViewModelsFilterMap.applyOnce(function (roomId, vm) {
            return vm.hidden = false;
          });
        }
      }, {
        key: "setFilter",
        value: function setFilter(query) {
          query = query.trim();

          if (query.length === 0) {
            this.clearFilter();
            return false;
          } else {
            var startFiltering = !this._tileViewModelsFilterMap.hasApply();
            var filter = new RoomFilter(query);

            this._tileViewModelsFilterMap.setApply(function (roomId, vm) {
              vm.hidden = !filter.matches(vm);
            });

            return startFiltering;
          }
        }
      }, {
        key: "closeUrl",
        get: function get() {
          return this._closeUrl;
        }
      }, {
        key: "settingsUrl",
        get: function get() {
          return this._settingsUrl;
        }
      }, {
        key: "tileViewModels",
        get: function get() {
          return this._tileViewModels;
        }
      }]);

      return LeftPanelViewModel;
    }(ViewModel);

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var UpdateAction = /*#__PURE__*/function () {
      function UpdateAction(remove, update, replace, updateParams) {
        _classCallCheck(this, UpdateAction);

        this._remove = remove;
        this._update = update;
        this._replace = replace;
        this._updateParams = updateParams;
      }

      _createClass(UpdateAction, [{
        key: "shouldReplace",
        get: function get() {
          return this._replace;
        }
      }, {
        key: "shouldRemove",
        get: function get() {
          return this._remove;
        }
      }, {
        key: "shouldUpdate",
        get: function get() {
          return this._update;
        }
      }, {
        key: "updateParams",
        get: function get() {
          return this._updateParams;
        }
      }], [{
        key: "Remove",
        value: function Remove() {
          return new UpdateAction(true, false, false, null);
        }
      }, {
        key: "Update",
        value: function Update(newParams) {
          return new UpdateAction(false, true, false, newParams);
        }
      }, {
        key: "Nothing",
        value: function Nothing() {
          return new UpdateAction(false, false, false, null);
        }
      }, {
        key: "Replace",
        value: function Replace(params) {
          return new UpdateAction(false, false, true, params);
        }
      }]);

      return UpdateAction;
    }();

    // for now, tileCreator should be stable in whether it returns a tile or not.
    // e.g. the decision to create a tile or not should be based on properties
    // not updated later on (e.g. event type)
    // also see big comment in onUpdate

    var TilesCollection = /*#__PURE__*/function (_BaseObservableList) {
      _inherits(TilesCollection, _BaseObservableList);

      var _super = _createSuper(TilesCollection);

      function TilesCollection(entries, tileCreator) {
        var _this;

        _classCallCheck(this, TilesCollection);

        _this = _super.call(this);
        _this._entries = entries;
        _this._tiles = null;
        _this._entrySubscription = null;
        _this._tileCreator = tileCreator;
        _this._emitSpontanousUpdate = _this._emitSpontanousUpdate.bind(_assertThisInitialized(_this));
        return _this;
      }

      _createClass(TilesCollection, [{
        key: "_emitSpontanousUpdate",
        value: function _emitSpontanousUpdate(tile, params) {
          var entry = tile.lowerEntry;

          var tileIdx = this._findTileIdx(entry);

          this.emitUpdate(tileIdx, tile, params);
        }
      }, {
        key: "onSubscribeFirst",
        value: function onSubscribeFirst() {
          this._entrySubscription = this._entries.subscribe(this);

          this._populateTiles();
        }
      }, {
        key: "_populateTiles",
        value: function _populateTiles() {
          this._tiles = [];
          var currentTile = null;

          var _iterator = _createForOfIteratorHelper(this._entries),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var entry = _step.value;

              if (!currentTile || !currentTile.tryIncludeEntry(entry)) {
                currentTile = this._tileCreator(entry);

                if (currentTile) {
                  this._tiles.push(currentTile);
                }
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          var prevTile = null;

          var _iterator2 = _createForOfIteratorHelper(this._tiles),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var tile = _step2.value;

              if (prevTile) {
                prevTile.updateNextSibling(tile);
              }

              tile.updatePreviousSibling(prevTile);
              prevTile = tile;
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          if (prevTile) {
            prevTile.updateNextSibling(null);
          } // now everything is wired up,
          // allow tiles to emit updates


          var _iterator3 = _createForOfIteratorHelper(this._tiles),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var _tile = _step3.value;

              _tile.setUpdateEmit(this._emitSpontanousUpdate);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      }, {
        key: "_findTileIdx",
        value: function _findTileIdx(entry) {
          return sortedIndex(this._tiles, entry, function (entry, tile) {
            // negate result because we're switching the order of the params
            return -tile.compareEntry(entry);
          });
        }
      }, {
        key: "_findTileAtIdx",
        value: function _findTileAtIdx(entry, idx) {
          var tile = this._getTileAtIdx(idx);

          if (tile && tile.compareEntry(entry) === 0) {
            return tile;
          }
        }
      }, {
        key: "_getTileAtIdx",
        value: function _getTileAtIdx(tileIdx) {
          if (tileIdx >= 0 && tileIdx < this._tiles.length) {
            return this._tiles[tileIdx];
          }

          return null;
        }
      }, {
        key: "onUnsubscribeLast",
        value: function onUnsubscribeLast() {
          this._entrySubscription = this._entrySubscription();

          for (var i = 0; i < this._tiles.length; i += 1) {
            this._tiles[i].dispose();
          }

          this._tiles = null;
        }
      }, {
        key: "onReset",
        value: function onReset() {
          // if TileViewModel were disposable, dispose here, or is that for views to do? views I suppose ...
          this._buildInitialTiles();

          this.emitReset();
        }
      }, {
        key: "onAdd",
        value: function onAdd(index, entry) {
          var tileIdx = this._findTileIdx(entry);

          var prevTile = this._getTileAtIdx(tileIdx - 1);

          if (prevTile && prevTile.tryIncludeEntry(entry)) {
            this.emitUpdate(tileIdx - 1, prevTile);
            return;
          } // not + 1 because this entry hasn't been added yet


          var nextTile = this._getTileAtIdx(tileIdx);

          if (nextTile && nextTile.tryIncludeEntry(entry)) {
            this.emitUpdate(tileIdx, nextTile);
            return;
          }

          var newTile = this._tileCreator(entry);

          if (newTile) {
            if (prevTile) {
              prevTile.updateNextSibling(newTile); // this emits an update while the add hasn't been emitted yet

              newTile.updatePreviousSibling(prevTile);
            }

            if (nextTile) {
              newTile.updateNextSibling(nextTile);
              nextTile.updatePreviousSibling(newTile);
            }

            this._tiles.splice(tileIdx, 0, newTile);

            this.emitAdd(tileIdx, newTile); // add event is emitted, now the tile
            // can emit updates

            newTile.setUpdateEmit(this._emitSpontanousUpdate);
          } // find position by sort key
          // ask siblings to be included? both? yes, twice: a (insert c here) b, ask a(c), if yes ask b(a), else ask b(c)? if yes then b(a)?

        }
      }, {
        key: "onUpdate",
        value: function onUpdate(index, entry, params) {
          // if an update is emitted while calling source.subscribe() from onSubscribeFirst, ignore it
          if (!this._tiles) {
            return;
          }

          var tileIdx = this._findTileIdx(entry);

          var tile = this._findTileAtIdx(entry, tileIdx);

          if (tile) {
            var action = tile.updateEntry(entry, params);

            if (action.shouldReplace) {
              var newTile = this._tileCreator(entry);

              if (newTile) {
                this._replaceTile(tileIdx, tile, newTile, action.updateParams);

                newTile.setUpdateEmit(this._emitSpontanousUpdate);
              } else {
                this._removeTile(tileIdx, tile);
              }
            }

            if (action.shouldRemove) {
              this._removeTile(tileIdx, tile);
            }

            if (action.shouldUpdate) {
              this.emitUpdate(tileIdx, tile, action.updateParams);
            }
          } // technically we should handle adding a tile here as well
          // in case before we didn't have a tile for it but now we do
          // but in reality we don't have this use case as the type and msgtype
          // doesn't change. Decryption maybe is the exception?
          // outcomes here can be
          //   tiles should be removed (got redacted and we don't want it in the timeline)
          //   tile should be added where there was none before ... ?
          //   entry should get it's own tile now
          //   merge with neighbours? ... hard to imagine use case for this  ...

        }
      }, {
        key: "_replaceTile",
        value: function _replaceTile(tileIdx, existingTile, newTile, updateParams) {
          existingTile.dispose();

          var prevTile = this._getTileAtIdx(tileIdx - 1);

          var nextTile = this._getTileAtIdx(tileIdx + 1);

          this._tiles[tileIdx] = newTile;
          prevTile === null || prevTile === void 0 ? void 0 : prevTile.updateNextSibling(newTile);
          newTile.updatePreviousSibling(prevTile);
          newTile.updateNextSibling(nextTile);
          nextTile === null || nextTile === void 0 ? void 0 : nextTile.updatePreviousSibling(newTile);
          this.emitUpdate(tileIdx, newTile, updateParams);
        }
      }, {
        key: "_removeTile",
        value: function _removeTile(tileIdx, tile) {
          var prevTile = this._getTileAtIdx(tileIdx - 1);

          var nextTile = this._getTileAtIdx(tileIdx + 1); // applying and emitting the remove should happen
          // atomically, as updateNext/PreviousSibling might
          // emit an update with the wrong index otherwise 


          this._tiles.splice(tileIdx, 1);

          tile.dispose();
          this.emitRemove(tileIdx, tile);
          prevTile === null || prevTile === void 0 ? void 0 : prevTile.updateNextSibling(nextTile);
          nextTile === null || nextTile === void 0 ? void 0 : nextTile.updatePreviousSibling(prevTile);
        } // would also be called when unloading a part of the timeline

      }, {
        key: "onRemove",
        value: function onRemove(index, entry) {
          var tileIdx = this._findTileIdx(entry);

          var tile = this._findTileAtIdx(entry, tileIdx);

          if (tile) {
            var removeTile = tile.removeEntry(entry);

            if (removeTile) {
              this._removeTile(tileIdx, tile);
            } else {
              this.emitUpdate(tileIdx, tile);
            }
          }
        }
      }, {
        key: "onMove",
        value: function onMove()
        /*fromIdx, toIdx, value*/
        {// this ... cannot happen in the timeline?
          // perhaps we can use this event to support a local echo (in a different fragment)
          // to be moved to the key of the remote echo, so we don't loose state ... ?
        }
      }, {
        key: Symbol.iterator,
        value: function value() {
          return this._tiles.values();
        }
      }, {
        key: "getFirst",
        value: function getFirst() {
          return this._tiles[0];
        }
      }, {
        key: "getTileIndex",
        value: function getTileIndex(searchTile) {
          var idx = sortedIndex(this._tiles, searchTile, function (searchTile, tile) {
            return searchTile.compare(tile);
          });
          var foundTile = this._tiles[idx];

          if ((foundTile === null || foundTile === void 0 ? void 0 : foundTile.compare(searchTile)) === 0) {
            return idx;
          }

          return -1;
        }
      }, {
        key: "sliceIterator",
        value: function sliceIterator(start, end) {
          return this._tiles.slice(start, end)[Symbol.iterator]();
        }
      }, {
        key: "length",
        get: function get() {
          return this._tiles.length;
        }
      }]);

      return TilesCollection;
    }(BaseObservableList);

    var TimelineViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(TimelineViewModel, _ViewModel);

      var _super = _createSuper(TimelineViewModel);

      function TimelineViewModel(options) {
        var _this;

        _classCallCheck(this, TimelineViewModel);

        _this = _super.call(this, options);
        var timeline = options.timeline,
            tilesCreator = options.tilesCreator;
        _this._timeline = _this.track(timeline);
        _this._tiles = new TilesCollection(timeline.entries, tilesCreator);
        _this._startTile = null;
        _this._endTile = null;
        _this._topLoadingPromise = null;
        _this._requestedStartTile = null;
        _this._requestedEndTile = null;
        _this._requestScheduled = false;
        _this._showJumpDown = false;
        return _this;
      }
      /** if this.tiles is empty, call this with undefined for both startTile and endTile */


      _createClass(TimelineViewModel, [{
        key: "setVisibleTileRange",
        value: function setVisibleTileRange(startTile, endTile) {
          var _this2 = this;

          // don't clear these once done as they are used to check
          // for more tiles once loadAtTop finishes
          this._requestedStartTile = startTile;
          this._requestedEndTile = endTile;

          if (!this._requestScheduled) {
            Promise.resolve().then(function () {
              _this2._setVisibleTileRange(_this2._requestedStartTile, _this2._requestedEndTile);

              _this2._requestScheduled = false;
            });
            this._requestScheduled = true;
          }
        }
      }, {
        key: "_setVisibleTileRange",
        value: function _setVisibleTileRange(startTile, endTile) {
          var _this3 = this;

          var loadTop;

          if (startTile && endTile) {
            // old tiles could have been removed from tilescollection once we support unloading
            this._startTile = startTile;
            this._endTile = endTile;

            var startIndex = this._tiles.getTileIndex(this._startTile);

            var endIndex = this._tiles.getTileIndex(this._endTile);

            var _iterator = _createForOfIteratorHelper(this._tiles.sliceIterator(startIndex, endIndex + 1)),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var tile = _step.value;
                tile.notifyVisible();
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            loadTop = startIndex < 10;

            this._setShowJumpDown(endIndex < this._tiles.length - 1);
          } else {
            // tiles collection is empty, load more at top
            loadTop = true;

            this._setShowJumpDown(false);
          }

          if (loadTop && !this._topLoadingPromise) {
            this._topLoadingPromise = this._timeline.loadAtTop(10).then(function (hasReachedEnd) {
              _this3._topLoadingPromise = null;

              if (!hasReachedEnd) {
                // check if more items need to be loaded by recursing
                // use the requested start / end tile,
                // so we don't end up overwriting a newly requested visible range here
                _this3.setVisibleTileRange(_this3._requestedStartTile, _this3._requestedEndTile);
              }
            });
          }
        }
      }, {
        key: "_setShowJumpDown",
        value: function _setShowJumpDown(show) {
          if (this._showJumpDown !== show) {
            this._showJumpDown = show;
            this.emitChange("showJumpDown");
          }
        }
      }, {
        key: "tiles",
        get: function get() {
          return this._tiles;
        }
      }, {
        key: "showJumpDown",
        get: function get() {
          return this._showJumpDown;
        }
      }]);

      return TimelineViewModel;
    }(ViewModel);

    var ComposerViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(ComposerViewModel, _ViewModel);

      var _super = _createSuper(ComposerViewModel);

      function ComposerViewModel(roomVM) {
        var _this;

        _classCallCheck(this, ComposerViewModel);

        _this = _super.call(this);
        _this._roomVM = roomVM;
        _this._isEmpty = true;
        _this._replyVM = null;
        return _this;
      }

      _createClass(ComposerViewModel, [{
        key: "setReplyingTo",
        value: function setReplyingTo(entry) {
          var _this$_replyVM;

          var changed = new Boolean(entry) !== new Boolean(this._replyVM) || !((_this$_replyVM = this._replyVM) === null || _this$_replyVM === void 0 ? void 0 : _this$_replyVM.id.equals(entry.asEventKey()));

          if (changed) {
            this._replyVM = this.disposeTracked(this._replyVM);

            if (entry) {
              this._replyVM = this.track(this._roomVM._createTile(entry));
            }

            this.emitChange("replyViewModel");
            this.emit("focus");
          }
        }
      }, {
        key: "clearReplyingTo",
        value: function clearReplyingTo() {
          this.setReplyingTo(null);
        }
      }, {
        key: "sendMessage",
        value: function () {
          var _sendMessage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(message) {
            var success;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this._roomVM._sendMessage(message, this._replyVM);

                  case 2:
                    success = _context.sent;

                    if (success) {
                      this._isEmpty = true;
                      this.emitChange("canSend");
                      this.clearReplyingTo();
                    }

                    return _context.abrupt("return", success);

                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function sendMessage(_x) {
            return _sendMessage.apply(this, arguments);
          }

          return sendMessage;
        }()
      }, {
        key: "sendPicture",
        value: function sendPicture() {
          this._roomVM._pickAndSendPicture();
        }
      }, {
        key: "sendFile",
        value: function sendFile() {
          this._roomVM._pickAndSendFile();
        }
      }, {
        key: "sendVideo",
        value: function sendVideo() {
          this._roomVM._pickAndSendVideo();
        }
      }, {
        key: "setInput",
        value: function () {
          var _setInput = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(text) {
            var wasEmpty;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    wasEmpty = this._isEmpty;
                    this._isEmpty = text.length === 0;

                    if (wasEmpty && !this._isEmpty) {
                      this._roomVM._room.ensureMessageKeyIsShared();
                    }

                    if (wasEmpty !== this._isEmpty) {
                      this.emitChange("canSend");
                    }

                  case 4:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function setInput(_x2) {
            return _setInput.apply(this, arguments);
          }

          return setInput;
        }()
      }, {
        key: "replyViewModel",
        get: function get() {
          return this._replyVM;
        }
      }, {
        key: "isEncrypted",
        get: function get() {
          return this._roomVM.isEncrypted;
        }
      }, {
        key: "canSend",
        get: function get() {
          return !this._isEmpty;
        }
      }, {
        key: "kind",
        get: function get() {
          return "composer";
        }
      }]);

      return ComposerViewModel;
    }(ViewModel);

    var SimpleTile = /*#__PURE__*/function (_ViewModel) {
      _inherits(SimpleTile, _ViewModel);

      var _super = _createSuper(SimpleTile);

      function SimpleTile(options) {
        var _this;

        _classCallCheck(this, SimpleTile);

        _this = _super.call(this, options);
        _this._entry = options.entry;
        return _this;
      } // view model props for all subclasses
      // hmmm, could also do instanceof ... ?


      _createClass(SimpleTile, [{
        key: "abortSending",
        value: function abortSending() {
          var _this$_entry$pendingE;

          (_this$_entry$pendingE = this._entry.pendingEvent) === null || _this$_entry$pendingE === void 0 ? void 0 : _this$_entry$pendingE.abort();
        } // TilesCollection contract below

      }, {
        key: "setUpdateEmit",
        value: function setUpdateEmit(emitUpdate) {
          var _this2 = this;

          this.updateOptions({
            emitChange: function emitChange(paramName) {
              // it can happen that after some network call
              // we switched away from the room and the response
              // comes in, triggering an emitChange in a tile that
              // has been disposed already (and hence the change
              // callback has been cleared by dispose) We should just ignore this.
              if (emitUpdate) {
                emitUpdate(_this2, paramName);
              }
            }
          });
        }
      }, {
        key: "compare",
        value: function compare(tile) {
          return this.upperEntry.compare(tile.upperEntry);
        }
      }, {
        key: "compareEntry",
        value: function compareEntry(entry) {
          return this._entry.compare(entry);
        } // update received for already included (falls within sort keys) entry

      }, {
        key: "updateEntry",
        value: function updateEntry(entry, param) {
          var renderedAsRedacted = this.shape === "redacted";

          if (!entry.isGap && entry.isRedacted !== renderedAsRedacted) {
            // recreate the tile if the entry becomes redacted
            return UpdateAction.Replace("shape");
          } else {
            this._entry = entry;
            return UpdateAction.Update(param);
          }
        } // return whether the tile should be removed
        // as SimpleTile only has one entry, the tile should be removed

      }, {
        key: "removeEntry",
        value: function removeEntry()
        /*entry*/
        {
          return true;
        } // SimpleTile can only contain 1 entry

      }, {
        key: "tryIncludeEntry",
        value: function tryIncludeEntry() {
          return false;
        } // let item know it has a new sibling

      }, {
        key: "updatePreviousSibling",
        value: function updatePreviousSibling()
        /*prev*/
        {} // let item know it has a new sibling

      }, {
        key: "updateNextSibling",
        value: function updateNextSibling()
        /*next*/
        {}
      }, {
        key: "notifyVisible",
        value: function notifyVisible() {}
      }, {
        key: "dispose",
        value: function dispose() {
          this.setUpdateEmit(null);

          _get(_getPrototypeOf(SimpleTile.prototype), "dispose", this).call(this);
        } // TilesCollection contract above

      }, {
        key: "shape",
        get: function get() {
          return null; // "gap" | "message" | "image" | ... ?
        } // don't show display name / avatar
        // probably only for BaseMessageTiles of some sort?

      }, {
        key: "isContinuation",
        get: function get() {
          return false;
        }
      }, {
        key: "hasDateSeparator",
        get: function get() {
          return false;
        }
      }, {
        key: "id",
        get: function get() {
          return this._entry.asEventKey();
        }
      }, {
        key: "isPending",
        get: function get() {
          return this._entry.isPending;
        }
      }, {
        key: "isUnsent",
        get: function get() {
          return this._entry.isPending && this._entry.pendingEvent.status !== SendStatus.Sent;
        }
      }, {
        key: "canAbortSending",
        get: function get() {
          return this._entry.isPending && !this._entry.pendingEvent.hasStartedSending;
        }
      }, {
        key: "upperEntry",
        get: function get() {
          return this._entry;
        }
      }, {
        key: "lowerEntry",
        get: function get() {
          return this._entry;
        }
      }, {
        key: "_room",
        get: function get() {
          return this._roomVM.room;
        }
      }, {
        key: "_roomVM",
        get: function get() {
          return this._options.roomVM;
        }
      }, {
        key: "_timeline",
        get: function get() {
          return this._options.timeline;
        }
      }, {
        key: "_powerLevels",
        get: function get() {
          return this._timeline.powerLevels;
        }
      }, {
        key: "_ownMember",
        get: function get() {
          return this._options.timeline.me;
        }
      }]);

      return SimpleTile;
    }(ViewModel);

    var GapTile = /*#__PURE__*/function (_SimpleTile) {
      _inherits(GapTile, _SimpleTile);

      var _super = _createSuper(GapTile);

      function GapTile(options) {
        var _this;

        _classCallCheck(this, GapTile);

        _this = _super.call(this, options);
        _this._loading = false;
        _this._error = null;
        _this._isAtTop = true;
        _this._siblingChanged = false;
        return _this;
      }

      _createClass(GapTile, [{
        key: "fill",
        value: function () {
          var _fill = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!(!this._loading && !this._entry.edgeReached)) {
                      _context.next = 19;
                      break;
                    }

                    this._loading = true;
                    this.emitChange("isLoading");
                    _context.prev = 3;
                    _context.next = 6;
                    return this._room.fillGap(this._entry, 10);

                  case 6:
                    _context.next = 14;
                    break;

                  case 8:
                    _context.prev = 8;
                    _context.t0 = _context["catch"](3);
                    console.error("room.fillGap(): ".concat(_context.t0.message, ":\n").concat(_context.t0.stack));
                    this._error = _context.t0;
                    this.emitChange("error"); // rethrow so caller of this method
                    // knows not to keep calling this for now

                    throw _context.t0;

                  case 14:
                    _context.prev = 14;
                    this._loading = false;
                    this.emitChange("isLoading");
                    return _context.finish(14);

                  case 18:
                    return _context.abrupt("return", true);

                  case 19:
                    return _context.abrupt("return", false);

                  case 20:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[3, 8, 14, 18]]);
          }));

          function fill() {
            return _fill.apply(this, arguments);
          }

          return fill;
        }()
      }, {
        key: "notifyVisible",
        value: function () {
          var _notifyVisible = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            var depth, canFillMore;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    // we do (up to 10) backfills while no new tiles have been added to the timeline
                    // because notifyVisible won't be called again until something gets added to the timeline
                    depth = 0;
                    this._siblingChanged = false;

                  case 2:
                    _context2.next = 4;
                    return this.fill();

                  case 4:
                    canFillMore = _context2.sent;
                    depth = depth + 1;

                  case 6:
                    if (depth < 10 && !this._siblingChanged && canFillMore && !this.isDisposed) {
                      _context2.next = 2;
                      break;
                    }

                  case 7:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function notifyVisible() {
            return _notifyVisible.apply(this, arguments);
          }

          return notifyVisible;
        }()
      }, {
        key: "updatePreviousSibling",
        value: function updatePreviousSibling(prev) {
          _get(_getPrototypeOf(GapTile.prototype), "updatePreviousSibling", this).call(this, prev);

          var isAtTop = !prev;

          if (this._isAtTop !== isAtTop) {
            this._isAtTop = isAtTop;
            this.emitChange("isAtTop");
          }

          this._siblingChanged = true;
        }
      }, {
        key: "updateNextSibling",
        value: function updateNextSibling() {
          // if the sibling of the gap changed while calling room.fill(),
          // we intepret this as at least one new tile has been added to
          // the timeline. See notifyVisible why this is important.
          this._siblingChanged = true;
        }
      }, {
        key: "updateEntry",
        value: function updateEntry(entry, params) {
          _get(_getPrototypeOf(GapTile.prototype), "updateEntry", this).call(this, entry, params);

          if (!entry.isGap) {
            return UpdateAction.Remove();
          } else {
            return UpdateAction.Nothing();
          }
        }
      }, {
        key: "isAtTop",
        get: function get() {
          return this._isAtTop;
        }
      }, {
        key: "shape",
        get: function get() {
          return "gap";
        }
      }, {
        key: "isLoading",
        get: function get() {
          return this._loading;
        }
      }, {
        key: "error",
        get: function get() {
          if (this._error) {
            var dir = this._entry.prev_batch ? "previous" : "next";
            return "Could not load ".concat(dir, " messages: ").concat(this._error.message);
          }

          return null;
        }
      }]);

      return GapTile;
    }(SimpleTile);

    var ReactionsViewModel = /*#__PURE__*/function () {
      function ReactionsViewModel(parentTile) {
        _classCallCheck(this, ReactionsViewModel);

        this._parentTile = parentTile;
        this._map = new ObservableMap();
        this._reactions = this._map.sortValues(function (a, b) {
          return a._compare(b);
        });
      }
      /** @package */


      _createClass(ReactionsViewModel, [{
        key: "update",
        value: function update(annotations, pendingAnnotations) {
          if (annotations) {
            for (var key in annotations) {
              if (annotations.hasOwnProperty(key)) {
                var annotation = annotations[key];

                var reaction = this._map.get(key);

                if (reaction) {
                  if (reaction._tryUpdate(annotation)) {
                    this._map.update(key);
                  }
                } else {
                  this._map.add(key, new ReactionViewModel(key, annotation, null, this._parentTile));
                }
              }
            }
          }

          if (pendingAnnotations) {
            var _iterator = _createForOfIteratorHelper(pendingAnnotations.entries()),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var _step$value = _slicedToArray(_step.value, 2),
                    _key = _step$value[0],
                    _annotation = _step$value[1];

                var _reaction = this._map.get(_key);

                if (_reaction) {
                  _reaction._tryUpdatePending(_annotation);

                  this._map.update(_key);
                } else {
                  this._map.add(_key, new ReactionViewModel(_key, null, _annotation, this._parentTile));
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          }

          var _iterator2 = _createForOfIteratorHelper(this._map.keys()),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var existingKey = _step2.value;
              var hasPending = pendingAnnotations === null || pendingAnnotations === void 0 ? void 0 : pendingAnnotations.has(existingKey);
              var hasRemote = annotations === null || annotations === void 0 ? void 0 : annotations.hasOwnProperty(existingKey);

              if (!hasRemote && !hasPending) {
                this._map.remove(existingKey);
              } else if (!hasRemote) {
                if (this._map.get(existingKey)._tryUpdate(null)) {
                  this._map.update(existingKey);
                }
              } else if (!hasPending) {
                if (this._map.get(existingKey)._tryUpdatePending(null)) {
                  this._map.update(existingKey);
                }
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      }, {
        key: "getReaction",
        value: function getReaction(key) {
          return this._map.get(key);
        }
      }, {
        key: "reactions",
        get: function get() {
          return this._reactions;
        }
      }]);

      return ReactionsViewModel;
    }();

    var ReactionViewModel = /*#__PURE__*/function () {
      function ReactionViewModel(key, annotation, pending, parentTile) {
        _classCallCheck(this, ReactionViewModel);

        this._key = key;
        this._annotation = annotation;
        this._pending = pending;
        this._parentTile = parentTile;
        this._isToggling = false;
      }

      _createClass(ReactionViewModel, [{
        key: "_tryUpdate",
        value: function _tryUpdate(annotation) {
          var oneSetAndOtherNot = !!this._annotation !== !!annotation;
          var bothSet = this._annotation && annotation;
          var areDifferent = bothSet && (annotation.me !== this._annotation.me || annotation.count !== this._annotation.count || annotation.firstTimestamp !== this._annotation.firstTimestamp);

          if (oneSetAndOtherNot || areDifferent) {
            this._annotation = annotation;
            return true;
          }

          return false;
        }
      }, {
        key: "_tryUpdatePending",
        value: function _tryUpdatePending(pending) {
          if (!pending && !this._pending) {
            return false;
          }

          this._pending = pending;
          return true;
        }
      }, {
        key: "_compare",
        value: function _compare(other) {
          // the comparator is also used to test for equality by sortValues, if the comparison returns 0
          // given that the firstTimestamp isn't set anymore when the last reaction is removed,
          // the remove event wouldn't be able to find the correct index anymore. So special case equality.
          if (other === this) {
            return 0;
          }

          if (this.count !== other.count) {
            return other.count - this.count;
          } else {
            var cmp = this.firstTimestamp - other.firstTimestamp;

            if (cmp === 0) {
              return this.key < other.key ? -1 : 1;
            }

            return cmp;
          }
        }
      }, {
        key: "toggle",
        value: function () {
          var _toggle = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var log,
                _args = arguments;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    log = _args.length > 0 && _args[0] !== undefined ? _args[0] : null;

                    if (!this._isToggling) {
                      _context.next = 4;
                      break;
                    }

                    console.log("busy toggling reaction already");
                    return _context.abrupt("return");

                  case 4:
                    this._isToggling = true;
                    _context.prev = 5;
                    _context.next = 8;
                    return this._parentTile.toggleReaction(this.key, log);

                  case 8:
                    _context.prev = 8;
                    this._isToggling = false;
                    return _context.finish(8);

                  case 11:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[5,, 8, 11]]);
          }));

          function toggle() {
            return _toggle.apply(this, arguments);
          }

          return toggle;
        }()
      }, {
        key: "key",
        get: function get() {
          return this._key;
        }
      }, {
        key: "count",
        get: function get() {
          var _this$_pending, _this$_annotation;

          return (((_this$_pending = this._pending) === null || _this$_pending === void 0 ? void 0 : _this$_pending.count) || 0) + (((_this$_annotation = this._annotation) === null || _this$_annotation === void 0 ? void 0 : _this$_annotation.count) || 0);
        }
      }, {
        key: "isPending",
        get: function get() {
          return this._pending !== null;
        }
        /** @returns {boolean} true if the user has a (pending) reaction
         *    already for this key, or they have a pending redaction for
         *    the reaction, false if there is nothing pending and
         *    the user has not reacted yet. */

      }, {
        key: "isActive",
        get: function get() {
          var _this$_annotation2;

          return ((_this$_annotation2 = this._annotation) === null || _this$_annotation2 === void 0 ? void 0 : _this$_annotation2.me) || this.isPending;
        }
      }, {
        key: "firstTimestamp",
        get: function get() {
          var ts = Number.MAX_SAFE_INTEGER;

          if (this._annotation) {
            ts = Math.min(ts, this._annotation.firstTimestamp);
          }

          if (this._pending) {
            ts = Math.min(ts, this._pending.firstTimestamp);
          }

          return ts;
        }
      }]);

      return ReactionViewModel;
    }(); // matrix classes uses in the integration test below

    var BaseMessageTile = /*#__PURE__*/function (_SimpleTile) {
      _inherits(BaseMessageTile, _SimpleTile);

      var _super = _createSuper(BaseMessageTile);

      function BaseMessageTile(options) {
        var _this;

        _classCallCheck(this, BaseMessageTile);

        _this = _super.call(this, options);
        _this._date = _this._entry.timestamp ? new Date(_this._entry.timestamp) : null;
        _this._isContinuation = false;
        _this._reactions = null;

        if (_this._entry.annotations || _this._entry.pendingAnnotations) {
          _this._updateReactions();
        }

        return _this;
      }

      _createClass(BaseMessageTile, [{
        key: "avatarUrl",
        value: function avatarUrl(size) {
          return getAvatarHttpUrl(this._entry.avatarUrl, size, this.platform, this._mediaRepository);
        }
      }, {
        key: "_getContent",
        value: function _getContent() {
          return this._entry.content;
        }
      }, {
        key: "updatePreviousSibling",
        value: function updatePreviousSibling(prev) {
          _get(_getPrototypeOf(BaseMessageTile.prototype), "updatePreviousSibling", this).call(this, prev);

          var isContinuation = false;

          if (prev && prev instanceof BaseMessageTile && prev.sender === this.sender) {
            // timestamp is null for pending events
            var myTimestamp = this._entry.timestamp;
            var otherTimestamp = prev._entry.timestamp; // other message was sent less than 5min ago

            isContinuation = myTimestamp - otherTimestamp < 5 * 60 * 1000;
          }

          if (isContinuation !== this._isContinuation) {
            this._isContinuation = isContinuation;
            this.emitChange("isContinuation");
          }
        }
      }, {
        key: "updateEntry",
        value: function updateEntry(entry, param) {
          var action = _get(_getPrototypeOf(BaseMessageTile.prototype), "updateEntry", this).call(this, entry, param);

          if (action.shouldUpdate) {
            this._updateReactions();
          }

          return action;
        }
      }, {
        key: "startReply",
        value: function startReply() {
          this._roomVM.startReply(this._entry);
        }
      }, {
        key: "reply",
        value: function reply(msgtype, body) {
          var log = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          return this._room.sendEvent("m.room.message", this._entry.reply(msgtype, body), null, log);
        }
      }, {
        key: "redact",
        value: function redact(reason, log) {
          return this._room.sendRedaction(this._entry.id, reason, log);
        }
      }, {
        key: "react",
        value: function react(key) {
          var _this2 = this;

          var log = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return this.logger.wrapOrRun(log, "react", /*#__PURE__*/function () {
            var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(log) {
              var _this2$_entry$pending, _this2$_entry$pending2;

              var redaction;
              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (_this2.canReact) {
                        _context.next = 3;
                        break;
                      }

                      log.set("powerlevel_lacking", true);
                      return _context.abrupt("return");

                    case 3:
                      if (!_this2._entry.haveAnnotation(key)) {
                        _context.next = 6;
                        break;
                      }

                      log.set("already_reacted", true);
                      return _context.abrupt("return");

                    case 6:
                      redaction = (_this2$_entry$pending = _this2._entry.pendingAnnotations) === null || _this2$_entry$pending === void 0 ? void 0 : (_this2$_entry$pending2 = _this2$_entry$pending.get(key)) === null || _this2$_entry$pending2 === void 0 ? void 0 : _this2$_entry$pending2.redactionEntry;

                      if (!(redaction && !redaction.pendingEvent.hasStartedSending)) {
                        _context.next = 13;
                        break;
                      }

                      log.set("abort_redaction", true);
                      _context.next = 11;
                      return redaction.pendingEvent.abort();

                    case 11:
                      _context.next = 15;
                      break;

                    case 13:
                      _context.next = 15;
                      return _this2._room.sendEvent("m.reaction", _this2._entry.annotate(key), null, log);

                    case 15:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }));

            return function (_x) {
              return _ref.apply(this, arguments);
            };
          }());
        }
      }, {
        key: "redactReaction",
        value: function redactReaction(key) {
          var _this3 = this;

          var log = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return this.logger.wrapOrRun(log, "redactReaction", /*#__PURE__*/function () {
            var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(log) {
              var _this3$_entry$pending, _this3$_entry$pending2;

              var entry;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      if (_this3._powerLevels.canRedactFromSender(_this3._ownMember.userId)) {
                        _context2.next = 3;
                        break;
                      }

                      log.set("powerlevel_lacking", true);
                      return _context2.abrupt("return");

                    case 3:
                      if (_this3._entry.haveAnnotation(key)) {
                        _context2.next = 6;
                        break;
                      }

                      log.set("not_yet_reacted", true);
                      return _context2.abrupt("return");

                    case 6:
                      entry = (_this3$_entry$pending = _this3._entry.pendingAnnotations) === null || _this3$_entry$pending === void 0 ? void 0 : (_this3$_entry$pending2 = _this3$_entry$pending.get(key)) === null || _this3$_entry$pending2 === void 0 ? void 0 : _this3$_entry$pending2.annotationEntry;

                      if (entry) {
                        _context2.next = 11;
                        break;
                      }

                      _context2.next = 10;
                      return _this3._timeline.getOwnAnnotationEntry(_this3._entry.id, key);

                    case 10:
                      entry = _context2.sent;

                    case 11:
                      if (!entry) {
                        _context2.next = 16;
                        break;
                      }

                      _context2.next = 14;
                      return _this3._room.sendRedaction(entry.id, null, log);

                    case 14:
                      _context2.next = 17;
                      break;

                    case 16:
                      log.set("no_reaction", true);

                    case 17:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2);
            }));

            return function (_x2) {
              return _ref2.apply(this, arguments);
            };
          }());
        }
      }, {
        key: "toggleReaction",
        value: function toggleReaction(key) {
          var _this4 = this;

          var log = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          return this.logger.wrapOrRun(log, "toggleReaction", /*#__PURE__*/function () {
            var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(log) {
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      if (!_this4._entry.haveAnnotation(key)) {
                        _context3.next = 5;
                        break;
                      }

                      _context3.next = 3;
                      return _this4.redactReaction(key, log);

                    case 3:
                      _context3.next = 7;
                      break;

                    case 5:
                      _context3.next = 7;
                      return _this4.react(key, log);

                    case 7:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3);
            }));

            return function (_x3) {
              return _ref3.apply(this, arguments);
            };
          }());
        }
      }, {
        key: "_updateReactions",
        value: function _updateReactions() {
          var _this$_entry = this._entry,
              annotations = _this$_entry.annotations,
              pendingAnnotations = _this$_entry.pendingAnnotations;

          if (!annotations && !pendingAnnotations) {
            if (this._reactions) {
              this._reactions = null;
            }
          } else {
            if (!this._reactions) {
              this._reactions = new ReactionsViewModel(this);
            }

            this._reactions.update(annotations, pendingAnnotations);
          }
        }
      }, {
        key: "_mediaRepository",
        get: function get() {
          return this._room.mediaRepository;
        }
      }, {
        key: "displayName",
        get: function get() {
          return this._entry.displayName || this.sender;
        }
      }, {
        key: "sender",
        get: function get() {
          return this._entry.sender;
        }
      }, {
        key: "memberPanelLink",
        get: function get() {
          return "".concat(this.urlCreator.urlUntilSegment("room"), "/member/").concat(this.sender);
        } // Avatar view model contract

      }, {
        key: "avatarColorNumber",
        get: function get() {
          return getIdentifierColorNumber(this._entry.sender);
        }
      }, {
        key: "avatarLetter",
        get: function get() {
          return avatarInitials(this.sender);
        }
      }, {
        key: "avatarTitle",
        get: function get() {
          return this.displayName;
        }
      }, {
        key: "date",
        get: function get() {
          return this._date && this._date.toLocaleDateString({}, {
            month: "numeric",
            day: "numeric"
          });
        }
      }, {
        key: "time",
        get: function get() {
          return this._date && this._date.toLocaleTimeString({}, {
            hour: "numeric",
            minute: "2-digit"
          });
        }
      }, {
        key: "isOwn",
        get: function get() {
          return this._entry.sender === this._ownMember.userId;
        }
      }, {
        key: "isContinuation",
        get: function get() {
          return this._isContinuation;
        }
      }, {
        key: "isUnverified",
        get: function get() {
          return this._entry.isUnverified;
        }
      }, {
        key: "canRedact",
        get: function get() {
          return this._powerLevels.canRedactFromSender(this._entry.sender);
        }
      }, {
        key: "reactions",
        get: function get() {
          if (this.shape !== "redacted") {
            return this._reactions;
          }

          return null;
        }
      }, {
        key: "canReact",
        get: function get() {
          return this._powerLevels.canSendType("m.reaction");
        }
      }]);

      return BaseMessageTile;
    }(SimpleTile);

    /*
    Copyright 2021 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */

    /*
    The regex is split into component strings;
    meaning that any escapes (\) must also
    be escaped.
    */
    var scheme = "(?:https|http|ftp):\\/\\/";
    var noSpaceNorPunctuation = "[^\\s.,?!)]";
    var hostCharacter = "[a-zA-Z0-9:.\\[\\]-]";
    /*
    Using non-consuming group here to combine two criteria for the last character.
    See point 1 below.
    */

    var host = "".concat(hostCharacter, "*(?=").concat(hostCharacter, ")").concat(noSpaceNorPunctuation);
    /*
    Use sub groups so we accept just / or #; but if anything comes after it,
    it should not end with punctuation or space.
    */

    var pathOrFragment = "(?:[\\/#](?:[^\\s]*".concat(noSpaceNorPunctuation, ")?)");
    /*
    Things to keep in mind:
    1.  URL must not contain non-ascii characters in host but may contain
        them in path or fragment components.
        https://matrix.org/<smiley> - valid
        https://matrix.org<smiley> - invalid
    2. Do not treat punctuation at the end as a part of the URL (.,?!)
    3. Path/fragment is optional.
    */

    var urlRegex = "".concat(scheme).concat(host).concat(pathOrFragment, "?");
    var regex = new RegExp(urlRegex, "gi");

    /**
     * Splits text into links and non-links.
     * For each such separated token, callback is called
     * with the token and a boolean passed as argument.
     * The boolean indicates whether the token is a link or not.
     * @param {string} text Text to split
     * @param {function(string, boolean)} callback A function to call with split tokens
     */

    function linkify(text, callback) {
      var matches = text.matchAll(regex);
      var curr = 0;

      var _iterator = _createForOfIteratorHelper(matches),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var match = _step.value;
          var precedingText = text.slice(curr, match.index);
          callback(precedingText, false);
          callback(match[0], true);
          var len = match[0].length;
          curr = match.index + len;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var remainingText = text.slice(curr);
      callback(remainingText, false);
    }

    /**
     * Parse text into parts such as newline, links and text.
     * @param {string} body A string to parse into parts
     * @returns {MessageBody} Parsed result
     */

    function parsePlainBody(body) {
      var parts = [];
      var lines = body.split("\n"); // create callback outside of loop

      var linkifyCallback = function linkifyCallback(text, isLink) {
        if (isLink) {
          parts.push(new LinkPart(text, [new TextPart(text)]));
        } else {
          parts.push(new TextPart(text));
        }
      };

      for (var i = 0; i < lines.length; i += 1) {
        var line = lines[i];

        if (line.length) {
          linkify(line, linkifyCallback);
        }

        var isLastLine = i >= lines.length - 1;

        if (!isLastLine) {
          parts.push(new NewLinePart());
        }
      }

      return new MessageBody(body, parts);
    }
    function stringAsBody(body) {
      return new MessageBody(body, [new TextPart(body)]);
    }
    var HeaderBlock = /*#__PURE__*/function () {
      function HeaderBlock(level, inlines) {
        _classCallCheck(this, HeaderBlock);

        this.level = level;
        this.inlines = inlines;
      }

      _createClass(HeaderBlock, [{
        key: "type",
        get: function get() {
          return "header";
        }
      }]);

      return HeaderBlock;
    }();
    var CodeBlock = /*#__PURE__*/function () {
      function CodeBlock(language, text) {
        _classCallCheck(this, CodeBlock);

        this.language = language;
        this.text = text;
      }

      _createClass(CodeBlock, [{
        key: "type",
        get: function get() {
          return "codeblock";
        }
      }]);

      return CodeBlock;
    }();
    var ListBlock = /*#__PURE__*/function () {
      function ListBlock(startOffset, items) {
        _classCallCheck(this, ListBlock);

        this.items = items;
        this.startOffset = startOffset;
      }

      _createClass(ListBlock, [{
        key: "type",
        get: function get() {
          return "list";
        }
      }]);

      return ListBlock;
    }();
    var TableBlock = /*#__PURE__*/function () {
      function TableBlock(head, body) {
        _classCallCheck(this, TableBlock);

        this.head = head;
        this.body = body;
      }

      _createClass(TableBlock, [{
        key: "type",
        get: function get() {
          return "table";
        }
      }]);

      return TableBlock;
    }();
    var RulePart = /*#__PURE__*/function () {
      function RulePart() {
        _classCallCheck(this, RulePart);
      }

      _createClass(RulePart, [{
        key: "type",
        get: function get() {
          return "rule";
        }
      }]);

      return RulePart;
    }();
    var NewLinePart = /*#__PURE__*/function () {
      function NewLinePart() {
        _classCallCheck(this, NewLinePart);
      }

      _createClass(NewLinePart, [{
        key: "type",
        get: function get() {
          return "newline";
        }
      }]);

      return NewLinePart;
    }();
    var FormatPart = /*#__PURE__*/function () {
      function FormatPart(format, children) {
        _classCallCheck(this, FormatPart);

        this.format = format.toLowerCase();
        this.children = children;
      }

      _createClass(FormatPart, [{
        key: "type",
        get: function get() {
          return "format";
        }
      }]);

      return FormatPart;
    }();
    var ImagePart = /*#__PURE__*/function () {
      function ImagePart(src, width, height, alt, title) {
        _classCallCheck(this, ImagePart);

        this.src = src;
        this.width = width;
        this.height = height;
        this.alt = alt;
        this.title = title;
      }

      _createClass(ImagePart, [{
        key: "type",
        get: function get() {
          return "image";
        }
      }]);

      return ImagePart;
    }();
    var PillPart = /*#__PURE__*/function () {
      function PillPart(id, href, children) {
        _classCallCheck(this, PillPart);

        this.id = id;
        this.href = href;
        this.children = children;
      }

      _createClass(PillPart, [{
        key: "type",
        get: function get() {
          return "pill";
        }
      }, {
        key: "avatarColorNumber",
        get: function get() {
          return getIdentifierColorNumber(this.id);
        }
      }, {
        key: "avatarInitials",
        get: function get() {
          return avatarInitials(this.id);
        }
      }]);

      return PillPart;
    }();
    var LinkPart = /*#__PURE__*/function () {
      function LinkPart(url, inlines) {
        _classCallCheck(this, LinkPart);

        this.url = url;
        this.inlines = inlines;
      }

      _createClass(LinkPart, [{
        key: "type",
        get: function get() {
          return "link";
        }
      }]);

      return LinkPart;
    }();
    var TextPart = /*#__PURE__*/function () {
      function TextPart(text) {
        _classCallCheck(this, TextPart);

        this.text = text;
      }

      _createClass(TextPart, [{
        key: "type",
        get: function get() {
          return "text";
        }
      }]);

      return TextPart;
    }();

    function isBlockquote(part) {
      return part.type === "format" && part.format === "blockquote";
    }

    var MessageBody = /*#__PURE__*/function () {
      function MessageBody(sourceString, parts) {
        _classCallCheck(this, MessageBody);

        this.sourceString = sourceString;
        this.parts = parts;
      }

      _createClass(MessageBody, [{
        key: "insertEmote",
        value: function insertEmote(string) {
          // We want to skip quotes introduced by replies when emoting.
          // We assume that such quotes are not TextParts, because replies
          // must have a formatted body.
          var i = 0;

          for (; i < this.parts.length && isBlockquote(this.parts[i]); i++) {
          }

          this.parts.splice(i, 0, new TextPart(string));
        }
      }]);

      return MessageBody;
    }();

    var BodyFormat = createEnum("Plain", "Html");
    var BaseTextTile = /*#__PURE__*/function (_BaseMessageTile) {
      _inherits(BaseTextTile, _BaseMessageTile);

      var _super = _createSuper(BaseTextTile);

      function BaseTextTile(options) {
        var _this;

        _classCallCheck(this, BaseTextTile);

        _this = _super.call(this, options);
        _this._messageBody = null;
        _this._format = null;
        return _this;
      }

      _createClass(BaseTextTile, [{
        key: "_parseBody",
        value: function _parseBody(body) {
          return stringAsBody(body);
        }
      }, {
        key: "_getBodyFormat",
        value: function _getBodyFormat() {
          return BodyFormat.Plain;
        }
      }, {
        key: "shape",
        get: function get() {
          return "message";
        }
      }, {
        key: "body",
        get: function get() {
          var body = this._getBody();

          var format = this._getBodyFormat(); // body is a string, so we can check for difference by just
          // doing an equality check
          // Even if the body hasn't changed, but the format has, we need
          // to re-fill our cache.


          if (!this._messageBody || this._messageBody.sourceString !== body || this._format !== format) {
            // body with markup is an array of parts,
            // so we should not recreate it for the same body string,
            // or else the equality check in the binding will always fail.
            // So cache it here.
            this._messageBody = this._parseBody(body, format);
            this._format = format;
          }

          return this._messageBody;
        }
      }]);

      return BaseTextTile;
    }(BaseMessageTile);

    /* At the time of writing (Jul 1 2021), Matrix Spec recommends
     * allowing the following HTML tags:
     *     font, del, h1, h2, h3, h4, h5, h6, blockquote, p, a, ul, ol, sup, sub, li, b, i, u,
     *     strong, em, strike, code, hr, br, div, table, thead, tbody, tr, th, td, caption, pre, span, img
     */

    /**
     * Nodes that don't have any properties to them other than their tag.
     * While <a> has `href`, and <img> has `src`, these have... themselves.
     */

    var basicInline = ["EM", "STRONG", "CODE", "DEL", "SPAN"];
    var basicBlock = ["DIV", "BLOCKQUOTE"];
    var safeSchemas = ["https", "http", "ftp", "mailto", "magnet"].map(function (name) {
      return "".concat(name, "://");
    });
    var baseUrl = 'https://matrix.to';
    var linkPrefix = "".concat(baseUrl, "/#/");

    var Deserializer = /*#__PURE__*/function () {
      function Deserializer(result, mediaRepository, allowReplies) {
        _classCallCheck(this, Deserializer);

        this.allowReplies = allowReplies;
        this.result = result;
        this.mediaRepository = mediaRepository;
      }

      _createClass(Deserializer, [{
        key: "parsePillLink",
        value: function parsePillLink(link) {
          if (!link.startsWith(linkPrefix)) {
            return null;
          }

          var contents = link.substring(linkPrefix.length);

          if (contents[0] === '@') {
            return contents;
          }

          return null;
        }
      }, {
        key: "parseLink",
        value: function parseLink(node, children) {
          var href = this.result.getAttributeValue(node, "href");
          var lcUrl = href === null || href === void 0 ? void 0 : href.toLowerCase(); // urls should be absolute and with a safe schema, as listed in the spec

          if (!lcUrl || !safeSchemas.some(function (schema) {
            return lcUrl.startsWith(schema);
          })) {
            return new FormatPart("span", children);
          }

          var pillId = this.parsePillLink(href);

          if (pillId) {
            return new PillPart(pillId, href, children);
          }

          return new LinkPart(href, children);
        }
      }, {
        key: "parseList",
        value: function parseList(node) {
          var result = this.result;
          var start = null;

          if (result.getNodeElementName(node) === "OL") {
            // Will return 1 for, say, '1A', which may not be intended?
            start = parseInt(result.getAttributeValue(node, "start")) || 1;
          }

          var items = [];

          var _iterator = _createForOfIteratorHelper(result.getChildNodes(node)),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var child = _step.value;

              if (result.getNodeElementName(child) !== "LI") {
                continue;
              }

              var item = this.parseAnyNodes(result.getChildNodes(child));
              items.push(item);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          return new ListBlock(start, items);
        }
      }, {
        key: "_ensureElement",
        value: function _ensureElement(node, tag) {
          return node && this.result.isElementNode(node) && this.result.getNodeElementName(node) === tag;
        }
      }, {
        key: "parseCodeBlock",
        value: function parseCodeBlock(node) {
          var result = this.result;
          var codeNode;

          var _iterator2 = _createForOfIteratorHelper(result.getChildNodes(node)),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var child = _step2.value;
              codeNode = child;
              break;
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          var language = null;

          if (!this._ensureElement(codeNode, "CODE")) {
            return new CodeBlock(language, this.result.getNodeText(node));
          }

          var cl = result.getAttributeValue(codeNode, "class") || "";

          var _iterator3 = _createForOfIteratorHelper(cl.split(" ")),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var clname = _step3.value;

              if (clname.startsWith("language-") && !clname.startsWith("language-_")) {
                language = clname.substring(9); // "language-".length

                break;
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          return new CodeBlock(language, this.result.getNodeText(codeNode));
        }
      }, {
        key: "parseImage",
        value: function parseImage(node) {
          var result = this.result;
          var src = result.getAttributeValue(node, "src") || "";
          var url = this.mediaRepository.mxcUrl(src); // We just ignore non-mxc `src` attributes.

          if (!url) {
            return null;
          }

          var width = parseInt(result.getAttributeValue(node, "width")) || null;
          var height = parseInt(result.getAttributeValue(node, "height")) || null;
          var alt = result.getAttributeValue(node, "alt");
          var title = result.getAttributeValue(node, "title");
          return new ImagePart(url, width, height, alt, title);
        }
      }, {
        key: "parseTableRow",
        value: function parseTableRow(row, tag) {
          var cells = [];

          var _iterator4 = _createForOfIteratorHelper(this.result.getChildNodes(row)),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var node = _step4.value;

              if (!this._ensureElement(node, tag)) {
                continue;
              }

              var children = this.result.getChildNodes(node);
              var inlines = this.parseInlineNodes(children);
              cells.push(inlines);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          return cells;
        }
      }, {
        key: "parseTableHead",
        value: function parseTableHead(head) {
          var headRow = null;

          var _iterator5 = _createForOfIteratorHelper(this.result.getChildNodes(head)),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var node = _step5.value;
              headRow = node;
              break;
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }

          if (this._ensureElement(headRow, "TR")) {
            return this.parseTableRow(headRow, "TH");
          }

          return null;
        }
      }, {
        key: "parseTableBody",
        value: function parseTableBody(body) {
          var rows = [];

          var _iterator6 = _createForOfIteratorHelper(this.result.getChildNodes(body)),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var node = _step6.value;

              if (!this._ensureElement(node, "TR")) {
                continue;
              }

              rows.push(this.parseTableRow(node, "TD"));
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }

          return rows;
        }
      }, {
        key: "parseTable",
        value: function parseTable(node) {
          // We are only assuming iterable, so convert to arrary for indexing.
          var children = Array.from(this.result.getChildNodes(node));
          var head, body;

          if (this._ensureElement(children[0], "THEAD") && this._ensureElement(children[1], "TBODY")) {
            head = this.parseTableHead(children[0]);
            body = this.parseTableBody(children[1]);
          } else if (this._ensureElement(children[0], "TBODY")) {
            head = null;
            body = this.parseTableBody(children[0]);
          }

          return new TableBlock(head, body);
        }
        /** Once a node is known to be an element,
         * attempt to interpret it as an inline element.
         *
         * @returns the inline message part, or null if the element
         *   is not inline or not allowed.
         */

      }, {
        key: "parseInlineElement",
        value: function parseInlineElement(node) {
          var result = this.result;
          var tag = result.getNodeElementName(node);
          var children = result.getChildNodes(node);

          switch (tag) {
            case "A":
              {
                var inlines = this.parseInlineNodes(children);
                return this.parseLink(node, inlines);
              }

            case "BR":
              return new NewLinePart();

            default:
              {
                if (!basicInline.includes(tag)) {
                  return null;
                }

                var _inlines = this.parseInlineNodes(children);

                return new FormatPart(tag, _inlines);
              }
          }
        }
        /** Attempt to interpret a node as inline.
         *
         * @returns the inline message part, or null if the
         *   element is not inline or not allowed.
         */

      }, {
        key: "parseInlineNode",
        value: function parseInlineNode(node) {
          if (this.result.isElementNode(node)) {
            return this.parseInlineElement(node);
          }

          return null;
        }
        /** Once a node is known to be an element, attempt
         * to interpret it as a block element.
         *
         * @returns the block message part, or null of the
         *   element is not a block or not allowed.
         */

      }, {
        key: "parseBlockElement",
        value: function parseBlockElement(node) {
          var result = this.result;
          var tag = result.getNodeElementName(node);
          var children = result.getChildNodes(node);

          switch (tag) {
            case "H1":
            case "H2":
            case "H3":
            case "H4":
            case "H5":
            case "H6":
              {
                var inlines = this.parseInlineNodes(children);
                return new HeaderBlock(parseInt(tag[1]), inlines);
              }

            case "UL":
            case "OL":
              return this.parseList(node);

            case "PRE":
              return this.parseCodeBlock(node);

            case "HR":
              return new RulePart();

            case "IMG":
              return this.parseImage(node);

            case "P":
              {
                var _inlines2 = this.parseInlineNodes(children);

                return new FormatPart(tag, _inlines2);
              }

            case "TABLE":
              return this.parseTable(node);

            default:
              {
                if (!basicBlock.includes(tag)) {
                  return null;
                }

                var blocks = this.parseAnyNodes(children);
                return new FormatPart(tag, blocks);
              }
          }
        }
        /** Attempt to parse a node as a block.
         *
         * @return the block message part, or null if the node
         *   is not a block element.
         */

      }, {
        key: "parseBlockNode",
        value: function parseBlockNode(node) {
          if (this.result.isElementNode(node)) {
            return this.parseBlockElement(node);
          }

          return null;
        }
      }, {
        key: "_parseTextParts",
        value: function _parseTextParts(node, into) {
          if (!this.result.isTextNode(node)) {
            return false;
          } // XXX pretty much identical to `MessageBody`'s.


          var linkifyCallback = function linkifyCallback(text, isLink) {
            if (isLink) {
              into.push(new LinkPart(text, [new TextPart(text)]));
            } else {
              into.push(new TextPart(text));
            }
          };

          linkify(this.result.getNodeText(node), linkifyCallback);
          return true;
        }
      }, {
        key: "_isAllowedNode",
        value: function _isAllowedNode(node) {
          return this.allowReplies || !this._ensureElement(node, "MX-REPLY");
        }
      }, {
        key: "_parseInlineNodes",
        value: function _parseInlineNodes(nodes, into) {
          var _iterator7 = _createForOfIteratorHelper(nodes),
              _step7;

          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var htmlNode = _step7.value;

              if (this._parseTextParts(htmlNode, into)) {
                // This was a text node, and we already
                // dumped its parts into our list.
                continue;
              }

              var node = this.parseInlineNode(htmlNode);

              if (node) {
                into.push(node);
                continue;
              } // Node is either block or unrecognized. In
              // both cases, just move on to its children.


              if (this._isAllowedNode(htmlNode)) {
                this._parseInlineNodes(this.result.getChildNodes(htmlNode), into);
              }
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }
        }
      }, {
        key: "parseInlineNodes",
        value: function parseInlineNodes(nodes) {
          var into = [];

          this._parseInlineNodes(nodes, into);

          return into;
        } // XXX very similar to `_parseInlineNodes`.

      }, {
        key: "_parseAnyNodes",
        value: function _parseAnyNodes(nodes, into) {
          var _iterator8 = _createForOfIteratorHelper(nodes),
              _step8;

          try {
            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
              var htmlNode = _step8.value;

              if (this._parseTextParts(htmlNode, into)) {
                // This was a text node, and we already
                // dumped its parts into our list.
                continue;
              }

              var node = this.parseInlineNode(htmlNode) || this.parseBlockNode(htmlNode);

              if (node) {
                into.push(node);
                continue;
              } // Node is unrecognized. Just move on to its children.


              if (this._isAllowedNode(htmlNode)) {
                this._parseAnyNodes(this.result.getChildNodes(htmlNode), into);
              }
            }
          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }
        }
      }, {
        key: "parseAnyNodes",
        value: function parseAnyNodes(nodes) {
          var into = [];

          this._parseAnyNodes(nodes, into);

          return into;
        }
      }]);

      return Deserializer;
    }();

    function parseHTMLBody(platform, mediaRepository, allowReplies, html) {
      var parseResult = platform.parseHTML(html);
      var deserializer = new Deserializer(parseResult, mediaRepository, allowReplies);
      var parts = deserializer.parseAnyNodes(parseResult.rootNodes);
      return new MessageBody(html, parts);
    }

    var TextTile = /*#__PURE__*/function (_BaseTextTile) {
      _inherits(TextTile, _BaseTextTile);

      var _super = _createSuper(TextTile);

      function TextTile() {
        _classCallCheck(this, TextTile);

        return _super.apply(this, arguments);
      }

      _createClass(TextTile, [{
        key: "_getContentString",
        value: function _getContentString(key) {
          var _this$_getContent;

          return ((_this$_getContent = this._getContent()) === null || _this$_getContent === void 0 ? void 0 : _this$_getContent[key]) || "";
        }
      }, {
        key: "_getPlainBody",
        value: function _getPlainBody() {
          return this._getContentString("body");
        }
      }, {
        key: "_getFormattedBody",
        value: function _getFormattedBody() {
          return this._getContentString("formatted_body");
        }
      }, {
        key: "_getBody",
        value: function _getBody() {
          if (this._getBodyFormat() === BodyFormat.Html) {
            return this._getFormattedBody();
          } else {
            return this._getPlainBody();
          }
        }
      }, {
        key: "_getBodyFormat",
        value: function _getBodyFormat() {
          var _this$_getContent2;

          if (((_this$_getContent2 = this._getContent()) === null || _this$_getContent2 === void 0 ? void 0 : _this$_getContent2.format) === "org.matrix.custom.html") {
            return BodyFormat.Html;
          } else {
            return BodyFormat.Plain;
          }
        }
      }, {
        key: "_parseBody",
        value: function _parseBody(body, format) {
          var _this$_getContent3;

          var messageBody;

          if (format === BodyFormat.Html) {
            messageBody = parseHTMLBody(this.platform, this._mediaRepository, this._entry.isReply, body);
          } else {
            messageBody = parsePlainBody(body);
          }

          if (((_this$_getContent3 = this._getContent()) === null || _this$_getContent3 === void 0 ? void 0 : _this$_getContent3.msgtype) === "m.emote") {
            messageBody.insertEmote("* ".concat(this.displayName, " "));
          }

          return messageBody;
        }
      }]);

      return TextTile;
    }(BaseTextTile);

    function _templateObject4$a() {
      var data = _taggedTemplateLiteral(["This message has been deleted."]);

      _templateObject4$a = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3$d() {
      var data = _taggedTemplateLiteral(["This message has been deleted (", ")."]);

      _templateObject3$d = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$i() {
      var data = _taggedTemplateLiteral(["This message is being deleted\u2026"]);

      _templateObject2$i = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$n() {
      var data = _taggedTemplateLiteral(["This message is being deleted (", ")\u2026"]);

      _templateObject$n = function _templateObject() {
        return data;
      };

      return data;
    }
    var RedactedTile = /*#__PURE__*/function (_BaseMessageTile) {
      _inherits(RedactedTile, _BaseMessageTile);

      var _super = _createSuper(RedactedTile);

      function RedactedTile() {
        _classCallCheck(this, RedactedTile);

        return _super.apply(this, arguments);
      }

      _createClass(RedactedTile, [{
        key: "abortPendingRedaction",
        value: function abortPendingRedaction() {
          return this._entry.abortPendingRedaction();
        }
      }, {
        key: "shape",
        get: function get() {
          return "redacted";
        }
      }, {
        key: "description",
        get: function get() {
          var redactionReason = this._entry.redactionReason;

          if (this.isRedacting) {
            if (redactionReason) {
              return this.i18n(_templateObject$n(), redactionReason);
            } else {
              return this.i18n(_templateObject2$i());
            }
          } else {
            if (redactionReason) {
              return this.i18n(_templateObject3$d(), redactionReason);
            } else {
              return this.i18n(_templateObject4$a());
            }
          }
        }
      }, {
        key: "isRedacting",
        get: function get() {
          return this._entry.isRedacting;
        }
        /** override parent property to disable redacting, even if still pending */

      }, {
        key: "canRedact",
        get: function get() {
          return false;
        }
      }]);

      return RedactedTile;
    }(BaseMessageTile);

    function _templateObject5$9() {
      var data = _taggedTemplateLiteral(["Error: ", ""]);

      _templateObject5$9 = function _templateObject5() {
        return data;
      };

      return data;
    }

    function _templateObject4$b() {
      var data = _taggedTemplateLiteral(["Sending\u2026"]);

      _templateObject4$b = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3$e() {
      var data = _taggedTemplateLiteral(["Uploading\u2026"]);

      _templateObject3$e = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$j() {
      var data = _taggedTemplateLiteral(["Encrypting\u2026"]);

      _templateObject2$j = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$o() {
      var data = _taggedTemplateLiteral(["Waiting\u2026"]);

      _templateObject$o = function _templateObject() {
        return data;
      };

      return data;
    }
    var MAX_HEIGHT = 300;
    var MAX_WIDTH = 400;
    var BaseMediaTile = /*#__PURE__*/function (_BaseMessageTile) {
      _inherits(BaseMediaTile, _BaseMessageTile);

      var _super = _createSuper(BaseMediaTile);

      function BaseMediaTile(options) {
        var _this;

        _classCallCheck(this, BaseMediaTile);

        _this = _super.call(this, options);
        _this._decryptedThumbnail = null;
        _this._decryptedFile = null;
        _this._error = null;

        if (!_this.isPending) {
          _this._tryLoadEncryptedThumbnail();
        }

        return _this;
      }

      _createClass(BaseMediaTile, [{
        key: "setViewError",
        value: function setViewError(err) {
          this._error = err;
          this.emitChange("error");
        }
      }, {
        key: "_loadEncryptedFile",
        value: function () {
          var _loadEncryptedFile2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(file) {
            var blob;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this._mediaRepository.downloadEncryptedFile(file, true);

                  case 2:
                    blob = _context.sent;

                    if (!this.isDisposed) {
                      _context.next = 6;
                      break;
                    }

                    blob.dispose();
                    return _context.abrupt("return");

                  case 6:
                    return _context.abrupt("return", this.track(blob));

                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function _loadEncryptedFile(_x) {
            return _loadEncryptedFile2.apply(this, arguments);
          }

          return _loadEncryptedFile;
        }()
      }, {
        key: "_tryLoadEncryptedThumbnail",
        value: function () {
          var _tryLoadEncryptedThumbnail2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            var _this$_getContent$inf, thumbnailFile, file;

            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.prev = 0;
                    thumbnailFile = (_this$_getContent$inf = this._getContent().info) === null || _this$_getContent$inf === void 0 ? void 0 : _this$_getContent$inf.thumbnail_file;
                    file = this._getContent().file;

                    if (!thumbnailFile) {
                      _context2.next = 10;
                      break;
                    }

                    _context2.next = 6;
                    return this._loadEncryptedFile(thumbnailFile);

                  case 6:
                    this._decryptedThumbnail = _context2.sent;
                    this.emitChange("thumbnailUrl");
                    _context2.next = 15;
                    break;

                  case 10:
                    if (!(file && this._isMainResourceImage())) {
                      _context2.next = 15;
                      break;
                    }

                    _context2.next = 13;
                    return this._loadEncryptedFile(file);

                  case 13:
                    this._decryptedFile = _context2.sent;
                    this.emitChange("thumbnailUrl");

                  case 15:
                    _context2.next = 21;
                    break;

                  case 17:
                    _context2.prev = 17;
                    _context2.t0 = _context2["catch"](0);
                    this._error = _context2.t0;
                    this.emitChange("error");

                  case 21:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[0, 17]]);
          }));

          function _tryLoadEncryptedThumbnail() {
            return _tryLoadEncryptedThumbnail2.apply(this, arguments);
          }

          return _tryLoadEncryptedThumbnail;
        }()
      }, {
        key: "_scaleFactor",
        value: function _scaleFactor() {
          var _this$_getContent;

          var info = (_this$_getContent = this._getContent()) === null || _this$_getContent === void 0 ? void 0 : _this$_getContent.info;
          var scaleHeightFactor = MAX_HEIGHT / (info === null || info === void 0 ? void 0 : info.h);
          var scaleWidthFactor = MAX_WIDTH / (info === null || info === void 0 ? void 0 : info.w); // take the smallest scale factor, to respect all constraints
          // we should not upscale images, so limit scale factor to 1 upwards

          return Math.min(scaleWidthFactor, scaleHeightFactor, 1);
        }
      }, {
        key: "_isMainResourceImage",
        value: function _isMainResourceImage() {
          return true; // overwritten in VideoTile
        }
      }, {
        key: "isUploading",
        get: function get() {
          return this.isPending && this._entry.pendingEvent.status === SendStatus.UploadingAttachments;
        }
      }, {
        key: "uploadPercentage",
        get: function get() {
          var pendingEvent = this._entry.pendingEvent;
          return pendingEvent && Math.round(pendingEvent.attachmentsSentBytes / pendingEvent.attachmentsTotalBytes * 100);
        }
      }, {
        key: "sendStatus",
        get: function get() {
          var pendingEvent = this._entry.pendingEvent;

          switch (pendingEvent === null || pendingEvent === void 0 ? void 0 : pendingEvent.status) {
            case SendStatus.Waiting:
              return this.i18n(_templateObject$o());

            case SendStatus.EncryptingAttachments:
            case SendStatus.Encrypting:
              return this.i18n(_templateObject2$j());

            case SendStatus.UploadingAttachments:
              return this.i18n(_templateObject3$e());

            case SendStatus.Sending:
              return this.i18n(_templateObject4$b());

            case SendStatus.Error:
              return this.i18n(_templateObject5$9(), pendingEvent.error.message);

            default:
              return "";
          }
        }
      }, {
        key: "thumbnailUrl",
        get: function get() {
          if (this._decryptedThumbnail) {
            return this._decryptedThumbnail.url;
          } else {
            var _this$_getContent$inf2;

            var thumbnailMxc = (_this$_getContent$inf2 = this._getContent().info) === null || _this$_getContent$inf2 === void 0 ? void 0 : _this$_getContent$inf2.thumbnail_url;

            if (thumbnailMxc) {
              return this._mediaRepository.mxcUrlThumbnail(thumbnailMxc, this.width, this.height, "scale");
            }
          }

          if (this._entry.isPending) {
            var attachment = this._entry.pendingEvent.getAttachment("info.thumbnail_url");

            return attachment && attachment.localPreview.url;
          }

          if (this._isMainResourceImage()) {
            if (this._decryptedFile) {
              return this._decryptedFile.url;
            } else {
              var _this$_getContent2;

              var mxcUrl = (_this$_getContent2 = this._getContent()) === null || _this$_getContent2 === void 0 ? void 0 : _this$_getContent2.url;

              if (typeof mxcUrl === "string") {
                return this._mediaRepository.mxcUrlThumbnail(mxcUrl, this.width, this.height, "scale");
              }
            }
          }

          return "";
        }
      }, {
        key: "width",
        get: function get() {
          var _this$_getContent3;

          var info = (_this$_getContent3 = this._getContent()) === null || _this$_getContent3 === void 0 ? void 0 : _this$_getContent3.info;
          return Math.round((info === null || info === void 0 ? void 0 : info.w) * this._scaleFactor());
        }
      }, {
        key: "height",
        get: function get() {
          var _this$_getContent4;

          var info = (_this$_getContent4 = this._getContent()) === null || _this$_getContent4 === void 0 ? void 0 : _this$_getContent4.info;
          return Math.round((info === null || info === void 0 ? void 0 : info.h) * this._scaleFactor());
        }
      }, {
        key: "mimeType",
        get: function get() {
          var _this$_getContent5;

          var info = (_this$_getContent5 = this._getContent()) === null || _this$_getContent5 === void 0 ? void 0 : _this$_getContent5.info;
          return info === null || info === void 0 ? void 0 : info.mimetype;
        }
      }, {
        key: "label",
        get: function get() {
          return this._getContent().body;
        }
      }, {
        key: "error",
        get: function get() {
          if (this._error) {
            return "Could not load media: ".concat(this._error.message);
          }

          return null;
        }
      }]);

      return BaseMediaTile;
    }(BaseMessageTile);

    var ImageTile = /*#__PURE__*/function (_BaseMediaTile) {
      _inherits(ImageTile, _BaseMediaTile);

      var _super = _createSuper(ImageTile);

      function ImageTile(options) {
        var _this;

        _classCallCheck(this, ImageTile);

        _this = _super.call(this, options);
        _this._lightboxUrl = _this.urlCreator.urlForSegments([// ensure the right room is active if in grid view
        _this.navigation.segment("room", _this._room.id), _this.navigation.segment("lightbox", _this._entry.id)]);
        return _this;
      }

      _createClass(ImageTile, [{
        key: "lightboxUrl",
        get: function get() {
          if (!this.isPending) {
            return this._lightboxUrl;
          }

          return "";
        }
      }, {
        key: "shape",
        get: function get() {
          return "image";
        }
      }]);

      return ImageTile;
    }(BaseMediaTile);

    var VideoTile = /*#__PURE__*/function (_BaseMediaTile) {
      _inherits(VideoTile, _BaseMediaTile);

      var _super = _createSuper(VideoTile);

      function VideoTile() {
        _classCallCheck(this, VideoTile);

        return _super.apply(this, arguments);
      }

      _createClass(VideoTile, [{
        key: "loadVideo",
        value: function () {
          var _loadVideo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var file;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    file = this._getContent().file;

                    if (!(file && !this._decryptedFile)) {
                      _context.next = 6;
                      break;
                    }

                    _context.next = 4;
                    return this._loadEncryptedFile(file);

                  case 4:
                    this._decryptedFile = _context.sent;
                    this.emitChange("videoUrl");

                  case 6:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function loadVideo() {
            return _loadVideo.apply(this, arguments);
          }

          return loadVideo;
        }()
      }, {
        key: "_isMainResourceImage",
        value: function _isMainResourceImage() {
          return false;
        }
      }, {
        key: "videoUrl",
        get: function get() {
          var _this$_getContent;

          if (this._decryptedFile) {
            return this._decryptedFile.url;
          }

          var mxcUrl = (_this$_getContent = this._getContent()) === null || _this$_getContent === void 0 ? void 0 : _this$_getContent.url;

          if (typeof mxcUrl === "string") {
            return this._mediaRepository.mxcUrl(mxcUrl);
          }

          return "";
        }
      }, {
        key: "shape",
        get: function get() {
          return "video";
        }
      }]);

      return VideoTile;
    }(BaseMediaTile);

    /*
    Copyright 2020 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function formatSize(size) {
      var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

      if (Number.isSafeInteger(size)) {
        var base = Math.min(3, Math.floor(Math.log(size) / Math.log(1024)));
        var formattedSize = Math.round(size / Math.pow(1024, base)).toFixed(decimals);

        switch (base) {
          case 0:
            return "".concat(formattedSize, " bytes");

          case 1:
            return "".concat(formattedSize, " KB");

          case 2:
            return "".concat(formattedSize, " MB");

          case 3:
            return "".concat(formattedSize, " GB");
        }
      }
    }

    function _templateObject7$5() {
      var data = _taggedTemplateLiteral(["Download ", " (", ")"]);

      _templateObject7$5 = function _templateObject7() {
        return data;
      };

      return data;
    }

    function _templateObject6$7() {
      var data = _taggedTemplateLiteral(["Downloading ", " (", ")\u2026"]);

      _templateObject6$7 = function _templateObject6() {
        return data;
      };

      return data;
    }

    function _templateObject5$a() {
      var data = _taggedTemplateLiteral(["Error: could not send ", ": ", ""]);

      _templateObject5$a = function _templateObject5() {
        return data;
      };

      return data;
    }

    function _templateObject4$c() {
      var data = _taggedTemplateLiteral(["Sending ", "\u2026"]);

      _templateObject4$c = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3$f() {
      var data = _taggedTemplateLiteral(["Uploading ", ": ", "%"]);

      _templateObject3$f = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$k() {
      var data = _taggedTemplateLiteral(["Encrypting ", "\u2026"]);

      _templateObject2$k = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$p() {
      var data = _taggedTemplateLiteral(["Waiting to send ", "\u2026"]);

      _templateObject$p = function _templateObject() {
        return data;
      };

      return data;
    }
    var FileTile = /*#__PURE__*/function (_BaseMessageTile) {
      _inherits(FileTile, _BaseMessageTile);

      var _super = _createSuper(FileTile);

      function FileTile(options) {
        var _this;

        _classCallCheck(this, FileTile);

        _this = _super.call(this, options);
        _this._downloadError = null;
        _this._downloading = false;
        return _this;
      }

      _createClass(FileTile, [{
        key: "download",
        value: function () {
          var _download = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var content, filename, blob, _blob;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!(this._downloading || this.isPending)) {
                      _context.next = 2;
                      break;
                    }

                    return _context.abrupt("return");

                  case 2:
                    content = this._getContent();
                    filename = content.body;
                    this._downloading = true;
                    this.emitChange("label");
                    _context.prev = 6;
                    _context.next = 9;
                    return this._mediaRepository.downloadAttachment(content);

                  case 9:
                    blob = _context.sent;
                    this.platform.saveFileAs(blob, filename);
                    _context.next = 16;
                    break;

                  case 13:
                    _context.prev = 13;
                    _context.t0 = _context["catch"](6);
                    this._downloadError = _context.t0;

                  case 16:
                    _context.prev = 16;
                    (_blob = blob) === null || _blob === void 0 ? void 0 : _blob.dispose();
                    this._downloading = false;
                    return _context.finish(16);

                  case 20:
                    this.emitChange("label");

                  case 21:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[6, 13, 16, 20]]);
          }));

          function download() {
            return _download.apply(this, arguments);
          }

          return download;
        }()
      }, {
        key: "label",
        get: function get() {
          if (this._downloadError) {
            return "Could not download file: ".concat(this._downloadError.message);
          }

          var content = this._getContent();

          var filename = content.body;

          if (this._entry.isPending) {
            var pendingEvent = this._entry.pendingEvent;

            switch (pendingEvent === null || pendingEvent === void 0 ? void 0 : pendingEvent.status) {
              case SendStatus.Waiting:
                return this.i18n(_templateObject$p(), filename);

              case SendStatus.EncryptingAttachments:
              case SendStatus.Encrypting:
                return this.i18n(_templateObject2$k(), filename);

              case SendStatus.UploadingAttachments:
                {
                  var percent = Math.round(pendingEvent.attachmentsSentBytes / pendingEvent.attachmentsTotalBytes * 100);
                  return this.i18n(_templateObject3$f(), filename, percent);
                }

              case SendStatus.Sending:
              case SendStatus.Sent:
                return this.i18n(_templateObject4$c(), filename);

              case SendStatus.Error:
                return this.i18n(_templateObject5$a(), filename, pendingEvent.error.message);

              default:
                return "Unknown send status for ".concat(filename);
            }
          } else {
            var _this$_getContent$inf;

            var size = formatSize((_this$_getContent$inf = this._getContent().info) === null || _this$_getContent$inf === void 0 ? void 0 : _this$_getContent$inf.size);

            if (this._downloading) {
              return this.i18n(_templateObject6$7(), filename, size);
            } else {
              return this.i18n(_templateObject7$5(), filename, size);
            }
          }
        }
      }, {
        key: "shape",
        get: function get() {
          return "file";
        }
      }]);

      return FileTile;
    }(BaseMessageTile);

    /*
    map urls:
    apple:   https://developer.apple.com/library/archive/featuredarticles/iPhoneURLScheme_Reference/MapLinks/MapLinks.html
    android: https://developers.google.com/maps/documentation/urls/guide
    wp:      maps:49.275267 -122.988617
    https://www.habaneroconsulting.com/stories/insights/2011/opening-native-map-apps-from-the-mobile-browser
    */

    var LocationTile = /*#__PURE__*/function (_BaseMessageTile) {
      _inherits(LocationTile, _BaseMessageTile);

      var _super = _createSuper(LocationTile);

      function LocationTile() {
        _classCallCheck(this, LocationTile);

        return _super.apply(this, arguments);
      }

      _createClass(LocationTile, [{
        key: "mapsLink",
        get: function get() {
          var geoUri = this._getContent().geo_uri;

          var _geoUri$split$1$split = geoUri.split(":")[1].split(","),
              _geoUri$split$1$split2 = _slicedToArray(_geoUri$split$1$split, 2),
              lat = _geoUri$split$1$split2[0],
              long = _geoUri$split$1$split2[1];

          return "maps:".concat(lat, " ").concat(long);
        }
      }, {
        key: "label",
        get: function get() {
          return "".concat(this.sender, " sent their location, click to see it in maps.");
        }
      }]);

      return LocationTile;
    }(BaseMessageTile);

    var RoomNameTile = /*#__PURE__*/function (_SimpleTile) {
      _inherits(RoomNameTile, _SimpleTile);

      var _super = _createSuper(RoomNameTile);

      function RoomNameTile() {
        _classCallCheck(this, RoomNameTile);

        return _super.apply(this, arguments);
      }

      _createClass(RoomNameTile, [{
        key: "shape",
        get: function get() {
          return "announcement";
        }
      }, {
        key: "announcement",
        get: function get() {
          var content = this._entry.content;
          return "".concat(this._entry.displayName || this._entry.sender, " named the room \"").concat(content === null || content === void 0 ? void 0 : content.name, "\"");
        }
      }]);

      return RoomNameTile;
    }(SimpleTile);

    var RoomMemberTile = /*#__PURE__*/function (_SimpleTile) {
      _inherits(RoomMemberTile, _SimpleTile);

      var _super = _createSuper(RoomMemberTile);

      function RoomMemberTile() {
        _classCallCheck(this, RoomMemberTile);

        return _super.apply(this, arguments);
      }

      _createClass(RoomMemberTile, [{
        key: "shape",
        get: function get() {
          return "announcement";
        }
      }, {
        key: "announcement",
        get: function get() {
          var _this$_entry$content;

          var _this$_entry = this._entry,
              sender = _this$_entry.sender,
              content = _this$_entry.content,
              prevContent = _this$_entry.prevContent,
              stateKey = _this$_entry.stateKey;
          var senderName = this._entry.displayName || sender;
          var targetName = sender === stateKey ? senderName : ((_this$_entry$content = this._entry.content) === null || _this$_entry$content === void 0 ? void 0 : _this$_entry$content.displayname) || stateKey;
          var membership = content && content.membership;
          var prevMembership = prevContent && prevContent.membership;

          if (prevMembership === "join" && membership === "join") {
            if (content.avatar_url !== prevContent.avatar_url) {
              return "".concat(senderName, " changed their avatar");
            } else if (content.displayname !== prevContent.displayname) {
              var _prevContent$displayn;

              if (!content.displayname) {
                return "".concat(stateKey, " removed their name (").concat(prevContent.displayname, ")");
              }

              return "".concat((_prevContent$displayn = prevContent.displayname) !== null && _prevContent$displayn !== void 0 ? _prevContent$displayn : stateKey, " changed their name to ").concat(content.displayname);
            }
          } else if (membership === "join") {
            return "".concat(targetName, " joined the room");
          } else if (membership === "invite") {
            return "".concat(targetName, " was invited to the room by ").concat(senderName);
          } else if (prevMembership === "invite") {
            if (membership === "join") {
              return "".concat(targetName, " accepted the invitation to join the room");
            } else if (membership === "leave") {
              return "".concat(targetName, " declined the invitation to join the room");
            }
          } else if (membership === "leave") {
            if (stateKey === sender) {
              return "".concat(targetName, " left the room");
            } else {
              var reason = content.reason;
              return "".concat(targetName, " was kicked from the room by ").concat(senderName).concat(reason ? ": ".concat(reason) : "");
            }
          } else if (membership === "ban") {
            return "".concat(targetName, " was banned from the room by ").concat(senderName);
          }

          return "".concat(sender, " membership changed to ").concat(content.membership);
        }
      }]);

      return RoomMemberTile;
    }(SimpleTile);

    function _templateObject2$l() {
      var data = _taggedTemplateLiteral(["Could not decrypt message because of unknown reason."]);

      _templateObject2$l = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$q() {
      var data = _taggedTemplateLiteral(["The sender hasn't sent us the key for this message yet."]);

      _templateObject$q = function _templateObject() {
        return data;
      };

      return data;
    }
    var EncryptedEventTile = /*#__PURE__*/function (_BaseTextTile) {
      _inherits(EncryptedEventTile, _BaseTextTile);

      var _super = _createSuper(EncryptedEventTile);

      function EncryptedEventTile() {
        _classCallCheck(this, EncryptedEventTile);

        return _super.apply(this, arguments);
      }

      _createClass(EncryptedEventTile, [{
        key: "updateEntry",
        value: function updateEntry(entry, params) {
          var parentResult = _get(_getPrototypeOf(EncryptedEventTile.prototype), "updateEntry", this).call(this, entry, params); // event got decrypted, recreate the tile and replace this one with it


          if (entry.eventType !== "m.room.encrypted") {
            // the "shape" parameter trigger tile recreation in TimelineView
            return UpdateAction.Replace("shape");
          } else {
            return parentResult;
          }
        }
      }, {
        key: "_getBody",
        value: function _getBody() {
          var decryptionError = this._entry.decryptionError;
          var code = decryptionError === null || decryptionError === void 0 ? void 0 : decryptionError.code;
          var string;

          if (code === "MEGOLM_NO_SESSION") {
            string = this.i18n(_templateObject$q());
          } else {
            string = (decryptionError === null || decryptionError === void 0 ? void 0 : decryptionError.message) || this.i18n(_templateObject2$l());
          }

          return string;
        }
      }, {
        key: "shape",
        get: function get() {
          return "message-status";
        }
      }]);

      return EncryptedEventTile;
    }(BaseTextTile);

    function _templateObject$r() {
      var data = _taggedTemplateLiteral(["", " has enabled end-to-end encryption"]);

      _templateObject$r = function _templateObject() {
        return data;
      };

      return data;
    }
    var EncryptionEnabledTile = /*#__PURE__*/function (_SimpleTile) {
      _inherits(EncryptionEnabledTile, _SimpleTile);

      var _super = _createSuper(EncryptionEnabledTile);

      function EncryptionEnabledTile() {
        _classCallCheck(this, EncryptionEnabledTile);

        return _super.apply(this, arguments);
      }

      _createClass(EncryptionEnabledTile, [{
        key: "shape",
        get: function get() {
          return "announcement";
        }
      }, {
        key: "announcement",
        get: function get() {
          var senderName = this._entry.displayName || this._entry.sender;
          return this.i18n(_templateObject$r(), senderName);
        }
      }]);

      return EncryptionEnabledTile;
    }(SimpleTile);

    function _templateObject2$m() {
      var data = _taggedTemplateLiteral(["The file ", " wasn't fully sent previously and could not be recovered."]);

      _templateObject2$m = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$s() {
      var data = _taggedTemplateLiteral(["The image ", " wasn't fully sent previously and could not be recovered."]);

      _templateObject$s = function _templateObject() {
        return data;
      };

      return data;
    }
    var MissingAttachmentTile = /*#__PURE__*/function (_BaseMessageTile) {
      _inherits(MissingAttachmentTile, _BaseMessageTile);

      var _super = _createSuper(MissingAttachmentTile);

      function MissingAttachmentTile() {
        _classCallCheck(this, MissingAttachmentTile);

        return _super.apply(this, arguments);
      }

      _createClass(MissingAttachmentTile, [{
        key: "shape",
        get: function get() {
          return "missing-attachment";
        }
      }, {
        key: "label",
        get: function get() {
          var name = this._getContent().body;

          var msgtype = this._getContent().msgtype;

          if (msgtype === "m.image") {
            return this.i18n(_templateObject$s(), name);
          } else {
            return this.i18n(_templateObject2$m(), name);
          }
        }
      }]);

      return MissingAttachmentTile;
    }(BaseMessageTile);

    /*
    Copyright 2020 Bruno Windels <bruno@windels.cloud>

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    function tilesCreator(baseOptions) {
      return function tilesCreator(entry, emitUpdate) {
        var options = Object.assign({
          entry: entry,
          emitUpdate: emitUpdate
        }, baseOptions);

        if (entry.isGap) {
          return new GapTile(options);
        } else if (entry.isPending && entry.pendingEvent.isMissingAttachments) {
          return new MissingAttachmentTile(options);
        } else if (entry.eventType) {
          switch (entry.eventType) {
            case "m.room.message":
              {
                if (entry.isRedacted) {
                  return new RedactedTile(options);
                }

                var content = entry.content;
                var msgtype = content && content.msgtype;

                switch (msgtype) {
                  case "m.text":
                  case "m.notice":
                  case "m.emote":
                    return new TextTile(options);

                  case "m.image":
                    return new ImageTile(options);

                  case "m.video":
                    return new VideoTile(options);

                  case "m.file":
                    return new FileTile(options);

                  case "m.location":
                    return new LocationTile(options);

                  default:
                    // unknown msgtype not rendered
                    return null;
                }
              }

            case "m.room.name":
              return new RoomNameTile(options);

            case "m.room.member":
              return new RoomMemberTile(options);

            case "m.room.encrypted":
              if (entry.isRedacted) {
                return new RedactedTile(options);
              }

              return new EncryptedEventTile(options);

            case "m.room.encryption":
              return new EncryptionEnabledTile(options);

            default:
              // unknown type not rendered
              return null;
          }
        }
      };
    }

    function _templateObject6$8() {
      var data = _taggedTemplateLiteral(["You left this room"]);

      _templateObject6$8 = function _templateObject6() {
        return data;
      };

      return data;
    }

    function _templateObject5$b() {
      var data = _taggedTemplateLiteral(["You were banned from the room by ", "."]);

      _templateObject5$b = function _templateObject5() {
        return data;
      };

      return data;
    }

    function _templateObject4$d() {
      var data = _taggedTemplateLiteral(["You were banned from the room by ", " because: ", ""]);

      _templateObject4$d = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3$g() {
      var data = _taggedTemplateLiteral(["You were kicked from the room by ", "."]);

      _templateObject3$g = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$n() {
      var data = _taggedTemplateLiteral(["You were kicked from the room by ", " because: ", ""]);

      _templateObject2$n = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$t() {
      var data = _taggedTemplateLiteral(["Empty Room"]);

      _templateObject$t = function _templateObject() {
        return data;
      };

      return data;
    }
    var RoomViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(RoomViewModel, _ViewModel);

      var _super = _createSuper(RoomViewModel);

      function RoomViewModel(options) {
        var _this;

        _classCallCheck(this, RoomViewModel);

        _this = _super.call(this, options);
        var room = options.room;
        _this._room = room;
        _this._timelineVM = null;
        _this._tilesCreator = null;
        _this._onRoomChange = _this._onRoomChange.bind(_assertThisInitialized(_this));
        _this._timelineError = null;
        _this._sendError = null;
        _this._composerVM = null;

        if (room.isArchived) {
          _this._composerVM = new ArchivedViewModel(_this.childOptions({
            archivedRoom: room
          }));
        } else {
          _this._composerVM = new ComposerViewModel(_assertThisInitialized(_this));
        }

        _this._clearUnreadTimout = null;
        _this._closeUrl = _this.urlCreator.urlUntilSegment("session");
        return _this;
      }

      _createClass(RoomViewModel, [{
        key: "load",
        value: function () {
          var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var timeline;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this._room.on("change", this._onRoomChange);

                    _context.prev = 1;
                    _context.next = 4;
                    return this._room.openTimeline();

                  case 4:
                    timeline = _context.sent;
                    this._tilesCreator = tilesCreator(this.childOptions({
                      roomVM: this,
                      timeline: timeline
                    }));
                    this._timelineVM = this.track(new TimelineViewModel(this.childOptions({
                      tilesCreator: this._tilesCreator,
                      timeline: timeline
                    })));
                    this.emitChange("timelineViewModel");
                    _context.next = 15;
                    break;

                  case 10:
                    _context.prev = 10;
                    _context.t0 = _context["catch"](1);
                    console.error("room.openTimeline(): ".concat(_context.t0.message, ":\n").concat(_context.t0.stack));
                    this._timelineError = _context.t0;
                    this.emitChange("error");

                  case 15:
                    this._clearUnreadAfterDelay();

                  case 16:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[1, 10]]);
          }));

          function load() {
            return _load.apply(this, arguments);
          }

          return load;
        }()
      }, {
        key: "_clearUnreadAfterDelay",
        value: function () {
          var _clearUnreadAfterDelay2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (!(this._room.isArchived || this._clearUnreadTimout)) {
                      _context2.next = 2;
                      break;
                    }

                    return _context2.abrupt("return");

                  case 2:
                    this._clearUnreadTimout = this.clock.createTimeout(2000);
                    _context2.prev = 3;
                    _context2.next = 6;
                    return this._clearUnreadTimout.elapsed();

                  case 6:
                    _context2.next = 8;
                    return this._room.clearUnread();

                  case 8:
                    this._clearUnreadTimout = null;
                    _context2.next = 15;
                    break;

                  case 11:
                    _context2.prev = 11;
                    _context2.t0 = _context2["catch"](3);

                    if (!(_context2.t0.name !== "AbortError")) {
                      _context2.next = 15;
                      break;
                    }

                    throw _context2.t0;

                  case 15:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[3, 11]]);
          }));

          function _clearUnreadAfterDelay() {
            return _clearUnreadAfterDelay2.apply(this, arguments);
          }

          return _clearUnreadAfterDelay;
        }()
      }, {
        key: "focus",
        value: function focus() {
          this._clearUnreadAfterDelay();
        }
      }, {
        key: "dispose",
        value: function dispose() {
          _get(_getPrototypeOf(RoomViewModel.prototype), "dispose", this).call(this);

          this._room.off("change", this._onRoomChange);

          if (this._room.isArchived) {
            this._room.release();
          }

          if (this._clearUnreadTimout) {
            this._clearUnreadTimout.abort();

            this._clearUnreadTimout = null;
          }
        } // room doesn't tell us yet which fields changed,
        // so emit all fields originating from summary

      }, {
        key: "_onRoomChange",
        value: function _onRoomChange() {
          if (this._room.isArchived) {
            this._composerVM.emitChange();
          }

          this.emitChange();
        }
      }, {
        key: "avatarUrl",
        value: function avatarUrl(size) {
          return getAvatarHttpUrl(this._room.avatarUrl, size, this.platform, this._room.mediaRepository);
        }
      }, {
        key: "leaveRoom",
        value: function leaveRoom() {
          this._room.leave();
        }
      }, {
        key: "forgetRoom",
        value: function forgetRoom() {
          this._room.forget();
        }
      }, {
        key: "rejoinRoom",
        value: function rejoinRoom() {
          this._room.join();
        }
      }, {
        key: "_createTile",
        value: function _createTile(entry) {
          return this._tilesCreator(entry);
        }
      }, {
        key: "_sendMessage",
        value: function () {
          var _sendMessage2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(message, replyingTo) {
            var msgtype;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (!(!this._room.isArchived && message)) {
                      _context3.next = 21;
                      break;
                    }

                    _context3.prev = 1;
                    msgtype = "m.text";

                    if (message.startsWith("/me ")) {
                      message = message.substr(4).trim();
                      msgtype = "m.emote";
                    }

                    if (!replyingTo) {
                      _context3.next = 9;
                      break;
                    }

                    _context3.next = 7;
                    return replyingTo.reply(msgtype, message);

                  case 7:
                    _context3.next = 11;
                    break;

                  case 9:
                    _context3.next = 11;
                    return this._room.sendEvent("m.room.message", {
                      msgtype: msgtype,
                      body: message
                    });

                  case 11:
                    _context3.next = 20;
                    break;

                  case 13:
                    _context3.prev = 13;
                    _context3.t0 = _context3["catch"](1);
                    console.error("room.sendMessage(): ".concat(_context3.t0.message, ":\n").concat(_context3.t0.stack));
                    this._sendError = _context3.t0;
                    this._timelineError = null;
                    this.emitChange("error");
                    return _context3.abrupt("return", false);

                  case 20:
                    return _context3.abrupt("return", true);

                  case 21:
                    return _context3.abrupt("return", false);

                  case 22:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[1, 13]]);
          }));

          function _sendMessage(_x, _x2) {
            return _sendMessage2.apply(this, arguments);
          }

          return _sendMessage;
        }()
      }, {
        key: "_pickAndSendFile",
        value: function () {
          var _pickAndSendFile2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
            var file;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.prev = 0;
                    _context4.next = 3;
                    return this.platform.openFile();

                  case 3:
                    file = _context4.sent;

                    if (file) {
                      _context4.next = 6;
                      break;
                    }

                    return _context4.abrupt("return");

                  case 6:
                    return _context4.abrupt("return", this._sendFile(file));

                  case 9:
                    _context4.prev = 9;
                    _context4.t0 = _context4["catch"](0);
                    console.error(_context4.t0);

                  case 12:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this, [[0, 9]]);
          }));

          function _pickAndSendFile() {
            return _pickAndSendFile2.apply(this, arguments);
          }

          return _pickAndSendFile;
        }()
      }, {
        key: "_sendFile",
        value: function () {
          var _sendFile2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(file) {
            var content;
            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    content = {
                      body: file.name,
                      msgtype: "m.file"
                    };
                    _context5.next = 3;
                    return this._room.sendEvent("m.room.message", content, {
                      "url": this._room.createAttachment(file.blob, file.name)
                    });

                  case 3:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));

          function _sendFile(_x3) {
            return _sendFile2.apply(this, arguments);
          }

          return _sendFile;
        }()
      }, {
        key: "_pickAndSendVideo",
        value: function () {
          var _pickAndSendVideo2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
            var file, video, content, attachments, limit, maxDimension, thumbnail;
            return regeneratorRuntime.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    _context6.prev = 0;

                    if (this.platform.hasReadPixelPermission()) {
                      _context6.next = 4;
                      break;
                    }

                    alert("Please allow canvas image data access, so we can scale your images down.");
                    return _context6.abrupt("return");

                  case 4:
                    _context6.next = 6;
                    return this.platform.openFile("video/*");

                  case 6:
                    file = _context6.sent;

                    if (file) {
                      _context6.next = 9;
                      break;
                    }

                    return _context6.abrupt("return");

                  case 9:
                    if (file.blob.mimeType.startsWith("video/")) {
                      _context6.next = 11;
                      break;
                    }

                    return _context6.abrupt("return", this._sendFile(file));

                  case 11:
                    _context6.prev = 11;
                    _context6.next = 14;
                    return this.platform.loadVideo(file.blob);

                  case 14:
                    video = _context6.sent;
                    _context6.next = 24;
                    break;

                  case 17:
                    _context6.prev = 17;
                    _context6.t0 = _context6["catch"](11);

                    if (!(_context6.t0 instanceof window.MediaError && _context6.t0.code === 4)) {
                      _context6.next = 23;
                      break;
                    }

                    throw new Error("this browser does not support videos of type ".concat(file === null || file === void 0 ? void 0 : file.blob.mimeType, "."));

                  case 23:
                    throw _context6.t0;

                  case 24:
                    content = {
                      body: file.name,
                      msgtype: "m.video",
                      info: videoToInfo(video)
                    };
                    attachments = {
                      "url": this._room.createAttachment(video.blob, file.name)
                    };
                    _context6.next = 28;
                    return this.platform.settingsStorage.getInt("sentImageSizeLimit");

                  case 28:
                    limit = _context6.sent;
                    maxDimension = limit || Math.min(video.maxDimension, 800);
                    _context6.next = 32;
                    return video.scale(maxDimension);

                  case 32:
                    thumbnail = _context6.sent;
                    content.info.thumbnail_info = imageToInfo(thumbnail);
                    attachments["info.thumbnail_url"] = this._room.createAttachment(thumbnail.blob, file.name);
                    _context6.next = 37;
                    return this._room.sendEvent("m.room.message", content, attachments);

                  case 37:
                    _context6.next = 44;
                    break;

                  case 39:
                    _context6.prev = 39;
                    _context6.t1 = _context6["catch"](0);
                    this._sendError = _context6.t1;
                    this.emitChange("error");
                    console.error(_context6.t1.stack);

                  case 44:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6, this, [[0, 39], [11, 17]]);
          }));

          function _pickAndSendVideo() {
            return _pickAndSendVideo2.apply(this, arguments);
          }

          return _pickAndSendVideo;
        }()
      }, {
        key: "_pickAndSendPicture",
        value: function () {
          var _pickAndSendPicture2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
            var file, image, limit, content, attachments, thumbnail;
            return regeneratorRuntime.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.prev = 0;

                    if (this.platform.hasReadPixelPermission()) {
                      _context7.next = 4;
                      break;
                    }

                    alert("Please allow canvas image data access, so we can scale your images down.");
                    return _context7.abrupt("return");

                  case 4:
                    _context7.next = 6;
                    return this.platform.openFile("image/*");

                  case 6:
                    file = _context7.sent;

                    if (file) {
                      _context7.next = 9;
                      break;
                    }

                    return _context7.abrupt("return");

                  case 9:
                    if (file.blob.mimeType.startsWith("image/")) {
                      _context7.next = 11;
                      break;
                    }

                    return _context7.abrupt("return", this._sendFile(file));

                  case 11:
                    _context7.next = 13;
                    return this.platform.loadImage(file.blob);

                  case 13:
                    image = _context7.sent;
                    _context7.next = 16;
                    return this.platform.settingsStorage.getInt("sentImageSizeLimit");

                  case 16:
                    limit = _context7.sent;

                    if (!(limit && image.maxDimension > limit)) {
                      _context7.next = 21;
                      break;
                    }

                    _context7.next = 20;
                    return image.scale(limit);

                  case 20:
                    image = _context7.sent;

                  case 21:
                    content = {
                      body: file.name,
                      msgtype: "m.image",
                      info: imageToInfo(image)
                    };
                    attachments = {
                      "url": this._room.createAttachment(image.blob, file.name)
                    };

                    if (!(image.maxDimension > 600)) {
                      _context7.next = 29;
                      break;
                    }

                    _context7.next = 26;
                    return image.scale(400);

                  case 26:
                    thumbnail = _context7.sent;
                    content.info.thumbnail_info = imageToInfo(thumbnail);
                    attachments["info.thumbnail_url"] = this._room.createAttachment(thumbnail.blob, file.name);

                  case 29:
                    _context7.next = 31;
                    return this._room.sendEvent("m.room.message", content, attachments);

                  case 31:
                    _context7.next = 38;
                    break;

                  case 33:
                    _context7.prev = 33;
                    _context7.t0 = _context7["catch"](0);
                    this._sendError = _context7.t0;
                    this.emitChange("error");
                    console.error(_context7.t0.stack);

                  case 38:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7, this, [[0, 33]]);
          }));

          function _pickAndSendPicture() {
            return _pickAndSendPicture2.apply(this, arguments);
          }

          return _pickAndSendPicture;
        }()
      }, {
        key: "openDetailsPanel",
        value: function openDetailsPanel() {
          var path = this.navigation.path.until("room");
          path = path.with(this.navigation.segment("right-panel", true));
          path = path.with(this.navigation.segment("details", true));
          this.navigation.applyPath(path);
        }
      }, {
        key: "startReply",
        value: function startReply(entry) {
          if (!this._room.isArchived) {
            this._composerVM.setReplyingTo(entry);
          }
        }
      }, {
        key: "kind",
        get: function get() {
          return "room";
        }
      }, {
        key: "closeUrl",
        get: function get() {
          return this._closeUrl;
        }
      }, {
        key: "name",
        get: function get() {
          return this._room.name || this.i18n(_templateObject$t());
        }
      }, {
        key: "id",
        get: function get() {
          return this._room.id;
        }
      }, {
        key: "timelineViewModel",
        get: function get() {
          return this._timelineVM;
        }
      }, {
        key: "isEncrypted",
        get: function get() {
          return this._room.isEncrypted;
        }
      }, {
        key: "error",
        get: function get() {
          if (this._timelineError) {
            return "Something went wrong loading the timeline: ".concat(this._timelineError.message);
          }

          if (this._sendError) {
            return "Something went wrong sending your message: ".concat(this._sendError.message);
          }

          return "";
        }
      }, {
        key: "avatarLetter",
        get: function get() {
          return avatarInitials(this.name);
        }
      }, {
        key: "avatarColorNumber",
        get: function get() {
          return getIdentifierColorNumber(this._room.avatarColorId);
        }
      }, {
        key: "avatarTitle",
        get: function get() {
          return this.name;
        }
      }, {
        key: "canLeave",
        get: function get() {
          return this._room.isJoined;
        }
      }, {
        key: "canForget",
        get: function get() {
          return this._room.isArchived;
        }
      }, {
        key: "canRejoin",
        get: function get() {
          return this._room.isArchived;
        }
      }, {
        key: "room",
        get: function get() {
          return this._room;
        }
      }, {
        key: "composerViewModel",
        get: function get() {
          return this._composerVM;
        }
      }]);

      return RoomViewModel;
    }(ViewModel);

    function imageToInfo(image) {
      return {
        w: image.width,
        h: image.height,
        mimetype: image.blob.mimeType,
        size: image.blob.size
      };
    }

    function videoToInfo(video) {
      var info = imageToInfo(video);
      info.duration = video.duration;
      return info;
    }

    var ArchivedViewModel = /*#__PURE__*/function (_ViewModel2) {
      _inherits(ArchivedViewModel, _ViewModel2);

      var _super2 = _createSuper(ArchivedViewModel);

      function ArchivedViewModel(options) {
        var _this2;

        _classCallCheck(this, ArchivedViewModel);

        _this2 = _super2.call(this, options);
        _this2._archivedRoom = options.archivedRoom;
        return _this2;
      }

      _createClass(ArchivedViewModel, [{
        key: "description",
        get: function get() {
          if (this._archivedRoom.isKicked) {
            if (this._archivedRoom.kickReason) {
              return this.i18n(_templateObject2$n(), this._archivedRoom.kickedBy.name, this._archivedRoom.kickReason);
            } else {
              return this.i18n(_templateObject3$g(), this._archivedRoom.kickedBy.name);
            }
          } else if (this._archivedRoom.isBanned) {
            if (this._archivedRoom.kickReason) {
              return this.i18n(_templateObject4$d(), this._archivedRoom.kickedBy.name, this._archivedRoom.kickReason);
            } else {
              return this.i18n(_templateObject5$b(), this._archivedRoom.kickedBy.name);
            }
          } else {
            return this.i18n(_templateObject6$8());
          }
        }
      }, {
        key: "kind",
        get: function get() {
          return "archived";
        }
      }]);

      return ArchivedViewModel;
    }(ViewModel);

    var UnknownRoomViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(UnknownRoomViewModel, _ViewModel);

      var _super = _createSuper(UnknownRoomViewModel);

      function UnknownRoomViewModel(options) {
        var _this;

        _classCallCheck(this, UnknownRoomViewModel);

        _this = _super.call(this, options);
        var roomIdOrAlias = options.roomIdOrAlias,
            session = options.session;
        _this._session = session;
        _this.roomIdOrAlias = roomIdOrAlias;
        _this._error = null;
        _this._busy = false;
        return _this;
      }

      _createClass(UnknownRoomViewModel, [{
        key: "join",
        value: function () {
          var _join = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var roomId;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this._busy = true;
                    this.emitChange("busy");
                    _context.prev = 2;
                    _context.next = 5;
                    return this._session.joinRoom(this.roomIdOrAlias);

                  case 5:
                    roomId = _context.sent;
                    // navigate to roomId if we were at the alias
                    // so we're subscribed to the right room status
                    // and we'll switch to the room view model once
                    // the join is synced
                    this.navigation.push("room", roomId); // keep busy on true while waiting for the join to sync

                    _context.next = 14;
                    break;

                  case 9:
                    _context.prev = 9;
                    _context.t0 = _context["catch"](2);
                    this._error = _context.t0;
                    this._busy = false;
                    this.emitChange("error");

                  case 14:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[2, 9]]);
          }));

          function join() {
            return _join.apply(this, arguments);
          }

          return join;
        }()
      }, {
        key: "error",
        get: function get() {
          var _this$_error;

          return (_this$_error = this._error) === null || _this$_error === void 0 ? void 0 : _this$_error.message;
        }
      }, {
        key: "busy",
        get: function get() {
          return this._busy;
        }
      }, {
        key: "kind",
        get: function get() {
          return "unknown";
        }
      }]);

      return UnknownRoomViewModel;
    }(ViewModel);

    var InviteViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(InviteViewModel, _ViewModel);

      var _super = _createSuper(InviteViewModel);

      function InviteViewModel(options) {
        var _this;

        _classCallCheck(this, InviteViewModel);

        _this = _super.call(this, options);
        var invite = options.invite,
            mediaRepository = options.mediaRepository;
        _this._invite = invite;
        _this._mediaRepository = mediaRepository;
        _this._onInviteChange = _this._onInviteChange.bind(_assertThisInitialized(_this));
        _this._error = null;
        _this._closeUrl = _this.urlCreator.urlUntilSegment("session");

        _this._invite.on("change", _this._onInviteChange);

        _this._inviter = null;

        if (_this._invite.inviter) {
          _this._inviter = new RoomMemberViewModel(_this._invite.inviter, mediaRepository, _this.platform);
        }

        _this._roomDescription = _this._createRoomDescription();
        return _this;
      }

      _createClass(InviteViewModel, [{
        key: "avatarUrl",
        value: function avatarUrl(size) {
          return getAvatarHttpUrl(this._invite.avatarUrl, size, this.platform, this._mediaRepository);
        }
      }, {
        key: "_createRoomDescription",
        value: function _createRoomDescription() {
          var parts = [];

          if (this._invite.isPublic) {
            parts.push("Public room");
          } else {
            parts.push("Private room");
          }

          if (this._invite.canonicalAlias) {
            parts.push(this._invite.canonicalAlias);
          }

          return parts.join(" • ");
        }
      }, {
        key: "focus",
        value: function focus() {}
      }, {
        key: "accept",
        value: function () {
          var _accept = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.prev = 0;
                    _context.next = 3;
                    return this._invite.accept();

                  case 3:
                    _context.next = 9;
                    break;

                  case 5:
                    _context.prev = 5;
                    _context.t0 = _context["catch"](0);
                    this._error = _context.t0;
                    this.emitChange("error");

                  case 9:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[0, 5]]);
          }));

          function accept() {
            return _accept.apply(this, arguments);
          }

          return accept;
        }()
      }, {
        key: "reject",
        value: function () {
          var _reject = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.prev = 0;
                    _context2.next = 3;
                    return this._invite.reject();

                  case 3:
                    _context2.next = 9;
                    break;

                  case 5:
                    _context2.prev = 5;
                    _context2.t0 = _context2["catch"](0);
                    this._error = _context2.t0;
                    this.emitChange("error");

                  case 9:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[0, 5]]);
          }));

          function reject() {
            return _reject.apply(this, arguments);
          }

          return reject;
        }()
      }, {
        key: "_onInviteChange",
        value: function _onInviteChange() {
          this.emitChange();
        }
      }, {
        key: "dispose",
        value: function dispose() {
          _get(_getPrototypeOf(InviteViewModel.prototype), "dispose", this).call(this);

          this._invite.off("change", this._onInviteChange);
        }
      }, {
        key: "kind",
        get: function get() {
          return "invite";
        }
      }, {
        key: "closeUrl",
        get: function get() {
          return this._closeUrl;
        }
      }, {
        key: "name",
        get: function get() {
          return this._invite.name;
        }
      }, {
        key: "id",
        get: function get() {
          return this._invite.id;
        }
      }, {
        key: "isEncrypted",
        get: function get() {
          return this._invite.isEncrypted;
        }
      }, {
        key: "isDirectMessage",
        get: function get() {
          return this._invite.isDirectMessage;
        }
      }, {
        key: "inviter",
        get: function get() {
          return this._inviter;
        }
      }, {
        key: "busy",
        get: function get() {
          return this._invite.accepting || this._invite.rejecting;
        }
      }, {
        key: "error",
        get: function get() {
          if (this._error) {
            return "Something went wrong: ".concat(this._error.message);
          }

          return "";
        }
      }, {
        key: "avatarLetter",
        get: function get() {
          return avatarInitials(this.name);
        }
      }, {
        key: "avatarColorNumber",
        get: function get() {
          return getIdentifierColorNumber(this._invite.avatarColorId);
        }
      }, {
        key: "roomDescription",
        get: function get() {
          return this._roomDescription;
        }
      }, {
        key: "avatarTitle",
        get: function get() {
          return this.name;
        }
      }]);

      return InviteViewModel;
    }(ViewModel);

    var RoomMemberViewModel = /*#__PURE__*/function () {
      function RoomMemberViewModel(member, mediaRepository, platform) {
        _classCallCheck(this, RoomMemberViewModel);

        this._member = member;
        this._mediaRepository = mediaRepository;
        this._platform = platform;
      }

      _createClass(RoomMemberViewModel, [{
        key: "avatarUrl",
        value: function avatarUrl(size) {
          return getAvatarHttpUrl(this._member.avatarUrl, size, this._platform, this._mediaRepository);
        }
      }, {
        key: "id",
        get: function get() {
          return this._member.userId;
        }
      }, {
        key: "name",
        get: function get() {
          return this._member.name;
        }
      }, {
        key: "avatarLetter",
        get: function get() {
          return avatarInitials(this.name);
        }
      }, {
        key: "avatarColorNumber",
        get: function get() {
          return getIdentifierColorNumber(this._member.userId);
        }
      }, {
        key: "avatarTitle",
        get: function get() {
          return this.name;
        }
      }]);

      return RoomMemberViewModel;
    }();

    var LightboxViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(LightboxViewModel, _ViewModel);

      var _super = _createSuper(LightboxViewModel);

      function LightboxViewModel(options) {
        var _this;

        _classCallCheck(this, LightboxViewModel);

        _this = _super.call(this, options);
        _this._eventId = options.eventId;
        _this._unencryptedImageUrl = null;
        _this._decryptedImage = null;
        _this._closeUrl = _this.urlCreator.urlUntilSegment("room");
        _this._eventEntry = null;
        _this._date = null;

        _this._subscribeToEvent(options.room, options.eventId);

        return _this;
      }

      _createClass(LightboxViewModel, [{
        key: "_subscribeToEvent",
        value: function _subscribeToEvent(room, eventId) {
          var _this2 = this;

          var eventObservable = room.observeEvent(eventId);
          this.track(eventObservable.subscribe(function (eventEntry) {
            _this2._loadEvent(room, eventEntry);
          }));

          this._loadEvent(room, eventObservable.get());
        }
      }, {
        key: "_loadEvent",
        value: function () {
          var _loadEvent2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(room, eventEntry) {
            var mediaRepository, content;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (eventEntry) {
                      _context.next = 2;
                      break;
                    }

                    return _context.abrupt("return");

                  case 2:
                    mediaRepository = room.mediaRepository;
                    this._eventEntry = eventEntry;
                    content = this._eventEntry.content;
                    this._date = this._eventEntry.timestamp ? new Date(this._eventEntry.timestamp) : null;

                    if (!content.url) {
                      _context.next = 11;
                      break;
                    }

                    this._unencryptedImageUrl = mediaRepository.mxcUrl(content.url);
                    this.emitChange("imageUrl");
                    _context.next = 18;
                    break;

                  case 11:
                    if (!content.file) {
                      _context.next = 18;
                      break;
                    }

                    _context.t0 = this;
                    _context.next = 15;
                    return mediaRepository.downloadEncryptedFile(content.file);

                  case 15:
                    _context.t1 = _context.sent;
                    this._decryptedImage = _context.t0.track.call(_context.t0, _context.t1);
                    this.emitChange("imageUrl");

                  case 18:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function _loadEvent(_x, _x2) {
            return _loadEvent2.apply(this, arguments);
          }

          return _loadEvent;
        }()
      }, {
        key: "close",
        value: function close() {
          this.platform.history.pushUrl(this.closeUrl);
        }
      }, {
        key: "imageWidth",
        get: function get() {
          var _this$_eventEntry, _this$_eventEntry$con, _this$_eventEntry$con2;

          return (_this$_eventEntry = this._eventEntry) === null || _this$_eventEntry === void 0 ? void 0 : (_this$_eventEntry$con = _this$_eventEntry.content) === null || _this$_eventEntry$con === void 0 ? void 0 : (_this$_eventEntry$con2 = _this$_eventEntry$con.info) === null || _this$_eventEntry$con2 === void 0 ? void 0 : _this$_eventEntry$con2.w;
        }
      }, {
        key: "imageHeight",
        get: function get() {
          var _this$_eventEntry2, _this$_eventEntry2$co, _this$_eventEntry2$co2;

          return (_this$_eventEntry2 = this._eventEntry) === null || _this$_eventEntry2 === void 0 ? void 0 : (_this$_eventEntry2$co = _this$_eventEntry2.content) === null || _this$_eventEntry2$co === void 0 ? void 0 : (_this$_eventEntry2$co2 = _this$_eventEntry2$co.info) === null || _this$_eventEntry2$co2 === void 0 ? void 0 : _this$_eventEntry2$co2.h;
        }
      }, {
        key: "name",
        get: function get() {
          var _this$_eventEntry3, _this$_eventEntry3$co;

          return (_this$_eventEntry3 = this._eventEntry) === null || _this$_eventEntry3 === void 0 ? void 0 : (_this$_eventEntry3$co = _this$_eventEntry3.content) === null || _this$_eventEntry3$co === void 0 ? void 0 : _this$_eventEntry3$co.body;
        }
      }, {
        key: "sender",
        get: function get() {
          var _this$_eventEntry4;

          return (_this$_eventEntry4 = this._eventEntry) === null || _this$_eventEntry4 === void 0 ? void 0 : _this$_eventEntry4.displayName;
        }
      }, {
        key: "imageUrl",
        get: function get() {
          if (this._decryptedImage) {
            return this._decryptedImage.url;
          } else if (this._unencryptedImageUrl) {
            return this._unencryptedImageUrl;
          } else {
            return "";
          }
        }
      }, {
        key: "date",
        get: function get() {
          return this._date && this._date.toLocaleDateString({}, {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric'
          });
        }
      }, {
        key: "time",
        get: function get() {
          return this._date && this._date.toLocaleTimeString({}, {
            hour: "numeric",
            minute: "2-digit"
          });
        }
      }, {
        key: "closeUrl",
        get: function get() {
          return this._closeUrl;
        }
      }]);

      return LightboxViewModel;
    }(ViewModel);

    function _templateObject5$c() {
      var data = _taggedTemplateLiteral(["Set up session backup to decrypt older messages."]);

      _templateObject5$c = function _templateObject5() {
        return data;
      };

      return data;
    }

    function _templateObject4$e() {
      var data = _taggedTemplateLiteral(["Sync failed because of ", ""]);

      _templateObject4$e = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3$h() {
      var data = _taggedTemplateLiteral(["Catching up with your conversations\u2026"]);

      _templateObject3$h = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$o() {
      var data = _taggedTemplateLiteral(["Trying to reconnect now\u2026"]);

      _templateObject2$o = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$u() {
      var data = _taggedTemplateLiteral(["Disconnected, trying to reconnect in ", "s\u2026"]);

      _templateObject$u = function _templateObject() {
        return data;
      };

      return data;
    }
    var SessionStatus = createEnum("Disconnected", "Connecting", "FirstSync", "Sending", "Syncing", "SyncError");
    var SessionStatusViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(SessionStatusViewModel, _ViewModel);

      var _super = _createSuper(SessionStatusViewModel);

      function SessionStatusViewModel(options) {
        var _this;

        _classCallCheck(this, SessionStatusViewModel);

        _this = _super.call(this, options);
        var sync = options.sync,
            reconnector = options.reconnector,
            session = options.session;
        _this._sync = sync;
        _this._reconnector = reconnector;
        _this._status = _this._calculateState(reconnector.connectionStatus.get(), sync.status.get());
        _this._session = session;
        _this._setupSessionBackupUrl = _this.urlCreator.urlForSegment("settings");
        _this._dismissSecretStorage = false;
        return _this;
      }

      _createClass(SessionStatusViewModel, [{
        key: "start",
        value: function start() {
          var _this2 = this;

          var update = function update() {
            return _this2._updateStatus();
          };

          this.track(this._sync.status.subscribe(update));
          this.track(this._reconnector.connectionStatus.subscribe(update));
          this.track(this._session.needsSessionBackup.subscribe(function () {
            _this2.emitChange();
          }));
        }
      }, {
        key: "_updateStatus",
        value: function _updateStatus() {
          var _this3 = this;

          var newStatus = this._calculateState(this._reconnector.connectionStatus.get(), this._sync.status.get());

          if (newStatus !== this._status) {
            if (newStatus === SessionStatus.Disconnected) {
              this._retryTimer = this.track(this.clock.createInterval(function () {
                _this3.emitChange("statusLabel");
              }, 1000));
            } else {
              this._retryTimer = this.disposeTracked(this._retryTimer);
            }

            this._status = newStatus;
            this.emitChange();
          }
        }
      }, {
        key: "_calculateState",
        value: function _calculateState(connectionStatus, syncStatus) {
          if (connectionStatus !== ConnectionStatus.Online) {
            switch (connectionStatus) {
              case ConnectionStatus.Reconnecting:
                return SessionStatus.Connecting;

              case ConnectionStatus.Waiting:
                return SessionStatus.Disconnected;
            }
          } else if (syncStatus !== SyncStatus.Syncing) {
            switch (syncStatus) {
              // InitialSync should be awaited in the SessionLoadViewModel,
              // but include it here anyway
              case SyncStatus.InitialSync:
              case SyncStatus.CatchupSync:
                return SessionStatus.FirstSync;

              case SyncStatus.Stopped:
                return SessionStatus.SyncError;
            }
          }
          /* else if (session.pendingMessageCount) {
            return SessionStatus.Sending;
          } */
          else {
              return SessionStatus.Syncing;
            }
        }
      }, {
        key: "dismiss",
        value: function dismiss() {
          if (this.isSecretStorageShown) {
            this._dismissSecretStorage = true;
            this.emitChange();
          }
        }
      }, {
        key: "connectNow",
        value: function connectNow() {
          if (this.isConnectNowShown) {
            this._reconnector.tryNow();
          }
        }
      }, {
        key: "setupSessionBackupUrl",
        get: function get() {
          return this._setupSessionBackupUrl;
        }
      }, {
        key: "isShown",
        get: function get() {
          return this._session.needsSessionBackup.get() && !this._dismissSecretStorage || this._status !== SessionStatus.Syncing;
        }
      }, {
        key: "statusLabel",
        get: function get() {
          switch (this._status) {
            case SessionStatus.Disconnected:
              {
                var retryIn = Math.round(this._reconnector.retryIn / 1000);
                return this.i18n(_templateObject$u(), retryIn);
              }

            case SessionStatus.Connecting:
              return this.i18n(_templateObject2$o());

            case SessionStatus.FirstSync:
              return this.i18n(_templateObject3$h());

            case SessionStatus.SyncError:
              return this.i18n(_templateObject4$e(), this._sync.error);
          }

          if (this._session.needsSessionBackup.get()) {
            return this.i18n(_templateObject5$c());
          }

          return "";
        }
      }, {
        key: "isWaiting",
        get: function get() {
          switch (this._status) {
            case SessionStatus.Connecting:
            case SessionStatus.FirstSync:
              return true;

            default:
              return false;
          }
        }
      }, {
        key: "isConnectNowShown",
        get: function get() {
          return this._status === SessionStatus.Disconnected;
        }
      }, {
        key: "isSecretStorageShown",
        get: function get() {
          // TODO: we need a model here where we can have multiple messages queued up and their buttons don't bleed into each other.
          return this._status === SessionStatus.Syncing && this._session.needsSessionBackup.get() && !this._dismissSecretStorage;
        }
      }, {
        key: "canDismiss",
        get: function get() {
          return this.isSecretStorageShown;
        }
      }]);

      return SessionStatusViewModel;
    }(ViewModel);

    function dedupeSparse(roomIds) {
      return roomIds.map(function (id, idx) {
        if (roomIds.slice(0, idx).includes(id)) {
          return undefined;
        } else {
          return id;
        }
      });
    }

    var RoomGridViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(RoomGridViewModel, _ViewModel);

      var _super = _createSuper(RoomGridViewModel);

      function RoomGridViewModel(options) {
        var _this;

        _classCallCheck(this, RoomGridViewModel);

        _this = _super.call(this, options);
        _this._width = options.width;
        _this._height = options.height;
        _this._createRoomViewModelObservable = options.createRoomViewModelObservable;
        _this._selectedIndex = 0;
        _this._viewModelsObservables = [];

        _this._setupNavigation();

        return _this;
      }

      _createClass(RoomGridViewModel, [{
        key: "_setupNavigation",
        value: function _setupNavigation() {
          var _this2 = this;

          var focusTileIndex = this.navigation.observe("empty-grid-tile");
          this.track(focusTileIndex.subscribe(function (index) {
            if (typeof index === "number") {
              _this2._setFocusIndex(index);
            }
          }));

          if (typeof focusTileIndex.get() === "number") {
            this._selectedIndex = focusTileIndex.get();
          }

          var focusedRoom = this.navigation.observe("room");
          this.track(focusedRoom.subscribe(function (roomId) {
            if (roomId) {
              // as the room will be in the "rooms" observable
              // (monitored by the parent vmo) as well,
              // we only change the focus here and trust
              // setRoomIds to have created the vmo already
              _this2._setFocusRoom(roomId);
            }
          })); // initial focus for a room is set by initializeRoomIdsAndTransferVM
        }
      }, {
        key: "roomViewModelAt",
        value: function roomViewModelAt(i) {
          var _this$_viewModelsObse;

          return (_this$_viewModelsObse = this._viewModelsObservables[i]) === null || _this$_viewModelsObse === void 0 ? void 0 : _this$_viewModelsObse.get();
        }
      }, {
        key: "_switchToRoom",
        value: function _switchToRoom(roomId) {
          var path = this.navigation.path.until("rooms");
          path = path.with(this.navigation.segment("room", roomId));
          path = addPanelIfNeeded(this.navigation, path);
          this.navigation.applyPath(path);
        }
      }, {
        key: "focusTile",
        value: function focusTile(index) {
          if (index === this._selectedIndex) {
            return;
          }

          var vmo = this._viewModelsObservables[index];

          if (vmo) {
            this._switchToRoom(vmo.id);
          } else {
            this.navigation.push("empty-grid-tile", index);
          }
        }
        /** called from SessionViewModel */

      }, {
        key: "initializeRoomIdsAndTransferVM",
        value: function initializeRoomIdsAndTransferVM(roomIds, existingRoomVM) {
          var _this3 = this;

          roomIds = dedupeSparse(roomIds);
          var transfered = false;

          if (existingRoomVM) {
            var index = roomIds.indexOf(existingRoomVM.id);

            if (index !== -1) {
              this._viewModelsObservables[index] = this.track(existingRoomVM);
              existingRoomVM.subscribe(function (viewModel) {
                return _this3._refreshRoomViewModel(viewModel);
              });
              transfered = true;
            }
          }

          this.setRoomIds(roomIds); // now all view models exist, set the focus to the selected room

          var focusedRoom = this.navigation.path.get("room");

          if (focusedRoom) {
            var _index = this._viewModelsObservables.findIndex(function (vmo) {
              return vmo && vmo.id === focusedRoom.value;
            });

            if (_index !== -1) {
              this._selectedIndex = _index;
            }
          }

          return transfered;
        }
        /** called from SessionViewModel */

      }, {
        key: "setRoomIds",
        value: function setRoomIds(roomIds) {
          var _this4 = this;

          roomIds = dedupeSparse(roomIds);
          var changed = false;
          var len = this._height * this._width;

          for (var i = 0; i < len; i += 1) {
            var newId = roomIds[i];
            var vmo = this._viewModelsObservables[i]; // did anything change?

            if (!vmo && newId || vmo && vmo.id !== newId) {
              if (vmo) {
                this._viewModelsObservables[i] = this.disposeTracked(vmo);
              }

              if (newId) {
                var _vmo = this._createRoomViewModelObservable(newId);

                this._viewModelsObservables[i] = this.track(_vmo);

                _vmo.subscribe(function (viewModel) {
                  return _this4._refreshRoomViewModel(viewModel);
                });

                _vmo.initialize();
              }

              changed = true;
            }
          }

          if (changed) {
            this.emitChange();
          }

          return changed;
        }
      }, {
        key: "_refreshRoomViewModel",
        value: function _refreshRoomViewModel(viewModel) {
          this.emitChange();
          viewModel === null || viewModel === void 0 ? void 0 : viewModel.focus();
        }
        /** called from SessionViewModel */

      }, {
        key: "releaseRoomViewModel",
        value: function releaseRoomViewModel(roomId) {
          var index = this._viewModelsObservables.findIndex(function (vmo) {
            return vmo && vmo.id === roomId;
          });

          if (index !== -1) {
            var vmo = this._viewModelsObservables[index];
            this.untrack(vmo);
            vmo.unsubscribeAll();
            this._viewModelsObservables[index] = null;
            return vmo;
          }
        }
      }, {
        key: "_setFocusIndex",
        value: function _setFocusIndex(idx) {
          var _vmo$get;

          if (idx === this._selectedIndex || idx >= this._width * this._height) {
            return;
          }

          this._selectedIndex = idx;
          var vmo = this._viewModelsObservables[this._selectedIndex];
          vmo === null || vmo === void 0 ? void 0 : (_vmo$get = vmo.get()) === null || _vmo$get === void 0 ? void 0 : _vmo$get.focus();
          this.emitChange("focusIndex");
        }
      }, {
        key: "_setFocusRoom",
        value: function _setFocusRoom(roomId) {
          var index = this._viewModelsObservables.findIndex(function (vmo) {
            return (vmo === null || vmo === void 0 ? void 0 : vmo.id) === roomId;
          });

          if (index >= 0) {
            this._setFocusIndex(index);
          }
        }
      }, {
        key: "focusIndex",
        get: function get() {
          return this._selectedIndex;
        }
      }, {
        key: "width",
        get: function get() {
          return this._width;
        }
      }, {
        key: "height",
        get: function get() {
          return this._height;
        }
      }]);

      return RoomGridViewModel;
    }(ViewModel);

    function _templateObject2$p() {
      var data = _taggedTemplateLiteral(["set up session backup"]);

      _templateObject2$p = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$v() {
      var data = _taggedTemplateLiteral(["Set up"]);

      _templateObject$v = function _templateObject() {
        return data;
      };

      return data;
    }
    var Status = createEnum("Enabled", "SetupKey", "SetupPhrase", "Pending");
    var SessionBackupViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(SessionBackupViewModel, _ViewModel);

      var _super = _createSuper(SessionBackupViewModel);

      function SessionBackupViewModel(options) {
        var _this;

        _classCallCheck(this, SessionBackupViewModel);

        _this = _super.call(this, options);
        _this._session = options.session;
        _this._error = null;
        _this._isBusy = false;
        _this._dehydratedDeviceId = undefined;
        _this._status = undefined;

        _this._reevaluateStatus();

        _this.track(_this._session.hasSecretStorageKey.subscribe(function () {
          if (_this._reevaluateStatus()) {
            _this.emitChange("status");
          }
        }));

        return _this;
      }

      _createClass(SessionBackupViewModel, [{
        key: "_reevaluateStatus",
        value: function _reevaluateStatus() {
          if (this._isBusy) {
            return false;
          }

          var status;

          var hasSecretStorageKey = this._session.hasSecretStorageKey.get();

          if (hasSecretStorageKey === true) {
            status = this._session.sessionBackup ? Status.Enabled : Status.SetupKey;
          } else if (hasSecretStorageKey === false) {
            status = Status.SetupKey;
          } else {
            status = Status.Pending;
          }

          var changed = status !== this._status;
          this._status = status;
          return changed;
        }
      }, {
        key: "offerDehydratedDeviceSetup",
        value: function offerDehydratedDeviceSetup() {
          return true;
        }
      }, {
        key: "showPhraseSetup",
        value: function showPhraseSetup() {
          if (this._status === Status.SetupKey) {
            this._status = Status.SetupPhrase;
            this.emitChange("status");
          }
        }
      }, {
        key: "showKeySetup",
        value: function showKeySetup() {
          if (this._status === Status.SetupPhrase) {
            this._status = Status.SetupKey;
            this.emitChange("status");
          }
        }
      }, {
        key: "_enterCredentials",
        value: function () {
          var _enterCredentials2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(keyType, credential, setupDehydratedDevice) {
            var key;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!credential) {
                      _context.next = 23;
                      break;
                    }

                    _context.prev = 1;
                    this._isBusy = true;
                    this.emitChange("isBusy");
                    _context.next = 6;
                    return this._session.enableSecretStorage(keyType, credential);

                  case 6:
                    key = _context.sent;

                    if (!setupDehydratedDevice) {
                      _context.next = 11;
                      break;
                    }

                    _context.next = 10;
                    return this._session.setupDehydratedDevice(key);

                  case 10:
                    this._dehydratedDeviceId = _context.sent;

                  case 11:
                    _context.next = 18;
                    break;

                  case 13:
                    _context.prev = 13;
                    _context.t0 = _context["catch"](1);
                    console.error(_context.t0);
                    this._error = _context.t0;
                    this.emitChange("error");

                  case 18:
                    _context.prev = 18;
                    this._isBusy = false;

                    this._reevaluateStatus();

                    this.emitChange("");
                    return _context.finish(18);

                  case 23:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[1, 13, 18, 23]]);
          }));

          function _enterCredentials(_x, _x2, _x3) {
            return _enterCredentials2.apply(this, arguments);
          }

          return _enterCredentials;
        }()
      }, {
        key: "enterSecurityPhrase",
        value: function enterSecurityPhrase(passphrase, setupDehydratedDevice) {
          this._enterCredentials(KeyType.Passphrase, passphrase, setupDehydratedDevice);
        }
      }, {
        key: "enterSecurityKey",
        value: function enterSecurityKey(securityKey, setupDehydratedDevice) {
          this._enterCredentials(KeyType.RecoveryKey, securityKey, setupDehydratedDevice);
        }
      }, {
        key: "disable",
        value: function () {
          var _disable = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.prev = 0;
                    this._isBusy = true;
                    this.emitChange("isBusy");
                    _context2.next = 5;
                    return this._session.disableSecretStorage();

                  case 5:
                    _context2.next = 12;
                    break;

                  case 7:
                    _context2.prev = 7;
                    _context2.t0 = _context2["catch"](0);
                    console.error(_context2.t0);
                    this._error = _context2.t0;
                    this.emitChange("error");

                  case 12:
                    _context2.prev = 12;
                    this._isBusy = false;

                    this._reevaluateStatus();

                    this.emitChange("");
                    return _context2.finish(12);

                  case 17:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[0, 7, 12, 17]]);
          }));

          function disable() {
            return _disable.apply(this, arguments);
          }

          return disable;
        }()
      }, {
        key: "decryptAction",
        get: function get() {
          return this.i18n(_templateObject$v());
        }
      }, {
        key: "purpose",
        get: function get() {
          return this.i18n(_templateObject2$p());
        }
      }, {
        key: "dehydratedDeviceId",
        get: function get() {
          return this._dehydratedDeviceId;
        }
      }, {
        key: "isBusy",
        get: function get() {
          return this._isBusy;
        }
      }, {
        key: "backupVersion",
        get: function get() {
          var _this$_session$sessio;

          return (_this$_session$sessio = this._session.sessionBackup) === null || _this$_session$sessio === void 0 ? void 0 : _this$_session$sessio.version;
        }
      }, {
        key: "status",
        get: function get() {
          return this._status;
        }
      }, {
        key: "error",
        get: function get() {
          var _this$_error;

          return (_this$_error = this._error) === null || _this$_error === void 0 ? void 0 : _this$_error.message;
        }
      }]);

      return SessionBackupViewModel;
    }(ViewModel);

    function _templateObject3$i() {
      var data = _taggedTemplateLiteral(["development version"]);

      _templateObject3$i = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$q() {
      var data = _taggedTemplateLiteral(["Push notifications are now enabled"]);

      _templateObject2$q = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$w() {
      var data = _taggedTemplateLiteral(["unknown"]);

      _templateObject$w = function _templateObject() {
        return data;
      };

      return data;
    }

    var PushNotificationStatus = function PushNotificationStatus() {
      _classCallCheck(this, PushNotificationStatus);

      this.supported = null;
      this.enabled = false;
      this.updating = false;
      this.enabledOnServer = null;
      this.serverError = null;
    };

    function formatKey(key) {
      var partLength = 4;
      var partCount = Math.ceil(key.length / partLength);
      var formattedKey = "";

      for (var i = 0; i < partCount; i += 1) {
        formattedKey += (formattedKey.length ? " " : "") + key.slice(i * partLength, (i + 1) * partLength);
      }

      return formattedKey;
    }

    var SettingsViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(SettingsViewModel, _ViewModel);

      var _super = _createSuper(SettingsViewModel);

      function SettingsViewModel(options) {
        var _this;

        _classCallCheck(this, SettingsViewModel);

        _this = _super.call(this, options);
        _this._updateService = options.updateService;
        var sessionContainer = options.sessionContainer;
        _this._sessionContainer = sessionContainer;
        _this._sessionBackupViewModel = _this.track(new SessionBackupViewModel(_this.childOptions({
          session: _this._session
        })));
        _this._closeUrl = _this.urlCreator.urlUntilSegment("session");
        _this._estimate = null;
        _this.sentImageSizeLimit = null;
        _this.minSentImageSizeLimit = 400;
        _this.maxSentImageSizeLimit = 4000;
        _this.pushNotifications = new PushNotificationStatus();
        _this._isLoggingOut = false;
        return _this;
      }

      _createClass(SettingsViewModel, [{
        key: "logout",
        value: function () {
          var _logout = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this._isLoggingOut = true;
                    _context.next = 3;
                    return this._sessionContainer.logout();

                  case 3:
                    this.emitChange("isLoggingOut");
                    this.navigation.push("session", true);

                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function logout() {
            return _logout.apply(this, arguments);
          }

          return logout;
        }()
      }, {
        key: "setSentImageSizeLimit",
        value: function setSentImageSizeLimit(size) {
          if (size > this.maxSentImageSizeLimit || size < this.minSentImageSizeLimit) {
            this.sentImageSizeLimit = null;
            this.platform.settingsStorage.remove("sentImageSizeLimit");
          } else {
            this.sentImageSizeLimit = Math.round(size);
            this.platform.settingsStorage.setInt("sentImageSizeLimit", size);
          }

          this.emitChange("sentImageSizeLimit");
        }
      }, {
        key: "load",
        value: function () {
          var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this.platform.estimateStorageUsage();

                  case 2:
                    this._estimate = _context2.sent;
                    _context2.next = 5;
                    return this.platform.settingsStorage.getInt("sentImageSizeLimit");

                  case 5:
                    this.sentImageSizeLimit = _context2.sent;
                    _context2.next = 8;
                    return this.platform.notificationService.supportsPush();

                  case 8:
                    this.pushNotifications.supported = _context2.sent;
                    _context2.next = 11;
                    return this._session.arePushNotificationsEnabled();

                  case 11:
                    this.pushNotifications.enabled = _context2.sent;
                    this.emitChange("");

                  case 13:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function load() {
            return _load.apply(this, arguments);
          }

          return load;
        }()
      }, {
        key: "checkForUpdate",
        value: function checkForUpdate() {
          var _this$platform$update;

          (_this$platform$update = this.platform.updateService) === null || _this$platform$update === void 0 ? void 0 : _this$platform$update.checkForUpdate();
        }
      }, {
        key: "_formatBytes",
        value: function _formatBytes(n) {
          if (typeof n === "number") {
            return Math.round(n / (1024 * 1024)).toFixed(1) + " MB";
          } else {
            return this.i18n(_templateObject$w());
          }
        }
      }, {
        key: "exportLogs",
        value: function () {
          var _exportLogs = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
            var logExport;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this.logger.export();

                  case 2:
                    logExport = _context3.sent;
                    this.platform.saveFileAs(logExport.asBlob(), "hydrogen-logs-".concat(this.platform.clock.now(), ".json"));

                  case 4:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function exportLogs() {
            return _exportLogs.apply(this, arguments);
          }

          return exportLogs;
        }()
      }, {
        key: "togglePushNotifications",
        value: function () {
          var _togglePushNotifications = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    this.pushNotifications.updating = true;
                    this.pushNotifications.enabledOnServer = null;
                    this.pushNotifications.serverError = null;
                    this.emitChange("pushNotifications.updating");
                    _context4.prev = 4;
                    _context4.next = 7;
                    return this._session.enablePushNotifications(!this.pushNotifications.enabled);

                  case 7:
                    if (!_context4.sent) {
                      _context4.next = 10;
                      break;
                    }

                    this.pushNotifications.enabled = !this.pushNotifications.enabled;

                    if (this.pushNotifications.enabled) {
                      this.platform.notificationService.showNotification(this.i18n(_templateObject2$q()));
                    }

                  case 10:
                    _context4.prev = 10;
                    this.pushNotifications.updating = false;
                    this.emitChange("pushNotifications.updating");
                    return _context4.finish(10);

                  case 14:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this, [[4,, 10, 14]]);
          }));

          function togglePushNotifications() {
            return _togglePushNotifications.apply(this, arguments);
          }

          return togglePushNotifications;
        }()
      }, {
        key: "checkPushEnabledOnServer",
        value: function () {
          var _checkPushEnabledOnServer = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    this.pushNotifications.enabledOnServer = null;
                    this.pushNotifications.serverError = null;
                    _context5.prev = 2;
                    _context5.next = 5;
                    return this._session.checkPusherEnabledOnHomeserver();

                  case 5:
                    this.pushNotifications.enabledOnServer = _context5.sent;
                    this.emitChange("pushNotifications.enabledOnServer");
                    _context5.next = 13;
                    break;

                  case 9:
                    _context5.prev = 9;
                    _context5.t0 = _context5["catch"](2);
                    this.pushNotifications.serverError = _context5.t0;
                    this.emitChange("pushNotifications.serverError");

                  case 13:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this, [[2, 9]]);
          }));

          function checkPushEnabledOnServer() {
            return _checkPushEnabledOnServer.apply(this, arguments);
          }

          return checkPushEnabledOnServer;
        }()
      }, {
        key: "_session",
        get: function get() {
          return this._sessionContainer.session;
        }
      }, {
        key: "isLoggingOut",
        get: function get() {
          return this._isLoggingOut;
        }
      }, {
        key: "closeUrl",
        get: function get() {
          return this._closeUrl;
        }
      }, {
        key: "fingerprintKey",
        get: function get() {
          var key = this._session.fingerprintKey;

          if (!key) {
            return null;
          }

          return formatKey(key);
        }
      }, {
        key: "deviceId",
        get: function get() {
          return this._session.deviceId;
        }
      }, {
        key: "userId",
        get: function get() {
          return this._session.userId;
        }
      }, {
        key: "version",
        get: function get() {
          var updateService = this.platform.updateService;

          if (updateService) {
            return "".concat(updateService.version, " (").concat(updateService.buildHash, ")");
          }

          return this.i18n(_templateObject3$i());
        }
      }, {
        key: "showUpdateButton",
        get: function get() {
          return !!this.platform.updateService;
        }
      }, {
        key: "sessionBackupViewModel",
        get: function get() {
          return this._sessionBackupViewModel;
        }
      }, {
        key: "storageQuota",
        get: function get() {
          var _this$_estimate;

          return this._formatBytes((_this$_estimate = this._estimate) === null || _this$_estimate === void 0 ? void 0 : _this$_estimate.quota);
        }
      }, {
        key: "storageUsage",
        get: function get() {
          var _this$_estimate2;

          return this._formatBytes((_this$_estimate2 = this._estimate) === null || _this$_estimate2 === void 0 ? void 0 : _this$_estimate2.usage);
        }
      }]);

      return SettingsViewModel;
    }(ViewModel);

    /**
    Depending on the status of a room (invited, joined, archived, or none),
    we want to show a different view with a different view model
    when showing a room. Furthermore, this logic is needed both in the 
    single room view and in the grid view. So this logic is extracted here,
    and this observable updates with the right view model as the status for
    a room changes.

    To not have to track the subscription manually in the SessionViewModel and
    the RoomGridViewModel, all subscriptions are removed in the dispose method.
    Only when transferring a RoomViewModelObservable between the SessionViewModel
    and RoomGridViewModel, unsubscribeAll should be  called prior to doing
    the transfer, so either parent view model don't keep getting updates for
    the now transferred child view model.

    This is also why there is an explicit initialize method, see comment there.
    */

    var RoomViewModelObservable = /*#__PURE__*/function (_ObservableValue) {
      _inherits(RoomViewModelObservable, _ObservableValue);

      var _super = _createSuper(RoomViewModelObservable);

      function RoomViewModelObservable(sessionViewModel, roomId) {
        var _this;

        _classCallCheck(this, RoomViewModelObservable);

        _this = _super.call(this, null);
        _this._statusSubscription = null;
        _this._sessionViewModel = sessionViewModel;
        _this.id = roomId;
        return _this;
      }
      /**
      Separate initialize method rather than doing this onSubscribeFirst because 
      we don't want to run this again when transferring this value between
      SessionViewModel and RoomGridViewModel, as onUnsubscribeLast and onSubscribeFirst
      are called in that case.
      */


      _createClass(RoomViewModelObservable, [{
        key: "initialize",
        value: function () {
          var _initialize = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            var _this2 = this;

            var session, statusObservable;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    session = this._sessionViewModel._sessionContainer.session;
                    _context2.next = 3;
                    return session.observeRoomStatus(this.id);

                  case 3:
                    statusObservable = _context2.sent;
                    _context2.t0 = this;
                    _context2.next = 7;
                    return this._statusToViewModel(statusObservable.get());

                  case 7:
                    _context2.t1 = _context2.sent;

                    _context2.t0.set.call(_context2.t0, _context2.t1);

                    this._statusSubscription = statusObservable.subscribe( /*#__PURE__*/function () {
                      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(status) {
                        var _this2$get;

                        return regeneratorRuntime.wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                // first dispose existing VM, if any
                                (_this2$get = _this2.get()) === null || _this2$get === void 0 ? void 0 : _this2$get.dispose();
                                _context.t0 = _this2;
                                _context.next = 4;
                                return _this2._statusToViewModel(status);

                              case 4:
                                _context.t1 = _context.sent;

                                _context.t0.set.call(_context.t0, _context.t1);

                              case 6:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee);
                      }));

                      return function (_x) {
                        return _ref.apply(this, arguments);
                      };
                    }());

                  case 10:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function initialize() {
            return _initialize.apply(this, arguments);
          }

          return initialize;
        }()
      }, {
        key: "_statusToViewModel",
        value: function () {
          var _statusToViewModel2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(status) {
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (!status.invited) {
                      _context3.next = 4;
                      break;
                    }

                    return _context3.abrupt("return", this._sessionViewModel._createInviteViewModel(this.id));

                  case 4:
                    if (!status.joined) {
                      _context3.next = 8;
                      break;
                    }

                    return _context3.abrupt("return", this._sessionViewModel._createRoomViewModel(this.id));

                  case 8:
                    if (!status.archived) {
                      _context3.next = 14;
                      break;
                    }

                    _context3.next = 11;
                    return this._sessionViewModel._createArchivedRoomViewModel(this.id);

                  case 11:
                    return _context3.abrupt("return", _context3.sent);

                  case 14:
                    return _context3.abrupt("return", this._sessionViewModel._createUnknownRoomViewModel(this.id));

                  case 15:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function _statusToViewModel(_x2) {
            return _statusToViewModel2.apply(this, arguments);
          }

          return _statusToViewModel;
        }()
      }, {
        key: "dispose",
        value: function dispose() {
          var _this$get;

          if (this._statusSubscription) {
            this._statusSubscription = this._statusSubscription();
          }

          this.unsubscribeAll();
          (_this$get = this.get()) === null || _this$get === void 0 ? void 0 : _this$get.dispose();
        }
      }]);

      return RoomViewModelObservable;
    }(ObservableValue);

    var RoomDetailsViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(RoomDetailsViewModel, _ViewModel);

      var _super = _createSuper(RoomDetailsViewModel);

      function RoomDetailsViewModel(options) {
        var _this;

        _classCallCheck(this, RoomDetailsViewModel);

        _this = _super.call(this, options);
        _this._room = options.room;
        _this._onRoomChange = _this._onRoomChange.bind(_assertThisInitialized(_this));

        _this._room.on("change", _this._onRoomChange);

        return _this;
      }

      _createClass(RoomDetailsViewModel, [{
        key: "avatarUrl",
        value: function avatarUrl(size) {
          return getAvatarHttpUrl(this._room.avatarUrl, size, this.platform, this._room.mediaRepository);
        }
      }, {
        key: "_onRoomChange",
        value: function _onRoomChange() {
          this.emitChange();
        }
      }, {
        key: "dispose",
        value: function dispose() {
          _get(_getPrototypeOf(RoomDetailsViewModel.prototype), "dispose", this).call(this);

          this._room.off("change", this._onRoomChange);
        }
      }, {
        key: "openPanel",
        value: function openPanel(segment) {
          var path = this.navigation.path.until("room");
          path = path.with(this.navigation.segment("right-panel", true));
          path = path.with(this.navigation.segment(segment, true));
          this.navigation.applyPath(path);
        }
      }, {
        key: "type",
        get: function get() {
          return "room-details";
        }
      }, {
        key: "shouldShowBackButton",
        get: function get() {
          return false;
        }
      }, {
        key: "previousSegmentName",
        get: function get() {
          return false;
        }
      }, {
        key: "roomId",
        get: function get() {
          return this._room.id;
        }
      }, {
        key: "canonicalAlias",
        get: function get() {
          return this._room.canonicalAlias;
        }
      }, {
        key: "name",
        get: function get() {
          return this._room.name;
        }
      }, {
        key: "isEncrypted",
        get: function get() {
          return !!this._room.isEncrypted;
        }
      }, {
        key: "memberCount",
        get: function get() {
          return this._room.joinedMemberCount;
        }
      }, {
        key: "avatarLetter",
        get: function get() {
          return avatarInitials(this.name);
        }
      }, {
        key: "avatarColorNumber",
        get: function get() {
          return getIdentifierColorNumber(this._room.avatarColorId);
        }
      }, {
        key: "avatarTitle",
        get: function get() {
          return this.name;
        }
      }]);

      return RoomDetailsViewModel;
    }(ViewModel);

    var MemberTileViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(MemberTileViewModel, _ViewModel);

      var _super = _createSuper(MemberTileViewModel);

      function MemberTileViewModel(options) {
        var _this;

        _classCallCheck(this, MemberTileViewModel);

        _this = _super.call(this, options);
        _this._member = _this._options.member;
        _this._mediaRepository = options.mediaRepository;
        _this._previousName = null;
        _this._nameChanged = true;
        return _this;
      }

      _createClass(MemberTileViewModel, [{
        key: "_updatePreviousName",
        value: function _updatePreviousName(newName) {
          var currentName = this._member.name;

          if (currentName !== newName) {
            this._previousName = currentName;
            this._nameChanged = true;
          } else {
            this._nameChanged = false;
          }
        }
      }, {
        key: "setDisambiguation",
        value: function setDisambiguation(status) {
          this._disambiguate = status;
          this.emitChange();
        }
      }, {
        key: "updateFrom",
        value: function updateFrom(newMember) {
          this._updatePreviousName(newMember.name);

          this._member = newMember;
        }
      }, {
        key: "avatarUrl",
        value: function avatarUrl(size) {
          return getAvatarHttpUrl(this._member.avatarUrl, size, this.platform, this._mediaRepository);
        }
      }, {
        key: "name",
        get: function get() {
          return "".concat(this._member.name).concat(this._disambiguationPart);
        }
      }, {
        key: "_disambiguationPart",
        get: function get() {
          return this._disambiguate ? " (".concat(this.userId, ")") : "";
        }
      }, {
        key: "userId",
        get: function get() {
          return this._member.userId;
        }
      }, {
        key: "previousName",
        get: function get() {
          return this._previousName;
        }
      }, {
        key: "nameChanged",
        get: function get() {
          return this._nameChanged;
        }
      }, {
        key: "detailsUrl",
        get: function get() {
          var roomId = this.navigation.path.get("room").value;
          return "".concat(this.urlCreator.openRoomActionUrl(roomId), "/member/").concat(this._member.userId);
        }
      }, {
        key: "avatarLetter",
        get: function get() {
          return avatarInitials(this.name);
        }
      }, {
        key: "avatarColorNumber",
        get: function get() {
          return getIdentifierColorNumber(this.userId);
        }
      }, {
        key: "avatarTitle",
        get: function get() {
          return this.name;
        }
      }]);

      return MemberTileViewModel;
    }(ViewModel);

    function createMemberComparator(powerLevels) {
      var collator = new Intl.Collator();

      var removeCharacter = function removeCharacter(string) {
        return string.charAt(0) === "@" ? string.slice(1) : string;
      };

      return function comparator(member, otherMember) {
        var p1 = powerLevels.getUserLevel(member.userId);
        var p2 = powerLevels.getUserLevel(otherMember.userId);

        if (p1 !== p2) {
          return p2 - p1;
        }

        var name = removeCharacter(member.name);
        var otherName = removeCharacter(otherMember.name);
        return collator.compare(name, otherName);
      };
    }

    /*
    Copyright 2021 The Matrix.org Foundation C.I.C.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    var Disambiguator = /*#__PURE__*/function () {
      function Disambiguator() {
        _classCallCheck(this, Disambiguator);

        this._map = new Map();
      }

      _createClass(Disambiguator, [{
        key: "_unDisambiguate",
        value: function _unDisambiguate(vm, array) {
          var idx = array.indexOf(vm);

          if (idx !== -1) {
            var _array$splice = array.splice(idx, 1),
                _array$splice2 = _slicedToArray(_array$splice, 1),
                removed = _array$splice2[0];

            removed.setDisambiguation(false);
          }
        }
      }, {
        key: "_handlePreviousName",
        value: function _handlePreviousName(vm) {
          var previousName = vm.previousName;

          if (typeof previousName !== "string") {
            return;
          }

          var value = this._map.get(previousName);

          if (Array.isArray(value)) {
            this._unDisambiguate(vm, value);

            if (value.length === 1) {
              var _vm = value[0];

              _vm.setDisambiguation(false);

              this._map.set(previousName, _vm);
            }
          } else {
            this._map.delete(previousName);
          }
        }
      }, {
        key: "_updateMap",
        value: function _updateMap(vm) {
          var name = vm.name;

          var value = this._map.get(name);

          if (value) {
            if (Array.isArray(value)) {
              if (value.findIndex(function (member) {
                return member.userId === vm.userId;
              }) !== -1) {
                return;
              }

              value.push(vm);
              return value;
            } else if (vm.userId !== value.userId) {
              var array = [value, vm];

              this._map.set(name, array);

              return array;
            }
          } else {
            this._map.set(name, vm);
          }
        }
      }, {
        key: "disambiguate",
        value: function disambiguate(vm) {
          if (!vm.nameChanged) {
            return;
          }

          this._handlePreviousName(vm);

          var value = this._updateMap(vm);

          value === null || value === void 0 ? void 0 : value.forEach(function (vm) {
            return vm.setDisambiguation(true);
          });
        }
      }]);

      return Disambiguator;
    }();

    var MemberListViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(MemberListViewModel, _ViewModel);

      var _super = _createSuper(MemberListViewModel);

      function MemberListViewModel(options) {
        var _this;

        _classCallCheck(this, MemberListViewModel);

        _this = _super.call(this, options);
        var list = options.members;
        var powerLevelsObservable = options.powerLevelsObservable;

        _this.track(powerLevelsObservable.subscribe(function () {
          /*resort based on new power levels here*/
        }));

        var powerLevels = powerLevelsObservable.get();
        _this.memberTileViewModels = _this._mapTileViewModels(list.members.filterValues(function (member) {
          return member.membership === "join";
        })).sortValues(createMemberComparator(powerLevels));
        _this.nameDisambiguator = new Disambiguator();
        _this.mediaRepository = options.mediaRepository;
        return _this;
      }

      _createClass(MemberListViewModel, [{
        key: "_mapTileViewModels",
        value: function _mapTileViewModels(members) {
          var _this2 = this;

          var mapper = function mapper(member, emitChange) {
            var mediaRepository = _this2.mediaRepository;
            var vm = new MemberTileViewModel(_this2.childOptions({
              member: member,
              emitChange: emitChange,
              mediaRepository: mediaRepository
            }));

            _this2.nameDisambiguator.disambiguate(vm);

            return vm;
          };

          var updater = function updater(vm, params, newMember) {
            vm.updateFrom(newMember);

            _this2.nameDisambiguator.disambiguate(vm);
          };

          return members.mapValues(mapper, updater);
        }
      }, {
        key: "type",
        get: function get() {
          return "member-list";
        }
      }, {
        key: "shouldShowBackButton",
        get: function get() {
          return true;
        }
      }, {
        key: "previousSegmentName",
        get: function get() {
          return "details";
        }
      }]);

      return MemberListViewModel;
    }(ViewModel);

    function _templateObject4$f() {
      var data = _taggedTemplateLiteral(["Custom (", ")"]);

      _templateObject4$f = function _templateObject4() {
        return data;
      };

      return data;
    }

    function _templateObject3$j() {
      var data = _taggedTemplateLiteral(["Default"]);

      _templateObject3$j = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$r() {
      var data = _taggedTemplateLiteral(["Moderator"]);

      _templateObject2$r = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$x() {
      var data = _taggedTemplateLiteral(["Admin"]);

      _templateObject$x = function _templateObject() {
        return data;
      };

      return data;
    }
    var MemberDetailsViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(MemberDetailsViewModel, _ViewModel);

      var _super = _createSuper(MemberDetailsViewModel);

      function MemberDetailsViewModel(options) {
        var _this;

        _classCallCheck(this, MemberDetailsViewModel);

        _this = _super.call(this, options);
        _this._observableMember = options.observableMember;
        _this._mediaRepository = options.mediaRepository;
        _this._member = _this._observableMember.get();
        _this._isEncrypted = options.isEncrypted;
        _this._powerLevelsObservable = options.powerLevelsObservable;

        _this.track(_this._powerLevelsObservable.subscribe(function () {
          return _this._onPowerLevelsChange();
        }));

        _this.track(_this._observableMember.subscribe(function () {
          return _this._onMemberChange();
        }));

        return _this;
      }

      _createClass(MemberDetailsViewModel, [{
        key: "_onMemberChange",
        value: function _onMemberChange() {
          this._member = this._observableMember.get();
          this.emitChange("member");
        }
      }, {
        key: "_onPowerLevelsChange",
        value: function _onPowerLevelsChange() {
          this.emitChange("role");
        }
      }, {
        key: "avatarUrl",
        value: function avatarUrl(size) {
          return getAvatarHttpUrl(this._member.avatarUrl, size, this.platform, this._mediaRepository);
        }
      }, {
        key: "name",
        get: function get() {
          return this._member.name;
        }
      }, {
        key: "userId",
        get: function get() {
          return this._member.userId;
        }
      }, {
        key: "type",
        get: function get() {
          return "member-details";
        }
      }, {
        key: "shouldShowBackButton",
        get: function get() {
          return true;
        }
      }, {
        key: "previousSegmentName",
        get: function get() {
          return "members";
        }
      }, {
        key: "role",
        get: function get() {
          if (this.powerLevel >= 100) {
            return this.i18n(_templateObject$x());
          } else if (this.powerLevel >= 50) {
            return this.i18n(_templateObject2$r());
          } else if (this.powerLevel === 0) {
            return this.i18n(_templateObject3$j());
          } else {
            return this.i18n(_templateObject4$f(), this.powerLevel);
          }
        }
      }, {
        key: "avatarLetter",
        get: function get() {
          return avatarInitials(this.name);
        }
      }, {
        key: "avatarColorNumber",
        get: function get() {
          return getIdentifierColorNumber(this.userId);
        }
      }, {
        key: "avatarTitle",
        get: function get() {
          return this.name;
        }
      }, {
        key: "isEncrypted",
        get: function get() {
          return this._isEncrypted;
        }
      }, {
        key: "powerLevel",
        get: function get() {
          var _this$_powerLevelsObs;

          return (_this$_powerLevelsObs = this._powerLevelsObservable.get()) === null || _this$_powerLevelsObs === void 0 ? void 0 : _this$_powerLevelsObs.getUserLevel(this._member.userId);
        }
      }, {
        key: "linkToUser",
        get: function get() {
          return "https://matrix.to/#/".concat(this._member.userId);
        }
      }]);

      return MemberDetailsViewModel;
    }(ViewModel);

    var RightPanelViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(RightPanelViewModel, _ViewModel);

      var _super = _createSuper(RightPanelViewModel);

      function RightPanelViewModel(options) {
        var _this;

        _classCallCheck(this, RightPanelViewModel);

        _this = _super.call(this, options);
        _this._room = options.room;
        _this._members = null;

        _this._setupNavigation();

        return _this;
      }

      _createClass(RightPanelViewModel, [{
        key: "_getMemberListArguments",
        value: function () {
          var _getMemberListArguments2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var _this2 = this;

            var room, powerLevelsObservable;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (this._members) {
                      _context.next = 5;
                      break;
                    }

                    _context.next = 3;
                    return this._room.loadMemberList();

                  case 3:
                    this._members = _context.sent;
                    this.track(function () {
                      return _this2._members.release();
                    });

                  case 5:
                    room = this._room;
                    _context.next = 8;
                    return this._room.observePowerLevels();

                  case 8:
                    powerLevelsObservable = _context.sent;
                    return _context.abrupt("return", {
                      members: this._members,
                      powerLevelsObservable: powerLevelsObservable,
                      mediaRepository: room.mediaRepository
                    });

                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function _getMemberListArguments() {
            return _getMemberListArguments2.apply(this, arguments);
          }

          return _getMemberListArguments;
        }()
      }, {
        key: "_getMemberDetailsArguments",
        value: function () {
          var _getMemberDetailsArguments2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            var segment, userId, observableMember, isEncrypted, powerLevelsObservable;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    segment = this.navigation.path.get("member");
                    userId = segment.value;
                    _context2.next = 4;
                    return this._room.observeMember(userId);

                  case 4:
                    observableMember = _context2.sent;

                    if (observableMember) {
                      _context2.next = 7;
                      break;
                    }

                    return _context2.abrupt("return", false);

                  case 7:
                    isEncrypted = this._room.isEncrypted;
                    _context2.next = 10;
                    return this._room.observePowerLevels();

                  case 10:
                    powerLevelsObservable = _context2.sent;
                    return _context2.abrupt("return", {
                      observableMember: observableMember,
                      isEncrypted: isEncrypted,
                      powerLevelsObservable: powerLevelsObservable,
                      mediaRepository: this._room.mediaRepository
                    });

                  case 12:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function _getMemberDetailsArguments() {
            return _getMemberDetailsArguments2.apply(this, arguments);
          }

          return _getMemberDetailsArguments;
        }()
      }, {
        key: "_setupNavigation",
        value: function _setupNavigation() {
          var _this3 = this;

          this._hookUpdaterToSegment("details", RoomDetailsViewModel, function () {
            return {
              room: _this3._room
            };
          });

          this._hookUpdaterToSegment("members", MemberListViewModel, function () {
            return _this3._getMemberListArguments();
          });

          this._hookUpdaterToSegment("member", MemberDetailsViewModel, function () {
            return _this3._getMemberDetailsArguments();
          }, function () {
            // If we fail to create the member details panel, fallback to memberlist
            var url = "".concat(_this3.urlCreator.urlUntilSegment("room"), "/members");

            _this3.urlCreator.pushUrl(url);
          });
        }
      }, {
        key: "_hookUpdaterToSegment",
        value: function _hookUpdaterToSegment(segment, viewmodel, argCreator, failCallback) {
          var observable = this.navigation.observe(segment);

          var updater = this._setupUpdater(segment, viewmodel, argCreator, failCallback);

          this.track(observable.subscribe(updater));
        }
      }, {
        key: "_setupUpdater",
        value: function _setupUpdater(segment, viewmodel, argCreator, failCallback) {
          var _this4 = this;

          var updater = /*#__PURE__*/function () {
            var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
              var _this4$navigation$pat;

              var skipDispose,
                  enable,
                  args,
                  _args3 = arguments;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      skipDispose = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : false;

                      if (!skipDispose) {
                        _this4._activeViewModel = _this4.disposeTracked(_this4._activeViewModel);
                      }

                      enable = !!((_this4$navigation$pat = _this4.navigation.path.get(segment)) === null || _this4$navigation$pat === void 0 ? void 0 : _this4$navigation$pat.value);

                      if (!enable) {
                        _context3.next = 11;
                        break;
                      }

                      _context3.next = 6;
                      return argCreator();

                    case 6:
                      args = _context3.sent;

                      if (!(!args && failCallback)) {
                        _context3.next = 10;
                        break;
                      }

                      failCallback();
                      return _context3.abrupt("return");

                    case 10:
                      _this4._activeViewModel = _this4.track(new viewmodel(_this4.childOptions(args)));

                    case 11:
                      _this4.emitChange("activeViewModel");

                    case 12:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3);
            }));

            return function updater() {
              return _ref.apply(this, arguments);
            };
          }();

          updater(true);
          return updater;
        }
      }, {
        key: "closePanel",
        value: function closePanel() {
          var path = this.navigation.path.until("room");
          this.navigation.applyPath(path);
        }
      }, {
        key: "showPreviousPanel",
        value: function showPreviousPanel() {
          var segmentName = this.activeViewModel.previousSegmentName;

          if (segmentName) {
            var path = this.navigation.path.until("room");
            path = path.with(this.navigation.segment("right-panel", true));
            path = path.with(this.navigation.segment(segmentName, true));
            this.navigation.applyPath(path);
          }
        }
      }, {
        key: "activeViewModel",
        get: function get() {
          return this._activeViewModel;
        }
      }]);

      return RightPanelViewModel;
    }(ViewModel);

    var SessionViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(SessionViewModel, _ViewModel);

      var _super = _createSuper(SessionViewModel);

      function SessionViewModel(options) {
        var _this;

        _classCallCheck(this, SessionViewModel);

        _this = _super.call(this, options);
        var sessionContainer = options.sessionContainer;
        _this._sessionContainer = _this.track(sessionContainer);
        _this._sessionStatusViewModel = _this.track(new SessionStatusViewModel(_this.childOptions({
          sync: sessionContainer.sync,
          reconnector: sessionContainer.reconnector,
          session: sessionContainer.session
        })));
        _this._leftPanelViewModel = _this.track(new LeftPanelViewModel(_this.childOptions({
          invites: _this._sessionContainer.session.invites,
          rooms: _this._sessionContainer.session.rooms
        })));
        _this._settingsViewModel = null;
        _this._roomViewModelObservable = null;
        _this._gridViewModel = null;

        _this._setupNavigation();

        return _this;
      }

      _createClass(SessionViewModel, [{
        key: "_setupNavigation",
        value: function _setupNavigation() {
          var _this2 = this;

          var gridRooms = this.navigation.observe("rooms"); // this gives us a set of room ids in the grid

          this.track(gridRooms.subscribe(function (roomIds) {
            _this2._updateGrid(roomIds);
          }));

          if (gridRooms.get()) {
            this._updateGrid(gridRooms.get());
          }

          var currentRoomId = this.navigation.observe("room"); // this gives us the active room

          this.track(currentRoomId.subscribe(function (roomId) {
            if (!_this2._gridViewModel) {
              _this2._updateRoom(roomId);
            }

            _this2._updateRightPanel();
          }));

          if (!this._gridViewModel) {
            this._updateRoom(currentRoomId.get());
          }

          var settings = this.navigation.observe("settings");
          this.track(settings.subscribe(function (settingsOpen) {
            _this2._updateSettings(settingsOpen);
          }));

          this._updateSettings(settings.get());

          var lightbox = this.navigation.observe("lightbox");
          this.track(lightbox.subscribe(function (eventId) {
            _this2._updateLightbox(eventId);
          }));

          this._updateLightbox(lightbox.get());

          var rightpanel = this.navigation.observe("right-panel");
          this.track(rightpanel.subscribe(function () {
            return _this2._updateRightPanel();
          }));

          this._updateRightPanel();
        }
      }, {
        key: "start",
        value: function start() {
          this._sessionStatusViewModel.start();
        }
      }, {
        key: "_updateGrid",
        value: function _updateGrid(roomIds) {
          var _this3 = this;

          var changed = !(this._gridViewModel && roomIds);
          var currentRoomId = this.navigation.path.get("room");

          if (roomIds) {
            if (!this._gridViewModel) {
              var _this$_roomViewModelO;

              this._gridViewModel = this.track(new RoomGridViewModel(this.childOptions({
                width: 3,
                height: 2,
                createRoomViewModelObservable: function createRoomViewModelObservable(roomId) {
                  return new RoomViewModelObservable(_this3, roomId);
                }
              }))); // try to transfer the current room view model, so we don't have to reload the timeline

              (_this$_roomViewModelO = this._roomViewModelObservable) === null || _this$_roomViewModelO === void 0 ? void 0 : _this$_roomViewModelO.unsubscribeAll();

              if (this._gridViewModel.initializeRoomIdsAndTransferVM(roomIds, this._roomViewModelObservable)) {
                this._roomViewModelObservable = this.untrack(this._roomViewModelObservable);
              } else if (this._roomViewModelObservable) {
                this._roomViewModelObservable = this.disposeTracked(this._roomViewModelObservable);
              }
            } else {
              this._gridViewModel.setRoomIds(roomIds);
            }
          } else if (this._gridViewModel && !roomIds) {
            // closing grid, try to show focused room in grid
            if (currentRoomId) {
              var vmo = this._gridViewModel.releaseRoomViewModel(currentRoomId.value);

              if (vmo) {
                this._roomViewModelObservable = this.track(vmo);

                this._roomViewModelObservable.subscribe(function () {
                  _this3.emitChange("activeMiddleViewModel");
                });
              }
            }

            this._gridViewModel = this.disposeTracked(this._gridViewModel);
          }

          if (changed) {
            this.emitChange("activeMiddleViewModel");
          }
        }
      }, {
        key: "_createRoomViewModel",
        value: function _createRoomViewModel(roomId) {
          var room = this._sessionContainer.session.rooms.get(roomId);

          if (room) {
            var roomVM = new RoomViewModel(this.childOptions({
              room: room
            }));
            roomVM.load();
            return roomVM;
          }

          return null;
        }
      }, {
        key: "_createUnknownRoomViewModel",
        value: function _createUnknownRoomViewModel(roomIdOrAlias) {
          return new UnknownRoomViewModel(this.childOptions({
            roomIdOrAlias: roomIdOrAlias,
            session: this._sessionContainer.session
          }));
        }
      }, {
        key: "_createArchivedRoomViewModel",
        value: function () {
          var _createArchivedRoomViewModel2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(roomId) {
            var room, roomVM;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this._sessionContainer.session.loadArchivedRoom(roomId);

                  case 2:
                    room = _context.sent;

                    if (!room) {
                      _context.next = 7;
                      break;
                    }

                    roomVM = new RoomViewModel(this.childOptions({
                      room: room
                    }));
                    roomVM.load();
                    return _context.abrupt("return", roomVM);

                  case 7:
                    return _context.abrupt("return", null);

                  case 8:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function _createArchivedRoomViewModel(_x) {
            return _createArchivedRoomViewModel2.apply(this, arguments);
          }

          return _createArchivedRoomViewModel;
        }()
      }, {
        key: "_createInviteViewModel",
        value: function _createInviteViewModel(roomId) {
          var invite = this._sessionContainer.session.invites.get(roomId);

          if (invite) {
            return new InviteViewModel(this.childOptions({
              invite: invite,
              mediaRepository: this._sessionContainer.session.mediaRepository
            }));
          }

          return null;
        }
      }, {
        key: "_updateRoom",
        value: function _updateRoom(roomId) {
          var _this$_roomViewModelO2,
              _this4 = this;

          // opening a room and already open?
          if (((_this$_roomViewModelO2 = this._roomViewModelObservable) === null || _this$_roomViewModelO2 === void 0 ? void 0 : _this$_roomViewModelO2.id) === roomId) {
            return;
          } // close if needed


          if (this._roomViewModelObservable) {
            this._roomViewModelObservable = this.disposeTracked(this._roomViewModelObservable);
          }

          if (!roomId) {
            // if clearing the activeMiddleViewModel rather than changing to a different one,
            // emit so the view picks it up and show the placeholder
            this.emitChange("activeMiddleViewModel");
            return;
          }

          var vmo = new RoomViewModelObservable(this, roomId);
          this._roomViewModelObservable = this.track(vmo); // subscription is unsubscribed in RoomViewModelObservable.dispose, and thus handled by track

          this._roomViewModelObservable.subscribe(function () {
            _this4.emitChange("activeMiddleViewModel");
          });

          vmo.initialize();
        }
      }, {
        key: "_updateSettings",
        value: function _updateSettings(settingsOpen) {
          if (this._settingsViewModel) {
            this._settingsViewModel = this.disposeTracked(this._settingsViewModel);
          }

          if (settingsOpen) {
            this._settingsViewModel = this.track(new SettingsViewModel(this.childOptions({
              sessionContainer: this._sessionContainer
            })));

            this._settingsViewModel.load();
          }

          this.emitChange("activeMiddleViewModel");
        }
      }, {
        key: "_updateLightbox",
        value: function _updateLightbox(eventId) {
          if (this._lightboxViewModel) {
            this._lightboxViewModel = this.disposeTracked(this._lightboxViewModel);
          }

          if (eventId) {
            var room = this._roomFromNavigation();

            this._lightboxViewModel = this.track(new LightboxViewModel(this.childOptions({
              eventId: eventId,
              room: room
            })));
          }

          this.emitChange("lightboxViewModel");
        }
      }, {
        key: "_roomFromNavigation",
        value: function _roomFromNavigation() {
          var _this$navigation$path;

          var roomId = (_this$navigation$path = this.navigation.path.get("room")) === null || _this$navigation$path === void 0 ? void 0 : _this$navigation$path.value;

          var room = this._sessionContainer.session.rooms.get(roomId);

          return room;
        }
      }, {
        key: "_updateRightPanel",
        value: function _updateRightPanel() {
          var _this$navigation$path2;

          this._rightPanelViewModel = this.disposeTracked(this._rightPanelViewModel);
          var enable = !!((_this$navigation$path2 = this.navigation.path.get("right-panel")) === null || _this$navigation$path2 === void 0 ? void 0 : _this$navigation$path2.value);

          if (enable) {
            var room = this._roomFromNavigation();

            this._rightPanelViewModel = this.track(new RightPanelViewModel(this.childOptions({
              room: room
            })));
          }

          this.emitChange("rightPanelViewModel");
        }
      }, {
        key: "id",
        get: function get() {
          return this._sessionContainer.sessionId;
        }
      }, {
        key: "activeMiddleViewModel",
        get: function get() {
          var _this$_roomViewModelO3;

          return ((_this$_roomViewModelO3 = this._roomViewModelObservable) === null || _this$_roomViewModelO3 === void 0 ? void 0 : _this$_roomViewModelO3.get()) || this._gridViewModel || this._settingsViewModel;
        }
      }, {
        key: "roomGridViewModel",
        get: function get() {
          return this._gridViewModel;
        }
      }, {
        key: "leftPanelViewModel",
        get: function get() {
          return this._leftPanelViewModel;
        }
      }, {
        key: "sessionStatusViewModel",
        get: function get() {
          return this._sessionStatusViewModel;
        }
      }, {
        key: "settingsViewModel",
        get: function get() {
          return this._settingsViewModel;
        }
      }, {
        key: "currentRoomViewModel",
        get: function get() {
          var _this$_roomViewModelO4;

          return (_this$_roomViewModelO4 = this._roomViewModelObservable) === null || _this$_roomViewModelO4 === void 0 ? void 0 : _this$_roomViewModelO4.get();
        }
      }, {
        key: "rightPanelViewModel",
        get: function get() {
          return this._rightPanelViewModel;
        }
      }, {
        key: "lightboxViewModel",
        get: function get() {
          return this._lightboxViewModel;
        }
      }]);

      return SessionViewModel;
    }(ViewModel);

    function _templateObject2$s() {
      var data = _taggedTemplateLiteral(["claim your dehydrated device"]);

      _templateObject2$s = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$y() {
      var data = _taggedTemplateLiteral(["Restore"]);

      _templateObject$y = function _templateObject() {
        return data;
      };

      return data;
    }
    var AccountSetupViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(AccountSetupViewModel, _ViewModel);

      var _super = _createSuper(AccountSetupViewModel);

      function AccountSetupViewModel(accountSetup) {
        var _this;

        _classCallCheck(this, AccountSetupViewModel);

        _this = _super.call(this);
        _this._accountSetup = accountSetup;
        _this._dehydratedDevice = undefined;
        _this._decryptDehydratedDeviceViewModel = undefined;

        if (_this._accountSetup.encryptedDehydratedDevice) {
          _this._decryptDehydratedDeviceViewModel = new DecryptDehydratedDeviceViewModel(_assertThisInitialized(_this), function (dehydratedDevice) {
            _this._dehydratedDevice = dehydratedDevice;
            _this._decryptDehydratedDeviceViewModel = undefined;

            _this.emitChange("deviceDecrypted");
          });
        }

        return _this;
      }

      _createClass(AccountSetupViewModel, [{
        key: "finish",
        value: function finish() {
          this._accountSetup.finish(this._dehydratedDevice);
        }
      }, {
        key: "decryptDehydratedDeviceViewModel",
        get: function get() {
          return this._decryptDehydratedDeviceViewModel;
        }
      }, {
        key: "deviceDecrypted",
        get: function get() {
          return !!this._dehydratedDevice;
        }
      }, {
        key: "dehydratedDeviceId",
        get: function get() {
          return this._accountSetup.encryptedDehydratedDevice.deviceId;
        }
      }]);

      return AccountSetupViewModel;
    }(ViewModel); // this vm adopts the same shape as SessionBackupViewModel so the same view can be reused.

    var DecryptDehydratedDeviceViewModel = /*#__PURE__*/function (_ViewModel2) {
      _inherits(DecryptDehydratedDeviceViewModel, _ViewModel2);

      var _super2 = _createSuper(DecryptDehydratedDeviceViewModel);

      function DecryptDehydratedDeviceViewModel(accountSetupViewModel, decryptedCallback) {
        var _this2;

        _classCallCheck(this, DecryptDehydratedDeviceViewModel);

        _this2 = _super2.call(this);
        _this2._accountSetupViewModel = accountSetupViewModel;
        _this2._isBusy = false;
        _this2._status = Status.SetupKey;
        _this2._error = undefined;
        _this2._decryptedCallback = decryptedCallback;
        return _this2;
      }

      _createClass(DecryptDehydratedDeviceViewModel, [{
        key: "showPhraseSetup",
        value: function showPhraseSetup() {
          if (this._status === Status.SetupKey) {
            this._status = Status.SetupPhrase;
            this.emitChange("status");
          }
        }
      }, {
        key: "showKeySetup",
        value: function showKeySetup() {
          if (this._status === Status.SetupPhrase) {
            this._status = Status.SetupKey;
            this.emitChange("status");
          }
        }
      }, {
        key: "_enterCredentials",
        value: function () {
          var _enterCredentials2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(keyType, credential) {
            var encryptedDehydratedDevice, dehydratedDevice;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!credential) {
                      _context.next = 20;
                      break;
                    }

                    _context.prev = 1;
                    this._isBusy = true;
                    this.emitChange("isBusy");
                    encryptedDehydratedDevice = this._accountSetupViewModel._accountSetup.encryptedDehydratedDevice;
                    _context.next = 7;
                    return encryptedDehydratedDevice.decrypt(keyType, credential);

                  case 7:
                    dehydratedDevice = _context.sent;

                    this._decryptedCallback(dehydratedDevice);

                    _context.next = 16;
                    break;

                  case 11:
                    _context.prev = 11;
                    _context.t0 = _context["catch"](1);
                    console.error(_context.t0);
                    this._error = _context.t0;
                    this.emitChange("error");

                  case 16:
                    _context.prev = 16;
                    this._isBusy = false;
                    this.emitChange("");
                    return _context.finish(16);

                  case 20:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[1, 11, 16, 20]]);
          }));

          function _enterCredentials(_x, _x2) {
            return _enterCredentials2.apply(this, arguments);
          }

          return _enterCredentials;
        }()
      }, {
        key: "enterSecurityPhrase",
        value: function enterSecurityPhrase(passphrase) {
          this._enterCredentials(KeyType.Passphrase, passphrase);
        }
      }, {
        key: "enterSecurityKey",
        value: function enterSecurityKey(securityKey) {
          this._enterCredentials(KeyType.RecoveryKey, securityKey);
        }
      }, {
        key: "disable",
        value: function disable() {}
      }, {
        key: "decryptAction",
        get: function get() {
          return this.i18n(_templateObject$y());
        }
      }, {
        key: "purpose",
        get: function get() {
          return this.i18n(_templateObject2$s());
        }
      }, {
        key: "offerDehydratedDeviceSetup",
        get: function get() {
          return false;
        }
      }, {
        key: "dehydratedDeviceId",
        get: function get() {
          var _this$_accountSetupVi;

          return (_this$_accountSetupVi = this._accountSetupViewModel._dehydratedDevice) === null || _this$_accountSetupVi === void 0 ? void 0 : _this$_accountSetupVi.deviceId;
        }
      }, {
        key: "isBusy",
        get: function get() {
          return this._isBusy;
        }
      }, {
        key: "backupVersion",
        get: function get() {
          return 0;
        }
      }, {
        key: "status",
        get: function get() {
          return this._status;
        }
      }, {
        key: "error",
        get: function get() {
          var _this$_error;

          return (_this$_error = this._error) === null || _this$_error === void 0 ? void 0 : _this$_error.message;
        }
      }]);

      return DecryptDehydratedDeviceViewModel;
    }(ViewModel);

    var SessionLoadViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(SessionLoadViewModel, _ViewModel);

      var _super = _createSuper(SessionLoadViewModel);

      function SessionLoadViewModel(options) {
        var _this;

        _classCallCheck(this, SessionLoadViewModel);

        _this = _super.call(this, options);
        var sessionContainer = options.sessionContainer,
            ready = options.ready,
            homeserver = options.homeserver,
            deleteSessionOnCancel = options.deleteSessionOnCancel;
        _this._sessionContainer = sessionContainer;
        _this._ready = ready;
        _this._homeserver = homeserver;
        _this._deleteSessionOnCancel = deleteSessionOnCancel;
        _this._loading = false;
        _this._error = null;
        _this.backUrl = _this.urlCreator.urlForSegment("session", true);
        _this._accountSetupViewModel = undefined;
        return _this;
      }

      _createClass(SessionLoadViewModel, [{
        key: "start",
        value: function () {
          var _start = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var _this2 = this;

            var loadStatus, loadError, sessionContainer;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!this._loading) {
                      _context.next = 2;
                      break;
                    }

                    return _context.abrupt("return");

                  case 2:
                    _context.prev = 2;
                    this._loading = true;
                    this.emitChange("loading");
                    this._waitHandle = this._sessionContainer.loadStatus.waitFor(function (s) {
                      if (s === LoadStatus.AccountSetup) {
                        _this2._accountSetupViewModel = new AccountSetupViewModel(_this2._sessionContainer.accountSetup);
                      } else {
                        _this2._accountSetupViewModel = undefined;
                      }

                      _this2.emitChange("loadLabel"); // wait for initial sync, but not catchup sync


                      var isCatchupSync = s === LoadStatus.FirstSync && _this2._sessionContainer.sync.status.get() === SyncStatus.CatchupSync;
                      return isCatchupSync || s === LoadStatus.LoginFailed || s === LoadStatus.Error || s === LoadStatus.Ready;
                    });
                    _context.prev = 6;
                    _context.next = 9;
                    return this._waitHandle.promise;

                  case 9:
                    _context.next = 14;
                    break;

                  case 11:
                    _context.prev = 11;
                    _context.t0 = _context["catch"](6);
                    return _context.abrupt("return");

                  case 14:
                    // TODO: should we deal with no connection during initial sync 
                    // and we're retrying as well here?
                    // e.g. show in the label what is going on wrt connectionstatus
                    // much like we will once you are in the app. Probably a good idea
                    // did it finish or get stuck at LoginFailed or Error?
                    loadStatus = this._sessionContainer.loadStatus.get();
                    loadError = this._sessionContainer.loadError;

                    if (loadStatus === LoadStatus.FirstSync || loadStatus === LoadStatus.Ready) {
                      sessionContainer = this._sessionContainer; // session container is ready,
                      // don't dispose it anymore when 
                      // we get disposed

                      this._sessionContainer = null;

                      this._ready(sessionContainer);
                    }

                    if (loadError) {
                      console.error("session load error", loadError);
                    }

                    _context.next = 24;
                    break;

                  case 20:
                    _context.prev = 20;
                    _context.t1 = _context["catch"](2);
                    this._error = _context.t1;
                    console.error("error thrown during session load", _context.t1.stack);

                  case 24:
                    _context.prev = 24;
                    this._loading = false; // loadLabel in case of sc.loadError also gets updated through this

                    this.emitChange("loading");
                    return _context.finish(24);

                  case 28:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[2, 20, 24, 28], [6, 11]]);
          }));

          function start() {
            return _start.apply(this, arguments);
          }

          return start;
        }()
      }, {
        key: "dispose",
        value: function dispose() {
          if (this._sessionContainer) {
            this._sessionContainer.dispose();

            this._sessionContainer = null;
          }

          if (this._waitHandle) {
            // rejects with AbortError
            this._waitHandle.dispose();

            this._waitHandle = null;
          }
        } // to show a spinner or not

      }, {
        key: "_getError",
        value: function _getError() {
          var _this$_sessionContain;

          return this._error || ((_this$_sessionContain = this._sessionContainer) === null || _this$_sessionContain === void 0 ? void 0 : _this$_sessionContain.loadError);
        }
      }, {
        key: "exportLogs",
        value: function () {
          var _exportLogs = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            var logExport;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this.logger.export();

                  case 2:
                    logExport = _context2.sent;
                    this.platform.saveFileAs(logExport.asBlob(), "hydrogen-logs-".concat(this.platform.clock.now(), ".json"));

                  case 4:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function exportLogs() {
            return _exportLogs.apply(this, arguments);
          }

          return exportLogs;
        }()
      }, {
        key: "logout",
        value: function () {
          var _logout = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this._sessionContainer.logout();

                  case 2:
                    this.navigation.push("session", true);

                  case 3:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function logout() {
            return _logout.apply(this, arguments);
          }

          return logout;
        }()
      }, {
        key: "loading",
        get: function get() {
          var sc = this._sessionContainer;

          if (sc && sc.loadStatus.get() === LoadStatus.AccountSetup) {
            return false;
          }

          return this._loading;
        }
      }, {
        key: "loadLabel",
        get: function get() {
          var sc = this._sessionContainer;

          var error = this._getError();

          if (error || sc && sc.loadStatus.get() === LoadStatus.Error) {
            return "Something went wrong: ".concat(error && error.message, ".");
          } // Statuses related to login are handled by respective login view models


          if (sc) {
            switch (sc.loadStatus.get()) {
              case LoadStatus.QueryAccount:
                return "Querying account encryption setup\u2026";

              case LoadStatus.AccountSetup:
                return "";
              // we'll show a header ing AccountSetupView

              case LoadStatus.SessionSetup:
                return "Setting up your encryption keys\u2026";

              case LoadStatus.Loading:
                return "Loading your conversations\u2026";

              case LoadStatus.FirstSync:
                return "Getting your conversations from the server\u2026";

              default:
                return this._sessionContainer.loadStatus.get();
            }
          }

          return "Preparing\u2026";
        }
      }, {
        key: "hasError",
        get: function get() {
          return !!this._getError();
        }
      }, {
        key: "accountSetupViewModel",
        get: function get() {
          return this._accountSetupViewModel;
        }
      }]);

      return SessionLoadViewModel;
    }(ViewModel);

    function _templateObject3$k() {
      var data = _taggedTemplateLiteral(["Something went wrong while checking your login and password."]);

      _templateObject3$k = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$t() {
      var data = _taggedTemplateLiteral(["Can't connect to ", "."]);

      _templateObject2$t = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$z() {
      var data = _taggedTemplateLiteral(["Your username and/or password don't seem to be correct."]);

      _templateObject$z = function _templateObject() {
        return data;
      };

      return data;
    }
    var PasswordLoginViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(PasswordLoginViewModel, _ViewModel);

      var _super = _createSuper(PasswordLoginViewModel);

      function PasswordLoginViewModel(options) {
        var _this;

        _classCallCheck(this, PasswordLoginViewModel);

        _this = _super.call(this, options);
        var loginOptions = options.loginOptions,
            attemptLogin = options.attemptLogin;
        _this._loginOptions = loginOptions;
        _this._attemptLogin = attemptLogin;
        _this._isBusy = false;
        _this._errorMessage = "";
        return _this;
      }

      _createClass(PasswordLoginViewModel, [{
        key: "setBusy",
        value: function setBusy(status) {
          this._isBusy = status;
          this.emitChange("isBusy");
        }
      }, {
        key: "_showError",
        value: function _showError(message) {
          this._errorMessage = message;
          this.emitChange("errorMessage");
        }
      }, {
        key: "login",
        value: function () {
          var _login = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(username, password) {
            var status, error;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this._errorMessage = "";
                    this.emitChange("errorMessage");
                    _context.next = 4;
                    return this._attemptLogin(this._loginOptions.password(username, password));

                  case 4:
                    status = _context.sent;
                    error = "";
                    _context.t0 = status;
                    _context.next = _context.t0 === LoginFailure.Credentials ? 9 : _context.t0 === LoginFailure.Connection ? 11 : _context.t0 === LoginFailure.Unknown ? 13 : 15;
                    break;

                  case 9:
                    error = this.i18n(_templateObject$z());
                    return _context.abrupt("break", 15);

                  case 11:
                    error = this.i18n(_templateObject2$t(), this._loginOptions.homeserver);
                    return _context.abrupt("break", 15);

                  case 13:
                    error = this.i18n(_templateObject3$k());
                    return _context.abrupt("break", 15);

                  case 15:
                    if (error) {
                      this._showError(error);
                    }

                  case 16:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function login(_x, _x2) {
            return _login.apply(this, arguments);
          }

          return login;
        }()
      }, {
        key: "isBusy",
        get: function get() {
          return this._isBusy;
        }
      }, {
        key: "errorMessage",
        get: function get() {
          return this._errorMessage;
        }
      }]);

      return PasswordLoginViewModel;
    }(ViewModel);

    var StartSSOLoginViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(StartSSOLoginViewModel, _ViewModel);

      var _super = _createSuper(StartSSOLoginViewModel);

      function StartSSOLoginViewModel(options) {
        var _this;

        _classCallCheck(this, StartSSOLoginViewModel);

        _this = _super.call(this, options);
        _this._sso = options.loginOptions.sso;
        _this._isBusy = false;
        return _this;
      }

      _createClass(StartSSOLoginViewModel, [{
        key: "setBusy",
        value: function setBusy(status) {
          this._isBusy = status;
          this.emitChange("isBusy");
        }
      }, {
        key: "startSSOLogin",
        value: function () {
          var _startSSOLogin = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var link;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this.platform.settingsStorage.setString("sso_ongoing_login_homeserver", this._sso.homeserver);

                  case 2:
                    link = this._sso.createSSORedirectURL(this.urlCreator.createSSOCallbackURL());
                    this.platform.openUrl(link);

                  case 4:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function startSSOLogin() {
            return _startSSOLogin.apply(this, arguments);
          }

          return startSSOLogin;
        }()
      }, {
        key: "isBusy",
        get: function get() {
          return this._isBusy;
        }
      }]);

      return StartSSOLoginViewModel;
    }(ViewModel);

    function _templateObject3$l() {
      var data = _taggedTemplateLiteral(["Something went wrong while checking your login token."]);

      _templateObject3$l = function _templateObject3() {
        return data;
      };

      return data;
    }

    function _templateObject2$u() {
      var data = _taggedTemplateLiteral(["Can't connect to ", "."]);

      _templateObject2$u = function _templateObject2() {
        return data;
      };

      return data;
    }

    function _templateObject$A() {
      var data = _taggedTemplateLiteral(["Your login token is invalid."]);

      _templateObject$A = function _templateObject() {
        return data;
      };

      return data;
    }
    var CompleteSSOLoginViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(CompleteSSOLoginViewModel, _ViewModel);

      var _super = _createSuper(CompleteSSOLoginViewModel);

      function CompleteSSOLoginViewModel(options) {
        var _this;

        _classCallCheck(this, CompleteSSOLoginViewModel);

        _this = _super.call(this, options);
        var loginToken = options.loginToken,
            sessionContainer = options.sessionContainer,
            attemptLogin = options.attemptLogin;
        _this._loginToken = loginToken;
        _this._sessionContainer = sessionContainer;
        _this._attemptLogin = attemptLogin;
        _this._errorMessage = "";

        _this.performSSOLoginCompletion();

        return _this;
      }

      _createClass(CompleteSSOLoginViewModel, [{
        key: "_showError",
        value: function _showError(message) {
          this._errorMessage = message;
          this.emitChange("errorMessage");
        }
      }, {
        key: "performSSOLoginCompletion",
        value: function () {
          var _performSSOLoginCompletion = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var homeserver, loginOptions, status, error;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (this._loginToken) {
                      _context.next = 2;
                      break;
                    }

                    return _context.abrupt("return");

                  case 2:
                    _context.next = 4;
                    return this.platform.settingsStorage.getString("sso_ongoing_login_homeserver");

                  case 4:
                    homeserver = _context.sent;
                    _context.prev = 5;
                    _context.next = 8;
                    return this._sessionContainer.queryLogin(homeserver).result;

                  case 8:
                    loginOptions = _context.sent;
                    _context.next = 15;
                    break;

                  case 11:
                    _context.prev = 11;
                    _context.t0 = _context["catch"](5);

                    this._showError(_context.t0.message);

                    return _context.abrupt("return");

                  case 15:
                    if (loginOptions.token) {
                      _context.next = 18;
                      break;
                    }

                    this.navigation.push("session");
                    return _context.abrupt("return");

                  case 18:
                    _context.next = 20;
                    return this._attemptLogin(loginOptions.token(this._loginToken));

                  case 20:
                    status = _context.sent;
                    error = "";
                    _context.t1 = status;
                    _context.next = _context.t1 === LoginFailure.Credentials ? 25 : _context.t1 === LoginFailure.Connection ? 27 : _context.t1 === LoginFailure.Unknown ? 29 : 31;
                    break;

                  case 25:
                    error = this.i18n(_templateObject$A());
                    return _context.abrupt("break", 31);

                  case 27:
                    error = this.i18n(_templateObject2$u(), homeserver);
                    return _context.abrupt("break", 31);

                  case 29:
                    error = this.i18n(_templateObject3$l());
                    return _context.abrupt("break", 31);

                  case 31:
                    if (error) {
                      this._showError(error);
                    }

                  case 32:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[5, 11]]);
          }));

          function performSSOLoginCompletion() {
            return _performSSOLoginCompletion.apply(this, arguments);
          }

          return performSSOLoginCompletion;
        }()
      }, {
        key: "errorMessage",
        get: function get() {
          return this._errorMessage;
        }
      }]);

      return CompleteSSOLoginViewModel;
    }(ViewModel);

    var LoginViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(LoginViewModel, _ViewModel);

      var _super = _createSuper(LoginViewModel);

      function LoginViewModel(options) {
        var _this;

        _classCallCheck(this, LoginViewModel);

        _this = _super.call(this, options);
        var ready = options.ready,
            defaultHomeserver = options.defaultHomeserver,
            createSessionContainer = options.createSessionContainer,
            loginToken = options.loginToken;
        _this._createSessionContainer = createSessionContainer;
        _this._ready = ready;
        _this._loginToken = loginToken;
        _this._sessionContainer = _this._createSessionContainer();
        _this._loginOptions = null;
        _this._passwordLoginViewModel = null;
        _this._startSSOLoginViewModel = null;
        _this._completeSSOLoginViewModel = null;
        _this._loadViewModel = null;
        _this._loadViewModelSubscription = null;
        _this._homeserver = defaultHomeserver;
        _this._queriedHomeserver = null;
        _this._errorMessage = "";
        _this._hideHomeserver = false;
        _this._isBusy = false;
        _this._abortHomeserverQueryTimeout = null;
        _this._abortQueryOperation = null;

        _this._initViewModels();

        return _this;
      }

      _createClass(LoginViewModel, [{
        key: "goBack",
        value: function goBack() {
          this.navigation.push("session");
        }
      }, {
        key: "_initViewModels",
        value: function () {
          var _initViewModels2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var _this2 = this;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!this._loginToken) {
                      _context.next = 6;
                      break;
                    }

                    this._hideHomeserver = true;
                    this._completeSSOLoginViewModel = this.track(new CompleteSSOLoginViewModel(this.childOptions({
                      sessionContainer: this._sessionContainer,
                      attemptLogin: function attemptLogin(loginMethod) {
                        return _this2.attemptLogin(loginMethod);
                      },
                      loginToken: this._loginToken
                    })));
                    this.emitChange("completeSSOLoginViewModel");
                    _context.next = 8;
                    break;

                  case 6:
                    _context.next = 8;
                    return this.queryHomeserver();

                  case 8:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function _initViewModels() {
            return _initViewModels2.apply(this, arguments);
          }

          return _initViewModels;
        }()
      }, {
        key: "_showPasswordLogin",
        value: function _showPasswordLogin() {
          var _this3 = this;

          this._passwordLoginViewModel = this.track(new PasswordLoginViewModel(this.childOptions({
            loginOptions: this._loginOptions,
            attemptLogin: function attemptLogin(loginMethod) {
              return _this3.attemptLogin(loginMethod);
            }
          })));
          this.emitChange("passwordLoginViewModel");
        }
      }, {
        key: "_showSSOLogin",
        value: function _showSSOLogin() {
          this._startSSOLoginViewModel = this.track(new StartSSOLoginViewModel(this.childOptions({
            loginOptions: this._loginOptions
          })));
          this.emitChange("startSSOLoginViewModel");
        }
      }, {
        key: "_showError",
        value: function _showError(message) {
          this._errorMessage = message;
          this.emitChange("errorMessage");
        }
      }, {
        key: "_setBusy",
        value: function _setBusy(status) {
          var _this$_passwordLoginV, _this$_startSSOLoginV;

          this._isBusy = status;
          (_this$_passwordLoginV = this._passwordLoginViewModel) === null || _this$_passwordLoginV === void 0 ? void 0 : _this$_passwordLoginV.setBusy(status);
          (_this$_startSSOLoginV = this._startSSOLoginViewModel) === null || _this$_startSSOLoginV === void 0 ? void 0 : _this$_startSSOLoginV.setBusy(status);
          this.emitChange("isBusy");
        }
      }, {
        key: "attemptLogin",
        value: function () {
          var _attemptLogin = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(loginMethod) {
            var loadStatus, handle, status;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    this._setBusy(true);

                    this._sessionContainer.startWithLogin(loginMethod, {
                      inspectAccountSetup: true
                    });

                    loadStatus = this._sessionContainer.loadStatus;
                    handle = loadStatus.waitFor(function (status) {
                      return status !== LoadStatus.Login;
                    });
                    _context2.next = 6;
                    return handle.promise;

                  case 6:
                    this._setBusy(false);

                    status = loadStatus.get();

                    if (!(status === LoadStatus.LoginFailed)) {
                      _context2.next = 10;
                      break;
                    }

                    return _context2.abrupt("return", this._sessionContainer.loginFailure);

                  case 10:
                    this._hideHomeserver = true;
                    this.emitChange("hideHomeserver");

                    this._disposeViewModels();

                    this._createLoadViewModel();

                    return _context2.abrupt("return", null);

                  case 15:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function attemptLogin(_x) {
            return _attemptLogin.apply(this, arguments);
          }

          return attemptLogin;
        }()
      }, {
        key: "_createLoadViewModel",
        value: function _createLoadViewModel() {
          var _this4 = this;

          this._loadViewModelSubscription = this.disposeTracked(this._loadViewModelSubscription);
          this._loadViewModel = this.disposeTracked(this._loadViewModel);
          this._loadViewModel = this.track(new SessionLoadViewModel(this.childOptions({
            ready: function ready(sessionContainer) {
              // make sure we don't delete the session in dispose when navigating away
              _this4._sessionContainer = null;

              _this4._ready(sessionContainer);
            },
            sessionContainer: this._sessionContainer,
            homeserver: this._homeserver
          })));

          this._loadViewModel.start();

          this.emitChange("loadViewModel");
          this._loadViewModelSubscription = this.track(this._loadViewModel.disposableOn("change", function () {
            if (!_this4._loadViewModel.loading) {
              _this4._loadViewModelSubscription = _this4.disposeTracked(_this4._loadViewModelSubscription);
            }

            _this4._setBusy(false);
          }));
        }
      }, {
        key: "_disposeViewModels",
        value: function _disposeViewModels() {
          this._startSSOLoginViewModel = this.disposeTracked(this._ssoLoginViewModel);
          this._passwordLoginViewModel = this.disposeTracked(this._passwordLoginViewModel);
          this._completeSSOLoginViewModel = this.disposeTracked(this._completeSSOLoginViewModel);
          this.emitChange("disposeViewModels");
        }
      }, {
        key: "setHomeserver",
        value: function () {
          var _setHomeserver = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(newHomeserver) {
            var timeout;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    this._homeserver = newHomeserver; // clear everything set by queryHomeserver

                    this._loginOptions = null;
                    this._queriedHomeserver = null;

                    this._showError("");

                    this._disposeViewModels();

                    this._abortQueryOperation = this.disposeTracked(this._abortQueryOperation);
                    this.emitChange(); // multiple fields changing
                    // also clear the timeout if it is still running

                    this.disposeTracked(this._abortHomeserverQueryTimeout);
                    timeout = this.clock.createTimeout(1000);
                    this._abortHomeserverQueryTimeout = this.track(function () {
                      return timeout.abort();
                    });
                    _context3.prev = 10;
                    _context3.next = 13;
                    return timeout.elapsed();

                  case 13:
                    _context3.next = 22;
                    break;

                  case 15:
                    _context3.prev = 15;
                    _context3.t0 = _context3["catch"](10);

                    if (!(_context3.t0.name === "AbortError")) {
                      _context3.next = 21;
                      break;
                    }

                    return _context3.abrupt("return");

                  case 21:
                    throw _context3.t0;

                  case 22:
                    this._abortHomeserverQueryTimeout = this.disposeTracked(this._abortHomeserverQueryTimeout);
                    this.queryHomeserver();

                  case 24:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[10, 15]]);
          }));

          function setHomeserver(_x2) {
            return _setHomeserver.apply(this, arguments);
          }

          return setHomeserver;
        }()
      }, {
        key: "queryHomeserver",
        value: function () {
          var _queryHomeserver = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
            var queryOperation;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!(this._homeserver === this._queriedHomeserver || this._homeserver === "")) {
                      _context4.next = 2;
                      break;
                    }

                    return _context4.abrupt("return");

                  case 2:
                    this._queriedHomeserver = this._homeserver; // given that setHomeserver already clears everything set here,
                    // and that is the only way to change the homeserver,
                    // we don't need to reset things again here.
                    // However, clear things set by setHomeserver:
                    // if query is called before the typing timeout hits (e.g. field lost focus),
                    // cancel the timeout so we don't query again.

                    this._abortHomeserverQueryTimeout = this.disposeTracked(this._abortHomeserverQueryTimeout); // cancel ongoing query operation, if any

                    this._abortQueryOperation = this.disposeTracked(this._abortQueryOperation);
                    _context4.prev = 5;
                    queryOperation = this._sessionContainer.queryLogin(this._homeserver);
                    this._abortQueryOperation = this.track(function () {
                      return queryOperation.abort();
                    });
                    this.emitChange("isFetchingLoginOptions");
                    _context4.next = 11;
                    return queryOperation.result;

                  case 11:
                    this._loginOptions = _context4.sent;
                    this.emitChange("resolvedHomeserver");
                    _context4.next = 22;
                    break;

                  case 15:
                    _context4.prev = 15;
                    _context4.t0 = _context4["catch"](5);

                    if (!(_context4.t0.name === "AbortError")) {
                      _context4.next = 21;
                      break;
                    }

                    return _context4.abrupt("return");

                  case 21:
                    this._loginOptions = null;

                  case 22:
                    _context4.prev = 22;
                    this._abortQueryOperation = this.disposeTracked(this._abortQueryOperation);
                    this.emitChange("isFetchingLoginOptions");
                    return _context4.finish(22);

                  case 26:
                    if (this._loginOptions) {
                      if (this._loginOptions.sso) {
                        this._showSSOLogin();
                      }

                      if (this._loginOptions.password) {
                        this._showPasswordLogin();
                      }

                      if (!this._loginOptions.sso && !this._loginOptions.password) {
                        this._showError("This homeserver supports neither SSO nor password based login flows");
                      }
                    } else {
                      this._showError("Could not query login methods supported by ".concat(this.homeserver));
                    }

                  case 27:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this, [[5, 15, 22, 26]]);
          }));

          function queryHomeserver() {
            return _queryHomeserver.apply(this, arguments);
          }

          return queryHomeserver;
        }()
      }, {
        key: "dispose",
        value: function dispose() {
          _get(_getPrototypeOf(LoginViewModel.prototype), "dispose", this).call(this);

          if (this._sessionContainer) {
            // if we move away before we're done with initial sync
            // delete the session
            this._sessionContainer.deleteSession();
          }
        }
      }, {
        key: "passwordLoginViewModel",
        get: function get() {
          return this._passwordLoginViewModel;
        }
      }, {
        key: "startSSOLoginViewModel",
        get: function get() {
          return this._startSSOLoginViewModel;
        }
      }, {
        key: "completeSSOLoginViewModel",
        get: function get() {
          return this._completeSSOLoginViewModel;
        }
      }, {
        key: "homeserver",
        get: function get() {
          return this._homeserver;
        }
      }, {
        key: "resolvedHomeserver",
        get: function get() {
          var _this$_loginOptions;

          return (_this$_loginOptions = this._loginOptions) === null || _this$_loginOptions === void 0 ? void 0 : _this$_loginOptions.homeserver;
        }
      }, {
        key: "errorMessage",
        get: function get() {
          return this._errorMessage;
        }
      }, {
        key: "showHomeserver",
        get: function get() {
          return !this._hideHomeserver;
        }
      }, {
        key: "loadViewModel",
        get: function get() {
          return this._loadViewModel;
        }
      }, {
        key: "isBusy",
        get: function get() {
          return this._isBusy;
        }
      }, {
        key: "isFetchingLoginOptions",
        get: function get() {
          return !!this._abortQueryOperation;
        }
      }]);

      return LoginViewModel;
    }(ViewModel);

    var SessionItemViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(SessionItemViewModel, _ViewModel);

      var _super = _createSuper(SessionItemViewModel);

      function SessionItemViewModel(options, pickerVM) {
        var _this;

        _classCallCheck(this, SessionItemViewModel);

        _this = _super.call(this, options);
        _this._pickerVM = pickerVM;
        _this._sessionInfo = options.sessionInfo;
        _this._isDeleting = false;
        _this._isClearing = false;
        _this._error = null;
        _this._exportDataUrl = null;
        return _this;
      }

      _createClass(SessionItemViewModel, [{
        key: "error",
        get: function get() {
          return this._error && this._error.message;
        }
      }, {
        key: "id",
        get: function get() {
          return this._sessionInfo.id;
        }
      }, {
        key: "openUrl",
        get: function get() {
          return this.urlCreator.urlForSegment("session", this.id);
        }
      }, {
        key: "label",
        get: function get() {
          var _this$_sessionInfo = this._sessionInfo,
              userId = _this$_sessionInfo.userId,
              comment = _this$_sessionInfo.comment;

          if (comment) {
            return "".concat(userId, " (").concat(comment, ")");
          } else {
            return userId;
          }
        }
      }, {
        key: "sessionInfo",
        get: function get() {
          return this._sessionInfo;
        }
      }, {
        key: "exportDataUrl",
        get: function get() {
          return this._exportDataUrl;
        }
      }, {
        key: "avatarColorNumber",
        get: function get() {
          return getIdentifierColorNumber(this._sessionInfo.userId);
        }
      }, {
        key: "avatarInitials",
        get: function get() {
          return avatarInitials(this._sessionInfo.userId);
        }
      }]);

      return SessionItemViewModel;
    }(ViewModel);

    var SessionPickerViewModel = /*#__PURE__*/function (_ViewModel2) {
      _inherits(SessionPickerViewModel, _ViewModel2);

      var _super2 = _createSuper(SessionPickerViewModel);

      function SessionPickerViewModel(options) {
        var _this2;

        _classCallCheck(this, SessionPickerViewModel);

        _this2 = _super2.call(this, options);
        _this2._sessions = new SortedArray(function (s1, s2) {
          return s1.id.localeCompare(s2.id);
        });
        _this2._loadViewModel = null;
        _this2._error = null;
        return _this2;
      } // this loads all the sessions


      _createClass(SessionPickerViewModel, [{
        key: "load",
        value: function () {
          var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var _this3 = this;

            var sessions;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this.platform.sessionInfoStorage.getAll();

                  case 2:
                    sessions = _context.sent;

                    this._sessions.setManyUnsorted(sessions.map(function (s) {
                      return new SessionItemViewModel(_this3.childOptions({
                        sessionInfo: s
                      }), _this3);
                    }));

                  case 4:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function load() {
            return _load.apply(this, arguments);
          }

          return load;
        }() // for the loading of 1 picked session

      }, {
        key: "loadViewModel",
        get: function get() {
          return this._loadViewModel;
        }
      }, {
        key: "sessions",
        get: function get() {
          return this._sessions;
        }
      }, {
        key: "cancelUrl",
        get: function get() {
          return this.urlCreator.urlForSegment("login");
        }
      }]);

      return SessionPickerViewModel;
    }(ViewModel);

    var RootViewModel = /*#__PURE__*/function (_ViewModel) {
      _inherits(RootViewModel, _ViewModel);

      var _super = _createSuper(RootViewModel);

      function RootViewModel(options) {
        var _this;

        _classCallCheck(this, RootViewModel);

        _this = _super.call(this, options);
        _this._createSessionContainer = options.createSessionContainer;
        _this._error = null;
        _this._sessionPickerViewModel = null;
        _this._sessionLoadViewModel = null;
        _this._loginViewModel = null;
        _this._sessionViewModel = null;
        _this._pendingSessionContainer = null;
        return _this;
      }

      _createClass(RootViewModel, [{
        key: "load",
        value: function () {
          var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var _this2 = this;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this.track(this.navigation.observe("login").subscribe(function () {
                      return _this2._applyNavigation();
                    }));
                    this.track(this.navigation.observe("session").subscribe(function () {
                      return _this2._applyNavigation();
                    }));
                    this.track(this.navigation.observe("sso").subscribe(function () {
                      return _this2._applyNavigation();
                    }));

                    this._applyNavigation(true);

                  case 4:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function load() {
            return _load.apply(this, arguments);
          }

          return load;
        }()
      }, {
        key: "_applyNavigation",
        value: function () {
          var _applyNavigation2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(shouldRestoreLastUrl) {
            var _this$navigation$path,
                _this$navigation$path2,
                _this3 = this;

            var isLogin, sessionId, loginToken, sessionContainer, sessionInfos;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    isLogin = this.navigation.path.get("login");
                    sessionId = (_this$navigation$path = this.navigation.path.get("session")) === null || _this$navigation$path === void 0 ? void 0 : _this$navigation$path.value;
                    loginToken = (_this$navigation$path2 = this.navigation.path.get("sso")) === null || _this$navigation$path2 === void 0 ? void 0 : _this$navigation$path2.value;

                    if (!isLogin) {
                      _context2.next = 7;
                      break;
                    }

                    if (this.activeSection !== "login") {
                      this._showLogin();
                    }

                    _context2.next = 31;
                    break;

                  case 7:
                    if (!(sessionId === true)) {
                      _context2.next = 11;
                      break;
                    }

                    if (this.activeSection !== "picker") {
                      this._showPicker();
                    }

                    _context2.next = 31;
                    break;

                  case 11:
                    if (!sessionId) {
                      _context2.next = 15;
                      break;
                    }

                    if (!this._sessionViewModel || this._sessionViewModel.id !== sessionId) {
                      // see _showLogin for where _pendingSessionContainer comes from
                      if (this._pendingSessionContainer && this._pendingSessionContainer.sessionId === sessionId) {
                        sessionContainer = this._pendingSessionContainer;
                        this._pendingSessionContainer = null;

                        this._showSession(sessionContainer);
                      } else {
                        // this should never happen, but we want to be sure not to leak it
                        if (this._pendingSessionContainer) {
                          this._pendingSessionContainer.dispose();

                          this._pendingSessionContainer = null;
                        }

                        this._showSessionLoader(sessionId);
                      }
                    }

                    _context2.next = 31;
                    break;

                  case 15:
                    if (!loginToken) {
                      _context2.next = 20;
                      break;
                    }

                    this.urlCreator.normalizeUrl();

                    if (this.activeSection !== "login") {
                      this._showLogin(loginToken);
                    }

                    _context2.next = 31;
                    break;

                  case 20:
                    _context2.prev = 20;

                    if (shouldRestoreLastUrl && this.urlCreator.tryRestoreLastUrl()) {
                      _context2.next = 26;
                      break;
                    }

                    _context2.next = 24;
                    return this.platform.sessionInfoStorage.getAll();

                  case 24:
                    sessionInfos = _context2.sent;

                    if (sessionInfos.length === 0) {
                      this.navigation.push("login");
                    } else if (sessionInfos.length === 1) {
                      this.navigation.push("session", sessionInfos[0].id);
                    } else {
                      this.navigation.push("session");
                    }

                  case 26:
                    _context2.next = 31;
                    break;

                  case 28:
                    _context2.prev = 28;
                    _context2.t0 = _context2["catch"](20);

                    this._setSection(function () {
                      return _this3._error = _context2.t0;
                    });

                  case 31:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[20, 28]]);
          }));

          function _applyNavigation(_x) {
            return _applyNavigation2.apply(this, arguments);
          }

          return _applyNavigation;
        }()
      }, {
        key: "_showPicker",
        value: function () {
          var _showPicker2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
            var _this4 = this;

            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    this._setSection(function () {
                      _this4._sessionPickerViewModel = new SessionPickerViewModel(_this4.childOptions());
                    });

                    _context3.prev = 1;
                    _context3.next = 4;
                    return this._sessionPickerViewModel.load();

                  case 4:
                    _context3.next = 9;
                    break;

                  case 6:
                    _context3.prev = 6;
                    _context3.t0 = _context3["catch"](1);

                    this._setSection(function () {
                      return _this4._error = _context3.t0;
                    });

                  case 9:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[1, 6]]);
          }));

          function _showPicker() {
            return _showPicker2.apply(this, arguments);
          }

          return _showPicker;
        }()
      }, {
        key: "_showLogin",
        value: function _showLogin(loginToken) {
          var _this5 = this;

          this._setSection(function () {
            _this5._loginViewModel = new LoginViewModel(_this5.childOptions({
              defaultHomeserver: _this5.platform.config["defaultHomeServer"],
              createSessionContainer: _this5._createSessionContainer,
              ready: function ready(sessionContainer) {
                // we don't want to load the session container again,
                // but we also want the change of screen to go through the navigation
                // so we store the session container in a temporary variable that will be
                // consumed by _applyNavigation, triggered by the navigation change
                // 
                // Also, we should not call _setSection before the navigation is in the correct state,
                // as url creation (e.g. in RoomTileViewModel)
                // won't be using the correct navigation base path.
                _this5._pendingSessionContainer = sessionContainer;

                _this5.navigation.push("session", sessionContainer.sessionId);
              },
              loginToken: loginToken
            }));
          });
        }
      }, {
        key: "_showSession",
        value: function _showSession(sessionContainer) {
          var _this6 = this;

          this._setSection(function () {
            _this6._sessionViewModel = new SessionViewModel(_this6.childOptions({
              sessionContainer: sessionContainer
            }));

            _this6._sessionViewModel.start();
          });
        }
      }, {
        key: "_showSessionLoader",
        value: function _showSessionLoader(sessionId) {
          var _this7 = this;

          var sessionContainer = this._createSessionContainer();

          sessionContainer.startWithExistingSession(sessionId);

          this._setSection(function () {
            _this7._sessionLoadViewModel = new SessionLoadViewModel(_this7.childOptions({
              sessionContainer: sessionContainer,
              ready: function ready(sessionContainer) {
                return _this7._showSession(sessionContainer);
              }
            }));

            _this7._sessionLoadViewModel.start();
          });
        }
      }, {
        key: "_setSection",
        value: function _setSection(setter) {
          // clear all members the activeSection depends on
          this._error = null;
          this._sessionPickerViewModel = this.disposeTracked(this._sessionPickerViewModel);
          this._sessionLoadViewModel = this.disposeTracked(this._sessionLoadViewModel);
          this._loginViewModel = this.disposeTracked(this._loginViewModel);
          this._sessionViewModel = this.disposeTracked(this._sessionViewModel); // now set it again

          setter();
          this._sessionPickerViewModel && this.track(this._sessionPickerViewModel);
          this._sessionLoadViewModel && this.track(this._sessionLoadViewModel);
          this._loginViewModel && this.track(this._loginViewModel);
          this._sessionViewModel && this.track(this._sessionViewModel);
          this.emitChange("activeSection");
        }
      }, {
        key: "activeSection",
        get: function get() {
          if (this._error) {
            return "error";
          } else if (this._sessionViewModel) {
            return "session";
          } else if (this._loginViewModel) {
            return "login";
          } else if (this._sessionPickerViewModel) {
            return "picker";
          } else if (this._sessionLoadViewModel) {
            return "loading";
          } else {
            return "redirecting";
          }
        }
      }, {
        key: "error",
        get: function get() {
          return this._error;
        }
      }, {
        key: "sessionViewModel",
        get: function get() {
          return this._sessionViewModel;
        }
      }, {
        key: "loginViewModel",
        get: function get() {
          return this._loginViewModel;
        }
      }, {
        key: "sessionPickerViewModel",
        get: function get() {
          return this._sessionPickerViewModel;
        }
      }, {
        key: "sessionLoadViewModel",
        get: function get() {
          return this._sessionLoadViewModel;
        }
      }]);

      return RootViewModel;
    }(ViewModel);

    // which does not support default exports,
    // see https://github.com/rollup/plugins/tree/master/packages/multi-entry

    function main(_x) {
      return _main.apply(this, arguments);
    }

    function _main() {
      _main = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(platform) {
        var navigation, urlRouter, olmPromise, workerPromise, vm;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                // to replay:
                // const fetchLog = await (await fetch("/fetchlogs/constrainterror.json")).json();
                // const replay = new ReplayRequester(fetchLog, {delay: false});
                // const request = replay.request;
                // to record:
                // const recorder = new RecordRequester(createFetchRequest(clock.createTimeout));
                // const request = recorder.request;
                // window.getBrawlFetchLog = () => recorder.log();
                navigation = createNavigation();
                platform.setNavigation(navigation);
                urlRouter = createRouter({
                  navigation: navigation,
                  history: platform.history
                });
                urlRouter.attach();
                olmPromise = platform.loadOlm();
                workerPromise = platform.loadOlmWorker();
                vm = new RootViewModel({
                  createSessionContainer: function createSessionContainer() {
                    return new SessionContainer({
                      platform: platform,
                      olmPromise: olmPromise,
                      workerPromise: workerPromise
                    });
                  },
                  platform: platform,
                  // the only public interface of the router is to create urls,
                  // so we call it that in the view models
                  urlCreator: urlRouter,
                  navigation: navigation
                });
                _context.next = 10;
                return vm.load();

              case 10:
                platform.createAndMountRootView(vm);
                _context.next = 16;
                break;

              case 13:
                _context.prev = 13;
                _context.t0 = _context["catch"](0);
                console.error("".concat(_context.t0.message, ":\n").concat(_context.t0.stack));

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 13]]);
      }));
      return _main.apply(this, arguments);
    }

    exports.Platform = Platform$1;
    exports.main = main;

    return exports;

}({}));

// @license-end